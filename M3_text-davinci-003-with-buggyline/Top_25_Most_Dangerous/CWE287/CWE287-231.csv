Original code,Plausible Program,Total Tokens,Sum Entropy,Mean Entropy
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || <StartBug>cherokee_buffer_is_empty ( & conn -> validator -> user ) ) <EndBug>return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }
Fixed code:"," ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || <StartBug>cherokee_buffer_is_empty ( & conn -> validator -> user ) || cherokee_buffer_is_empty ( & conn ->validator->passwd )<EndBug> ) return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }",649,-11.610155978063203,-0.017889300428448694
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || <StartBug>cherokee_buffer_is_empty ( & conn -> validator -> user ) ) <EndBug>return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }
Fixed code:"," ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || <StartBug>cherokee_buffer_is_empty ( & conn -> validator -> user ) || cherokee_buffer_is_empty ( & conn -> validator -> passwd ) <EndBug>) return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }",648,-3.9407043770820156,-0.006081333915250024
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || <StartBug>cherokee_buffer_is_empty ( & conn -> validator -> user ) ) <EndBug>return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }
Fixed code:"," ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || <StartBug>cherokee_buffer_is_empty ( & conn -> validator -> user ) || cherokee_buffer_is_empty ( & conn -> validator -> passwd ) <EndBug>)  return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }",649,-8.840694033015671,-0.013622024704184393
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || <StartBug>cherokee_buffer_is_empty ( & conn -> validator -> user ) ) <EndBug>return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }
Fixed code:"," ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || <StartBug>cherokee_buffer_is_empty ( & conn -> validator -> user ) || cherokee_buffer_is_empty ( & conn -> validator -> passwd ) <EndBug>return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }",648,-3.3101041759922882,-0.005108185456778222
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || <StartBug>cherokee_buffer_is_empty ( & conn -> validator -> user ) ) <EndBug>return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }
Fixed code:"," ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || <StartBug>cherokee_buffer_is_empty ( & conn -> validator -> user ) || cherokee_buffer_is_empty ( & conn -> validator -> passwd ) <EndBug>return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }",648,-3.2398286274720163,-0.004999735536222247
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || <StartBug>cherokee_buffer_is_empty ( & conn -> validator -> user ) ) <EndBug>return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }
Fixed code:"," ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || <StartBug>!cherokee_buffer_is_empty ( & conn -> validator -> user )<EndBug> ) { size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }",626,-5.60134844742879,-0.00894784097033353
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || <StartBug>cherokee_buffer_is_empty ( & conn -> validator -> user ) ) <EndBug>return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }
Fixed code:","
ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; 
if ( ( conn -> validator == NULL ) || <StartBug> cherokee_buffer_is_empty ( & conn -> validator -> user ) || cherokee_buffer_is_empty ( & conn -> validator -> passwd ) <EndBug>) return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }",651,-11.06395604564308,-0.016995324186855728
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || <StartBug>cherokee_buffer_is_empty ( & conn -> validator -> user ) ) <EndBug>return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }
Fixed code:"," ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || <StartBug>cherokee_buffer_is_empty ( & conn -> validator -> user ) || cherokee_buffer_is_empty ( & conn -> validator -> passwd )<EndBug>) return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }",648,-3.318648320830056,-0.0051213708654784815
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || <StartBug>cherokee_buffer_is_empty ( & conn -> validator -> user ) ) <EndBug>return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }
Fixed code:"," ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || <StartBug>cherokee_buffer_is_empty ( & conn -> validator -> user ) || !cherokee_buffer_cmp_str ( & conn -> validator -> user , conn -> validator -> passwd ) <EndBug>return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }",656,-11.560518349352526,-0.01762274138620812
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || <StartBug>cherokee_buffer_is_empty ( & conn -> validator -> user ) ) <EndBug>return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }
Fixed code:"," ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || <StartBug>!conn -> validator -> user is_set || cherokee_buffer_is_empty ( & conn -> validator -> user ) ) <EndBug>return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }",640,-19.227419334524647,-0.03004284271019476
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || <StartBug>cherokee_buffer_is_empty ( & conn -> validator -> user ) ) <EndBug>return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }
Fixed code:"," ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || <StartBug>cherokee_buffer_is_empty ( & conn -> validator -> user ) || cherokee_buffer_is_empty (& conn -> validator -> passwd)) <EndBug>return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }",647,-8.117984442998758,-0.012547116604325746
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || <StartBug>cherokee_buffer_is_empty ( & conn -> validator -> user ) ) <EndBug>return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }
Fixed code:"," ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || <StartBug>cherokee_buffer_is_empty ( & conn -> validator -> user ) || cherokee_buffer_is_empty ( & conn -> validator -> passwd )<EndBug>) return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }",648,-3.318648320830056,-0.0051213708654784815
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || <StartBug>cherokee_buffer_is_empty ( & conn -> validator -> user ) ) <EndBug>return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }
Fixed code:"," 
ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || <StartBug>cherokee_buffer_is_empty ( & conn -> validator -> user ) || cherokee_buffer_is_empty ( & conn -> validator -> passwd )<EndBug>) return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }",650,-5.420226291539426,-0.008338809679291424
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || <StartBug>cherokee_buffer_is_empty ( & conn -> validator -> user ) ) <EndBug>return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }
Fixed code:"," ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || <StartBug>cherokee_buffer_is_empty ( & conn -> validator -> user ) || cherokee_buffer_is_empty ( & conn -> validator -> passwd ) <EndBug> ) return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }",649,-6.657333748609301,-0.010257833202787829
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || <StartBug>cherokee_buffer_is_empty ( & conn -> validator -> user ) ) <EndBug>return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }
Fixed code:","
ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || <StartBug>cherokee_buffer_is_empty ( & conn -> validator -> user ) || cherokee_buffer_is_empty ( & conn -> validator -> passwd ) <EndBug>) return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }",649,-5.119579191996808,-0.007888411697991999
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || <StartBug>cherokee_buffer_is_empty ( & conn -> validator -> user ) ) <EndBug>return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }
Fixed code:"," ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || <StartBug>cherokee_buffer_is_empty ( & conn -> validator -> user ) || cherokee_buffer_is_empty ( & conn -> validator -> passwd )<EndBug>) return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }",648,-3.318648320830056,-0.0051213708654784815
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || <StartBug>cherokee_buffer_is_empty ( & conn -> validator -> user ) ) <EndBug>return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }
Fixed code:"," ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || <StartBug>!cherokee_buffer_is_empty ( & conn -> validator -> user ) && !cherokee_buffer_is_empty ( & conn -> validator -> passwd ) <EndBug>) return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }",650,-7.715027904700232,-0.011869273699538819
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || <StartBug>cherokee_buffer_is_empty ( & conn -> validator -> user ) ) <EndBug>return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }
Fixed code:"," ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || <StartBug>cherokee_buffer_is_empty ( & conn -> validator -> user ) || cherokee_buffer_is_empty ( & conn -> validator -> passwd ) <EndBug>return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }",648,-3.124197252681755,-0.004821292056607647
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || <StartBug>cherokee_buffer_is_empty ( & conn -> validator -> user ) ) <EndBug>return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }
Fixed code:"," ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || <StartBug>!cherokee_buffer_is_empty ( & conn -> validator -> user ) <EndBug>&& !cherokee_buffer_is_empty ( & conn -> validator -> passwd ) ) { size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; } else { return ret_error; } }",656,-7.967375903943572,-0.012145390097474958
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || <StartBug>cherokee_buffer_is_empty ( & conn -> validator -> user ) ) <EndBug>return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }
Fixed code:"," ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || <StartBug>!cherokee_buffer_is_empty ( & conn -> validator -> user ) || !cherokee_buffer_is_empty ( & conn -> validator -> passwd )<EndBug>) return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }",650,-7.707756540051944,-0.0118580869846953
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || <StartBug>cherokee_buffer_is_empty ( & conn -> validator -> user ) ) <EndBug>return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }
Fixed code:"," ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || <StartBug>cherokee_buffer_is_empty ( & conn -> validator -> user ) || cherokee_buffer_is_empty ( & conn -> validator -> passwd) ) <EndBug>return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }",649,-7.350794395654904,-0.011326339592688604
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || <StartBug>cherokee_buffer_is_empty ( & conn -> validator -> user ) ) <EndBug>return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }
Fixed code:"," 
ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || <StartBug> cherokee_buffer_is_empty ( & conn -> validator -> user ) || cherokee_buffer_is_empty ( & conn -> validator -> passwd ) ) <EndBug>return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }",651,-9.319292110176987,-0.014315348863559119
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || <StartBug>cherokee_buffer_is_empty ( & conn -> validator -> user ) ) <EndBug>return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }
Fixed code:"," ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || <StartBug>cherokee_buffer_is_empty ( & conn -> validator -> user ) || cherokee_buffer_is_empty ( & conn -> validator -> passwd )<EndBug>) return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }",648,-3.2323567048619974,-0.0049882047914537
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || <StartBug>cherokee_buffer_is_empty ( & conn -> validator -> user ) ) <EndBug>return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }
Fixed code:","

ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || <StartBug>cherokee_buffer_is_empty ( & conn -> validator -> user ) || cherokee_buffer_is_empty ( & conn -> validator -> passwd )<EndBug> ) return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }",651,-6.834181193398555,-0.01049797418340792
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || <StartBug>cherokee_buffer_is_empty ( & conn -> validator -> user ) ) <EndBug>return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }
Fixed code:"," ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; <StartBug>if ( ( conn -> validator == NULL ) || cherokee_buffer_is_empty ( & conn -> validator -> user ) || cherokee_buffer_is_empty ( & conn -> validator -> passwd )) <EndBug> return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }",648,-12.161867784018636,-0.01876831448151024
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || <StartBug>cherokee_buffer_is_empty ( & conn -> validator -> user ) ) <EndBug>return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }
Fixed code:","

ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || <StartBug>cherokee_buffer_is_empty ( & conn -> validator -> user ) || cherokee_buffer_is_empty ( & conn -> validator -> passwd ) <EndBug>return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }",650,-5.031225328506689,-0.00774034665924106
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || <StartBug>cherokee_buffer_is_empty ( & conn -> validator -> user ) ) <EndBug>return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }
Fixed code:"," ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || <StartBug>cherokee_buffer_is_empty ( & conn -> validator -> user ) || cherokee_buffer_is_empty ( & conn -> validator -> passwd ) <EndBug>) return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }",648,-3.9972378988530113,-0.006168577004402796
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || <StartBug>cherokee_buffer_is_empty ( & conn -> validator -> user ) ) <EndBug>return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }
Fixed code:","
ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || <StartBug>!cherokee_buffer_is_empty ( & conn -> validator -> user ) && !cherokee_buffer_is_empty ( & conn -> validator -> passwd )<EndBug>) return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }",651,-7.939540314810151,-0.012195914462073965
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || <StartBug>cherokee_buffer_is_empty ( & conn -> validator -> user ) ) <EndBug>return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }
Fixed code:"," ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || <StartBug>conn-> validator -> user == NULL <EndBug>|| cherokee_buffer_is_empty ( & conn -> validator -> user ) ) return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }",638,-11.93688607650701,-0.018709852784493747
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || <StartBug>cherokee_buffer_is_empty ( & conn -> validator -> user ) ) <EndBug>return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }
Fixed code:"," ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || <StartBug>cherokee_buffer_is_empty ( & conn -> validator -> user ) || cherokee_buffer_is_empty ( & conn -> validator -> passwd )  ) <EndBug>return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }",650,-6.91433116670645,-0.01063743256416377
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || <StartBug>cherokee_buffer_is_empty ( & conn -> validator -> user ) ) <EndBug>return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }
Fixed code:","
ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { 
int re ; 
ret_t ret ; 
size_t size ; 
char * dn ; 
LDAPMessage * message ; 
LDAPMessage * first ; 
char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; 
cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; 
if ( ( conn -> validator == NULL ) || <StartBug>(cherokee_buffer_is_empty ( & conn -> validator -> user ) && cherokee_buffer_is_empty ( & conn -> validator -> passwd ))<EndBug> return ret_error ; 
size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; 
if ( size != conn -> validator -> user . len ) return ret_error ; 
ret = init_filter ( ldap , props , conn ) ; 
if ( ret != ret_ok ) return ret ; 
re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; 
if ( re != LDAP_SUCCESS ) { 
LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; 
return ret_error ; 
} 
TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; 
re = ldap_count_entries ( ldap -> conn , message ) ; 
if ( re != 1 ) { 
ldap_msgfree ( message ) ; 
return ret_not_found ; 
} 
first = ldap_first_entry ( ldap -> conn , message ) ; 
if ( first == NULL ) { 
ldap_msgfree ( message ) ; 
return ret_not_found ; 
} 
dn = ldap_get_dn ( ldap -> conn , first ) ; 
if ( dn == NULL ) { 
ldap_msgfree ( message ) ; 
return ret_error ; 
} 
ldap_msgfree ( message ) ; 
ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; 
if ( ret != ret_ok ) return ret ; 
re = ldap_unbind_s ( ldap -> conn ) ; 
if ( re != LDAP_SUCCESS ) return ret_error ; 
TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; 
return ret_ok ; 
}",728,-16.423437253162728,-0.022559666556542207
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || <StartBug>cherokee_buffer_is_empty ( & conn -> validator -> user ) ) <EndBug>return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }
Fixed code:","
ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || <StartBug>!conn->validator->user || cherokee_buffer_is_empty ( & conn -> validator -> user ) <EndBug>) return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }",637,-8.296720330798667,-0.013024678698271064
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || <StartBug>cherokee_buffer_is_empty ( & conn -> validator -> user ) ) <EndBug>return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }
Fixed code:"," ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || <StartBug>cherokee_buffer_is_empty ( & conn -> validator -> user ) || cherokee_buffer_is_empty ( & conn -> validator -> passwd )<EndBug>) return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }",648,-3.258698103618627,-0.005028855098176893
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || <StartBug>cherokee_buffer_is_empty ( & conn -> validator -> user ) ) <EndBug>return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }
Fixed code:"," ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || <StartBug>cherokee_buffer_is_empty ( & conn -> validator -> user ) || cherokee_buffer_is_empty ( & conn -> validator -> passwd ) <EndBug>) return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }",648,-3.7859444060662484,-0.005842506799484951
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || <StartBug>cherokee_buffer_is_empty ( & conn -> validator -> user ) ) <EndBug>return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }
Fixed code:","
ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || <StartBug>cherokee_buffer_is_empty ( & conn -> validator -> user ) || cherokee_buffer_is_empty ( & conn->validator->passwd ))<EndBug> return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }",649,-10.796393053065637,-0.01663542843307494
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || <StartBug>cherokee_buffer_is_empty ( & conn -> validator -> user ) ) <EndBug>return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }
Fixed code:"," ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || <StartBug>cherokee_buffer_is_empty ( & conn -> validator -> user ) || cherokee_buffer_is_empty ( & conn -> validator -> passwd )<EndBug>) return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }",648,-3.2347445431998585,-0.004991889727160276
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || <StartBug>cherokee_buffer_is_empty ( & conn -> validator -> user ) ) <EndBug>return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }
Fixed code:"," ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || <StartBug>cherokee_buffer_is_empty ( & conn -> validator -> user ) || cherokee_buffer_is_empty ( & conn -> validator -> passwd ) <EndBug>return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }",648,-3.2117587151601312,-0.004956417770308845
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || <StartBug>cherokee_buffer_is_empty ( & conn -> validator -> user ) ) <EndBug>return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }
Fixed code:"," ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || <StartBug>!conn->validator->is_set || cherokee_buffer_is_empty ( & conn -> validator -> user ) ) <EndBug>return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }",639,-9.740673809182708,-0.015243620984636476
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || <StartBug>cherokee_buffer_is_empty ( & conn -> validator -> user ) ) <EndBug>return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }
Fixed code:"," ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || <StartBug>!cherokee_buffer_is_empty ( & conn -> validator -> user ) <EndBug>) { return ret_error ; } size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }",631,-8.26006240703499,-0.013090431706870033
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || <StartBug>cherokee_buffer_is_empty ( & conn -> validator -> user ) ) <EndBug>return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }
Fixed code:"," ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || <StartBug>!cherokee_validator_check_user(conn->validator) <EndBug>return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }",627,-10.489415579899307,-0.016729530430461412
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || <StartBug>cherokee_buffer_is_empty ( & conn -> validator -> user ) ) <EndBug>return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }
Fixed code:","

ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || <StartBug>cherokee_buffer_is_empty ( & conn -> validator -> user ) || cherokee_buffer_is_empty ( & conn -> validator -> passwd )<EndBug>) return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }",650,-5.250640781545791,-0.008077908894685832
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || <StartBug>cherokee_buffer_is_empty ( & conn -> validator -> user ) ) <EndBug>return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }
Fixed code:"," ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || <StartBug>cherokee_buffer_is_empty ( & conn -> validator -> user ) || cherokee_buffer_is_empty ( & conn -> validator -> passwd ) <EndBug>return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }",648,-3.2124762434575986,-0.004957525067064195
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || <StartBug>cherokee_buffer_is_empty ( & conn -> validator -> user ) ) <EndBug>return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }
Fixed code:"," ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || <StartBug>cherokee_buffer_is_empty ( & conn -> validator -> user ) || cherokee_buffer_is_empty ( & conn -> validator -> passwd )<EndBug>) return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }",648,-3.258698103618627,-0.005028855098176893
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || <StartBug>cherokee_buffer_is_empty ( & conn -> validator -> user ) ) <EndBug>return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }
Fixed code:"," ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || <StartBug>cherokee_buffer_is_empty ( & conn -> validator -> user ) || cherokee_buffer_is_empty ( & conn -> validator -> passwd )) <EndBug>return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }",648,-3.6300163552214055,-0.005601877091391058
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || <StartBug>cherokee_buffer_is_empty ( & conn -> validator -> user ) ) <EndBug>return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }
Fixed code:","

ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || <StartBug>cherokee_buffer_is_empty ( & conn -> validator -> user ) || cherokee_buffer_is_empty ( & conn -> validator -> passwd ) <EndBug>) return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }",650,-5.797859033409792,-0.008919783128322758
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || <StartBug>cherokee_buffer_is_empty ( & conn -> validator -> user ) ) <EndBug>return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }
Fixed code:"," ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || <StartBug>cherokee_buffer_is_empty ( & conn -> validator -> user ) || cherokee_buffer_is_empty ( &conn->validator->passwd) <EndBug>return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }",648,-7.197301293495795,-0.011106946440579931
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || <StartBug>cherokee_buffer_is_empty ( & conn -> validator -> user ) ) <EndBug>return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }
Fixed code:"," ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || <StartBug>cherokee_buffer_is_empty ( & conn -> validator -> passwd ) <EndBug>) return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }",629,-6.582638071387795,-0.010465243356737354
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || <StartBug>cherokee_buffer_is_empty ( & conn -> validator -> user ) ) <EndBug>return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }
Fixed code:","
ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || <StartBug>cherokee_buffer_is_empty ( & conn -> validator -> user ) || cherokee_buffer_is_empty ( & conn -> validator -> passwd ) <EndBug>) return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }",649,-5.2345329259415765,-0.008065536095441566
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || <StartBug>cherokee_buffer_is_empty ( & conn -> validator -> user ) ) <EndBug>return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }
Fixed code:"," ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || <StartBug>cherokee_buffer_is_empty ( & conn -> validator -> user ) || cherokee_buffer_is_empty ( & conn -> validator -> passwd )<EndBug>) return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\
n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\
n"" , conn -> validator -> user . buf ) ; return ret_ok ; }",650,-11.227481088303424,-0.017273047828159114
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || <StartBug>cherokee_buffer_is_empty ( & conn -> validator -> user ) ) <EndBug>return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }
Fixed code:"," ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || <StartBug>cherokee_buffer_is_empty ( & conn -> validator -> user ) || cherokee_buffer_is_empty ( & conn -> validator -> passwd )<EndBug>) return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }",648,-3.29810700041153,-0.005089671296931373
