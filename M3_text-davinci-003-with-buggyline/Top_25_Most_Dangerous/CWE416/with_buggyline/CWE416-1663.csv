Original code,Plausible Program,Number of Bugs Present,Total Tokens,Sum Entropy,Mean Entropy
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
int sctp_do_peeloff ( struct sock * sk , sctp_assoc_t id , struct socket * * sockp ) { struct sctp_association * asoc = sctp_id2assoc ( sk , id ) ; struct sctp_sock * sp = sctp_sk ( sk ) ; struct socket * sock ; <StartBug> int err = 0 ; <EndBug> if ( ! asoc ) return - EINVAL ; if ( waitqueue_active ( & asoc -> wait ) ) return - EBUSY ; if ( ! sctp_style ( sk , UDP ) ) return - EINVAL ; err = sock_create ( sk -> sk_family , SOCK_SEQPACKET , IPPROTO_SCTP , & sock ) ; if ( err < 0 ) return err ; sctp_copy_sock ( sock -> sk , sk , asoc ) ; sp -> pf -> to_sk_daddr ( & asoc -> peer . primary_addr , sk ) ; sctp_sock_migrate ( sk , sock -> sk , asoc , SCTP_SOCKET_UDP_HIGH_BANDWIDTH ) ; * sockp = sock ; return err ; }
Fixed code:","
int sctp_do_peeloff ( struct sock * sk , sctp_assoc_t id , struct socket * * sockp ) { struct sctp_association * asoc = sctp_id2assoc ( sk , id ) ; struct sctp_sock * sp = sctp_sk ( sk ) ; struct socket * sock ; <StartBug> int err ; <EndBug> err = 0; if ( ! asoc ) return - EINVAL ; if ( waitqueue_active ( & asoc -> wait ) ) return - EBUSY ; if ( ! sctp_style ( sk , UDP ) ) return - EINVAL ; err = sock_create ( sk -> sk_family , SOCK_SEQPACKET , IPPROTO_SCTP , & sock ) ; if ( err < 0 ) return err ; sctp_copy_sock ( sock -> sk , sk , asoc ) ; sp -> pf -> to_sk_daddr ( & asoc -> peer . primary_addr , sk ) ; sctp_sock_migrate ( sk , sock -> sk , asoc , SCTP_SOCKET_UDP_HIGH_BANDWIDTH ) ; * sockp = sock ; return err ; }",1,287,-2.909520939286928,-0.010137703621208808
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
int sctp_do_peeloff ( struct sock * sk , sctp_assoc_t id , struct socket * * sockp ) { struct sctp_association * asoc = sctp_id2assoc ( sk , id ) ; struct sctp_sock * sp = sctp_sk ( sk ) ; struct socket * sock ; <StartBug> int err = 0 ; <EndBug> if ( ! asoc ) return - EINVAL ; if ( waitqueue_active ( & asoc -> wait ) ) return - EBUSY ; if ( ! sctp_style ( sk , UDP ) ) return - EINVAL ; err = sock_create ( sk -> sk_family , SOCK_SEQPACKET , IPPROTO_SCTP , & sock ) ; if ( err < 0 ) return err ; sctp_copy_sock ( sock -> sk , sk , asoc ) ; sp -> pf -> to_sk_daddr ( & asoc -> peer . primary_addr , sk ) ; sctp_sock_migrate ( sk , sock -> sk , asoc , SCTP_SOCKET_UDP_HIGH_BANDWIDTH ) ; * sockp = sock ; return err ; }
Fixed code:","
int sctp_do_peeloff ( struct sock * sk , sctp_assoc_t id , struct socket * * sockp ) { struct sctp_association * asoc = sctp_id2assoc ( sk , id ) ; struct sctp_sock * sp = sctp_sk ( sk ) ; struct socket * sock ; <StartBug> int err = 0 ; sock = * sockp; <EndBug> if ( ! asoc ) return - EINVAL ; if ( waitqueue_active ( & asoc -> wait ) ) return - EBUSY ; if ( ! sctp_style ( sk , UDP ) ) return - EINVAL ; err = sock_create ( sk -> sk_family , SOCK_SEQPACKET , IPPROTO_SCTP , & sock ) ; if ( err < 0 ) return err ; sctp_copy_sock ( sock -> sk , sk , asoc ) ; sp -> pf -> to_sk_daddr ( & asoc -> peer . primary_addr , sk ) ; sctp_sock_migrate ( sk , sock -> sk , asoc , SCTP_SOCKET_UDP_HIGH_BANDWIDTH ) ; * sockp = sock ; return err ; }",1,291,-6.3206829647389045,-0.021720560016284893
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
int sctp_do_peeloff ( struct sock * sk , sctp_assoc_t id , struct socket * * sockp ) { struct sctp_association * asoc = sctp_id2assoc ( sk , id ) ; struct sctp_sock * sp = sctp_sk ( sk ) ; struct socket * sock ; <StartBug> int err = 0 ; <EndBug> if ( ! asoc ) return - EINVAL ; if ( waitqueue_active ( & asoc -> wait ) ) return - EBUSY ; if ( ! sctp_style ( sk , UDP ) ) return - EINVAL ; err = sock_create ( sk -> sk_family , SOCK_SEQPACKET , IPPROTO_SCTP , & sock ) ; if ( err < 0 ) return err ; sctp_copy_sock ( sock -> sk , sk , asoc ) ; sp -> pf -> to_sk_daddr ( & asoc -> peer . primary_addr , sk ) ; sctp_sock_migrate ( sk , sock -> sk , asoc , SCTP_SOCKET_UDP_HIGH_BANDWIDTH ) ; * sockp = sock ; return err ; }
Fixed code:","
int sctp_do_peeloff (struct sock *sk, sctp_assoc_t id, struct socket **sockp) { 
	struct sctp_association *asoc = sctp_id2assoc(sk, id); 
	struct sctp_sock *sp = sctp_sk(sk); 
	struct socket *sock; 
	int err = 0; 
	if (!asoc) 
		return -EINVAL; 
	if (waitqueue_active(&asoc->wait)) 
		return -EBUSY; 
	if (!sctp_style(sk, UDP)) 
		return -EINVAL; 
	err = sock_create(sk->sk_family, SOCK_SEQPACKET, IPPROTO_SCTP, &sock); 
	if (err < 0) 
		return err; 
	
	<StartBug>
	sctp_association_hold(asoc);
	<EndBug>
	
	sctp_copy_sock(sock->sk, sk, asoc); 
	sp->pf->to_sk_daddr(&asoc->peer.primary_addr, sk); 
	sctp_sock_migrate(sk, sock->sk, asoc, SCTP_SOCKET_UDP_HIGH_BANDWIDTH); 
	*sockp = sock; 
	
	<StartBug>
	sctp_association_put(asoc);
	<EndBug>
	
	return err; 
}",1,389,-21.533628325707014,-0.05535637101724168
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
int sctp_do_peeloff ( struct sock * sk , sctp_assoc_t id , struct socket * * sockp ) { struct sctp_association * asoc = sctp_id2assoc ( sk , id ) ; struct sctp_sock * sp = sctp_sk ( sk ) ; struct socket * sock ; <StartBug> int err = 0 ; <EndBug> if ( ! asoc ) return - EINVAL ; if ( waitqueue_active ( & asoc -> wait ) ) return - EBUSY ; if ( ! sctp_style ( sk , UDP ) ) return - EINVAL ; err = sock_create ( sk -> sk_family , SOCK_SEQPACKET , IPPROTO_SCTP , & sock ) ; if ( err < 0 ) return err ; sctp_copy_sock ( sock -> sk , sk , asoc ) ; sp -> pf -> to_sk_daddr ( & asoc -> peer . primary_addr , sk ) ; sctp_sock_migrate ( sk , sock -> sk , asoc , SCTP_SOCKET_UDP_HIGH_BANDWIDTH ) ; * sockp = sock ; return err ; }
Fixed code:","
int sctp_do_peeloff ( struct sock * sk , sctp_assoc_t id , struct socket * * sockp ) { struct sctp_association * asoc = sctp_id2assoc ( sk , id ) ; struct sctp_sock * sp = sctp_sk ( sk ) ; struct socket * sock ; <StartBug> int err ; <EndBug> err = 0; if ( ! asoc ) return - EINVAL ; if ( waitqueue_active ( & asoc -> wait ) ) return - EBUSY ; if ( ! sctp_style ( sk , UDP ) ) return - EINVAL ; err = sock_create ( sk -> sk_family , SOCK_SEQPACKET , IPPROTO_SCTP , & sock ) ; if ( err < 0 ) return err ; sctp_copy_sock ( sock -> sk , sk , asoc ) ; sp -> pf -> to_sk_daddr ( & asoc -> peer . primary_addr , sk ) ; sctp_sock_migrate ( sk , sock -> sk , asoc , SCTP_SOCKET_UDP_HIGH_BANDWIDTH ) ; * sockp = sock ; return err ; }",1,287,-2.909520939286928,-0.010137703621208808
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
int sctp_do_peeloff ( struct sock * sk , sctp_assoc_t id , struct socket * * sockp ) { struct sctp_association * asoc = sctp_id2assoc ( sk , id ) ; struct sctp_sock * sp = sctp_sk ( sk ) ; struct socket * sock ; <StartBug> int err = 0 ; <EndBug> if ( ! asoc ) return - EINVAL ; if ( waitqueue_active ( & asoc -> wait ) ) return - EBUSY ; if ( ! sctp_style ( sk , UDP ) ) return - EINVAL ; err = sock_create ( sk -> sk_family , SOCK_SEQPACKET , IPPROTO_SCTP , & sock ) ; if ( err < 0 ) return err ; sctp_copy_sock ( sock -> sk , sk , asoc ) ; sp -> pf -> to_sk_daddr ( & asoc -> peer . primary_addr , sk ) ; sctp_sock_migrate ( sk , sock -> sk , asoc , SCTP_SOCKET_UDP_HIGH_BANDWIDTH ) ; * sockp = sock ; return err ; }
Fixed code:","
int sctp_do_peeloff ( struct sock * sk , sctp_assoc_t id , struct socket * * sockp ) { struct sctp_association * asoc = sctp_id2assoc ( sk , id ) ; struct sctp_sock * sp = sctp_sk ( sk ) ; struct socket * sock ; <StartBug> int err = 0 ; sock = NULL ; <EndBug> if ( ! asoc ) return - EINVAL ; if ( waitqueue_active ( & asoc -> wait ) ) return - EBUSY ; if ( ! sctp_style ( sk , UDP ) ) return - EINVAL ; err = sock_create ( sk -> sk_family , SOCK_SEQPACKET , IPPROTO_SCTP , & sock ) ; if ( err < 0 ) return err ; sctp_copy_sock ( sock -> sk , sk , asoc ) ; sp -> pf -> to_sk_daddr ( & asoc -> peer . primary_addr , sk ) ; sctp_sock_migrate ( sk , sock -> sk , asoc , SCTP_SOCKET_UDP_HIGH_BANDWIDTH ) ; * sockp = sock ; return err ; }",1,289,-3.2622506251990306,-0.01128806444705547
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
int sctp_do_peeloff ( struct sock * sk , sctp_assoc_t id , struct socket * * sockp ) { struct sctp_association * asoc = sctp_id2assoc ( sk , id ) ; struct sctp_sock * sp = sctp_sk ( sk ) ; struct socket * sock ; <StartBug> int err = 0 ; <EndBug> if ( ! asoc ) return - EINVAL ; if ( waitqueue_active ( & asoc -> wait ) ) return - EBUSY ; if ( ! sctp_style ( sk , UDP ) ) return - EINVAL ; err = sock_create ( sk -> sk_family , SOCK_SEQPACKET , IPPROTO_SCTP , & sock ) ; if ( err < 0 ) return err ; sctp_copy_sock ( sock -> sk , sk , asoc ) ; sp -> pf -> to_sk_daddr ( & asoc -> peer . primary_addr , sk ) ; sctp_sock_migrate ( sk , sock -> sk , asoc , SCTP_SOCKET_UDP_HIGH_BANDWIDTH ) ; * sockp = sock ; return err ; }
Fixed code:","
int sctp_do_peeloff ( struct sock * sk , sctp_assoc_t id , struct socket * * sockp ) { struct sctp_association * asoc = sctp_id2assoc ( sk , id ) ; struct sctp_sock * sp = sctp_sk ( sk ) ; struct socket * sock ; <StartBug> int err ; <EndBug> err = 0; if ( ! asoc ) return - EINVAL ; if ( waitqueue_active ( & asoc -> wait ) ) return - EBUSY ; if ( ! sctp_style ( sk , UDP ) ) return - EINVAL ; err = sock_create ( sk -> sk_family , SOCK_SEQPACKET , IPPROTO_SCTP , & sock ) ; if ( err < 0 ) return err ; sctp_copy_sock ( sock -> sk , sk , asoc ) ; sp -> pf -> to_sk_daddr ( & asoc -> peer . primary_addr , sk ) ; sctp_sock_migrate ( sk , sock -> sk , asoc , SCTP_SOCKET_UDP_HIGH_BANDWIDTH ) ; * sockp = sock ; return err ; }",1,287,-2.909520939286928,-0.010137703621208808
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
int sctp_do_peeloff ( struct sock * sk , sctp_assoc_t id , struct socket * * sockp ) { struct sctp_association * asoc = sctp_id2assoc ( sk , id ) ; struct sctp_sock * sp = sctp_sk ( sk ) ; struct socket * sock ; <StartBug> int err = 0 ; <EndBug> if ( ! asoc ) return - EINVAL ; if ( waitqueue_active ( & asoc -> wait ) ) return - EBUSY ; if ( ! sctp_style ( sk , UDP ) ) return - EINVAL ; err = sock_create ( sk -> sk_family , SOCK_SEQPACKET , IPPROTO_SCTP , & sock ) ; if ( err < 0 ) return err ; sctp_copy_sock ( sock -> sk , sk , asoc ) ; sp -> pf -> to_sk_daddr ( & asoc -> peer . primary_addr , sk ) ; sctp_sock_migrate ( sk , sock -> sk , asoc , SCTP_SOCKET_UDP_HIGH_BANDWIDTH ) ; * sockp = sock ; return err ; }
Fixed code:","
int sctp_do_peeloff ( struct sock * sk , sctp_assoc_t id , struct socket * * sockp ) { struct sctp_association * asoc = sctp_id2assoc ( sk , id ) ; struct sctp_sock * sp = sctp_sk ( sk ) ; struct socket * sock ; <StartBug> int err = 0 ; if ( ! asoc ) { err = - EINVAL ; goto err_out ; } <EndBug> if ( waitqueue_active ( & asoc -> wait ) ) return - EBUSY ; if ( ! sctp_style ( sk , UDP ) ) return - EINVAL ; err = sock_create ( sk -> sk_family , SOCK_SEQPACKET , IPPROTO_SCTP , & sock ) ; if ( err < 0 ) return err ; sctp_copy_sock ( sock -> sk , sk , asoc ) ; sp -> pf -> to_sk_daddr ( & asoc -> peer . primary_addr , sk ) ; sctp_sock_migrate ( sk , sock -> sk , asoc , SCTP_SOCKET_UDP_HIGH_BANDWIDTH ) ; * sockp = sock ; return err ; err_out : kfree ( asoc ) ; return err ; }",1,307,-11.201902898596112,-0.03648828305731632
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
int sctp_do_peeloff ( struct sock * sk , sctp_assoc_t id , struct socket * * sockp ) { struct sctp_association * asoc = sctp_id2assoc ( sk , id ) ; struct sctp_sock * sp = sctp_sk ( sk ) ; struct socket * sock ; <StartBug> int err = 0 ; <EndBug> if ( ! asoc ) return - EINVAL ; if ( waitqueue_active ( & asoc -> wait ) ) return - EBUSY ; if ( ! sctp_style ( sk , UDP ) ) return - EINVAL ; err = sock_create ( sk -> sk_family , SOCK_SEQPACKET , IPPROTO_SCTP , & sock ) ; if ( err < 0 ) return err ; sctp_copy_sock ( sock -> sk , sk , asoc ) ; sp -> pf -> to_sk_daddr ( & asoc -> peer . primary_addr , sk ) ; sctp_sock_migrate ( sk , sock -> sk , asoc , SCTP_SOCKET_UDP_HIGH_BANDWIDTH ) ; * sockp = sock ; return err ; }
Fixed code:","
int sctp_do_peeloff ( struct sock * sk , sctp_assoc_t id , struct socket * * sockp ) { struct sctp_association * asoc = sctp_id2assoc ( sk , id ) ; struct sctp_sock * sp = sctp_sk ( sk ) ; struct socket * sock ; <StartBug> int err = 0 ; sock = NULL ; <EndBug> if ( ! asoc ) return - EINVAL ; if ( waitqueue_active ( & asoc -> wait ) ) return - EBUSY ; if ( ! sctp_style ( sk , UDP ) ) return - EINVAL ; err = sock_create ( sk -> sk_family , SOCK_SEQPACKET , IPPROTO_SCTP , & sock ) ; if ( err < 0 ) return err ; sctp_copy_sock ( sock -> sk , sk , asoc ) ; sp -> pf -> to_sk_daddr ( & asoc -> peer . primary_addr , sk ) ; sctp_sock_migrate ( sk , sock -> sk , asoc , SCTP_SOCKET_UDP_HIGH_BANDWIDTH ) ; * sockp = sock ; return err ; }",1,289,-3.171653046899751,-0.010974578016954156
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
int sctp_do_peeloff ( struct sock * sk , sctp_assoc_t id , struct socket * * sockp ) { struct sctp_association * asoc = sctp_id2assoc ( sk , id ) ; struct sctp_sock * sp = sctp_sk ( sk ) ; struct socket * sock ; <StartBug> int err = 0 ; <EndBug> if ( ! asoc ) return - EINVAL ; if ( waitqueue_active ( & asoc -> wait ) ) return - EBUSY ; if ( ! sctp_style ( sk , UDP ) ) return - EINVAL ; err = sock_create ( sk -> sk_family , SOCK_SEQPACKET , IPPROTO_SCTP , & sock ) ; if ( err < 0 ) return err ; sctp_copy_sock ( sock -> sk , sk , asoc ) ; sp -> pf -> to_sk_daddr ( & asoc -> peer . primary_addr , sk ) ; sctp_sock_migrate ( sk , sock -> sk , asoc , SCTP_SOCKET_UDP_HIGH_BANDWIDTH ) ; * sockp = sock ; return err ; }
Fixed code:","
int sctp_do_peeloff ( struct sock * sk , sctp_assoc_t id , struct socket * * sockp ) { struct sctp_association * asoc = sctp_id2assoc ( sk , id ) ; struct sctp_sock * sp = sctp_sk ( sk ) ; struct socket * sock ; <StartBug> int err = 0 ; sock = NULL; <EndBug> if ( ! asoc ) return - EINVAL ; if ( waitqueue_active ( & asoc -> wait ) ) return - EBUSY ; if ( ! sctp_style ( sk , UDP ) ) return - EINVAL ; err = sock_create ( sk -> sk_family , SOCK_SEQPACKET , IPPROTO_SCTP , & sock ) ; if ( err < 0 ) return err ; sctp_copy_sock ( sock -> sk , sk , asoc ) ; sp -> pf -> to_sk_daddr ( & asoc -> peer . primary_addr , sk ) ; sctp_sock_migrate ( sk , sock -> sk , asoc , SCTP_SOCKET_UDP_HIGH_BANDWIDTH ) ; * sockp = sock ; return err ; }",1,289,-3.0391772687835763,-0.010516184321050438
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
int sctp_do_peeloff ( struct sock * sk , sctp_assoc_t id , struct socket * * sockp ) { struct sctp_association * asoc = sctp_id2assoc ( sk , id ) ; struct sctp_sock * sp = sctp_sk ( sk ) ; struct socket * sock ; <StartBug> int err = 0 ; <EndBug> if ( ! asoc ) return - EINVAL ; if ( waitqueue_active ( & asoc -> wait ) ) return - EBUSY ; if ( ! sctp_style ( sk , UDP ) ) return - EINVAL ; err = sock_create ( sk -> sk_family , SOCK_SEQPACKET , IPPROTO_SCTP , & sock ) ; if ( err < 0 ) return err ; sctp_copy_sock ( sock -> sk , sk , asoc ) ; sp -> pf -> to_sk_daddr ( & asoc -> peer . primary_addr , sk ) ; sctp_sock_migrate ( sk , sock -> sk , asoc , SCTP_SOCKET_UDP_HIGH_BANDWIDTH ) ; * sockp = sock ; return err ; }
Fixed code:","
int sctp_do_peeloff ( struct sock * sk , sctp_assoc_t id , struct socket * * sockp ) { struct sctp_association * asoc = sctp_id2assoc ( sk , id ) ; struct sctp_sock * sp = sctp_sk ( sk ) ; struct socket * sock ; <StartBug> int err = 0 ; sock = NULL; <EndBug> if ( ! asoc ) return - EINVAL ; if ( waitqueue_active ( & asoc -> wait ) ) return - EBUSY ; if ( ! sctp_style ( sk , UDP ) ) return - EINVAL ; err = sock_create ( sk -> sk_family , SOCK_SEQPACKET , IPPROTO_SCTP , & sock ) ; if ( err < 0 ) return err ; sctp_copy_sock ( sock -> sk , sk , asoc ) ; sp -> pf -> to_sk_daddr ( & asoc -> peer . primary_addr , sk ) ; sctp_sock_migrate ( sk , sock -> sk , asoc , SCTP_SOCKET_UDP_HIGH_BANDWIDTH ) ; * sockp = sock ; return err ; }",1,289,-2.8970233618931824,-0.010024302290287829
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
int sctp_do_peeloff ( struct sock * sk , sctp_assoc_t id , struct socket * * sockp ) { struct sctp_association * asoc = sctp_id2assoc ( sk , id ) ; struct sctp_sock * sp = sctp_sk ( sk ) ; struct socket * sock ; <StartBug> int err = 0 ; <EndBug> if ( ! asoc ) return - EINVAL ; if ( waitqueue_active ( & asoc -> wait ) ) return - EBUSY ; if ( ! sctp_style ( sk , UDP ) ) return - EINVAL ; err = sock_create ( sk -> sk_family , SOCK_SEQPACKET , IPPROTO_SCTP , & sock ) ; if ( err < 0 ) return err ; sctp_copy_sock ( sock -> sk , sk , asoc ) ; sp -> pf -> to_sk_daddr ( & asoc -> peer . primary_addr , sk ) ; sctp_sock_migrate ( sk , sock -> sk , asoc , SCTP_SOCKET_UDP_HIGH_BANDWIDTH ) ; * sockp = sock ; return err ; }
Fixed code:","
int sctp_do_peeloff ( struct sock * sk , sctp_assoc_t id , struct socket * * sockp ) { struct sctp_association * asoc = sctp_id2assoc ( sk , id ) ; struct sctp_sock * sp = sctp_sk ( sk ) ; struct socket * sock ; <StartBug> int err = 0 ; /* Set err to 0*/ if ( ! asoc ){ /* Release asoc */ sctp_association_put(asoc); return - EINVAL ; } <EndBug> if ( waitqueue_active ( & asoc -> wait ) ) { /* Release asoc */ sctp_association_put(asoc); return - EBUSY ; } if ( ! sctp_style ( sk , UDP ) ) { /* Release asoc */ sctp_association_put(asoc); return - EINVAL ; } err = sock_create ( sk -> sk_family , SOCK_SEQPACKET , IPPROTO_SCTP , & sock ) ; if ( err < 0 ) { /* Release asoc */ sctp_association_put(asoc); return err ; } sctp_copy_sock ( sock -> sk , sk , asoc ) ; sp -> pf -> to_sk_daddr ( & asoc -> peer . primary_addr , sk ) ; sctp_sock_migrate ( sk , sock -> sk , asoc , SCTP_SOCKET_UDP_HIGH_BANDWIDTH ) ; * sockp = sock ; /* Release asoc */ sctp_association_put(asoc); return err ; }",1,384,-30.687141308965167,-0.07991443049209679
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
int sctp_do_peeloff ( struct sock * sk , sctp_assoc_t id , struct socket * * sockp ) { struct sctp_association * asoc = sctp_id2assoc ( sk , id ) ; struct sctp_sock * sp = sctp_sk ( sk ) ; struct socket * sock ; <StartBug> int err = 0 ; <EndBug> if ( ! asoc ) return - EINVAL ; if ( waitqueue_active ( & asoc -> wait ) ) return - EBUSY ; if ( ! sctp_style ( sk , UDP ) ) return - EINVAL ; err = sock_create ( sk -> sk_family , SOCK_SEQPACKET , IPPROTO_SCTP , & sock ) ; if ( err < 0 ) return err ; sctp_copy_sock ( sock -> sk , sk , asoc ) ; sp -> pf -> to_sk_daddr ( & asoc -> peer . primary_addr , sk ) ; sctp_sock_migrate ( sk , sock -> sk , asoc , SCTP_SOCKET_UDP_HIGH_BANDWIDTH ) ; * sockp = sock ; return err ; }
Fixed code:","
int sctp_do_peeloff ( struct sock * sk , sctp_assoc_t id , struct socket * * sockp ) { struct sctp_association * asoc = sctp_id2assoc ( sk , id ) ; struct sctp_sock * sp = sctp_sk ( sk ) ; struct socket * sock ; <StartBug> int err = 0 ; if ( ! asoc ) { err = - EINVAL ; goto out ; } <EndBug> if ( waitqueue_active ( & asoc -> wait ) ) { err = - EBUSY ; goto out ; } if ( ! sctp_style ( sk , UDP ) ) { err = - EINVAL ; goto out ; } err = sock_create ( sk -> sk_family , SOCK_SEQPACKET , IPPROTO_SCTP , & sock ) ; if ( err < 0 ) goto out ; sctp_copy_sock ( sock -> sk , sk , asoc ) ; sp -> pf -> to_sk_daddr ( & asoc -> peer . primary_addr , sk ) ; sctp_sock_migrate ( sk , sock -> sk , asoc , SCTP_SOCKET_UDP_HIGH_BANDWIDTH ) ; * sockp = sock ; out : return err ; }",1,305,-5.7532964033950735,-0.018863266896377292
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
int sctp_do_peeloff ( struct sock * sk , sctp_assoc_t id , struct socket * * sockp ) { struct sctp_association * asoc = sctp_id2assoc ( sk , id ) ; struct sctp_sock * sp = sctp_sk ( sk ) ; struct socket * sock ; <StartBug> int err = 0 ; <EndBug> if ( ! asoc ) return - EINVAL ; if ( waitqueue_active ( & asoc -> wait ) ) return - EBUSY ; if ( ! sctp_style ( sk , UDP ) ) return - EINVAL ; err = sock_create ( sk -> sk_family , SOCK_SEQPACKET , IPPROTO_SCTP , & sock ) ; if ( err < 0 ) return err ; sctp_copy_sock ( sock -> sk , sk , asoc ) ; sp -> pf -> to_sk_daddr ( & asoc -> peer . primary_addr , sk ) ; sctp_sock_migrate ( sk , sock -> sk , asoc , SCTP_SOCKET_UDP_HIGH_BANDWIDTH ) ; * sockp = sock ; return err ; }
Fixed code:","
int sctp_do_peeloff ( struct sock * sk , sctp_assoc_t id , struct socket * * sockp ) { struct sctp_association * asoc = sctp_id2assoc ( sk , id ) ; struct sctp_sock * sp = sctp_sk ( sk ) ; struct socket * sock ; <StartBug> int err ; <EndBug> err = 0 ; if ( ! asoc ) return - EINVAL ; if ( waitqueue_active ( & asoc -> wait ) ) return - EBUSY ; if ( ! sctp_style ( sk , UDP ) ) return - EINVAL ; err = sock_create ( sk -> sk_family , SOCK_SEQPACKET , IPPROTO_SCTP , & sock ) ; if ( err < 0 ) return err ; sctp_copy_sock ( sock -> sk , sk , asoc ) ; sp -> pf -> to_sk_daddr ( & asoc -> peer . primary_addr , sk ) ; sctp_sock_migrate ( sk , sock -> sk , asoc , SCTP_SOCKET_UDP_HIGH_BANDWIDTH ) ; * sockp = sock ; return err ; }",1,287,-3.9308376899693913,-0.013696298571321921
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
int sctp_do_peeloff ( struct sock * sk , sctp_assoc_t id , struct socket * * sockp ) { struct sctp_association * asoc = sctp_id2assoc ( sk , id ) ; struct sctp_sock * sp = sctp_sk ( sk ) ; struct socket * sock ; <StartBug> int err = 0 ; <EndBug> if ( ! asoc ) return - EINVAL ; if ( waitqueue_active ( & asoc -> wait ) ) return - EBUSY ; if ( ! sctp_style ( sk , UDP ) ) return - EINVAL ; err = sock_create ( sk -> sk_family , SOCK_SEQPACKET , IPPROTO_SCTP , & sock ) ; if ( err < 0 ) return err ; sctp_copy_sock ( sock -> sk , sk , asoc ) ; sp -> pf -> to_sk_daddr ( & asoc -> peer . primary_addr , sk ) ; sctp_sock_migrate ( sk , sock -> sk , asoc , SCTP_SOCKET_UDP_HIGH_BANDWIDTH ) ; * sockp = sock ; return err ; }
Fixed code:","
int sctp_do_peeloff ( struct sock * sk , sctp_assoc_t id , struct socket * * sockp ) { struct sctp_association * asoc = sctp_id2assoc ( sk , id ) ; struct sctp_sock * sp = sctp_sk ( sk ) ; struct socket * sock ; <StartBug> int err = 0 ; if ( asoc ) { err = sock_create ( sk -> sk_family , SOCK_SEQPACKET , IPPROTO_SCTP , & sock ) ; if ( err < 0 ) { if ( asoc ) sctp_association_put ( asoc ) ; return err ; } <EndBug> if ( waitqueue_active ( & asoc -> wait ) ) { if ( asoc ) sctp_association_put ( asoc ) ; return - EBUSY ; } if ( ! sctp_style ( sk , UDP ) ) { if ( asoc ) sctp_association_put ( asoc ) ; return - EINVAL ; } sctp_copy_sock ( sock -> sk , sk , asoc ) ; sp -> pf -> to_sk_daddr ( & asoc -> peer . primary_addr , sk ) ; sctp_sock_migrate ( sk , sock -> sk , asoc , SCTP_SOCKET_UDP_HIGH_BANDWIDTH ) ; * sockp = sock ; return err ; }",1,339,-15.815369959416255,-0.04665300872984146
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
int sctp_do_peeloff ( struct sock * sk , sctp_assoc_t id , struct socket * * sockp ) { struct sctp_association * asoc = sctp_id2assoc ( sk , id ) ; struct sctp_sock * sp = sctp_sk ( sk ) ; struct socket * sock ; <StartBug> int err = 0 ; <EndBug> if ( ! asoc ) return - EINVAL ; if ( waitqueue_active ( & asoc -> wait ) ) return - EBUSY ; if ( ! sctp_style ( sk , UDP ) ) return - EINVAL ; err = sock_create ( sk -> sk_family , SOCK_SEQPACKET , IPPROTO_SCTP , & sock ) ; if ( err < 0 ) return err ; sctp_copy_sock ( sock -> sk , sk , asoc ) ; sp -> pf -> to_sk_daddr ( & asoc -> peer . primary_addr , sk ) ; sctp_sock_migrate ( sk , sock -> sk , asoc , SCTP_SOCKET_UDP_HIGH_BANDWIDTH ) ; * sockp = sock ; return err ; }
Fixed code:","
int sctp_do_peeloff ( struct sock * sk , sctp_assoc_t id , struct socket * * sockp ) { struct sctp_association * asoc = sctp_id2assoc ( sk , id ) ; struct sctp_sock * sp = sctp_sk ( sk ) ; struct socket * sock ; <StartBug> int err = 0 ; sock_release(sock); <EndBug> if ( ! asoc ) return - EINVAL ; if ( waitqueue_active ( & asoc -> wait ) ) return - EBUSY ; if ( ! sctp_style ( sk , UDP ) ) return - EINVAL ; err = sock_create ( sk -> sk_family , SOCK_SEQPACKET , IPPROTO_SCTP , & sock ) ; if ( err < 0 ) return err ; sctp_copy_sock ( sock -> sk , sk , asoc ) ; sp -> pf -> to_sk_daddr ( & asoc -> peer . primary_addr , sk ) ; sctp_sock_migrate ( sk , sock -> sk , asoc , SCTP_SOCKET_UDP_HIGH_BANDWIDTH ) ; * sockp = sock ; return err ; }",1,292,-3.899276906882798,-0.013353688037269856
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
int sctp_do_peeloff ( struct sock * sk , sctp_assoc_t id , struct socket * * sockp ) { struct sctp_association * asoc = sctp_id2assoc ( sk , id ) ; struct sctp_sock * sp = sctp_sk ( sk ) ; struct socket * sock ; <StartBug> int err = 0 ; <EndBug> if ( ! asoc ) return - EINVAL ; if ( waitqueue_active ( & asoc -> wait ) ) return - EBUSY ; if ( ! sctp_style ( sk , UDP ) ) return - EINVAL ; err = sock_create ( sk -> sk_family , SOCK_SEQPACKET , IPPROTO_SCTP , & sock ) ; if ( err < 0 ) return err ; sctp_copy_sock ( sock -> sk , sk , asoc ) ; sp -> pf -> to_sk_daddr ( & asoc -> peer . primary_addr , sk ) ; sctp_sock_migrate ( sk , sock -> sk , asoc , SCTP_SOCKET_UDP_HIGH_BANDWIDTH ) ; * sockp = sock ; return err ; }
Fixed code:","
int sctp_do_peeloff ( struct sock * sk , sctp_assoc_t id , struct socket * * sockp ) { struct sctp_association * asoc = sctp_id2assoc ( sk , id ) ; struct sctp_sock * sp = sctp_sk ( sk ) ; struct socket * sock ; <StartBug> int err = 0 ; sock = sock_create ( sk -> sk_family , SOCK_SEQPACKET , IPPROTO_SCTP , & sock ) ; if ( sock == NULL )  return -ENOMEM; <EndBug> if ( ! asoc ) return - EINVAL ; if ( waitqueue_active ( & asoc -> wait ) ) return - EBUSY ; if ( ! sctp_style ( sk , UDP ) ) return - EINVAL ; err = sock_create ( sk -> sk_family , SOCK_SEQPACKET , IPPROTO_SCTP , & sock ) ; if ( err < 0 ) return err ; sctp_copy_sock ( sock -> sk , sk , asoc ) ; sp -> pf -> to_sk_daddr ( & asoc -> peer . primary_addr , sk ) ; sctp_sock_migrate ( sk , sock -> sk , asoc , SCTP_SOCKET_UDP_HIGH_BANDWIDTH ) ; * sockp = sock ; return err ; }",1,331,-15.282377563870293,-0.046170324966375506
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
int sctp_do_peeloff ( struct sock * sk , sctp_assoc_t id , struct socket * * sockp ) { struct sctp_association * asoc = sctp_id2assoc ( sk , id ) ; struct sctp_sock * sp = sctp_sk ( sk ) ; struct socket * sock ; <StartBug> int err = 0 ; <EndBug> if ( ! asoc ) return - EINVAL ; if ( waitqueue_active ( & asoc -> wait ) ) return - EBUSY ; if ( ! sctp_style ( sk , UDP ) ) return - EINVAL ; err = sock_create ( sk -> sk_family , SOCK_SEQPACKET , IPPROTO_SCTP , & sock ) ; if ( err < 0 ) return err ; sctp_copy_sock ( sock -> sk , sk , asoc ) ; sp -> pf -> to_sk_daddr ( & asoc -> peer . primary_addr , sk ) ; sctp_sock_migrate ( sk , sock -> sk , asoc , SCTP_SOCKET_UDP_HIGH_BANDWIDTH ) ; * sockp = sock ; return err ; }
Fixed code:","
int sctp_do_peeloff ( struct sock * sk , sctp_assoc_t id , struct socket * * sockp ) { struct sctp_association * asoc = sctp_id2assoc ( sk , id ) ; struct sctp_sock * sp = sctp_sk ( sk ) ; struct socket * sock ; <StartBug> int err = 0 ; sock = NULL; <EndBug> if ( ! asoc ) return - EINVAL ; if ( waitqueue_active ( & asoc -> wait ) ) return - EBUSY ; if ( ! sctp_style ( sk , UDP ) ) return - EINVAL ; err = sock_create ( sk -> sk_family , SOCK_SEQPACKET , IPPROTO_SCTP , & sock ) ; if ( err < 0 ) return err ; sctp_copy_sock ( sock -> sk , sk , asoc ) ; sp -> pf -> to_sk_daddr ( & asoc -> peer . primary_addr , sk ) ; sctp_sock_migrate ( sk , sock -> sk , asoc , SCTP_SOCKET_UDP_HIGH_BANDWIDTH ) ; * sockp = sock ; return err ; }",1,289,-2.9931729197753465,-0.010356999722406043
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
int sctp_do_peeloff ( struct sock * sk , sctp_assoc_t id , struct socket * * sockp ) { struct sctp_association * asoc = sctp_id2assoc ( sk , id ) ; struct sctp_sock * sp = sctp_sk ( sk ) ; struct socket * sock ; <StartBug> int err = 0 ; <EndBug> if ( ! asoc ) return - EINVAL ; if ( waitqueue_active ( & asoc -> wait ) ) return - EBUSY ; if ( ! sctp_style ( sk , UDP ) ) return - EINVAL ; err = sock_create ( sk -> sk_family , SOCK_SEQPACKET , IPPROTO_SCTP , & sock ) ; if ( err < 0 ) return err ; sctp_copy_sock ( sock -> sk , sk , asoc ) ; sp -> pf -> to_sk_daddr ( & asoc -> peer . primary_addr , sk ) ; sctp_sock_migrate ( sk , sock -> sk , asoc , SCTP_SOCKET_UDP_HIGH_BANDWIDTH ) ; * sockp = sock ; return err ; }
Fixed code:","
int sctp_do_peeloff ( struct sock * sk , sctp_assoc_t id , struct socket * * sockp ) { struct sctp_association * asoc = sctp_id2assoc ( sk , id ) ; struct sctp_sock * sp = sctp_sk ( sk ) ; struct socket * sock ; <StartBug> int err = 0 ; if ( ! asoc ) return - EINVAL ; err = sock_create ( sk -> sk_family , SOCK_SEQPACKET , IPPROTO_SCTP , & sock ) ; <EndBug> if ( waitqueue_active ( & asoc -> wait ) ) return - EBUSY ; if ( ! sctp_style ( sk , UDP ) ) return - EINVAL ; if ( err < 0 ) return err ; sctp_copy_sock ( sock -> sk , sk , asoc ) ; sp -> pf -> to_sk_daddr ( & asoc -> peer . primary_addr , sk ) ; sctp_sock_migrate ( sk , sock -> sk , asoc , SCTP_SOCKET_UDP_HIGH_BANDWIDTH ) ; * sockp = sock ; return err ; }",1,285,-10.578650843184308,-0.03711807313398003
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
int sctp_do_peeloff ( struct sock * sk , sctp_assoc_t id , struct socket * * sockp ) { struct sctp_association * asoc = sctp_id2assoc ( sk , id ) ; struct sctp_sock * sp = sctp_sk ( sk ) ; struct socket * sock ; <StartBug> int err = 0 ; <EndBug> if ( ! asoc ) return - EINVAL ; if ( waitqueue_active ( & asoc -> wait ) ) return - EBUSY ; if ( ! sctp_style ( sk , UDP ) ) return - EINVAL ; err = sock_create ( sk -> sk_family , SOCK_SEQPACKET , IPPROTO_SCTP , & sock ) ; if ( err < 0 ) return err ; sctp_copy_sock ( sock -> sk , sk , asoc ) ; sp -> pf -> to_sk_daddr ( & asoc -> peer . primary_addr , sk ) ; sctp_sock_migrate ( sk , sock -> sk , asoc , SCTP_SOCKET_UDP_HIGH_BANDWIDTH ) ; * sockp = sock ; return err ; }
Fixed code:","
int sctp_do_peeloff ( struct sock * sk , sctp_assoc_t id , struct socket * * sockp ) { struct sctp_association * asoc = sctp_id2assoc ( sk , id ) ; struct sctp_sock * sp = sctp_sk ( sk ) ; struct socket * sock ; <StartBug> int err = 0 ; sock = * sockp ; <EndBug> if ( ! asoc ) return - EINVAL ; if ( waitqueue_active ( & asoc -> wait ) ) return - EBUSY ; if ( ! sctp_style ( sk , UDP ) ) return - EINVAL ; err = sock_create ( sk -> sk_family , SOCK_SEQPACKET , IPPROTO_SCTP , & sock ) ; if ( err < 0 ) return err ; sctp_copy_sock ( sock -> sk , sk , asoc ) ; sp -> pf -> to_sk_daddr ( & asoc -> peer . primary_addr , sk ) ; sctp_sock_migrate ( sk , sock -> sk , asoc , SCTP_SOCKET_UDP_HIGH_BANDWIDTH ) ; * sockp = sock ; return err ; }",1,291,-5.095741372937578,-0.017511138738617107
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
int sctp_do_peeloff ( struct sock * sk , sctp_assoc_t id , struct socket * * sockp ) { struct sctp_association * asoc = sctp_id2assoc ( sk , id ) ; struct sctp_sock * sp = sctp_sk ( sk ) ; struct socket * sock ; <StartBug> int err = 0 ; <EndBug> if ( ! asoc ) return - EINVAL ; if ( waitqueue_active ( & asoc -> wait ) ) return - EBUSY ; if ( ! sctp_style ( sk , UDP ) ) return - EINVAL ; err = sock_create ( sk -> sk_family , SOCK_SEQPACKET , IPPROTO_SCTP , & sock ) ; if ( err < 0 ) return err ; sctp_copy_sock ( sock -> sk , sk , asoc ) ; sp -> pf -> to_sk_daddr ( & asoc -> peer . primary_addr , sk ) ; sctp_sock_migrate ( sk , sock -> sk , asoc , SCTP_SOCKET_UDP_HIGH_BANDWIDTH ) ; * sockp = sock ; return err ; }
Fixed code:","
int sctp_do_peeloff ( struct sock * sk , sctp_assoc_t id , struct socket * * sockp ) { struct sctp_association * asoc = sctp_id2assoc ( sk , id ) ; struct sctp_sock * sp = sctp_sk ( sk ) ; struct socket * sock ; <StartBug> int err = 0 ; if ( ! asoc ) { err = - EINVAL ; goto out ; } <EndBug> if ( waitqueue_active ( & asoc -> wait ) ) { err = - EBUSY ; goto out ; } if ( ! sctp_style ( sk , UDP ) ) { err = - EINVAL ; goto out ; } err = sock_create ( sk -> sk_family , SOCK_SEQPACKET , IPPROTO_SCTP , & sock ) ; if ( err < 0 ) goto out ; sctp_copy_sock ( sock -> sk , sk , asoc ) ; sp -> pf -> to_sk_daddr ( & asoc -> peer . primary_addr , sk ) ; sctp_sock_migrate ( sk , sock -> sk , asoc , SCTP_SOCKET_UDP_HIGH_BANDWIDTH ) ; * sockp = sock ; out : return err ; }",1,305,-5.71077280988902,-0.018723845278324658
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
int sctp_do_peeloff ( struct sock * sk , sctp_assoc_t id , struct socket * * sockp ) { struct sctp_association * asoc = sctp_id2assoc ( sk , id ) ; struct sctp_sock * sp = sctp_sk ( sk ) ; struct socket * sock ; <StartBug> int err = 0 ; <EndBug> if ( ! asoc ) return - EINVAL ; if ( waitqueue_active ( & asoc -> wait ) ) return - EBUSY ; if ( ! sctp_style ( sk , UDP ) ) return - EINVAL ; err = sock_create ( sk -> sk_family , SOCK_SEQPACKET , IPPROTO_SCTP , & sock ) ; if ( err < 0 ) return err ; sctp_copy_sock ( sock -> sk , sk , asoc ) ; sp -> pf -> to_sk_daddr ( & asoc -> peer . primary_addr , sk ) ; sctp_sock_migrate ( sk , sock -> sk , asoc , SCTP_SOCKET_UDP_HIGH_BANDWIDTH ) ; * sockp = sock ; return err ; }
Fixed code:","
int sctp_do_peeloff ( struct sock * sk , sctp_assoc_t id , struct socket * * sockp ) { struct sctp_association * asoc = sctp_id2assoc ( sk , id ) ; struct sctp_sock * sp = sctp_sk ( sk ) ; struct socket * sock ; <StartBug> int err = 0 ; sock_release ( sock ) ; <EndBug> if ( ! asoc ) return - EINVAL ; if ( waitqueue_active ( & asoc -> wait ) ) return - EBUSY ; if ( ! sctp_style ( sk , UDP ) ) return - EINVAL ; err = sock_create ( sk -> sk_family , SOCK_SEQPACKET , IPPROTO_SCTP , & sock ) ; if ( err < 0 ) return err ; sctp_copy_sock ( sock -> sk , sk , asoc ) ; sp -> pf -> to_sk_daddr ( & asoc -> peer . primary_addr , sk ) ; sctp_sock_migrate ( sk , sock -> sk , asoc , SCTP_SOCKET_UDP_HIGH_BANDWIDTH ) ; * sockp = sock ; return err ; }",1,292,-3.361540722238102,-0.011512125761089391
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
int sctp_do_peeloff ( struct sock * sk , sctp_assoc_t id , struct socket * * sockp ) { struct sctp_association * asoc = sctp_id2assoc ( sk , id ) ; struct sctp_sock * sp = sctp_sk ( sk ) ; struct socket * sock ; <StartBug> int err = 0 ; <EndBug> if ( ! asoc ) return - EINVAL ; if ( waitqueue_active ( & asoc -> wait ) ) return - EBUSY ; if ( ! sctp_style ( sk , UDP ) ) return - EINVAL ; err = sock_create ( sk -> sk_family , SOCK_SEQPACKET , IPPROTO_SCTP , & sock ) ; if ( err < 0 ) return err ; sctp_copy_sock ( sock -> sk , sk , asoc ) ; sp -> pf -> to_sk_daddr ( & asoc -> peer . primary_addr , sk ) ; sctp_sock_migrate ( sk , sock -> sk , asoc , SCTP_SOCKET_UDP_HIGH_BANDWIDTH ) ; * sockp = sock ; return err ; }
Fixed code:","
int sctp_do_peeloff ( struct sock * sk , sctp_assoc_t id , struct socket * * sockp ) { struct sctp_association * asoc = sctp_id2assoc ( sk , id ) ; struct sctp_sock * sp = sctp_sk ( sk ) ; struct socket * sock ; <StartBug> int err ; <EndBug> err = 0; if ( ! asoc ) return - EINVAL ; if ( waitqueue_active ( & asoc -> wait ) ) return - EBUSY ; if ( ! sctp_style ( sk , UDP ) ) return - EINVAL ; err = sock_create ( sk -> sk_family , SOCK_SEQPACKET , IPPROTO_SCTP , & sock ) ; if ( err < 0 ) return err ; sctp_copy_sock ( sock -> sk , sk , asoc ) ; sp -> pf -> to_sk_daddr ( & asoc -> peer . primary_addr , sk ) ; sctp_sock_migrate ( sk , sock -> sk , asoc , SCTP_SOCKET_UDP_HIGH_BANDWIDTH ) ; * sockp = sock ; return err ; }",1,287,-2.8751780896962393,-0.01001804212437714
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
int sctp_do_peeloff ( struct sock * sk , sctp_assoc_t id , struct socket * * sockp ) { struct sctp_association * asoc = sctp_id2assoc ( sk , id ) ; struct sctp_sock * sp = sctp_sk ( sk ) ; struct socket * sock ; <StartBug> int err = 0 ; <EndBug> if ( ! asoc ) return - EINVAL ; if ( waitqueue_active ( & asoc -> wait ) ) return - EBUSY ; if ( ! sctp_style ( sk , UDP ) ) return - EINVAL ; err = sock_create ( sk -> sk_family , SOCK_SEQPACKET , IPPROTO_SCTP , & sock ) ; if ( err < 0 ) return err ; sctp_copy_sock ( sock -> sk , sk , asoc ) ; sp -> pf -> to_sk_daddr ( & asoc -> peer . primary_addr , sk ) ; sctp_sock_migrate ( sk , sock -> sk , asoc , SCTP_SOCKET_UDP_HIGH_BANDWIDTH ) ; * sockp = sock ; return err ; }
Fixed code:","
int sctp_do_peeloff ( struct sock * sk , sctp_assoc_t id , struct socket * * sockp ) { struct sctp_association * asoc = sctp_id2assoc ( sk , id ) ; struct sctp_sock * sp = sctp_sk ( sk ) ; struct socket * sock ; <StartBug> int err = 0 ; sock = kzalloc ( sizeof ( struct socket ) , GFP_KERNEL ) ; if ( ! sock ) { err = - ENOMEM ; return err ; } <EndBug> if ( ! asoc ) return - EINVAL ; if ( waitqueue_active ( & asoc -> wait ) ) return - EBUSY ; if ( ! sctp_style ( sk , UDP ) ) return - EINVAL ; err = sock_create ( sk -> sk_family , SOCK_SEQPACKET , IPPROTO_SCTP , & sock ) ; if ( err < 0 ) return err ; sctp_copy_sock ( sock -> sk , sk , asoc ) ; sp -> pf -> to_sk_daddr ( & asoc -> peer . primary_addr , sk ) ; sctp_sock_migrate ( sk , sock -> sk , asoc , SCTP_SOCKET_UDP_HIGH_BANDWIDTH ) ; * sockp = sock ; return err ; }",1,322,-9.671360891301838,-0.03003528227112372
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
int sctp_do_peeloff ( struct sock * sk , sctp_assoc_t id , struct socket * * sockp ) { struct sctp_association * asoc = sctp_id2assoc ( sk , id ) ; struct sctp_sock * sp = sctp_sk ( sk ) ; struct socket * sock ; <StartBug> int err = 0 ; <EndBug> if ( ! asoc ) return - EINVAL ; if ( waitqueue_active ( & asoc -> wait ) ) return - EBUSY ; if ( ! sctp_style ( sk , UDP ) ) return - EINVAL ; err = sock_create ( sk -> sk_family , SOCK_SEQPACKET , IPPROTO_SCTP , & sock ) ; if ( err < 0 ) return err ; sctp_copy_sock ( sock -> sk , sk , asoc ) ; sp -> pf -> to_sk_daddr ( & asoc -> peer . primary_addr , sk ) ; sctp_sock_migrate ( sk , sock -> sk , asoc , SCTP_SOCKET_UDP_HIGH_BANDWIDTH ) ; * sockp = sock ; return err ; }
Fixed code:","
int sctp_do_peeloff ( struct sock * sk , sctp_assoc_t id , struct socket * * sockp ) { struct sctp_association * asoc = sctp_id2assoc ( sk , id ) ; struct sctp_sock * sp = sctp_sk ( sk ) ; struct socket * sock ; <StartBug> int err ; <EndBug> err = 0 ; if ( ! asoc ) return - EINVAL ; if ( waitqueue_active ( & asoc -> wait ) ) return - EBUSY ; if ( ! sctp_style ( sk , UDP ) ) return - EINVAL ; err = sock_create ( sk -> sk_family , SOCK_SEQPACKET , IPPROTO_SCTP , & sock ) ; if ( err < 0 ) return err ; sctp_copy_sock ( sock -> sk , sk , asoc ) ; sp -> pf -> to_sk_daddr ( & asoc -> peer . primary_addr , sk ) ; sctp_sock_migrate ( sk , sock -> sk , asoc , SCTP_SOCKET_UDP_HIGH_BANDWIDTH ) ; * sockp = sock ; return err ; }",1,287,-4.002380734421789,-0.013945577471852922
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
int sctp_do_peeloff ( struct sock * sk , sctp_assoc_t id , struct socket * * sockp ) { struct sctp_association * asoc = sctp_id2assoc ( sk , id ) ; struct sctp_sock * sp = sctp_sk ( sk ) ; struct socket * sock ; <StartBug> int err = 0 ; <EndBug> if ( ! asoc ) return - EINVAL ; if ( waitqueue_active ( & asoc -> wait ) ) return - EBUSY ; if ( ! sctp_style ( sk , UDP ) ) return - EINVAL ; err = sock_create ( sk -> sk_family , SOCK_SEQPACKET , IPPROTO_SCTP , & sock ) ; if ( err < 0 ) return err ; sctp_copy_sock ( sock -> sk , sk , asoc ) ; sp -> pf -> to_sk_daddr ( & asoc -> peer . primary_addr , sk ) ; sctp_sock_migrate ( sk , sock -> sk , asoc , SCTP_SOCKET_UDP_HIGH_BANDWIDTH ) ; * sockp = sock ; return err ; }
Fixed code:","
int sctp_do_peeloff ( struct sock * sk , sctp_assoc_t id , struct socket * * sockp ) { struct sctp_association * asoc = sctp_id2assoc ( sk , id ) ; struct sctp_sock * sp = sctp_sk ( sk ) ; struct socket * sock ; <StartBug> int err = 0 ; sock_release(sock); <EndBug> if ( ! asoc ) return - EINVAL ; if ( waitqueue_active ( & asoc -> wait ) ) return - EBUSY ; if ( ! sctp_style ( sk , UDP ) ) return - EINVAL ; err = sock_create ( sk -> sk_family , SOCK_SEQPACKET , IPPROTO_SCTP , & sock ) ; if ( err < 0 ) return err ; sctp_copy_sock ( sock -> sk , sk , asoc ) ; sp -> pf -> to_sk_daddr ( & asoc -> peer . primary_addr , sk ) ; sctp_sock_migrate ( sk , sock -> sk , asoc , SCTP_SOCKET_UDP_HIGH_BANDWIDTH ) ; * sockp = sock ; return err ; }",1,292,-3.5351571329584432,-0.012106702510131654
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
int sctp_do_peeloff ( struct sock * sk , sctp_assoc_t id , struct socket * * sockp ) { struct sctp_association * asoc = sctp_id2assoc ( sk , id ) ; struct sctp_sock * sp = sctp_sk ( sk ) ; struct socket * sock ; <StartBug> int err = 0 ; <EndBug> if ( ! asoc ) return - EINVAL ; if ( waitqueue_active ( & asoc -> wait ) ) return - EBUSY ; if ( ! sctp_style ( sk , UDP ) ) return - EINVAL ; err = sock_create ( sk -> sk_family , SOCK_SEQPACKET , IPPROTO_SCTP , & sock ) ; if ( err < 0 ) return err ; sctp_copy_sock ( sock -> sk , sk , asoc ) ; sp -> pf -> to_sk_daddr ( & asoc -> peer . primary_addr , sk ) ; sctp_sock_migrate ( sk , sock -> sk , asoc , SCTP_SOCKET_UDP_HIGH_BANDWIDTH ) ; * sockp = sock ; return err ; }
Fixed code:","
int sctp_do_peeloff ( struct sock * sk , sctp_assoc_t id , struct socket * * sockp ) { struct sctp_association * asoc = sctp_id2assoc ( sk , id ) ; struct sctp_sock * sp = sctp_sk ( sk ) ; struct socket * sock ; <StartBug> int err ; sock = NULL; <EndBug> if ( ! asoc ) return - EINVAL ; if ( waitqueue_active ( & asoc -> wait ) ) return - EBUSY ; if ( ! sctp_style ( sk , UDP ) ) return - EINVAL ; err = sock_create ( sk -> sk_family , SOCK_SEQPACKET , IPPROTO_SCTP , & sock ) ; if ( err < 0 ) return err ; sctp_copy_sock ( sock -> sk , sk , asoc ) ; sp -> pf -> to_sk_daddr ( & asoc -> peer . primary_addr , sk ) ; sctp_sock_migrate ( sk , sock -> sk , asoc , SCTP_SOCKET_UDP_HIGH_BANDWIDTH ) ; * sockp = sock ; return 0 ; }",1,287,-8.908298006709503,-0.031039365877036595
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
int sctp_do_peeloff ( struct sock * sk , sctp_assoc_t id , struct socket * * sockp ) { struct sctp_association * asoc = sctp_id2assoc ( sk , id ) ; struct sctp_sock * sp = sctp_sk ( sk ) ; struct socket * sock ; <StartBug> int err = 0 ; <EndBug> if ( ! asoc ) return - EINVAL ; if ( waitqueue_active ( & asoc -> wait ) ) return - EBUSY ; if ( ! sctp_style ( sk , UDP ) ) return - EINVAL ; err = sock_create ( sk -> sk_family , SOCK_SEQPACKET , IPPROTO_SCTP , & sock ) ; if ( err < 0 ) return err ; sctp_copy_sock ( sock -> sk , sk , asoc ) ; sp -> pf -> to_sk_daddr ( & asoc -> peer . primary_addr , sk ) ; sctp_sock_migrate ( sk , sock -> sk , asoc , SCTP_SOCKET_UDP_HIGH_BANDWIDTH ) ; * sockp = sock ; return err ; }
Fixed code:","
int sctp_do_peeloff ( struct sock * sk , sctp_assoc_t id , struct socket * * sockp ) { struct sctp_association * asoc ; int err = 0 ; <StartBug> asoc = sctp_id2assoc ( sk , id ) ; <EndBug> if ( ! asoc ) return - EINVAL ; if ( waitqueue_active ( & asoc -> wait ) ) return - EBUSY ; if ( ! sctp_style ( sk , UDP ) ) return - EINVAL ; err = sock_create ( sk -> sk_family , SOCK_SEQPACKET , IPPROTO_SCTP , & sock ) ; if ( err < 0 ) return err ; sctp_copy_sock ( sock -> sk , sk , asoc ) ; sp -> pf -> to_sk_daddr ( & asoc -> peer . primary_addr , sk ) ; sctp_sock_migrate ( sk , sock -> sk , asoc , SCTP_SOCKET_UDP_HIGH_BANDWIDTH ) ; * sockp = sock ; return err ; }",1,264,-9.502962529488903,-0.035996070187457964
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
int sctp_do_peeloff ( struct sock * sk , sctp_assoc_t id , struct socket * * sockp ) { struct sctp_association * asoc = sctp_id2assoc ( sk , id ) ; struct sctp_sock * sp = sctp_sk ( sk ) ; struct socket * sock ; <StartBug> int err = 0 ; <EndBug> if ( ! asoc ) return - EINVAL ; if ( waitqueue_active ( & asoc -> wait ) ) return - EBUSY ; if ( ! sctp_style ( sk , UDP ) ) return - EINVAL ; err = sock_create ( sk -> sk_family , SOCK_SEQPACKET , IPPROTO_SCTP , & sock ) ; if ( err < 0 ) return err ; sctp_copy_sock ( sock -> sk , sk , asoc ) ; sp -> pf -> to_sk_daddr ( & asoc -> peer . primary_addr , sk ) ; sctp_sock_migrate ( sk , sock -> sk , asoc , SCTP_SOCKET_UDP_HIGH_BANDWIDTH ) ; * sockp = sock ; return err ; }
Fixed code:","
int sctp_do_peeloff ( struct sock * sk , sctp_assoc_t id , struct socket * * sockp ) { struct sctp_association * asoc = sctp_id2assoc ( sk , id ) ; struct sctp_sock * sp = sctp_sk ( sk ) ; struct socket * sock ; <StartBug> int err = 0 ; if ( ! asoc ) { err = - EINVAL ; goto out ; } <EndBug> if ( waitqueue_active ( & asoc -> wait ) ) { err = - EBUSY ; goto out ; } if ( ! sctp_style ( sk , UDP ) ) { err = - EINVAL ; goto out ; } err = sock_create ( sk -> sk_family , SOCK_SEQPACKET , IPPROTO_SCTP , & sock ) ; if ( err < 0 ) goto out ; sctp_copy_sock ( sock -> sk , sk , asoc ) ; sp -> pf -> to_sk_daddr ( & asoc -> peer . primary_addr , sk ) ; sctp_sock_migrate ( sk , sock -> sk , asoc , SCTP_SOCKET_UDP_HIGH_BANDWIDTH ) ; * sockp = sock ; out : return err ; }",1,305,-5.71077280988902,-0.018723845278324658
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
int sctp_do_peeloff ( struct sock * sk , sctp_assoc_t id , struct socket * * sockp ) { struct sctp_association * asoc = sctp_id2assoc ( sk , id ) ; struct sctp_sock * sp = sctp_sk ( sk ) ; struct socket * sock ; <StartBug> int err = 0 ; <EndBug> if ( ! asoc ) return - EINVAL ; if ( waitqueue_active ( & asoc -> wait ) ) return - EBUSY ; if ( ! sctp_style ( sk , UDP ) ) return - EINVAL ; err = sock_create ( sk -> sk_family , SOCK_SEQPACKET , IPPROTO_SCTP , & sock ) ; if ( err < 0 ) return err ; sctp_copy_sock ( sock -> sk , sk , asoc ) ; sp -> pf -> to_sk_daddr ( & asoc -> peer . primary_addr , sk ) ; sctp_sock_migrate ( sk , sock -> sk , asoc , SCTP_SOCKET_UDP_HIGH_BANDWIDTH ) ; * sockp = sock ; return err ; }
Fixed code:","

int sctp_do_peeloff(struct sock *sk, sctp_assoc_t id, struct socket **sockp) {
    struct sctp_association *asoc = sctp_id2assoc(sk, id);
    struct sctp_sock *sp = sctp_sk(sk);
    struct socket *sock;
    int err = 0;

    if (!asoc) 
        return -EINVAL;
    if (waitqueue_active(&asoc->wait)) 
        return -EBUSY;
    if (!sctp_style(sk, UDP)) 
        return -EINVAL;
    // <StartBug>
    if (asoc->base.sk) 
        sock_put(asoc->base.sk);
    // <EndBug>
    err = sock_create(sk->sk_family, SOCK_SEQPACKET, IPPROTO_SCTP, &sock);
    if (err < 0) 
        return err;
    sctp_copy_sock(sock->sk, sk, asoc);
    sp->pf->to_sk_daddr(&asoc->peer.primary_addr, sk);
    sctp_sock_migrate(sk, sock->sk, asoc, SCTP_SOCKET_UDP_HIGH_BANDWIDTH);
    *sockp = sock;
    return err;
}",1,350,-23.14013529316012,-0.06611467226617178
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
int sctp_do_peeloff ( struct sock * sk , sctp_assoc_t id , struct socket * * sockp ) { struct sctp_association * asoc = sctp_id2assoc ( sk , id ) ; struct sctp_sock * sp = sctp_sk ( sk ) ; struct socket * sock ; <StartBug> int err = 0 ; <EndBug> if ( ! asoc ) return - EINVAL ; if ( waitqueue_active ( & asoc -> wait ) ) return - EBUSY ; if ( ! sctp_style ( sk , UDP ) ) return - EINVAL ; err = sock_create ( sk -> sk_family , SOCK_SEQPACKET , IPPROTO_SCTP , & sock ) ; if ( err < 0 ) return err ; sctp_copy_sock ( sock -> sk , sk , asoc ) ; sp -> pf -> to_sk_daddr ( & asoc -> peer . primary_addr , sk ) ; sctp_sock_migrate ( sk , sock -> sk , asoc , SCTP_SOCKET_UDP_HIGH_BANDWIDTH ) ; * sockp = sock ; return err ; }
Fixed code:","
int sctp_do_peeloff ( struct sock * sk , sctp_assoc_t id , struct socket * * sockp ) { struct sctp_association * asoc = sctp_id2assoc ( sk , id ) ; struct sctp_sock * sp = sctp_sk ( sk ) ; struct socket * sock ; <StartBug> int err = 0 ; if ( ! asoc ) { err = - EINVAL ; goto out ; } <EndBug> if ( waitqueue_active ( & asoc -> wait ) ) return - EBUSY ; if ( ! sctp_style ( sk , UDP ) ) return - EINVAL ; err = sock_create ( sk -> sk_family , SOCK_SEQPACKET , IPPROTO_SCTP , & sock ) ; if ( err < 0 ) return err ; sctp_copy_sock ( sock -> sk , sk , asoc ) ; sp -> pf -> to_sk_daddr ( & asoc -> peer . primary_addr , sk ) ; sctp_sock_migrate ( sk , sock -> sk , asoc , SCTP_SOCKET_UDP_HIGH_BANDWIDTH ) ; * sockp = sock ; out : return err ; }",1,293,-6.550135662917309,-0.022355411818830405
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
int sctp_do_peeloff ( struct sock * sk , sctp_assoc_t id , struct socket * * sockp ) { struct sctp_association * asoc = sctp_id2assoc ( sk , id ) ; struct sctp_sock * sp = sctp_sk ( sk ) ; struct socket * sock ; <StartBug> int err = 0 ; <EndBug> if ( ! asoc ) return - EINVAL ; if ( waitqueue_active ( & asoc -> wait ) ) return - EBUSY ; if ( ! sctp_style ( sk , UDP ) ) return - EINVAL ; err = sock_create ( sk -> sk_family , SOCK_SEQPACKET , IPPROTO_SCTP , & sock ) ; if ( err < 0 ) return err ; sctp_copy_sock ( sock -> sk , sk , asoc ) ; sp -> pf -> to_sk_daddr ( & asoc -> peer . primary_addr , sk ) ; sctp_sock_migrate ( sk , sock -> sk , asoc , SCTP_SOCKET_UDP_HIGH_BANDWIDTH ) ; * sockp = sock ; return err ; }
Fixed code:","
int sctp_do_peeloff ( struct sock * sk , sctp_assoc_t id , struct socket * * sockp ) { struct sctp_association * asoc = sctp_id2assoc ( sk , id ) ; struct sctp_sock * sp = sctp_sk ( sk ) ; struct socket * sock ; <StartBug> int err = 0 ; sock_release ( sock ) ; <EndBug> if ( ! asoc ) return - EINVAL ; if ( waitqueue_active ( & asoc -> wait ) ) return - EBUSY ; if ( ! sctp_style ( sk , UDP ) ) return - EINVAL ; err = sock_create ( sk -> sk_family , SOCK_SEQPACKET , IPPROTO_SCTP , & sock ) ; if ( err < 0 ) return err ; sctp_copy_sock ( sock -> sk , sk , asoc ) ; sp -> pf -> to_sk_daddr ( & asoc -> peer . primary_addr , sk ) ; sctp_sock_migrate ( sk , sock -> sk , asoc , SCTP_SOCKET_UDP_HIGH_BANDWIDTH ) ; * sockp = sock ; return err ; }",1,292,-3.361540722238102,-0.011512125761089391
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
int sctp_do_peeloff ( struct sock * sk , sctp_assoc_t id , struct socket * * sockp ) { struct sctp_association * asoc = sctp_id2assoc ( sk , id ) ; struct sctp_sock * sp = sctp_sk ( sk ) ; struct socket * sock ; <StartBug> int err = 0 ; <EndBug> if ( ! asoc ) return - EINVAL ; if ( waitqueue_active ( & asoc -> wait ) ) return - EBUSY ; if ( ! sctp_style ( sk , UDP ) ) return - EINVAL ; err = sock_create ( sk -> sk_family , SOCK_SEQPACKET , IPPROTO_SCTP , & sock ) ; if ( err < 0 ) return err ; sctp_copy_sock ( sock -> sk , sk , asoc ) ; sp -> pf -> to_sk_daddr ( & asoc -> peer . primary_addr , sk ) ; sctp_sock_migrate ( sk , sock -> sk , asoc , SCTP_SOCKET_UDP_HIGH_BANDWIDTH ) ; * sockp = sock ; return err ; }
Fixed code:","
int sctp_do_peeloff ( struct sock * sk , sctp_assoc_t id , struct socket * * sockp ) { struct sctp_association * asoc = sctp_id2assoc ( sk , id ) ; struct sctp_sock * sp = sctp_sk ( sk ) ; struct socket * sock ; <StartBug> int err = 0 ; sock = NULL; <EndBug> if ( ! asoc ) return - EINVAL ; if ( waitqueue_active ( & asoc -> wait ) ) return - EBUSY ; if ( ! sctp_style ( sk , UDP ) ) return - EINVAL ; err = sock_create ( sk -> sk_family , SOCK_SEQPACKET , IPPROTO_SCTP , & sock ) ; if ( err < 0 ) return err ; sctp_copy_sock ( sock -> sk , sk , asoc ) ; sp -> pf -> to_sk_daddr ( & asoc -> peer . primary_addr , sk ) ; sctp_sock_migrate ( sk , sock -> sk , asoc , SCTP_SOCKET_UDP_HIGH_BANDWIDTH ) ; * sockp = sock ; return err ; }",1,289,-2.9288566582498494,-0.010134452104670759
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
int sctp_do_peeloff ( struct sock * sk , sctp_assoc_t id , struct socket * * sockp ) { struct sctp_association * asoc = sctp_id2assoc ( sk , id ) ; struct sctp_sock * sp = sctp_sk ( sk ) ; struct socket * sock ; <StartBug> int err = 0 ; <EndBug> if ( ! asoc ) return - EINVAL ; if ( waitqueue_active ( & asoc -> wait ) ) return - EBUSY ; if ( ! sctp_style ( sk , UDP ) ) return - EINVAL ; err = sock_create ( sk -> sk_family , SOCK_SEQPACKET , IPPROTO_SCTP , & sock ) ; if ( err < 0 ) return err ; sctp_copy_sock ( sock -> sk , sk , asoc ) ; sp -> pf -> to_sk_daddr ( & asoc -> peer . primary_addr , sk ) ; sctp_sock_migrate ( sk , sock -> sk , asoc , SCTP_SOCKET_UDP_HIGH_BANDWIDTH ) ; * sockp = sock ; return err ; }
Fixed code:","
int sctp_do_peeloff ( struct sock * sk , sctp_assoc_t id , struct socket * * sockp ) { struct sctp_association * asoc = sctp_id2assoc ( sk , id ) ; struct sctp_sock * sp = sctp_sk ( sk ) ; struct socket * sock ; <StartBug> int err = 0 ; sock = NULL ; <EndBug> if ( ! asoc ) return - EINVAL ; if ( waitqueue_active ( & asoc -> wait ) ) return - EBUSY ; if ( ! sctp_style ( sk , UDP ) ) return - EINVAL ; err = sock_create ( sk -> sk_family , SOCK_SEQPACKET , IPPROTO_SCTP , & sock ) ; if ( err < 0 ) return err ; sctp_copy_sock ( sock -> sk , sk , asoc ) ; sp -> pf -> to_sk_daddr ( & asoc -> peer . primary_addr , sk ) ; sctp_sock_migrate ( sk , sock -> sk , asoc , SCTP_SOCKET_UDP_HIGH_BANDWIDTH ) ; * sockp = sock ; return err ; }",1,289,-3.2299824888156685,-0.011176409995901967
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
int sctp_do_peeloff ( struct sock * sk , sctp_assoc_t id , struct socket * * sockp ) { struct sctp_association * asoc = sctp_id2assoc ( sk , id ) ; struct sctp_sock * sp = sctp_sk ( sk ) ; struct socket * sock ; <StartBug> int err = 0 ; <EndBug> if ( ! asoc ) return - EINVAL ; if ( waitqueue_active ( & asoc -> wait ) ) return - EBUSY ; if ( ! sctp_style ( sk , UDP ) ) return - EINVAL ; err = sock_create ( sk -> sk_family , SOCK_SEQPACKET , IPPROTO_SCTP , & sock ) ; if ( err < 0 ) return err ; sctp_copy_sock ( sock -> sk , sk , asoc ) ; sp -> pf -> to_sk_daddr ( & asoc -> peer . primary_addr , sk ) ; sctp_sock_migrate ( sk , sock -> sk , asoc , SCTP_SOCKET_UDP_HIGH_BANDWIDTH ) ; * sockp = sock ; return err ; }
Fixed code:","
int sctp_do_peeloff ( struct sock * sk , sctp_assoc_t id , struct socket * * sockp ) { struct sctp_association * asoc = sctp_id2assoc ( sk , id ) ; struct sctp_sock * sp = sctp_sk ( sk ) ; struct socket * sock ; <StartBug> int err = 0 ; kfree(asoc); <EndBug> if ( ! asoc ) return - EINVAL ; if ( waitqueue_active ( & asoc -> wait ) ) return - EBUSY ; if ( ! sctp_style ( sk , UDP ) ) return - EINVAL ; err = sock_create ( sk -> sk_family , SOCK_SEQPACKET , IPPROTO_SCTP , & sock ) ; if ( err < 0 ) return err ; sctp_copy_sock ( sock -> sk , sk , asoc ) ; sp -> pf -> to_sk_daddr ( & asoc -> peer . primary_addr , sk ) ; sctp_sock_migrate ( sk , sock -> sk , asoc , SCTP_SOCKET_UDP_HIGH_BANDWIDTH ) ; * sockp = sock ; return err ; }",1,291,-6.993277273899829,-0.024031880666322437
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
int sctp_do_peeloff ( struct sock * sk , sctp_assoc_t id , struct socket * * sockp ) { struct sctp_association * asoc = sctp_id2assoc ( sk , id ) ; struct sctp_sock * sp = sctp_sk ( sk ) ; struct socket * sock ; <StartBug> int err = 0 ; <EndBug> if ( ! asoc ) return - EINVAL ; if ( waitqueue_active ( & asoc -> wait ) ) return - EBUSY ; if ( ! sctp_style ( sk , UDP ) ) return - EINVAL ; err = sock_create ( sk -> sk_family , SOCK_SEQPACKET , IPPROTO_SCTP , & sock ) ; if ( err < 0 ) return err ; sctp_copy_sock ( sock -> sk , sk , asoc ) ; sp -> pf -> to_sk_daddr ( & asoc -> peer . primary_addr , sk ) ; sctp_sock_migrate ( sk , sock -> sk , asoc , SCTP_SOCKET_UDP_HIGH_BANDWIDTH ) ; * sockp = sock ; return err ; }
Fixed code:","
int sctp_do_peeloff ( struct sock * sk , sctp_assoc_t id , struct socket * * sockp ) { struct sctp_association * asoc = sctp_id2assoc ( sk , id ) ; struct sctp_sock * sp = sctp_sk ( sk ) ; struct socket * sock ; <StartBug> int err = 0 ; sock_release ( sock ) ; <EndBug> if ( ! asoc ) return - EINVAL ; if ( waitqueue_active ( & asoc -> wait ) ) return - EBUSY ; if ( ! sctp_style ( sk , UDP ) ) return - EINVAL ; err = sock_create ( sk -> sk_family , SOCK_SEQPACKET , IPPROTO_SCTP , & sock ) ; if ( err < 0 ) return err ; sctp_copy_sock ( sock -> sk , sk , asoc ) ; sp -> pf -> to_sk_daddr ( & asoc -> peer . primary_addr , sk ) ; sctp_sock_migrate ( sk , sock -> sk , asoc , SCTP_SOCKET_UDP_HIGH_BANDWIDTH ) ; * sockp = sock ; return err ; }",1,292,-3.6560784820548293,-0.012520816719365854
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
int sctp_do_peeloff ( struct sock * sk , sctp_assoc_t id , struct socket * * sockp ) { struct sctp_association * asoc = sctp_id2assoc ( sk , id ) ; struct sctp_sock * sp = sctp_sk ( sk ) ; struct socket * sock ; <StartBug> int err = 0 ; <EndBug> if ( ! asoc ) return - EINVAL ; if ( waitqueue_active ( & asoc -> wait ) ) return - EBUSY ; if ( ! sctp_style ( sk , UDP ) ) return - EINVAL ; err = sock_create ( sk -> sk_family , SOCK_SEQPACKET , IPPROTO_SCTP , & sock ) ; if ( err < 0 ) return err ; sctp_copy_sock ( sock -> sk , sk , asoc ) ; sp -> pf -> to_sk_daddr ( & asoc -> peer . primary_addr , sk ) ; sctp_sock_migrate ( sk , sock -> sk , asoc , SCTP_SOCKET_UDP_HIGH_BANDWIDTH ) ; * sockp = sock ; return err ; }
Fixed code:","
int sctp_do_peeloff ( struct sock * sk , sctp_assoc_t id , struct socket * * sockp ) { struct sctp_association * asoc = sctp_id2assoc ( sk , id ) ; struct sctp_sock * sp = sctp_sk ( sk ) ; struct socket * sock ; <StartBug> int err = 0 ; sock = NULL; <EndBug> if ( ! asoc ) return - EINVAL ; if ( waitqueue_active ( & asoc -> wait ) ) return - EBUSY ; if ( ! sctp_style ( sk , UDP ) ) return - EINVAL ; err = sock_create ( sk -> sk_family , SOCK_SEQPACKET , IPPROTO_SCTP , & sock ) ; if ( err < 0 ) return err ; sctp_copy_sock ( sock -> sk , sk , asoc ) ; sp -> pf -> to_sk_daddr ( & asoc -> peer . primary_addr , sk ) ; sctp_sock_migrate ( sk , sock -> sk , asoc , SCTP_SOCKET_UDP_HIGH_BANDWIDTH ) ; * sockp = sock ; return err ; }",1,289,-2.8933254619830473,-0.010011506788868675
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
int sctp_do_peeloff ( struct sock * sk , sctp_assoc_t id , struct socket * * sockp ) { struct sctp_association * asoc = sctp_id2assoc ( sk , id ) ; struct sctp_sock * sp = sctp_sk ( sk ) ; struct socket * sock ; <StartBug> int err = 0 ; <EndBug> if ( ! asoc ) return - EINVAL ; if ( waitqueue_active ( & asoc -> wait ) ) return - EBUSY ; if ( ! sctp_style ( sk , UDP ) ) return - EINVAL ; err = sock_create ( sk -> sk_family , SOCK_SEQPACKET , IPPROTO_SCTP , & sock ) ; if ( err < 0 ) return err ; sctp_copy_sock ( sock -> sk , sk , asoc ) ; sp -> pf -> to_sk_daddr ( & asoc -> peer . primary_addr , sk ) ; sctp_sock_migrate ( sk , sock -> sk , asoc , SCTP_SOCKET_UDP_HIGH_BANDWIDTH ) ; * sockp = sock ; return err ; }
Fixed code:","
int sctp_do_peeloff ( struct sock * sk , sctp_assoc_t id , struct socket * * sockp ) { struct sctp_association * asoc = sctp_id2assoc ( sk , id ) ; struct sctp_sock * sp = sctp_sk ( sk ) ; struct socket * sock ; <StartBug> int err = 0 ; if ( ! asoc ) { err = - EINVAL ; goto err_out ; } <EndBug> if ( waitqueue_active ( & asoc -> wait ) ) { err = - EBUSY ; goto err_out ; } if ( ! sctp_style ( sk , UDP ) ) { err = - EINVAL ; goto err_out ; } err = sock_create ( sk -> sk_family , SOCK_SEQPACKET , IPPROTO_SCTP , & sock ) ; if ( err < 0 ) goto err_out ; sctp_copy_sock ( sock -> sk , sk , asoc ) ; sp -> pf -> to_sk_daddr ( & asoc -> peer . primary_addr , sk ) ; sctp_sock_migrate ( sk , sock -> sk , asoc , SCTP_SOCKET_UDP_HIGH_BANDWIDTH ) ; * sockp = sock ; return err ; err_out: return err ; }",1,318,-10.062292081162289,-0.031642427928183295
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
int sctp_do_peeloff ( struct sock * sk , sctp_assoc_t id , struct socket * * sockp ) { struct sctp_association * asoc = sctp_id2assoc ( sk , id ) ; struct sctp_sock * sp = sctp_sk ( sk ) ; struct socket * sock ; <StartBug> int err = 0 ; <EndBug> if ( ! asoc ) return - EINVAL ; if ( waitqueue_active ( & asoc -> wait ) ) return - EBUSY ; if ( ! sctp_style ( sk , UDP ) ) return - EINVAL ; err = sock_create ( sk -> sk_family , SOCK_SEQPACKET , IPPROTO_SCTP , & sock ) ; if ( err < 0 ) return err ; sctp_copy_sock ( sock -> sk , sk , asoc ) ; sp -> pf -> to_sk_daddr ( & asoc -> peer . primary_addr , sk ) ; sctp_sock_migrate ( sk , sock -> sk , asoc , SCTP_SOCKET_UDP_HIGH_BANDWIDTH ) ; * sockp = sock ; return err ; }
Fixed code:","
int sctp_do_peeloff ( struct sock * sk , sctp_assoc_t id , struct socket * * sockp ) { struct sctp_association * asoc = sctp_id2assoc ( sk , id ) ; struct sctp_sock * sp = sctp_sk ( sk ) ; struct socket * sock ; <StartBug> int err ; <EndBug> err = 0; if ( ! asoc ) return - EINVAL ; if ( waitqueue_active ( & asoc -> wait ) ) return - EBUSY ; if ( ! sctp_style ( sk , UDP ) ) return - EINVAL ; err = sock_create ( sk -> sk_family , SOCK_SEQPACKET , IPPROTO_SCTP , & sock ) ; if ( err < 0 ) return err ; sctp_copy_sock ( sock -> sk , sk , asoc ) ; sp -> pf -> to_sk_daddr ( & asoc -> peer . primary_addr , sk ) ; sctp_sock_migrate ( sk , sock -> sk , asoc , SCTP_SOCKET_UDP_HIGH_BANDWIDTH ) ; * sockp = sock ; return err ; }",1,287,-2.726897460391901,-0.00950138487941429
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
int sctp_do_peeloff ( struct sock * sk , sctp_assoc_t id , struct socket * * sockp ) { struct sctp_association * asoc = sctp_id2assoc ( sk , id ) ; struct sctp_sock * sp = sctp_sk ( sk ) ; struct socket * sock ; <StartBug> int err = 0 ; <EndBug> if ( ! asoc ) return - EINVAL ; if ( waitqueue_active ( & asoc -> wait ) ) return - EBUSY ; if ( ! sctp_style ( sk , UDP ) ) return - EINVAL ; err = sock_create ( sk -> sk_family , SOCK_SEQPACKET , IPPROTO_SCTP , & sock ) ; if ( err < 0 ) return err ; sctp_copy_sock ( sock -> sk , sk , asoc ) ; sp -> pf -> to_sk_daddr ( & asoc -> peer . primary_addr , sk ) ; sctp_sock_migrate ( sk , sock -> sk , asoc , SCTP_SOCKET_UDP_HIGH_BANDWIDTH ) ; * sockp = sock ; return err ; }
Fixed code:","
int sctp_do_peeloff ( struct sock * sk , sctp_assoc_t id , struct socket * * sockp ) { struct sctp_association * asoc = sctp_id2assoc ( sk , id ) ; struct sctp_sock * sp = sctp_sk ( sk ) ; struct socket * sock ; <StartBug> int err = - EINVAL ; <EndBug> if ( ! asoc ) return - EINVAL ; if ( waitqueue_active ( & asoc -> wait ) ) return - EBUSY ; if ( ! sctp_style ( sk , UDP ) ) return - EINVAL ; err = sock_create ( sk -> sk_family , SOCK_SEQPACKET , IPPROTO_SCTP , & sock ) ; if ( err < 0 ) return err ; sctp_copy_sock ( sock -> sk , sk , asoc ) ; sp -> pf -> to_sk_daddr ( & asoc -> peer . primary_addr , sk ) ; sctp_sock_migrate ( sk , sock -> sk , asoc , SCTP_SOCKET_UDP_HIGH_BANDWIDTH ) ; * sockp = sock ; return err ; }",1,288,-5.339440476511233,-0.018539723876775115
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
int sctp_do_peeloff ( struct sock * sk , sctp_assoc_t id , struct socket * * sockp ) { struct sctp_association * asoc = sctp_id2assoc ( sk , id ) ; struct sctp_sock * sp = sctp_sk ( sk ) ; struct socket * sock ; <StartBug> int err = 0 ; <EndBug> if ( ! asoc ) return - EINVAL ; if ( waitqueue_active ( & asoc -> wait ) ) return - EBUSY ; if ( ! sctp_style ( sk , UDP ) ) return - EINVAL ; err = sock_create ( sk -> sk_family , SOCK_SEQPACKET , IPPROTO_SCTP , & sock ) ; if ( err < 0 ) return err ; sctp_copy_sock ( sock -> sk , sk , asoc ) ; sp -> pf -> to_sk_daddr ( & asoc -> peer . primary_addr , sk ) ; sctp_sock_migrate ( sk , sock -> sk , asoc , SCTP_SOCKET_UDP_HIGH_BANDWIDTH ) ; * sockp = sock ; return err ; }
Fixed code:","
int sctp_do_peeloff ( struct sock * sk , sctp_assoc_t id , struct socket * * sockp ) { struct sctp_association * asoc = sctp_id2assoc ( sk , id ) ; struct sctp_sock * sp = sctp_sk ( sk ) ; struct socket * sock ; <StartBug> int err = 0 ; err = -EINVAL ; <EndBug> if ( ! asoc ) return err ; if ( waitqueue_active ( & asoc -> wait ) ) return - EBUSY ; if ( ! sctp_style ( sk , UDP ) ) return err ; err = sock_create ( sk -> sk_family , SOCK_SEQPACKET , IPPROTO_SCTP , & sock ) ; if ( err < 0 ) return err ; sctp_copy_sock ( sock -> sk , sk , asoc ) ; sp -> pf -> to_sk_daddr ( & asoc -> peer . primary_addr , sk ) ; sctp_sock_migrate ( sk , sock -> sk , asoc , SCTP_SOCKET_UDP_HIGH_BANDWIDTH ) ; * sockp = sock ; return err ; }",1,286,-9.199976710822087,-0.03216775073714016
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
int sctp_do_peeloff ( struct sock * sk , sctp_assoc_t id , struct socket * * sockp ) { struct sctp_association * asoc = sctp_id2assoc ( sk , id ) ; struct sctp_sock * sp = sctp_sk ( sk ) ; struct socket * sock ; <StartBug> int err = 0 ; <EndBug> if ( ! asoc ) return - EINVAL ; if ( waitqueue_active ( & asoc -> wait ) ) return - EBUSY ; if ( ! sctp_style ( sk , UDP ) ) return - EINVAL ; err = sock_create ( sk -> sk_family , SOCK_SEQPACKET , IPPROTO_SCTP , & sock ) ; if ( err < 0 ) return err ; sctp_copy_sock ( sock -> sk , sk , asoc ) ; sp -> pf -> to_sk_daddr ( & asoc -> peer . primary_addr , sk ) ; sctp_sock_migrate ( sk , sock -> sk , asoc , SCTP_SOCKET_UDP_HIGH_BANDWIDTH ) ; * sockp = sock ; return err ; }
Fixed code:","
int sctp_do_peeloff ( struct sock * sk , sctp_assoc_t id , struct socket * * sockp ) { struct sctp_association * asoc = sctp_id2assoc ( sk , id ) ; struct sctp_sock * sp = sctp_sk ( sk ) ; struct socket * sock ; <StartBug> int err = 0 ; sock = NULL; <EndBug> if ( ! asoc ) return - EINVAL ; if ( waitqueue_active ( & asoc -> wait ) ) return - EBUSY ; if ( ! sctp_style ( sk , UDP ) ) return - EINVAL ; err = sock_create ( sk -> sk_family , SOCK_SEQPACKET , IPPROTO_SCTP , & sock ) ; if ( err < 0 ) return err ; sctp_copy_sock ( sock -> sk , sk , asoc ) ; sp -> pf -> to_sk_daddr ( & asoc -> peer . primary_addr , sk ) ; sctp_sock_migrate ( sk , sock -> sk , asoc , SCTP_SOCKET_UDP_HIGH_BANDWIDTH ) ; * sockp = sock ; return err ; }",1,289,-3.032105096355049,-0.01049171313617664
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
int sctp_do_peeloff ( struct sock * sk , sctp_assoc_t id , struct socket * * sockp ) { struct sctp_association * asoc = sctp_id2assoc ( sk , id ) ; struct sctp_sock * sp = sctp_sk ( sk ) ; struct socket * sock ; <StartBug> int err = 0 ; <EndBug> if ( ! asoc ) return - EINVAL ; if ( waitqueue_active ( & asoc -> wait ) ) return - EBUSY ; if ( ! sctp_style ( sk , UDP ) ) return - EINVAL ; err = sock_create ( sk -> sk_family , SOCK_SEQPACKET , IPPROTO_SCTP , & sock ) ; if ( err < 0 ) return err ; sctp_copy_sock ( sock -> sk , sk , asoc ) ; sp -> pf -> to_sk_daddr ( & asoc -> peer . primary_addr , sk ) ; sctp_sock_migrate ( sk , sock -> sk , asoc , SCTP_SOCKET_UDP_HIGH_BANDWIDTH ) ; * sockp = sock ; return err ; }
Fixed code:","
int sctp_do_peeloff ( struct sock * sk , sctp_assoc_t id , struct socket * * sockp ) { struct sctp_association * asoc = sctp_id2assoc ( sk , id ) ; struct sctp_sock * sp = sctp_sk ( sk ) ; struct socket * sock ; <StartBug> int err = 0 ; sock_release ( sock ) ; <EndBug> if ( ! asoc ) return - EINVAL ; if ( waitqueue_active ( & asoc -> wait ) ) return - EBUSY ; if ( ! sctp_style ( sk , UDP ) ) return - EINVAL ; err = sock_create ( sk -> sk_family , SOCK_SEQPACKET , IPPROTO_SCTP , & sock ) ; if ( err < 0 ) return err ; sctp_copy_sock ( sock -> sk , sk , asoc ) ; sp -> pf -> to_sk_daddr ( & asoc -> peer . primary_addr , sk ) ; sctp_sock_migrate ( sk , sock -> sk , asoc , SCTP_SOCKET_UDP_HIGH_BANDWIDTH ) ; * sockp = sock ; return err ; }",1,292,-3.6405507887156996,-0.012467639687382534
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
int sctp_do_peeloff ( struct sock * sk , sctp_assoc_t id , struct socket * * sockp ) { struct sctp_association * asoc = sctp_id2assoc ( sk , id ) ; struct sctp_sock * sp = sctp_sk ( sk ) ; struct socket * sock ; <StartBug> int err = 0 ; <EndBug> if ( ! asoc ) return - EINVAL ; if ( waitqueue_active ( & asoc -> wait ) ) return - EBUSY ; if ( ! sctp_style ( sk , UDP ) ) return - EINVAL ; err = sock_create ( sk -> sk_family , SOCK_SEQPACKET , IPPROTO_SCTP , & sock ) ; if ( err < 0 ) return err ; sctp_copy_sock ( sock -> sk , sk , asoc ) ; sp -> pf -> to_sk_daddr ( & asoc -> peer . primary_addr , sk ) ; sctp_sock_migrate ( sk , sock -> sk , asoc , SCTP_SOCKET_UDP_HIGH_BANDWIDTH ) ; * sockp = sock ; return err ; }
Fixed code:","
int sctp_do_peeloff ( struct sock * sk , sctp_assoc_t id , struct socket * * sockp ) { struct sctp_association * asoc = sctp_id2assoc ( sk , id ) ; struct sctp_sock * sp = sctp_sk ( sk ) ; struct socket * sock ; <StartBug> int err = 0 ; if ( ! asoc ) { err = - EINVAL ; goto out ; } <EndBug> if ( waitqueue_active ( & asoc -> wait ) ) { err = - EBUSY ; goto out ; } if ( ! sctp_style ( sk , UDP ) ) { err = - EINVAL ; goto out ; } err = sock_create ( sk -> sk_family , SOCK_SEQPACKET , IPPROTO_SCTP , & sock ) ; if ( err < 0 ) { err = - EINVAL ; goto out ; } sctp_copy_sock ( sock -> sk , sk , asoc ) ; sp -> pf -> to_sk_daddr ( & asoc -> peer . primary_addr , sk ) ; sctp_sock_migrate ( sk , sock -> sk , asoc , SCTP_SOCKET_UDP_HIGH_BANDWIDTH ) ; out : * sockp = sock ; return err ; }",1,314,-14.647283417180505,-0.04664739941777231
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
int sctp_do_peeloff ( struct sock * sk , sctp_assoc_t id , struct socket * * sockp ) { struct sctp_association * asoc = sctp_id2assoc ( sk , id ) ; struct sctp_sock * sp = sctp_sk ( sk ) ; struct socket * sock ; <StartBug> int err = 0 ; <EndBug> if ( ! asoc ) return - EINVAL ; if ( waitqueue_active ( & asoc -> wait ) ) return - EBUSY ; if ( ! sctp_style ( sk , UDP ) ) return - EINVAL ; err = sock_create ( sk -> sk_family , SOCK_SEQPACKET , IPPROTO_SCTP , & sock ) ; if ( err < 0 ) return err ; sctp_copy_sock ( sock -> sk , sk , asoc ) ; sp -> pf -> to_sk_daddr ( & asoc -> peer . primary_addr , sk ) ; sctp_sock_migrate ( sk , sock -> sk , asoc , SCTP_SOCKET_UDP_HIGH_BANDWIDTH ) ; * sockp = sock ; return err ; }
Fixed code:","
int sctp_do_peeloff ( struct sock * sk , sctp_assoc_t id , struct socket * * sockp ) { struct sctp_association * asoc = sctp_id2assoc ( sk , id ) ; struct sctp_sock * sp = sctp_sk ( sk ) ; struct socket * sock ; int err = 0 ; <StartBug> if ( asoc ) { if ( waitqueue_active ( & asoc -> wait ) ) { err = - EBUSY ; goto out ; } } <EndBug> if ( ! sctp_style ( sk , UDP ) ) { err = - EINVAL ; goto out ; } err = sock_create ( sk -> sk_family , SOCK_SEQPACKET , IPPROTO_SCTP , & sock ) ; if ( err < 0 ) goto out ; sctp_copy_sock ( sock -> sk , sk , asoc ) ; sp -> pf -> to_sk_daddr ( & asoc -> peer . primary_addr , sk ) ; sctp_sock_migrate ( sk , sock -> sk , asoc , SCTP_SOCKET_UDP_HIGH_BANDWIDTH ) ; * sockp = sock ; out : return err ; }",1,294,-8.921846903577745,-0.030346418039380083
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
int sctp_do_peeloff ( struct sock * sk , sctp_assoc_t id , struct socket * * sockp ) { struct sctp_association * asoc = sctp_id2assoc ( sk , id ) ; struct sctp_sock * sp = sctp_sk ( sk ) ; struct socket * sock ; <StartBug> int err = 0 ; <EndBug> if ( ! asoc ) return - EINVAL ; if ( waitqueue_active ( & asoc -> wait ) ) return - EBUSY ; if ( ! sctp_style ( sk , UDP ) ) return - EINVAL ; err = sock_create ( sk -> sk_family , SOCK_SEQPACKET , IPPROTO_SCTP , & sock ) ; if ( err < 0 ) return err ; sctp_copy_sock ( sock -> sk , sk , asoc ) ; sp -> pf -> to_sk_daddr ( & asoc -> peer . primary_addr , sk ) ; sctp_sock_migrate ( sk , sock -> sk , asoc , SCTP_SOCKET_UDP_HIGH_BANDWIDTH ) ; * sockp = sock ; return err ; }
Fixed code:","
int sctp_do_peeloff ( struct sock * sk , sctp_assoc_t id , struct socket * * sockp ) { struct sctp_association * asoc = sctp_id2assoc ( sk , id ) ; struct sctp_sock * sp = sctp_sk ( sk ) ; struct socket * sock ; <StartBug> int err ; <EndBug> err = 0; if ( ! asoc ) return - EINVAL ; if ( waitqueue_active ( & asoc -> wait ) ) return - EBUSY ; if ( ! sctp_style ( sk , UDP ) ) return - EINVAL ; err = sock_create ( sk -> sk_family , SOCK_SEQPACKET , IPPROTO_SCTP , & sock ) ; if ( err < 0 ) return err ; sctp_copy_sock ( sock -> sk , sk , asoc ) ; sp -> pf -> to_sk_daddr ( & asoc -> peer . primary_addr , sk ) ; sctp_sock_migrate ( sk , sock -> sk , asoc , SCTP_SOCKET_UDP_HIGH_BANDWIDTH ) ; * sockp = sock ; return err ; }",1,287,-2.8296706285155326,-0.009859479541865968
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
int sctp_do_peeloff ( struct sock * sk , sctp_assoc_t id , struct socket * * sockp ) { struct sctp_association * asoc = sctp_id2assoc ( sk , id ) ; struct sctp_sock * sp = sctp_sk ( sk ) ; struct socket * sock ; <StartBug> int err = 0 ; <EndBug> if ( ! asoc ) return - EINVAL ; if ( waitqueue_active ( & asoc -> wait ) ) return - EBUSY ; if ( ! sctp_style ( sk , UDP ) ) return - EINVAL ; err = sock_create ( sk -> sk_family , SOCK_SEQPACKET , IPPROTO_SCTP , & sock ) ; if ( err < 0 ) return err ; sctp_copy_sock ( sock -> sk , sk , asoc ) ; sp -> pf -> to_sk_daddr ( & asoc -> peer . primary_addr , sk ) ; sctp_sock_migrate ( sk , sock -> sk , asoc , SCTP_SOCKET_UDP_HIGH_BANDWIDTH ) ; * sockp = sock ; return err ; }
Fixed code:","
int sctp_do_peeloff ( struct sock * sk , sctp_assoc_t id , struct socket * * sockp ) { struct sctp_association * asoc = sctp_id2assoc ( sk , id ) ; struct sctp_sock * sp = sctp_sk ( sk ) ; <StartBug> int err = 0 ; struct socket * sock ; <EndBug> if ( ! asoc ) return - EINVAL ; if ( waitqueue_active ( & asoc -> wait ) ) return - EBUSY ; if ( ! sctp_style ( sk , UDP ) ) return - EINVAL ; err = sock_create ( sk -> sk_family , SOCK_SEQPACKET , IPPROTO_SCTP , & sock ) ; if ( err < 0 ) return err ; sctp_copy_sock ( sock -> sk , sk , asoc ) ; sp -> pf -> to_sk_daddr ( & asoc -> peer . primary_addr , sk ) ; sctp_sock_migrate ( sk , sock -> sk , asoc , SCTP_SOCKET_UDP_HIGH_BANDWIDTH ) ; * sockp = sock ; return err ; }",1,285,-5.1728367901397405,-0.018150304526806108
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
int sctp_do_peeloff ( struct sock * sk , sctp_assoc_t id , struct socket * * sockp ) { struct sctp_association * asoc = sctp_id2assoc ( sk , id ) ; struct sctp_sock * sp = sctp_sk ( sk ) ; struct socket * sock ; <StartBug> int err = 0 ; <EndBug> if ( ! asoc ) return - EINVAL ; if ( waitqueue_active ( & asoc -> wait ) ) return - EBUSY ; if ( ! sctp_style ( sk , UDP ) ) return - EINVAL ; err = sock_create ( sk -> sk_family , SOCK_SEQPACKET , IPPROTO_SCTP , & sock ) ; if ( err < 0 ) return err ; sctp_copy_sock ( sock -> sk , sk , asoc ) ; sp -> pf -> to_sk_daddr ( & asoc -> peer . primary_addr , sk ) ; sctp_sock_migrate ( sk , sock -> sk , asoc , SCTP_SOCKET_UDP_HIGH_BANDWIDTH ) ; * sockp = sock ; return err ; }
Fixed code:","
int sctp_do_peeloff ( struct sock * sk , sctp_assoc_t id , struct socket * * sockp ) { struct sctp_association * asoc = sctp_id2assoc ( sk , id ) ; struct sctp_sock * sp = sctp_sk ( sk ) ; struct socket * sock ; <StartBug> int err = 0 ; sock = NULL ; <EndBug> if ( ! asoc ) return - EINVAL ; if ( waitqueue_active ( & asoc -> wait ) ) return - EBUSY ; if ( ! sctp_style ( sk , UDP ) ) return - EINVAL ; err = sock_create ( sk -> sk_family , SOCK_SEQPACKET , IPPROTO_SCTP , & sock ) ; if ( err < 0 ) return err ; sctp_copy_sock ( sock -> sk , sk , asoc ) ; sp -> pf -> to_sk_daddr ( & asoc -> peer . primary_addr , sk ) ; sctp_sock_migrate ( sk , sock -> sk , asoc , SCTP_SOCKET_UDP_HIGH_BANDWIDTH ) ; * sockp = sock ; return err ; }",1,289,-3.31338006701571,-0.011464982930850208
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
int sctp_do_peeloff ( struct sock * sk , sctp_assoc_t id , struct socket * * sockp ) { struct sctp_association * asoc = sctp_id2assoc ( sk , id ) ; struct sctp_sock * sp = sctp_sk ( sk ) ; struct socket * sock ; <StartBug> int err = 0 ; <EndBug> if ( ! asoc ) return - EINVAL ; if ( waitqueue_active ( & asoc -> wait ) ) return - EBUSY ; if ( ! sctp_style ( sk , UDP ) ) return - EINVAL ; err = sock_create ( sk -> sk_family , SOCK_SEQPACKET , IPPROTO_SCTP , & sock ) ; if ( err < 0 ) return err ; sctp_copy_sock ( sock -> sk , sk , asoc ) ; sp -> pf -> to_sk_daddr ( & asoc -> peer . primary_addr , sk ) ; sctp_sock_migrate ( sk , sock -> sk , asoc , SCTP_SOCKET_UDP_HIGH_BANDWIDTH ) ; * sockp = sock ; return err ; }
Fixed code:","
int sctp_do_peeloff ( struct sock * sk , sctp_assoc_t id , struct socket * * sockp ) { struct sctp_association * asoc = sctp_id2assoc ( sk , id ) ; struct sctp_sock * sp = sctp_sk ( sk ) ; struct socket * sock ; <StartBug> int err = 0 ; sock_release ( sock ) ; <EndBug> if ( ! asoc ) return - EINVAL ; if ( waitqueue_active ( & asoc -> wait ) ) return - EBUSY ; if ( ! sctp_style ( sk , UDP ) ) return - EINVAL ; err = sock_create ( sk -> sk_family , SOCK_SEQPACKET , IPPROTO_SCTP , & sock ) ; if ( err < 0 ) return err ; sctp_copy_sock ( sock -> sk , sk , asoc ) ; sp -> pf -> to_sk_daddr ( & asoc -> peer . primary_addr , sk ) ; sctp_sock_migrate ( sk , sock -> sk , asoc , SCTP_SOCKET_UDP_HIGH_BANDWIDTH ) ; * sockp = sock ; return err ; }",1,292,-3.6405507887156996,-0.012467639687382534
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
int sctp_do_peeloff ( struct sock * sk , sctp_assoc_t id , struct socket * * sockp ) { struct sctp_association * asoc = sctp_id2assoc ( sk , id ) ; struct sctp_sock * sp = sctp_sk ( sk ) ; struct socket * sock ; <StartBug> int err = 0 ; <EndBug> if ( ! asoc ) return - EINVAL ; if ( waitqueue_active ( & asoc -> wait ) ) return - EBUSY ; if ( ! sctp_style ( sk , UDP ) ) return - EINVAL ; err = sock_create ( sk -> sk_family , SOCK_SEQPACKET , IPPROTO_SCTP , & sock ) ; if ( err < 0 ) return err ; sctp_copy_sock ( sock -> sk , sk , asoc ) ; sp -> pf -> to_sk_daddr ( & asoc -> peer . primary_addr , sk ) ; sctp_sock_migrate ( sk , sock -> sk , asoc , SCTP_SOCKET_UDP_HIGH_BANDWIDTH ) ; * sockp = sock ; return err ; }
Fixed code:","
int sctp_do_peeloff ( struct sock * sk , sctp_assoc_t id , struct socket * * sockp ) { struct sctp_association * asoc = sctp_id2assoc ( sk , id ) ; struct sctp_sock * sp = sctp_sk ( sk ) ; struct socket * sock ; <StartBug> int err = 0 ; sock_release ( sock ) ; <EndBug> if ( ! asoc ) return - EINVAL ; if ( waitqueue_active ( & asoc -> wait ) ) return - EBUSY ; if ( ! sctp_style ( sk , UDP ) ) return - EINVAL ; err = sock_create ( sk -> sk_family , SOCK_SEQPACKET , IPPROTO_SCTP , & sock ) ; if ( err < 0 ) return err ; sctp_copy_sock ( sock -> sk , sk , asoc ) ; sp -> pf -> to_sk_daddr ( & asoc -> peer . primary_addr , sk ) ; sctp_sock_migrate ( sk , sock -> sk , asoc , SCTP_SOCKET_UDP_HIGH_BANDWIDTH ) ; * sockp = sock ; return err ; }",1,292,-3.6208407272566987,-0.012400139476906503
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
int sctp_do_peeloff ( struct sock * sk , sctp_assoc_t id , struct socket * * sockp ) { struct sctp_association * asoc = sctp_id2assoc ( sk , id ) ; struct sctp_sock * sp = sctp_sk ( sk ) ; struct socket * sock ; <StartBug> int err = 0 ; <EndBug> if ( ! asoc ) return - EINVAL ; if ( waitqueue_active ( & asoc -> wait ) ) return - EBUSY ; if ( ! sctp_style ( sk , UDP ) ) return - EINVAL ; err = sock_create ( sk -> sk_family , SOCK_SEQPACKET , IPPROTO_SCTP , & sock ) ; if ( err < 0 ) return err ; sctp_copy_sock ( sock -> sk , sk , asoc ) ; sp -> pf -> to_sk_daddr ( & asoc -> peer . primary_addr , sk ) ; sctp_sock_migrate ( sk , sock -> sk , asoc , SCTP_SOCKET_UDP_HIGH_BANDWIDTH ) ; * sockp = sock ; return err ; }
Fixed code:","
int sctp_do_peeloff ( struct sock * sk , sctp_assoc_t id , struct socket * * sockp ) { struct sctp_association * asoc = sctp_id2assoc ( sk , id ) ; struct sctp_sock * sp = sctp_sk ( sk ) ; struct socket * sock ; <StartBug> int err = 0 ; sock = NULL; <EndBug> if ( ! asoc ) return - EINVAL ; if ( waitqueue_active ( & asoc -> wait ) ) return - EBUSY ; if ( ! sctp_style ( sk , UDP ) ) return - EINVAL ; err = sock_create ( sk -> sk_family , SOCK_SEQPACKET , IPPROTO_SCTP , & sock ) ; if ( err < 0 ) return err ; sctp_copy_sock ( sock -> sk , sk , asoc ) ; sp -> pf -> to_sk_daddr ( & asoc -> peer . primary_addr , sk ) ; sctp_sock_migrate ( sk , sock -> sk , asoc , SCTP_SOCKET_UDP_HIGH_BANDWIDTH ) ; * sockp = sock ; return err ; }",1,289,-3.105432885412431,-0.010745442510077615
