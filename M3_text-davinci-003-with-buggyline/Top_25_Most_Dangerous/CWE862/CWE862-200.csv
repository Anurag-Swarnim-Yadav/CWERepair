Original code,Plausible Program,Total Tokens,Sum Entropy,Mean Entropy
"The Original Code is vulnerable to CWE-862: Missing Authorization. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: <StartBug>static void construct_get_dest_keyring ( struct key * * _dest_keyring ) <EndBug>{ struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) <StartBug>break ; <EndBug>} case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( ""[dk %d]"" , key_serial ( dest_keyring ) ) ; <StartBug>return ; <EndBug>}
Fixed code:"," <StartBug>static int construct_get_dest_keyring ( struct key * * _dest_keyring ) <EndBug>{ struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; <StartBug>if (!hasAuthorization(cred, authkey)) { dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; }<EndBug> if ( dest_keyring ) break ; } case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( ""[dk %d]"" , key_serial ( dest_keyring ) ) ; return 0 ; }",551,-27.198602378453675,-0.04936225477033335
"The Original Code is vulnerable to CWE-862: Missing Authorization. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: <StartBug>static void construct_get_dest_keyring ( struct key * * _dest_keyring ) <EndBug>{ struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) <StartBug>break ; <EndBug>} case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( ""[dk %d]"" , key_serial ( dest_keyring ) ) ; <StartBug>return ; <EndBug>}
Fixed code:","
static void construct_get_dest_keyring ( struct key * * _dest_keyring ) { struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) { if ( authkey->uid == current_uid() ) { dest_keyring = key_get ( rka -> dest_keyring ) ; } else { <StartBug>kleave(""[denied]""); <EndBug>return; } } up_read ( & authkey -> sem ) ; if ( dest_keyring ) break ; } case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( ""[dk %d]"" , key_serial ( dest_keyring ) ) ; return ;}",581,-31.81330448368608,-0.05475611787209308
"The Original Code is vulnerable to CWE-862: Missing Authorization. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: <StartBug>static void construct_get_dest_keyring ( struct key * * _dest_keyring ) <EndBug>{ struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) <StartBug>break ; <EndBug>} case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( ""[dk %d]"" , key_serial ( dest_keyring ) ) ; <StartBug>return ; <EndBug>}
Fixed code:"," <StartBug>static void construct_get_dest_keyring ( struct key * * _dest_keyring ) <EndBug>{ struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) && key_validate(rka->dest_keyring) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) <StartBug>break ; <EndBug>} case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( ""[dk %d]"" , key_serial ( dest_keyring ) ) ; <StartBug>return ; <EndBug>}",581,-9.28482324343756,-0.01598076289748289
"The Original Code is vulnerable to CWE-862: Missing Authorization. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: <StartBug>static void construct_get_dest_keyring ( struct key * * _dest_keyring ) <EndBug>{ struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) <StartBug>break ; <EndBug>} case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( ""[dk %d]"" , key_serial ( dest_keyring ) ) ; <StartBug>return ; <EndBug>}
Fixed code:"," <StartBug>static void construct_get_dest_keyring ( struct key * * _dest_keyring ) <EndBug>{ struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) && rka->uid == current_uid() ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) <StartBug>break ; <EndBug>} case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( ""[dk %d]"" , key_serial ( dest_keyring ) ) ; <StartBug>return ; <EndBug>}",577,-7.478503932264532,-0.01296101201432328
"The Original Code is vulnerable to CWE-862: Missing Authorization. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: <StartBug>static void construct_get_dest_keyring ( struct key * * _dest_keyring ) <EndBug>{ struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) <StartBug>break ; <EndBug>} case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( ""[dk %d]"" , key_serial ( dest_keyring ) ) ; <StartBug>return ; <EndBug>}
Fixed code:"," <StartBug>static void construct_get_dest_keyring ( struct key * * _dest_keyring ) <EndBug>{ struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) && rka->cred->uid == cred->uid) <StartBug>dest_keyring = key_get ( rka -> dest_keyring ) ; <EndBug>up_read ( & authkey -> sem ) ; if ( dest_keyring ) break ; } case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( ""[dk %d]"" , key_serial ( dest_keyring ) ) ; <StartBug>return ; <EndBug>}",579,-10.447014204542038,-0.018043202425806627
"The Original Code is vulnerable to CWE-862: Missing Authorization. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: <StartBug>static void construct_get_dest_keyring ( struct key * * _dest_keyring ) <EndBug>{ struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) <StartBug>break ; <EndBug>} case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( ""[dk %d]"" , key_serial ( dest_keyring ) ) ; <StartBug>return ; <EndBug>}
Fixed code:"," <StartBug>static void construct_get_dest_keyring ( struct key * * _dest_keyring ) <EndBug>{ struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) && key_cred_uid_eq ( authkey -> cred , cred ) ) <StartBug>// Check if the credential UIDs match <EndBug>dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) <StartBug>break ; <EndBug>} case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( ""[dk %d]"" , key_serial ( dest_keyring ) ) ; <StartBug>return ; <EndBug>}",600,-28.43732019957189,-0.04739553366595315
"The Original Code is vulnerable to CWE-862: Missing Authorization. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: <StartBug>static void construct_get_dest_keyring ( struct key * * _dest_keyring ) <EndBug>{ struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) <StartBug>break ; <EndBug>} case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( ""[dk %d]"" , key_serial ( dest_keyring ) ) ; <StartBug>return ; <EndBug>}
Fixed code:","
<StartBug>static void construct_get_dest_keyring ( struct key * * _dest_keyring ) <EndBug>{ struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) { <StartBug>if ( authkey -> uid == cred -> uid || authkey -> gid == cred->gid) <EndBug>{ dest_keyring = key_get ( rka -> dest_keyring ) ; <StartBug>} <EndBug>up_read ( & authkey -> sem ) ; if ( dest_keyring ) break ; } case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( ""[dk %d]"" , key_serial ( dest_keyring ) ) ; <StartBug>return ; <EndBug>}",603,-26.79592365458803,-0.044437684335966884
"The Original Code is vulnerable to CWE-862: Missing Authorization. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: <StartBug>static void construct_get_dest_keyring ( struct key * * _dest_keyring ) <EndBug>{ struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) <StartBug>break ; <EndBug>} case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( ""[dk %d]"" , key_serial ( dest_keyring ) ) ; <StartBug>return ; <EndBug>}
Fixed code:"," <StartBug>static int construct_get_dest_keyring ( struct key * * _dest_keyring ) <EndBug>{ struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) && is_auth_key(authkey)) <StartBug> dest_keyring = key_get ( rka -> dest_keyring ) ; <EndBug> up_read ( & authkey -> sem ) ; if ( dest_keyring ) break ; } case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( ""[dk %d]"" , key_serial ( dest_keyring ) ) ; <StartBug>return 0; <EndBug>}",577,-16.63547593790379,-0.028830980828256136
"The Original Code is vulnerable to CWE-862: Missing Authorization. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: <StartBug>static void construct_get_dest_keyring ( struct key * * _dest_keyring ) <EndBug>{ struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) <StartBug>break ; <EndBug>} case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( ""[dk %d]"" , key_serial ( dest_keyring ) ) ; <StartBug>return ; <EndBug>}
Fixed code:"," <StartBug>static void construct_get_dest_keyring ( struct key * * _dest_keyring ) <EndBug>{ struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) && check_request_key_auth(cred,authkey)) <StartBug>dest_keyring = key_get ( rka -> dest_keyring ) ; <EndBug>up_read ( & authkey -> sem ) ; if ( dest_keyring ) break ; } case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( ""[dk %d]"" , key_serial ( dest_keyring ) ) ; return ; }

//Added function
int check_request_key_auth( const struct cred * cred, struct key * authkey){
    //Check if the user has the necessary permissions to access the keyring
    if (cred->uid == authkey->uid || cred->gid == authkey->gid || 
        has_capability(cred->cap_effective, CAP_SYS_ADMIN)){
            return 1;
    }
    
    return 0;
}",682,-66.53910741595737,-0.09756467363043603
"The Original Code is vulnerable to CWE-862: Missing Authorization. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: <StartBug>static void construct_get_dest_keyring ( struct key * * _dest_keyring ) <EndBug>{ struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) <StartBug>break ; <EndBug>} case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( ""[dk %d]"" , key_serial ( dest_keyring ) ) ; <StartBug>return ; <EndBug>}
Fixed code:"," <StartBug>static int construct_get_dest_keyring ( struct key * * _dest_keyring ) <EndBug>{ struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) && verify_auth_key(authkey) ) {<StartBug> dest_keyring = key_get ( rka -> dest_keyring ) ; <EndBug>} up_read ( & authkey -> sem ) ; if ( dest_keyring ) break ; } case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( ""[dk %d]"" , key_serial ( dest_keyring ) ) ; <StartBug> return 1; <EndBug>}",580,-26.183091396520524,-0.045143261028483664
"The Original Code is vulnerable to CWE-862: Missing Authorization. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: <StartBug>static void construct_get_dest_keyring ( struct key * * _dest_keyring ) <EndBug>{ struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) <StartBug>break ; <EndBug>} case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( ""[dk %d]"" , key_serial ( dest_keyring ) ) ; <StartBug>return ; <EndBug>}
Fixed code:"," <StartBug>static void construct_get_dest_keyring ( struct key * * _dest_keyring ) <EndBug>{ struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) && key_validate_structure ( rka -> dest_keyring , current_cred ( ) ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) <StartBug>break ; <EndBug>} case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( ""[dk %d]"" , key_serial ( dest_keyring ) ) ; <StartBug>return ; <EndBug>}",591,-18.84605209991385,-0.031888413028619035
"The Original Code is vulnerable to CWE-862: Missing Authorization. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: <StartBug>static void construct_get_dest_keyring ( struct key * * _dest_keyring ) <EndBug>{ struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) <StartBug>break ; <EndBug>} case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( ""[dk %d]"" , key_serial ( dest_keyring ) ) ; <StartBug>return ; <EndBug>}
Fixed code:"," <StartBug>static void construct_get_dest_keyring ( struct key * * _dest_keyring ) <EndBug>{ struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) && <StartBug>rka->dest_keyring == cred->process_keyring<EndBug>) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) break ; } case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( ""[dk %d]"" , key_serial ( dest_keyring ) ) ; <StartBug>return ; <EndBug>}",581,-18.88047636485344,-0.0324965169790937
"The Original Code is vulnerable to CWE-862: Missing Authorization. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: <StartBug>static void construct_get_dest_keyring ( struct key * * _dest_keyring ) <EndBug>{ struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) <StartBug>break ; <EndBug>} case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( ""[dk %d]"" , key_serial ( dest_keyring ) ) ; <StartBug>return ; <EndBug>}
Fixed code:"," <StartBug>static void construct_get_dest_keyring ( struct key * * _dest_keyring ) <EndBug>{ struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) && (authkey->uid == cred->uid)) //Compare user ids  dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) <StartBug>break ; <EndBug>} case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( ""[dk %d]"" , key_serial ( dest_keyring ) ) ; <StartBug>return ; <EndBug>}",583,-26.0418596961276,-0.04466871302937839
"The Original Code is vulnerable to CWE-862: Missing Authorization. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: <StartBug>static void construct_get_dest_keyring ( struct key * * _dest_keyring ) <EndBug>{ struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) <StartBug>break ; <EndBug>} case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( ""[dk %d]"" , key_serial ( dest_keyring ) ) ; <StartBug>return ; <EndBug>}
Fixed code:"," <StartBug>static void construct_get_dest_keyring ( struct key * * _dest_keyring ) <EndBug>{ struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; if (authkey->uid == cred->euid) { //Added this line to check authorization down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) <StartBug>break ; <EndBug>} } case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( ""[dk %d]"" , key_serial ( dest_keyring ) ) ; <StartBug>return ; <EndBug>}",588,-21.544745802266053,-0.036640724153513694
"The Original Code is vulnerable to CWE-862: Missing Authorization. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: <StartBug>static void construct_get_dest_keyring ( struct key * * _dest_keyring ) <EndBug>{ struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) <StartBug>break ; <EndBug>} case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( ""[dk %d]"" , key_serial ( dest_keyring ) ) ; <StartBug>return ; <EndBug>}
Fixed code:","

static void construct_get_dest_keyring ( struct key * * _dest_keyring ) { struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) { if ( authkey -> uid == cred -> uid) { dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) break ; } } else { up_read ( & authkey -> sem ) ; } } case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( ""[dk %d]"" , key_serial ( dest_keyring ) ) ; return ; }",576,-18.41365767546442,-0.031968155686570174
"The Original Code is vulnerable to CWE-862: Missing Authorization. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: <StartBug>static void construct_get_dest_keyring ( struct key * * _dest_keyring ) <EndBug>{ struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) <StartBug>break ; <EndBug>} case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( ""[dk %d]"" , key_serial ( dest_keyring ) ) ; <StartBug>return ; <EndBug>}
Fixed code:"," <StartBug>static int construct_get_dest_keyring ( struct key * * _dest_keyring ) <EndBug>{ struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; <StartBug>if ( ! check_authorization(cred, authkey)) {<EndBug> up_read ( & authkey -> sem ) ; return -EPERM; <StartBug>} <EndBug> rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) <StartBug>break ; <EndBug>} case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( ""[dk %d]"" , key_serial ( dest_keyring ) ) ; <StartBug>return 0 ; <EndBug>}",617,-24.546493422794818,-0.03978361981004022
"The Original Code is vulnerable to CWE-862: Missing Authorization. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: <StartBug>static void construct_get_dest_keyring ( struct key * * _dest_keyring ) <EndBug>{ struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) <StartBug>break ; <EndBug>} case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( ""[dk %d]"" , key_serial ( dest_keyring ) ) ; <StartBug>return ; <EndBug>}
Fixed code:"," <StartBug>static void construct_get_dest_keyring ( struct key * * _dest_keyring ) <EndBug>{ struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) && rka->uid == cred->uid) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) <StartBug>break ; <EndBug>} case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( ""[dk %d]"" , key_serial ( dest_keyring ) ) ; <StartBug>return ; <EndBug>}",576,-6.120266875057288,-0.010625463324752235
"The Original Code is vulnerable to CWE-862: Missing Authorization. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: <StartBug>static void construct_get_dest_keyring ( struct key * * _dest_keyring ) <EndBug>{ struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) <StartBug>break ; <EndBug>} case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( ""[dk %d]"" , key_serial ( dest_keyring ) ) ; <StartBug>return ; <EndBug>}
Fixed code:"," <StartBug>static void construct_get_dest_keyring ( struct key * * _dest_keyring ) <EndBug>{ struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; // Added if-statement to check if user has authorization to access dest_keyring if (rka->uid == cred->uid) { if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) <StartBug>break ; <EndBug>} } case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( ""[dk %d]"" , key_serial ( dest_keyring ) ) ; <StartBug>return ; <EndBug>}",597,-29.065535801970906,-0.04868598961804172
"The Original Code is vulnerable to CWE-862: Missing Authorization. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: <StartBug>static void construct_get_dest_keyring ( struct key * * _dest_keyring ) <EndBug>{ struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) <StartBug>break ; <EndBug>} case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( ""[dk %d]"" , key_serial ( dest_keyring ) ) ; <StartBug>return ; <EndBug>}
Fixed code:"," <StartBug>static void construct_get_dest_keyring ( struct key * * _dest_keyring ) <EndBug>{ struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if (test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ){ <StartBug>return; <EndBug>} dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) <StartBug>break ; <EndBug>} case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( ""[dk %d]"" , key_serial ( dest_keyring ) ) ; <StartBug>return ; <EndBug>}",578,-17.445112245902873,-0.030181855096717773
"The Original Code is vulnerable to CWE-862: Missing Authorization. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: <StartBug>static void construct_get_dest_keyring ( struct key * * _dest_keyring ) <EndBug>{ struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) <StartBug>break ; <EndBug>} case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( ""[dk %d]"" , key_serial ( dest_keyring ) ) ; <StartBug>return ; <EndBug>}
Fixed code:","

static void construct_get_dest_keyring ( struct key * * _dest_keyring ) { struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; // Check for authorization before accessing the keyring if (has_auth(authkey) && ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags )) { down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) break ; } } case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( ""[dk %d]"" , key_serial ( dest_keyring ) ) ; return ; }

// Function to check for authorization before accessing keyring
bool has_auth(struct key *authkey) {
    bool auth_valid = false;
    if(authkey) {
        if(authkey->has_auth) {
            auth_valid = true;
        }
    }
    return auth_valid;
}",640,-64.05541145041597,-0.10008658039127497
"The Original Code is vulnerable to CWE-862: Missing Authorization. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: <StartBug>static void construct_get_dest_keyring ( struct key * * _dest_keyring ) <EndBug>{ struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) <StartBug>break ; <EndBug>} case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( ""[dk %d]"" , key_serial ( dest_keyring ) ) ; <StartBug>return ; <EndBug>}
Fixed code:"," <StartBug>static void construct_get_dest_keyring ( struct key * * _dest_keyring ) <EndBug>{  struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) && rka->uid == cred->uid )  <StartBug> dest_keyring = key_get ( rka -> dest_keyring ) ; <EndBug> up_read ( & authkey -> sem ) ; if ( dest_keyring ) break ; } case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( ""[dk %d]"" , key_serial ( dest_keyring ) ) ; return ;}",570,-19.974133314893415,-0.035042339148935814
"The Original Code is vulnerable to CWE-862: Missing Authorization. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: <StartBug>static void construct_get_dest_keyring ( struct key * * _dest_keyring ) <EndBug>{ struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) <StartBug>break ; <EndBug>} case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( ""[dk %d]"" , key_serial ( dest_keyring ) ) ; <StartBug>return ; <EndBug>}
Fixed code:","<StartBug>  static void construct_get_dest_keyring ( struct key * * _dest_keyring )  <EndBug>{ struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) && rka->uid == cred->uid)  <StartBug> dest_keyring = key_get ( rka -> dest_keyring ) ; <EndBug> up_read ( & authkey -> sem ) ; if ( dest_keyring ) break ; } case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( ""[dk %d]"" , key_serial ( dest_keyring ) ) ; return ;}",571,-23.075481833147478,-0.040412402509890505
"The Original Code is vulnerable to CWE-862: Missing Authorization. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: <StartBug>static void construct_get_dest_keyring ( struct key * * _dest_keyring ) <EndBug>{ struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) <StartBug>break ; <EndBug>} case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( ""[dk %d]"" , key_serial ( dest_keyring ) ) ; <StartBug>return ; <EndBug>}
Fixed code:"," <StartBug>static void construct_get_dest_keyring ( struct key * * _dest_keyring ) <EndBug>{ struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) && rka->cred->uid == current_uid()) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) <StartBug>break ; <EndBug>} case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( ""[dk %d]"" , key_serial ( dest_keyring ) ) ; <StartBug>return ; <EndBug>}",579,-8.491278584098065,-0.01466542069792412
"The Original Code is vulnerable to CWE-862: Missing Authorization. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: <StartBug>static void construct_get_dest_keyring ( struct key * * _dest_keyring ) <EndBug>{ struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) <StartBug>break ; <EndBug>} case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( ""[dk %d]"" , key_serial ( dest_keyring ) ) ; <StartBug>return ; <EndBug>}
Fixed code:"," <StartBug>static void construct_get_dest_keyring ( struct key * * _dest_keyring ) <EndBug>{ struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) && dest_keyring == rka->dest_keyring) <StartBug>dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) break ;<EndBug> } case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( ""[dk %d]"" , key_serial ( dest_keyring ) ) ; <StartBug>return ; <EndBug>}",580,-13.146475629330565,-0.02266633729194925
"The Original Code is vulnerable to CWE-862: Missing Authorization. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: <StartBug>static void construct_get_dest_keyring ( struct key * * _dest_keyring ) <EndBug>{ struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) <StartBug>break ; <EndBug>} case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( ""[dk %d]"" , key_serial ( dest_keyring ) ) ; <StartBug>return ; <EndBug>}
Fixed code:"," <StartBug>static void construct_get_dest_keyring ( struct key * * _dest_keyring ) <EndBug>{ struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) && rka->dest_keyring == authkey->uid) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) <StartBug>break ; <EndBug>} case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( ""[dk %d]"" , key_serial ( dest_keyring ) ) ; <StartBug>return ; <EndBug>}",580,-10.073715710598513,-0.017368475363100884
"The Original Code is vulnerable to CWE-862: Missing Authorization. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: <StartBug>static void construct_get_dest_keyring ( struct key * * _dest_keyring ) <EndBug>{ struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) <StartBug>break ; <EndBug>} case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( ""[dk %d]"" , key_serial ( dest_keyring ) ) ; <StartBug>return ; <EndBug>}
Fixed code:"," <StartBug>static void construct_get_dest_keyring ( struct key * * _dest_keyring ) <EndBug>{ struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; <StartBug>if(authkey->uid == cred->uid || uid_eq(authkey->uid, cred->uid)){<EndBug> if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; <StartBug>}<EndBug> up_read ( & authkey -> sem ) ; if ( dest_keyring ) <StartBug>break ; <EndBug>} case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( ""[dk %d]"" , key_serial ( dest_keyring ) ) ; <StartBug>return ; <EndBug>}",610,-20.19868166197184,-0.033112592888478426
"The Original Code is vulnerable to CWE-862: Missing Authorization. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: <StartBug>static void construct_get_dest_keyring ( struct key * * _dest_keyring ) <EndBug>{ struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) <StartBug>break ; <EndBug>} case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( ""[dk %d]"" , key_serial ( dest_keyring ) ) ; <StartBug>return ; <EndBug>}
Fixed code:","
static void construct_get_dest_keyring ( struct key * * _dest_keyring ) { struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) && rka->uid == current_uid()) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) break ; } case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( ""[dk %d]"" , key_serial ( dest_keyring ) ) ; return ; }",553,-11.196851973217935,-0.02024747192263641
"The Original Code is vulnerable to CWE-862: Missing Authorization. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: <StartBug>static void construct_get_dest_keyring ( struct key * * _dest_keyring ) <EndBug>{ struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) <StartBug>break ; <EndBug>} case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( ""[dk %d]"" , key_serial ( dest_keyring ) ) ; <StartBug>return ; <EndBug>}
Fixed code:"," <StartBug>static void construct_get_dest_keyring ( struct key * * _dest_keyring ) <EndBug>{ struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; <StartBug> if(cred->uid != rka->cred->uid){ <EndBug>   up_read ( & authkey -> sem ) ; break ; <StartBug>}<EndBug> if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) <StartBug>break ; <EndBug>} case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( ""[dk %d]"" , key_serial ( dest_keyring ) ) ; <StartBug>return ; <EndBug>}",613,-26.492617585189354,-0.0432179732221686
"The Original Code is vulnerable to CWE-862: Missing Authorization. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: <StartBug>static void construct_get_dest_keyring ( struct key * * _dest_keyring ) <EndBug>{ struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) <StartBug>break ; <EndBug>} case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( ""[dk %d]"" , key_serial ( dest_keyring ) ) ; <StartBug>return ; <EndBug>}
Fixed code:"," <StartBug>static void construct_get_dest_keyring ( struct key * * _dest_keyring ) <EndBug>{ struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) && (rka->cred->uid == cred->uid) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) <StartBug>break ; <EndBug>} case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( ""[dk %d]"" , key_serial ( dest_keyring ) ) ; <StartBug>return ; <EndBug>}",581,-11.034449029722737,-0.018992167004686294
"The Original Code is vulnerable to CWE-862: Missing Authorization. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: <StartBug>static void construct_get_dest_keyring ( struct key * * _dest_keyring ) <EndBug>{ struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) <StartBug>break ; <EndBug>} case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( ""[dk %d]"" , key_serial ( dest_keyring ) ) ; <StartBug>return ; <EndBug>}
Fixed code:"," <StartBug>static void construct_get_dest_keyring ( struct key * * _dest_keyring ) <EndBug>{ struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) && cred->uid == rka->cred->uid) <StartBug>dest_keyring = key_get ( rka -> dest_keyring ) ; <EndBug>up_read ( & authkey -> sem ) ; if ( dest_keyring ) break ; } case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( ""[dk %d]"" , key_serial ( dest_keyring ) ) ; <StartBug>return ; <EndBug>}",579,-11.185303268740851,-0.01931831307209128
"The Original Code is vulnerable to CWE-862: Missing Authorization. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: <StartBug>static void construct_get_dest_keyring ( struct key * * _dest_keyring ) <EndBug>{ struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) <StartBug>break ; <EndBug>} case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( ""[dk %d]"" , key_serial ( dest_keyring ) ) ; <StartBug>return ; <EndBug>}
Fixed code:"," <StartBug>static void construct_get_dest_keyring ( struct key * * _dest_keyring ) <EndBug>{ struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; <StartBug>if(!key_permission(dest_keyring, cred->euid)){<EndBug> dest_keyring = NULL; <StartBug>}<EndBug> } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) <StartBug>if(key_permission(rka->dest_keyring, cred->euid)){<EndBug> dest_keyring = key_get ( rka -> dest_keyring ) ; <StartBug>}<EndBug> up_read ( & authkey -> sem ) ; if ( dest_keyring ) break ; } case KEY_REQKEY_DEFL_THREAD_KEYRING : <StartBug>if(key_permission(cred->thread_keyring, cred->euid)){<EndBug> dest_keyring = key_get ( cred -> thread_keyring ) ; <StartBug>}<EndBug> if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : <StartBug>if(key_permission(cred->process_keyring, cred->euid)){<EndBug> dest_keyring = key_get ( cred -> process_keyring ) ; <StartBug>}<EndBug> if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; <StartBug>if(key_permission(rcu_dereference(cred->session_keyring), cred->euid)){<EndBug> dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; <StartBug>}<EndBug> rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : <StartBug>if(key_permission(cred->user->session_keyring, cred->euid)){<EndBug> dest_keyring = key_get ( cred -> user -> session_keyring ) ; <StartBug>}<EndBug> break ; case KEY_REQKEY_DEFL_USER_KEYRING : <StartBug>if(key_permission(cred->user->uid_keyring, cred->euid)){<EndBug> dest_keyring = key_get ( cred -> user -> uid_keyring ) ; <StartBug>}<EndBug> break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( ""[dk %d]"" , key_serial ( dest_keyring ) ) ; <StartBug>return ; <EndBug>}",841,-21.611794712804084,-0.025697734497983453
"The Original Code is vulnerable to CWE-862: Missing Authorization. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: <StartBug>static void construct_get_dest_keyring ( struct key * * _dest_keyring ) <EndBug>{ struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) <StartBug>break ; <EndBug>} case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( ""[dk %d]"" , key_serial ( dest_keyring ) ) ; <StartBug>return ; <EndBug>}
Fixed code:"," <StartBug>static void construct_get_dest_keyring ( struct key * * _dest_keyring ) <EndBug>{ struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; <StartBug> if(! test_auth_key_permissions(authkey, rka)){ <EndBug> down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) <StartBug>break ; <EndBug>} } case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( ""[dk %d]"" , key_serial ( dest_keyring ) ) ; <StartBug>return ; <EndBug>}",595,-34.63842804726746,-0.05821584545759237
"The Original Code is vulnerable to CWE-862: Missing Authorization. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: <StartBug>static void construct_get_dest_keyring ( struct key * * _dest_keyring ) <EndBug>{ struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) <StartBug>break ; <EndBug>} case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( ""[dk %d]"" , key_serial ( dest_keyring ) ) ; <StartBug>return ; <EndBug>}
Fixed code:"," <StartBug>static void construct_get_dest_keyring ( struct key * * _dest_keyring ) <EndBug>{ struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) { rka = authkey -> payload . data [ 0 ] ; if ( rka -> uid == cred -> uid || rka->gid == cred->gid ) { dest_keyring = key_get ( rka -> dest_keyring ) ; } } up_read ( & authkey -> sem ) ; if ( dest_keyring ) <StartBug>break ; <EndBug>} case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( ""[dk %d]"" , key_serial ( dest_keyring ) ) ; <StartBug>return ; <EndBug>}",595,-20.48477058201169,-0.03442818585212049
"The Original Code is vulnerable to CWE-862: Missing Authorization. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: <StartBug>static void construct_get_dest_keyring ( struct key * * _dest_keyring ) <EndBug>{ struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) <StartBug>break ; <EndBug>} case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( ""[dk %d]"" , key_serial ( dest_keyring ) ) ; <StartBug>return ; <EndBug>}
Fixed code:"," <StartBug>static void construct_get_dest_keyring ( struct key * * _dest_keyring ) <EndBug>{ struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) && authkey->uid == cred->euid) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) <StartBug>break ; <EndBug>} case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( ""[dk %d]"" , key_serial ( dest_keyring ) ) ; <StartBug>return ; <EndBug>}",577,-8.551867448846284,-0.014821260743234461
"The Original Code is vulnerable to CWE-862: Missing Authorization. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: <StartBug>static void construct_get_dest_keyring ( struct key * * _dest_keyring ) <EndBug>{ struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) <StartBug>break ; <EndBug>} case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( ""[dk %d]"" , key_serial ( dest_keyring ) ) ; <StartBug>return ; <EndBug>}
Fixed code:"," <StartBug>static void construct_get_dest_keyring ( struct key * * _dest_keyring ) <EndBug>{ struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) && rka->cred == cred ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) <StartBug>break ; <EndBug>} case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( ""[dk %d]"" , key_serial ( dest_keyring ) ) ; <StartBug>return ; <EndBug>}",575,-8.178391232727733,-0.014223289100396058
"The Original Code is vulnerable to CWE-862: Missing Authorization. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: <StartBug>static void construct_get_dest_keyring ( struct key * * _dest_keyring ) <EndBug>{ struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) <StartBug>break ; <EndBug>} case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( ""[dk %d]"" , key_serial ( dest_keyring ) ) ; <StartBug>return ; <EndBug>}
Fixed code:"," <StartBug>static void construct_get_dest_keyring ( struct key * * _dest_keyring ) <EndBug>{ struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; <StartBug>if (authkey->type != &key_type_request_key_auth) { kleave(""[dk -1]""); return; }<EndBug> down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) <StartBug>break ; <EndBug>} case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( ""[dk %d]"" , key_serial ( dest_keyring ) ) ; <StartBug>return ; <EndBug>}",606,-17.64700296222483,-0.029120466934364403
"The Original Code is vulnerable to CWE-862: Missing Authorization. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: <StartBug>static void construct_get_dest_keyring ( struct key * * _dest_keyring ) <EndBug>{ struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) <StartBug>break ; <EndBug>} case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( ""[dk %d]"" , key_serial ( dest_keyring ) ) ; <StartBug>return ; <EndBug>}
Fixed code:"," <StartBug>static void construct_get_dest_keyring ( struct key * * _dest_keyring ) <EndBug>{ struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; <StartBug>if(cred->request_key_auth != NULL && (cred->request_key_auth)->payload.data[0] != NULL && cred->request_key_auth->payload.data[0]->dest_keyring != NULL) {
	authkey = cred->request_key_auth; 
	down_read(&authkey->sem); 
	rka = authkey->payload.data[0]; 
	if (!test_bit(KEY_FLAG_REVOKED, &authkey->flags) && key_permission(authkey, KEY_NEED_AUTH)) { 
		dest_keyring = key_get(rka->dest_keyring); 
 	} 
 	up_read(&authkey->sem); 
	if (dest_keyring) break; <EndBug>} else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) break ; } case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( ""[dk %d]"" , key_serial ( dest_keyring ) ) ; return ; }",751,-59.56418023816646,-0.0793131561094094
"The Original Code is vulnerable to CWE-862: Missing Authorization. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: <StartBug>static void construct_get_dest_keyring ( struct key * * _dest_keyring ) <EndBug>{ struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) <StartBug>break ; <EndBug>} case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( ""[dk %d]"" , key_serial ( dest_keyring ) ) ; <StartBug>return ; <EndBug>}
Fixed code:"," <StartBug>static void construct_get_dest_keyring ( struct key * * _dest_keyring ) <EndBug>{ struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; <StartBug> if (authkey->uid != cred->uid) { up_read(&authkey->sem); break; } <EndBug> if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) <StartBug>break ; <EndBug>} case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( ""[dk %d]"" , key_serial ( dest_keyring ) ) ; <StartBug>if (authkey->uid != cred->uid) return; <EndBug>}",610,-17.251904179470234,-0.028281810130279073
"The Original Code is vulnerable to CWE-862: Missing Authorization. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: <StartBug>static void construct_get_dest_keyring ( struct key * * _dest_keyring ) <EndBug>{ struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) <StartBug>break ; <EndBug>} case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( ""[dk %d]"" , key_serial ( dest_keyring ) ) ; <StartBug>return ; <EndBug>}
Fixed code:"," <StartBug>static void construct_get_dest_keyring ( struct key * * _dest_keyring ) <EndBug>{ struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) && rka->cred == cred) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) <StartBug>break ; <EndBug>} case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( ""[dk %d]"" , key_serial ( dest_keyring ) ) ; <StartBug>return ; <EndBug>}",575,-8.078019252543895,-0.014048729134858946
"The Original Code is vulnerable to CWE-862: Missing Authorization. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: <StartBug>static void construct_get_dest_keyring ( struct key * * _dest_keyring ) <EndBug>{ struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) <StartBug>break ; <EndBug>} case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( ""[dk %d]"" , key_serial ( dest_keyring ) ) ; <StartBug>return ; <EndBug>}
Fixed code:"," 
<StartBug>static void construct_get_dest_keyring ( struct key * * _dest_keyring ) <EndBug>{ struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; if (authkey->permission == KEY_ALLOW_REQUEST) { down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) <StartBug>break ; <EndBug>} } case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( ""[dk %d]"" , key_serial ( dest_keyring ) ) ; <StartBug>return ; <EndBug>}",587,-26.515704968357333,-0.04517155871951845
"The Original Code is vulnerable to CWE-862: Missing Authorization. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: <StartBug>static void construct_get_dest_keyring ( struct key * * _dest_keyring ) <EndBug>{ struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) <StartBug>break ; <EndBug>} case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( ""[dk %d]"" , key_serial ( dest_keyring ) ) ; <StartBug>return ; <EndBug>}
Fixed code:"," <StartBug>static void construct_get_dest_keyring ( struct key * * _dest_keyring ) <EndBug>{ struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) && cred->uid == rka->cred->uid) <StartBug>dest_keyring = key_get ( rka -> dest_keyring ) ; <EndBug>up_read ( & authkey -> sem ) ; if ( dest_keyring ) <StartBug>break ; <EndBug>} case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( ""[dk %d]"" , key_serial ( dest_keyring ) ) ; <StartBug>return ; <EndBug>}",587,-10.937749253536555,-0.018633303668716447
"The Original Code is vulnerable to CWE-862: Missing Authorization. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: <StartBug>static void construct_get_dest_keyring ( struct key * * _dest_keyring ) <EndBug>{ struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) <StartBug>break ; <EndBug>} case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( ""[dk %d]"" , key_serial ( dest_keyring ) ) ; <StartBug>return ; <EndBug>}
Fixed code:"," <StartBug>static void construct_get_dest_keyring ( struct key * * _dest_keyring ) <EndBug>{ struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; <StartBug>if (dest_keyring->uid == cred->uid || dest_keyring->gid == cred->gid) {<EndBug> } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) <StartBug>if (dest_keyring->uid == cred->uid || dest_keyring->gid == cred->gid) {<EndBug> break ; } } case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) <StartBug>if (dest_keyring->uid == cred->uid || dest_keyring->gid == cred->gid) {<EndBug> break ; } case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) <StartBug>if (dest_keyring->uid == cred->uid || dest_keyring->gid == cred->gid) {<EndBug> break ; } case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) <StartBug>if (dest_keyring->uid == cred->uid || dest_keyring->gid == cred->gid) {<EndBug> break ; } case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( ""[dk %d]"" , key_serial ( dest_keyring ) ) ; <StartBug>return ; <EndBug>}",738,-17.090889040518945,-0.02315838623376551
"The Original Code is vulnerable to CWE-862: Missing Authorization. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: <StartBug>static void construct_get_dest_keyring ( struct key * * _dest_keyring ) <EndBug>{ struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) <StartBug>break ; <EndBug>} case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( ""[dk %d]"" , key_serial ( dest_keyring ) ) ; <StartBug>return ; <EndBug>}
Fixed code:"," <StartBug>static void construct_get_dest_keyring ( struct key * * _dest_keyring ) <EndBug>{ struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; if(!capable(CAP_SYS_ADMIN)) <StartBug>return -EPERM; <EndBug> else { down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) <StartBug>break ; <EndBug>} } case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( ""[dk %d]"" , key_serial ( dest_keyring ) ) ; <StartBug>if(!capable(CAP_SYS_ADMIN)) return -EPERM; <EndBug> else return; <EndBug>}",623,-25.15757981607001,-0.040381348019374014
"The Original Code is vulnerable to CWE-862: Missing Authorization. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: <StartBug>static void construct_get_dest_keyring ( struct key * * _dest_keyring ) <EndBug>{ struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) <StartBug>break ; <EndBug>} case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( ""[dk %d]"" , key_serial ( dest_keyring ) ) ; <StartBug>return ; <EndBug>}
Fixed code:"," <StartBug>static void construct_get_dest_keyring ( struct key * * _dest_keyring ) <EndBug>{ struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) && key_check ( authkey , cred ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) <StartBug>break ; <EndBug>} case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( ""[dk %d]"" , key_serial ( dest_keyring ) ) ; <StartBug>return ; <EndBug>}",577,-11.53456340872123,-0.019990577831405943
"The Original Code is vulnerable to CWE-862: Missing Authorization. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: <StartBug>static void construct_get_dest_keyring ( struct key * * _dest_keyring ) <EndBug>{ struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) <StartBug>break ; <EndBug>} case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( ""[dk %d]"" , key_serial ( dest_keyring ) ) ; <StartBug>return ; <EndBug>}
Fixed code:"," <StartBug>static void construct_get_dest_keyring ( struct key * * _dest_keyring ) <EndBug>{ struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) && rka->uid == current_euid() ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) <StartBug>break ; <EndBug>} case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( ""[dk %d]"" , key_serial ( dest_keyring ) ) ; <StartBug>return ; <EndBug>}",578,-9.776632897926689,-0.0169145897888005
"The Original Code is vulnerable to CWE-862: Missing Authorization. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: <StartBug>static void construct_get_dest_keyring ( struct key * * _dest_keyring ) <EndBug>{ struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) <StartBug>break ; <EndBug>} case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( ""[dk %d]"" , key_serial ( dest_keyring ) ) ; <StartBug>return ; <EndBug>}
Fixed code:"," <StartBug>static void construct_get_dest_keyring ( struct key * * _dest_keyring ) <EndBug>{ struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) && (cred->request_key_auth == rka->dest_keyring)) <StartBug>dest_keyring = key_get ( rka -> dest_keyring ) ; <EndBug> up_read ( & authkey -> sem ) ; if ( dest_keyring ) break ; } case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( ""[dk %d]"" , key_serial ( dest_keyring ) ) ; return ;}",577,-16.71789422952254,-0.028973820155151715
"The Original Code is vulnerable to CWE-862: Missing Authorization. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: <StartBug>static void construct_get_dest_keyring ( struct key * * _dest_keyring ) <EndBug>{ struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) <StartBug>break ; <EndBug>} case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( ""[dk %d]"" , key_serial ( dest_keyring ) ) ; <StartBug>return ; <EndBug>}
Fixed code:"," <StartBug>static void construct_get_dest_keyring ( struct key * * _dest_keyring ) <EndBug>{ struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; <StartBug>if ( rka->uid == cred->uid && ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) <EndBug>dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) <StartBug>break ; <EndBug>} case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( ""[dk %d]"" , key_serial ( dest_keyring ) ) ; <StartBug>return ; <EndBug>}",584,-9.907613622345904,-0.016965091819085454
"The Original Code is vulnerable to CWE-862: Missing Authorization. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: <StartBug>static void construct_get_dest_keyring ( struct key * * _dest_keyring ) <EndBug>{ struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) <StartBug>break ; <EndBug>} case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( ""[dk %d]"" , key_serial ( dest_keyring ) ) ; <StartBug>return ; <EndBug>}
Fixed code:"," <StartBug>static void construct_get_dest_keyring ( struct key * * _dest_keyring ) <EndBug>{ struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) &&  key_check(authkey, cred->request_key_auth) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) <StartBug>break ; <EndBug>} case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( ""[dk %d]"" , key_serial ( dest_keyring ) ) ; <StartBug>return ; <EndBug>}",584,-19.71121304413784,-0.03375207713037301
"The Original Code is vulnerable to CWE-862: Missing Authorization. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: <StartBug>static void construct_get_dest_keyring ( struct key * * _dest_keyring ) <EndBug>{ struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) <StartBug>break ; <EndBug>} case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( ""[dk %d]"" , key_serial ( dest_keyring ) ) ; <StartBug>return ; <EndBug>}
Fixed code:"," <StartBug>static int construct_get_dest_keyring ( struct key * * _dest_keyring ) <EndBug>{ struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) && rka->dest_keyring ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) <StartBug>break ; <EndBug>} case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( ""[dk %d]"" , key_serial ( dest_keyring ) ) ; <StartBug>return 0; <EndBug>}",576,-13.543207340968936,-0.023512512744737736
"The Original Code is vulnerable to CWE-862: Missing Authorization. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: <StartBug>static void construct_get_dest_keyring ( struct key * * _dest_keyring ) <EndBug>{ struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) <StartBug>break ; <EndBug>} case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( ""[dk %d]"" , key_serial ( dest_keyring ) ) ; <StartBug>return ; <EndBug>}
Fixed code:","  <StartBug>static void construct_get_dest_keyring (struct key ** _dest_keyring) <EndBug>{ struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) && rka->callout_info->cred == cred) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) <StartBug>break ; <EndBug>} case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( ""[dk %d]"" , key_serial ( dest_keyring ) ) ; <StartBug>return ; <EndBug>}",580,-23.045330469596642,-0.03973332839585628
