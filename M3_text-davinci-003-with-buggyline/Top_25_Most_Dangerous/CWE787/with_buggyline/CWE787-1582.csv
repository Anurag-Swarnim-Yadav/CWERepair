Original code,Plausible Program,Number of Bugs Present,Total Tokens,Sum Entropy,Mean Entropy
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
<StartBug> void jslTokenAsString ( int token , char * str , size_t len ) { <EndBug> if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { <StartBug> case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; return ; <EndBug> <StartBug> case LEX_ID : strncpy ( str , ""ID"" , len ) ; return ; <EndBug> <StartBug> case LEX_INT : strncpy ( str , ""INT"" , len ) ; return ; <EndBug> <StartBug> case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; return ; <EndBug> <StartBug> case LEX_STR : strncpy ( str , ""STRING"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len ) ; return ; <EndBug> <StartBug> case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; return ; <EndBug> <StartBug> case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; return ; <EndBug> } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; <StartBug> strncpy ( str , & tokenNames [ p ] , len ) ; <EndBug> return ; } <StartBug> assert ( len >= 10 ) ; <EndBug> espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }
Fixed code:","
void jslTokenAsString ( int token , char * str , size_t len ) { if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { case LEX_EOF : <StartBug> strncpy ( str , ""EOF"" , len - 1 ) ; <EndBug> return ; case LEX_ID : <StartBug> strncpy ( str , ""ID"" , len - 1 ) ; <EndBug> return ; case LEX_INT : <StartBug> strncpy ( str , ""INT"" , len - 1 ) ; <EndBug> return ; case LEX_FLOAT : <StartBug> strncpy ( str , ""FLOAT"" , len - 1 ) ; <EndBug> return ; case LEX_STR : <StartBug> strncpy ( str , ""STRING"" , len - 1 ) ; <EndBug> return ; case LEX_UNFINISHED_STR : <StartBug> strncpy ( str , ""UNFINISHED STRING"" , len - 1 ) ; <EndBug> return ; case LEX_TEMPLATE_LITERAL : <StartBug> strncpy ( str , ""TEMPLATE LITERAL"" , len - 1 ) ; <EndBug> return ; case LEX_UNFINISHED_TEMPLATE_LITERAL : <StartBug> strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len - 1 ) ; <EndBug> return ; case LEX_REGEX : <StartBug> strncpy ( str , ""REGEX"" , len - 1 ) ; <EndBug> return ; case LEX_UNFINISHED_REGEX : <StartBug> strncpy ( str , ""UNFINISHED REGEX"" , len - 1 ) ; <EndBug> return ; case LEX_UNFINISHED_COMMENT : <StartBug> strncpy ( str , ""UNFINISHED COMMENT"" , len - 1 ) ; <EndBug> return ; } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; <StartBug> strncpy ( str , & tokenNames [ p ] , len - 1 ) ; <EndBug> return ; } <StartBug> assert ( len >= 11 ) ; <EndBug> espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }",14,986,-6.574811897882051,-0.006668166225032506
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
<StartBug> void jslTokenAsString ( int token , char * str , size_t len ) { <EndBug> if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { <StartBug> case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; return ; <EndBug> <StartBug> case LEX_ID : strncpy ( str , ""ID"" , len ) ; return ; <EndBug> <StartBug> case LEX_INT : strncpy ( str , ""INT"" , len ) ; return ; <EndBug> <StartBug> case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; return ; <EndBug> <StartBug> case LEX_STR : strncpy ( str , ""STRING"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len ) ; return ; <EndBug> <StartBug> case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; return ; <EndBug> <StartBug> case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; return ; <EndBug> } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; <StartBug> strncpy ( str , & tokenNames [ p ] , len ) ; <EndBug> return ; } <StartBug> assert ( len >= 10 ) ; <EndBug> espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }
Fixed code:","
<StartBug> void jslTokenAsString ( int token , char * str , size_t len ) { <EndBug> if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { <StartBug> case LEX_EOF : strncpy ( str , ""EOF"" , len - 1 ) ; return ; <EndBug> <StartBug> case LEX_ID : strncpy ( str , ""ID"" , len - 1 ) ; return ; <EndBug> <StartBug> case LEX_INT : strncpy ( str , ""INT"" , len - 1 ) ; return ; <EndBug> <StartBug> case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len - 1 ) ; return ; <EndBug> <StartBug> case LEX_STR : strncpy ( str , ""STRING"" , len - 1 ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len - 1 ) ; return ; <EndBug> <StartBug> case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len - 1 ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len - 1 ) ; return ; <EndBug> <StartBug> case LEX_REGEX : strncpy ( str , ""REGEX"" , len - 1 ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len - 1 ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len - 1 ) ; return ; <EndBug> } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; <StartBug> strncpy ( str , & tokenNames [ p ] , len - 1 ) ; <EndBug> str[len-1] = '\0'; return ; } <StartBug> assert ( len >= 10 ) ; <EndBug> espruino_snprintf ( str , len , ""?[%d]""",14,1000,-7.222123727131725,-0.007222123727131725
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
<StartBug> void jslTokenAsString ( int token , char * str , size_t len ) { <EndBug> if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { <StartBug> case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; return ; <EndBug> <StartBug> case LEX_ID : strncpy ( str , ""ID"" , len ) ; return ; <EndBug> <StartBug> case LEX_INT : strncpy ( str , ""INT"" , len ) ; return ; <EndBug> <StartBug> case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; return ; <EndBug> <StartBug> case LEX_STR : strncpy ( str , ""STRING"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len ) ; return ; <EndBug> <StartBug> case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; return ; <EndBug> <StartBug> case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; return ; <EndBug> } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; <StartBug> strncpy ( str , & tokenNames [ p ] , len ) ; <EndBug> return ; } <StartBug> assert ( len >= 10 ) ; <EndBug> espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }
Fixed code:","
<StartBug> void jslTokenAsString ( int token , char * str , size_t len ) { <EndBug> if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { <StartBug> case LEX_EOF : strncpy ( str , ""EOF"" , len-1 ) ; return ; <EndBug> <StartBug> case LEX_ID : strncpy ( str , ""ID"" , len-1 ) ; return ; <EndBug> <StartBug> case LEX_INT : strncpy ( str , ""INT"" , len-1 ) ; return ; <EndBug> <StartBug> case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len-1 ) ; return ; <EndBug> <StartBug> case LEX_STR : strncpy ( str , ""STRING"" , len-1 ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len-1 ) ; return ; <EndBug> <StartBug> case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len-1 ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len-1 ) ; return ; <EndBug> <StartBug> case LEX_REGEX : strncpy ( str , ""REGEX"" , len-1 ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len-1 ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len-1 ) ; return ; <EndBug> } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; <StartBug> strncpy ( str , & tokenNames [ p ] , len-1 ) ; <EndBug> return ; } <StartBug> assert ( len >= 10 ) ; <EndBug> espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }",14,994,-2.7557966175316193,-0.0027724312047601803
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
<StartBug> void jslTokenAsString ( int token , char * str , size_t len ) { <EndBug> if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { <StartBug> case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; return ; <EndBug> <StartBug> case LEX_ID : strncpy ( str , ""ID"" , len ) ; return ; <EndBug> <StartBug> case LEX_INT : strncpy ( str , ""INT"" , len ) ; return ; <EndBug> <StartBug> case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; return ; <EndBug> <StartBug> case LEX_STR : strncpy ( str , ""STRING"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len ) ; return ; <EndBug> <StartBug> case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; return ; <EndBug> <StartBug> case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; return ; <EndBug> } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; <StartBug> strncpy ( str , & tokenNames [ p ] , len ) ; <EndBug> return ; } <StartBug> assert ( len >= 10 ) ; <EndBug> espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }
Fixed code:","
void jslTokenAsString ( int token , char * str , size_t len ) { if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { case LEX_EOF : strncpy ( str , ""EOF"" , len - 1 ) ; return ; case LEX_ID : strncpy ( str , ""ID"" , len - 1 ) ; return ; case LEX_INT : strncpy ( str , ""INT"" , len - 1 ) ; return ; case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len - 1 ) ; return ; case LEX_STR : strncpy ( str , ""STRING"" , len - 1 ) ; return ; case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len - 1 ) ; return ; case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len - 1 ) ; return ; case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len - 1 ) ; return ; case LEX_REGEX : strncpy ( str , ""REGEX"" , len - 1 ) ; return ; case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len - 1 ) ; return ; case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len - 1 ) ; return ; } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; strncpy ( str , & tokenNames [ p ] , len - 1 ) ; return ; } assert ( len >= 10 ) ; espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }",14,882,-3.596292326756139,-0.004077428941900384
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
<StartBug> void jslTokenAsString ( int token , char * str , size_t len ) { <EndBug> if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { <StartBug> case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; return ; <EndBug> <StartBug> case LEX_ID : strncpy ( str , ""ID"" , len ) ; return ; <EndBug> <StartBug> case LEX_INT : strncpy ( str , ""INT"" , len ) ; return ; <EndBug> <StartBug> case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; return ; <EndBug> <StartBug> case LEX_STR : strncpy ( str , ""STRING"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len ) ; return ; <EndBug> <StartBug> case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; return ; <EndBug> <StartBug> case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; return ; <EndBug> } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; <StartBug> strncpy ( str , & tokenNames [ p ] , len ) ; <EndBug> return ; } <StartBug> assert ( len >= 10 ) ; <EndBug> espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }
Fixed code:","
void jslTokenAsString ( int token , char * str , size_t len ) { 
if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } 
switch ( token ) { 
case LEX_EOF : 
strncpy ( str , ""EOF"" , len - 1 ) ; // added -1 
return ; 

case LEX_ID : 
strncpy ( str , ""ID"" , len - 1 ) ; // added -1 
return ; 

case LEX_INT : 
strncpy ( str , ""INT"" , len - 1 ) ; // added -1 
return ; 

case LEX_FLOAT : 
strncpy ( str , ""FLOAT"" , len - 1 ) ; // added -1 
return ; 

case LEX_STR : 
strncpy ( str , ""STRING"" , len - 1 ) ; // added -1 
return ; 

case LEX_UNFINISHED_STR : 
strncpy ( str , ""UNFINISHED STRING"" , len - 1 ) ; // added -1 
return ; 

case LEX_TEMPLATE_LITERAL : 
strncpy ( str , ""TEMPLATE LITERAL"" , len - 1 ) ; // added -1 
return ; 

case LEX_UNFINISHED_TEMPLATE_LITERAL : 
strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len - 1 ) ; // added -1 
return ; 

case LEX_REGEX : 
strncpy ( str , ""REGEX"" , len - 1 ) ; // added -1 
return ; 

case LEX_UNFINISHED_REGEX : 
strncpy ( str , ""UNFINISHED REGEX"" , len - 1 ) ; // added -1 
return ; 

case LEX_UNFINISHED_COMMENT : 
strncpy ( str , ""UNFINISHED COMMENT"" , len - 1 ) ; // added -1 
return ; 
} 
if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { 
const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; 
unsigned int p = 0 ; 
int n = token - _LEX_OPERATOR_START ; 
while ( n > 0 && p < sizeof ( tokenNames ) ) { 
while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; 
p ++ ; 
n -- ; 
} 
assert ( n == 0 ) ; 
strncpy ( str , & tokenNames [ p ] , len - 1 ) ; // added",14,1000,-23.534277325144373,-0.023534277325144373
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
<StartBug> void jslTokenAsString ( int token , char * str , size_t len ) { <EndBug> if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { <StartBug> case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; return ; <EndBug> <StartBug> case LEX_ID : strncpy ( str , ""ID"" , len ) ; return ; <EndBug> <StartBug> case LEX_INT : strncpy ( str , ""INT"" , len ) ; return ; <EndBug> <StartBug> case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; return ; <EndBug> <StartBug> case LEX_STR : strncpy ( str , ""STRING"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len ) ; return ; <EndBug> <StartBug> case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; return ; <EndBug> <StartBug> case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; return ; <EndBug> } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; <StartBug> strncpy ( str , & tokenNames [ p ] , len ) ; <EndBug> return ; } <StartBug> assert ( len >= 10 ) ; <EndBug> espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }
Fixed code:","
<StartBug> void jslTokenAsString ( int token , char * str , size_t len ) { <EndBug> if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { <StartBug> case LEX_EOF : strncpy ( str , ""EOF"" , len-1 ) ; return ; <EndBug> <StartBug> case LEX_ID : strncpy ( str , ""ID"" , len-1 ) ; return ; <EndBug> <StartBug> case LEX_INT : strncpy ( str , ""INT"" , len-1 ) ; return ; <EndBug> <StartBug> case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len-1 ) ; return ; <EndBug> <StartBug> case LEX_STR : strncpy ( str , ""STRING"" , len-1 ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len-1 ) ; return ; <EndBug> <StartBug> case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len-1 ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len-1 ) ; return ; <EndBug> <StartBug> case LEX_REGEX : strncpy ( str , ""REGEX"" , len-1 ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len-1 ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len-1 ) ; return ; <EndBug> } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; <StartBug> strncpy ( str , & tokenNames [ p ] , len-1 ) ; <EndBug> return ; } <StartBug> assert ( len >= 10 ) ; <EndBug> espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }",14,994,-2.825254954663719,-0.0028423088075087716
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
<StartBug> void jslTokenAsString ( int token , char * str , size_t len ) { <EndBug> if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { <StartBug> case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; return ; <EndBug> <StartBug> case LEX_ID : strncpy ( str , ""ID"" , len ) ; return ; <EndBug> <StartBug> case LEX_INT : strncpy ( str , ""INT"" , len ) ; return ; <EndBug> <StartBug> case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; return ; <EndBug> <StartBug> case LEX_STR : strncpy ( str , ""STRING"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len ) ; return ; <EndBug> <StartBug> case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; return ; <EndBug> <StartBug> case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; return ; <EndBug> } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; <StartBug> strncpy ( str , & tokenNames [ p ] , len ) ; <EndBug> return ; } <StartBug> assert ( len >= 10 ) ; <EndBug> espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }
Fixed code:","
void jslTokenAsString ( int token , char * str , size_t len ) { if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { case LEX_EOF : strncpy ( str , ""EOF"" , len - 1 ) ; return ; case LEX_ID : strncpy ( str , ""ID"" , len - 1 ) ; return ; case LEX_INT : strncpy ( str , ""INT"" , len - 1 ) ; return ; case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len - 1 ) ; return ; case LEX_STR : strncpy ( str , ""STRING"" , len - 1 ) ; return ; case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len - 1 ) ; return ; case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len - 1 ) ; return ; case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len - 1 ) ; return ; case LEX_REGEX : strncpy ( str , ""REGEX"" , len - 1 ) ; return ; case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len - 1 ) ; return ; case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len - 1 ) ; return ; } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; strncpy ( str , & tokenNames [ p ] , len - 1 ) ; return ; } assert ( len >= 10 ) ; espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }",14,882,-3.5640445543892,-0.004040866841711111
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
<StartBug> void jslTokenAsString ( int token , char * str , size_t len ) { <EndBug> if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { <StartBug> case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; return ; <EndBug> <StartBug> case LEX_ID : strncpy ( str , ""ID"" , len ) ; return ; <EndBug> <StartBug> case LEX_INT : strncpy ( str , ""INT"" , len ) ; return ; <EndBug> <StartBug> case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; return ; <EndBug> <StartBug> case LEX_STR : strncpy ( str , ""STRING"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len ) ; return ; <EndBug> <StartBug> case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; return ; <EndBug> <StartBug> case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; return ; <EndBug> } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; <StartBug> strncpy ( str , & tokenNames [ p ] , len ) ; <EndBug> return ; } <StartBug> assert ( len >= 10 ) ; <EndBug> espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }
Fixed code:","
void jslTokenAsString ( int token , char * str , size_t len ) { if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { case LEX_EOF : <StartBug> strncpy ( str , ""EOF"" , len - 1 ) ; str[len - 1] = 0; <EndBug> return ; case LEX_ID : <StartBug> strncpy ( str , ""ID"" , len - 1 ) ; str[len - 1] = 0; <EndBug> return ; case LEX_INT : <StartBug> strncpy ( str , ""INT"" , len - 1 ) ; str[len - 1] = 0; <EndBug> return ; case LEX_FLOAT : <StartBug> strncpy ( str , ""FLOAT"" , len - 1 ) ; str[len - 1] = 0; <EndBug> return ; case LEX_STR : <StartBug> strncpy ( str , ""STRING"" , len - 1 ) ; str[len - 1] = 0; <EndBug> return ; case LEX_UNFINISHED_STR : <StartBug> strncpy ( str , ""UNFINISHED STRING"" , len - 1 ) ; str[len - 1] = 0; <EndBug> return ; case LEX_TEMPLATE_LITERAL : <StartBug> strncpy ( str , ""TEMPLATE LITERAL"" , len - 1 ) ; str[len - 1] = 0; <EndBug> return ; case LEX_UNFINISHED_TEMPLATE_LITERAL : <StartBug> strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len - 1 ) ; str[len - 1] = 0; <EndBug> return ; case LEX_REGEX : <StartBug> strncpy ( str , ""REGEX"" , len - 1 ) ; str[len - 1] = 0; <EndBug> return ; case LEX_UNFINISHED_REGEX : <StartBug> strncpy ( str , ""UNFINISHED REGEX"" , len - 1 ) ; str[len - 1] = 0; <EndBug> return ; case LEX_UNFINISHED_COMMENT : <StartBug> strncpy ( str , ""UNFINISHED COMMENT"" , len - 1 ) ; str[len - 1] = 0; <EndBug> return ; } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames",14,1000,-9.299987292634652,-0.009299987292634652
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
<StartBug> void jslTokenAsString ( int token , char * str , size_t len ) { <EndBug> if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { <StartBug> case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; return ; <EndBug> <StartBug> case LEX_ID : strncpy ( str , ""ID"" , len ) ; return ; <EndBug> <StartBug> case LEX_INT : strncpy ( str , ""INT"" , len ) ; return ; <EndBug> <StartBug> case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; return ; <EndBug> <StartBug> case LEX_STR : strncpy ( str , ""STRING"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len ) ; return ; <EndBug> <StartBug> case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; return ; <EndBug> <StartBug> case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; return ; <EndBug> } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; <StartBug> strncpy ( str , & tokenNames [ p ] , len ) ; <EndBug> return ; } <StartBug> assert ( len >= 10 ) ; <EndBug> espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }
Fixed code:"," 
<StartBug> void jslTokenAsString ( int token , char * str , size_t len ) { <EndBug> if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { case LEX_EOF : <StartBug> strncpy ( str , ""EOF"" , len-1 ) ; <EndBug> str[len - 1] = '\0'; return ;  case LEX_ID : <StartBug> strncpy ( str , ""ID"" , len-1 ) ; <EndBug> str[len - 1] = '\0'; return ; case LEX_INT : <StartBug> strncpy ( str , ""INT"" , len-1 ) ; <EndBug> str[len - 1] = '\0'; return ; case LEX_FLOAT : <StartBug> strncpy ( str , ""FLOAT"" , len-1 ) ; <EndBug> str[len - 1] = '\0'; return ; case LEX_STR : <StartBug> strncpy ( str , ""STRING"" , len-1 ) ; <EndBug> str[len - 1] = '\0'; return ; case LEX_UNFINISHED_STR : <StartBug> strncpy ( str , ""UNFINISHED STRING"" , len-1 ) ; <EndBug> str[len - 1] = '\0'; return ; case LEX_TEMPLATE_LITERAL : <StartBug> strncpy ( str , ""TEMPLATE LITERAL"" , len-1 ) ; <EndBug> str[len - 1] = '\0'; return ; case LEX_UNFINISHED_TEMPLATE_LITERAL : <StartBug> strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len-1 ) ; <EndBug> str[len - 1] = '\0'; return ; case LEX_REGEX : <StartBug> strncpy ( str , ""REGEX"" , len-1 ) ; <EndBug> str[len - 1] = '\0'; return ; case LEX_UNFINISHED_REGEX : <StartBug> strncpy ( str , ""UNFINISHED REGEX"" , len-1 ) ; <EndBug> str[len - 1] = '\0'; return ; case LEX_UNFINISHED_COMMENT : <StartBug> strncpy ( str , ""UNFINISHED COMMENT"" , len-1 ) ; <EndBug> str[len - 1] = '\0'; return ; } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_",14,1000,-17.690454992544854,-0.017690454992544853
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
<StartBug> void jslTokenAsString ( int token , char * str , size_t len ) { <EndBug> if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { <StartBug> case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; return ; <EndBug> <StartBug> case LEX_ID : strncpy ( str , ""ID"" , len ) ; return ; <EndBug> <StartBug> case LEX_INT : strncpy ( str , ""INT"" , len ) ; return ; <EndBug> <StartBug> case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; return ; <EndBug> <StartBug> case LEX_STR : strncpy ( str , ""STRING"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len ) ; return ; <EndBug> <StartBug> case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; return ; <EndBug> <StartBug> case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; return ; <EndBug> } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; <StartBug> strncpy ( str , & tokenNames [ p ] , len ) ; <EndBug> return ; } <StartBug> assert ( len >= 10 ) ; <EndBug> espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }
Fixed code:","
<StartBug> void jslTokenAsString ( int token , char * str , size_t len ) { <EndBug> if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { <StartBug> case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; str[len - 1] = '\0'; return ; <EndBug> <StartBug> case LEX_ID : strncpy ( str , ""ID"" , len ) ; str[len - 1] = '\0'; return ; <EndBug> <StartBug> case LEX_INT : strncpy ( str , ""INT"" , len ) ; str[len - 1] = '\0'; return ; <EndBug> <StartBug> case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; str[len - 1] = '\0'; return ; <EndBug> <StartBug> case LEX_STR : strncpy ( str , ""STRING"" , len ) ; str[len - 1] = '\0'; return ; <EndBug> <StartBug> case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len ) ; str[len - 1] = '\0'; return ; <EndBug> <StartBug> case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; str[len - 1] = '\0'; return ; <EndBug> <StartBug> case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; str[len - 1] = '\0'; return ; <EndBug> <StartBug> case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; str[len - 1] = '\0'; return ; <EndBug> <StartBug> case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len ) ; str[len - 1] = '\0'; return ; <EndBug> <StartBug> case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; str[len - 1] = '\0'; return ; <EndBug> } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p",14,1000,-6.059445713855385,-0.006059445713855385
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
<StartBug> void jslTokenAsString ( int token , char * str , size_t len ) { <EndBug> if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { <StartBug> case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; return ; <EndBug> <StartBug> case LEX_ID : strncpy ( str , ""ID"" , len ) ; return ; <EndBug> <StartBug> case LEX_INT : strncpy ( str , ""INT"" , len ) ; return ; <EndBug> <StartBug> case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; return ; <EndBug> <StartBug> case LEX_STR : strncpy ( str , ""STRING"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len ) ; return ; <EndBug> <StartBug> case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; return ; <EndBug> <StartBug> case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; return ; <EndBug> } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; <StartBug> strncpy ( str , & tokenNames [ p ] , len ) ; <EndBug> return ; } <StartBug> assert ( len >= 10 ) ; <EndBug> espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }
Fixed code:","
<StartBug> void jslTokenAsString ( int token , char * str , size_t len ) { <EndBug> if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { <StartBug> case LEX_EOF : strncpy ( str , ""EOF"" , len-1 ) ; return ; <EndBug> <StartBug> case LEX_ID : strncpy ( str , ""ID"" , len-1 ) ; return ; <EndBug> <StartBug> case LEX_INT : strncpy ( str , ""INT"" , len-1 ) ; return ; <EndBug> <StartBug> case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len-1 ) ; return ; <EndBug> <StartBug> case LEX_STR : strncpy ( str , ""STRING"" , len-1 ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len-1 ) ; return ; <EndBug> <StartBug> case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len-1 ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len-1 ) ; return ; <EndBug> <StartBug> case LEX_REGEX : strncpy ( str , ""REGEX"" , len-1 ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len-1 ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len-1 ) ; return ; <EndBug> } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; <StartBug> strncpy ( str , & tokenNames [ p ] , len-1 ) ; <EndBug> return ; } <StartBug> assert ( len >= 10 ) ; <EndBug> espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }",14,994,-2.7557966175316193,-0.0027724312047601803
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
<StartBug> void jslTokenAsString ( int token , char * str , size_t len ) { <EndBug> if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { <StartBug> case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; return ; <EndBug> <StartBug> case LEX_ID : strncpy ( str , ""ID"" , len ) ; return ; <EndBug> <StartBug> case LEX_INT : strncpy ( str , ""INT"" , len ) ; return ; <EndBug> <StartBug> case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; return ; <EndBug> <StartBug> case LEX_STR : strncpy ( str , ""STRING"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len ) ; return ; <EndBug> <StartBug> case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; return ; <EndBug> <StartBug> case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; return ; <EndBug> } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; <StartBug> strncpy ( str , & tokenNames [ p ] , len ) ; <EndBug> return ; } <StartBug> assert ( len >= 10 ) ; <EndBug> espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }
Fixed code:","
<StartBug> void jslTokenAsString ( int token , char * str , size_t len ) { <EndBug> if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { <StartBug> case LEX_EOF : strncpy ( str , ""EOF"" , len - 1 ) ; return ; <EndBug> <StartBug> case LEX_ID : strncpy ( str , ""ID"" , len - 1 ) ; return ; <EndBug> <StartBug> case LEX_INT : strncpy ( str , ""INT"" , len - 1 ) ; return ; <EndBug> <StartBug> case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len - 1 ) ; return ; <EndBug> <StartBug> case LEX_STR : strncpy ( str , ""STRING"" , len - 1 ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len - 1 ) ; return ; <EndBug> <StartBug> case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len - 1 ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len - 1 ) ; return ; <EndBug> <StartBug> case LEX_REGEX : strncpy ( str , ""REGEX"" , len - 1 ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len - 1 ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len - 1 ) ; return ; <EndBug> } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; <StartBug> strncpy ( str , & tokenNames [ p ] , len - 1 ) ; <EndBug> return ; } <StartBug> assert ( len >= 10 ) ; <EndBug> espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }",14,994,-3.7499927376585256,-0.00377262850871079
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
<StartBug> void jslTokenAsString ( int token , char * str , size_t len ) { <EndBug> if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { <StartBug> case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; return ; <EndBug> <StartBug> case LEX_ID : strncpy ( str , ""ID"" , len ) ; return ; <EndBug> <StartBug> case LEX_INT : strncpy ( str , ""INT"" , len ) ; return ; <EndBug> <StartBug> case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; return ; <EndBug> <StartBug> case LEX_STR : strncpy ( str , ""STRING"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len ) ; return ; <EndBug> <StartBug> case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; return ; <EndBug> <StartBug> case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; return ; <EndBug> } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; <StartBug> strncpy ( str , & tokenNames [ p ] , len ) ; <EndBug> return ; } <StartBug> assert ( len >= 10 ) ; <EndBug> espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }
Fixed code:","
void jslTokenAsString ( int token , char * str , size_t len ) { if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { case LEX_EOF : strncpy ( str , ""EOF"" , len - 1 ) ; return ; case LEX_ID : strncpy ( str , ""ID"" , len - 1 ) ; return ; case LEX_INT : strncpy ( str , ""INT"" , len - 1 ) ; return ; case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len - 1 ) ; return ; case LEX_STR : strncpy ( str , ""STRING"" , len - 1 ) ; return ; case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len - 1 ) ; return ; case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len - 1 ) ; return ; case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len - 1 ) ; return ; case LEX_REGEX : strncpy ( str , ""REGEX"" , len - 1 ) ; return ; case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len - 1 ) ; return ; case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len - 1 ) ; return ; } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; strncpy ( str , & tokenNames [ p ] , len - 1 ) ; return ; } assert ( len >= 10 ) ; espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }",14,882,-3.5640445543892,-0.004040866841711111
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
<StartBug> void jslTokenAsString ( int token , char * str , size_t len ) { <EndBug> if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { <StartBug> case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; return ; <EndBug> <StartBug> case LEX_ID : strncpy ( str , ""ID"" , len ) ; return ; <EndBug> <StartBug> case LEX_INT : strncpy ( str , ""INT"" , len ) ; return ; <EndBug> <StartBug> case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; return ; <EndBug> <StartBug> case LEX_STR : strncpy ( str , ""STRING"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len ) ; return ; <EndBug> <StartBug> case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; return ; <EndBug> <StartBug> case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; return ; <EndBug> } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; <StartBug> strncpy ( str , & tokenNames [ p ] , len ) ; <EndBug> return ; } <StartBug> assert ( len >= 10 ) ; <EndBug> espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }
Fixed code:","
<StartBug> void jslTokenAsString ( int token , char * str , size_t len ) { <EndBug> if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { <StartBug> case LEX_EOF : if (len < 4) { return; } strncpy ( str , ""EOF"" , len ) ; return ; <EndBug> <StartBug> case LEX_ID : if (len < 3) { return; } strncpy ( str , ""ID"" , len ) ; return ; <EndBug> <StartBug> case LEX_INT : if (len < 4) { return; } strncpy ( str , ""INT"" , len ) ; return ; <EndBug> <StartBug> case LEX_FLOAT : if (len < 6) { return; } strncpy ( str , ""FLOAT"" , len ) ; return ; <EndBug> <StartBug> case LEX_STR : if (len < 7) { return; } strncpy ( str , ""STRING"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_STR : if (len < 17) { return; } strncpy ( str , ""UNFINISHED STRING"" , len ) ; return ; <EndBug> <StartBug> case LEX_TEMPLATE_LITERAL : if (len < 16) { return; } strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_TEMPLATE_LITERAL : if (len < 27) { return; } strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; return ; <EndBug> <StartBug> case LEX_REGEX : if (len < 6) { return; } strncpy ( str , ""REGEX"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_REGEX : if (len < 18) { return; } strncpy ( str , ""UNFINISHED REGEX"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_COMMENT : if (len < 20) { return; } strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; return ; <EndBug> } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p",14,1000,-11.004287264862706,-0.011004287264862706
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
<StartBug> void jslTokenAsString ( int token , char * str , size_t len ) { <EndBug> if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { <StartBug> case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; return ; <EndBug> <StartBug> case LEX_ID : strncpy ( str , ""ID"" , len ) ; return ; <EndBug> <StartBug> case LEX_INT : strncpy ( str , ""INT"" , len ) ; return ; <EndBug> <StartBug> case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; return ; <EndBug> <StartBug> case LEX_STR : strncpy ( str , ""STRING"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len ) ; return ; <EndBug> <StartBug> case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; return ; <EndBug> <StartBug> case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; return ; <EndBug> } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; <StartBug> strncpy ( str , & tokenNames [ p ] , len ) ; <EndBug> return ; } <StartBug> assert ( len >= 10 ) ; <EndBug> espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }
Fixed code:","
<StartBug> void jslTokenAsString ( int token , char * str , size_t len ) { <EndBug> if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { <StartBug> case LEX_EOF : strncpy ( str , ""EOF"" , len - 1 ) ; return ; <EndBug> <StartBug> case LEX_ID : strncpy ( str , ""ID"" , len - 1 ) ; return ; <EndBug> <StartBug> case LEX_INT : strncpy ( str , ""INT"" , len - 1 ) ; return ; <EndBug> <StartBug> case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len - 1) ; return ; <EndBug> <StartBug> case LEX_STR : strncpy ( str , ""STRING"" , len - 1 ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len - 1 ) ; return ; <EndBug> <StartBug> case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len - 1 ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len - 1 ) ; return ; <EndBug> <StartBug> case LEX_REGEX : strncpy ( str , ""REGEX"" , len - 1 ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len - 1 ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len - 1 ) ; return ; <EndBug> } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; <StartBug> strncpy ( str , & tokenNames [ p ] , len - 1 ) ; <EndBug> return ; } <StartBug> assert ( len >= 10 ) ; <EndBug> espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }",14,994,-9.37471881486551,-0.009431306654794275
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
<StartBug> void jslTokenAsString ( int token , char * str , size_t len ) { <EndBug> if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { <StartBug> case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; return ; <EndBug> <StartBug> case LEX_ID : strncpy ( str , ""ID"" , len ) ; return ; <EndBug> <StartBug> case LEX_INT : strncpy ( str , ""INT"" , len ) ; return ; <EndBug> <StartBug> case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; return ; <EndBug> <StartBug> case LEX_STR : strncpy ( str , ""STRING"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len ) ; return ; <EndBug> <StartBug> case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; return ; <EndBug> <StartBug> case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; return ; <EndBug> } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; <StartBug> strncpy ( str , & tokenNames [ p ] , len ) ; <EndBug> return ; } <StartBug> assert ( len >= 10 ) ; <EndBug> espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }
Fixed code:","
<StartBug> void jslTokenAsString ( int token , char * str , size_t len ) { <EndBug> if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { <StartBug> case LEX_EOF : strncpy ( str , ""EOF"" , len-1 ) ; return ; <EndBug> <StartBug> case LEX_ID : strncpy ( str , ""ID"" , len-1 ) ; return ; <EndBug> <StartBug> case LEX_INT : strncpy ( str , ""INT"" , len-1 ) ; return ; <EndBug> <StartBug> case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len-1 ) ; return ; <EndBug> <StartBug> case LEX_STR : strncpy ( str , ""STRING"" , len-1 ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len-1 ) ; return ; <EndBug> <StartBug> case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len-1 ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len-1 ) ; return ; <EndBug> <StartBug> case LEX_REGEX : strncpy ( str , ""REGEX"" , len-1 ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len-1 ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len-1 ) ; return ; <EndBug> } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; <StartBug> strncpy ( str , & tokenNames [ p ] , len-1 ) ; <EndBug> return ; } <StartBug> assert ( len >= 10 ) ; <EndBug> espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }",14,994,-2.825254954663719,-0.0028423088075087716
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
<StartBug> void jslTokenAsString ( int token , char * str , size_t len ) { <EndBug> if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { <StartBug> case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; return ; <EndBug> <StartBug> case LEX_ID : strncpy ( str , ""ID"" , len ) ; return ; <EndBug> <StartBug> case LEX_INT : strncpy ( str , ""INT"" , len ) ; return ; <EndBug> <StartBug> case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; return ; <EndBug> <StartBug> case LEX_STR : strncpy ( str , ""STRING"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len ) ; return ; <EndBug> <StartBug> case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; return ; <EndBug> <StartBug> case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; return ; <EndBug> } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; <StartBug> strncpy ( str , & tokenNames [ p ] , len ) ; <EndBug> return ; } <StartBug> assert ( len >= 10 ) ; <EndBug> espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }
Fixed code:","
<StartBug> void jslTokenAsString ( int token , char * str , size_t len ) { <EndBug> if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { <StartBug> case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; return ; <EndBug> <StartBug> case LEX_ID : strncpy ( str , ""ID"" , len ) ; return ; <EndBug> <StartBug> case LEX_INT : strncpy ( str , ""INT"" , len ) ; return ; <EndBug> <StartBug> case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; return ; <EndBug> <StartBug> case LEX_STR : strncpy ( str , ""STRING"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len ) ; return ; <EndBug> <StartBug> case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; return ; <EndBug> <StartBug> case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; return ; <EndBug> } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; <StartBug> strncpy ( str , & tokenNames [ p ] , (len - 1)); str[len - 1] = '\0'; <EndBug> return ; } <StartBug> assert ( len >= 10 ) ; <EndBug> espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }",14,983,-9.389036049300682,-0.009551410019634467
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
<StartBug> void jslTokenAsString ( int token , char * str , size_t len ) { <EndBug> if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { <StartBug> case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; return ; <EndBug> <StartBug> case LEX_ID : strncpy ( str , ""ID"" , len ) ; return ; <EndBug> <StartBug> case LEX_INT : strncpy ( str , ""INT"" , len ) ; return ; <EndBug> <StartBug> case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; return ; <EndBug> <StartBug> case LEX_STR : strncpy ( str , ""STRING"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len ) ; return ; <EndBug> <StartBug> case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; return ; <EndBug> <StartBug> case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; return ; <EndBug> } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; <StartBug> strncpy ( str , & tokenNames [ p ] , len ) ; <EndBug> return ; } <StartBug> assert ( len >= 10 ) ; <EndBug> espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }
Fixed code:","
<StartBug> void jslTokenAsString ( int token , char * str , size_t len ) { <EndBug> if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { <StartBug> case LEX_EOF : if(len < 4) return; //add this line strncpy ( str , ""EOF"" , len ) ; return ; <EndBug> <StartBug> case LEX_ID : if(len < 3) return; //add this line strncpy ( str , ""ID"" , len ) ; return ; <EndBug> <StartBug> case LEX_INT : if(len < 4) return; //add this line strncpy ( str , ""INT"" , len ) ; return ; <EndBug> <StartBug> case LEX_FLOAT : if(len < 6) return; //add this line strncpy ( str , ""FLOAT"" , len ) ; return ; <EndBug> <StartBug> case LEX_STR : if(len < 7) return; //add this line strncpy ( str , ""STRING"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_STR : if(len < 17) return; //add this line strncpy ( str , ""UNFINISHED STRING"" , len ) ; return ; <EndBug> <StartBug> case LEX_TEMPLATE_LITERAL : if(len < 16) return; //add this line strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_TEMPLATE_LITERAL : if(len < 28) return; //add this line strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; return ; <EndBug> <StartBug> case LEX_REGEX : if(len < 6) return; //add this line strncpy ( str , ""REGEX"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_REGEX : if(len < 18) return; //add this line strncpy ( str , ""UNFINISHED REGEX"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_COMMENT : if(len < 22) return; //add this line strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; return ; <EndBug> } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof (",14,1000,-23.427290033325193,-0.023427290033325193
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
<StartBug> void jslTokenAsString ( int token , char * str , size_t len ) { <EndBug> if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { <StartBug> case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; return ; <EndBug> <StartBug> case LEX_ID : strncpy ( str , ""ID"" , len ) ; return ; <EndBug> <StartBug> case LEX_INT : strncpy ( str , ""INT"" , len ) ; return ; <EndBug> <StartBug> case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; return ; <EndBug> <StartBug> case LEX_STR : strncpy ( str , ""STRING"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len ) ; return ; <EndBug> <StartBug> case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; return ; <EndBug> <StartBug> case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; return ; <EndBug> } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; <StartBug> strncpy ( str , & tokenNames [ p ] , len ) ; <EndBug> return ; } <StartBug> assert ( len >= 10 ) ; <EndBug> espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }
Fixed code:","
<StartBug> void jslTokenAsString ( int token , char * str , size_t len ) { <EndBug> if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; return ; case LEX_ID : strncpy ( str , ""ID"" , len ) ; return ; case LEX_INT : strncpy ( str , ""INT"" , len ) ; return ; case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; return ; case LEX_STR : strncpy ( str , ""STRING"" , len ) ; return ; case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len ) ; return ; case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; return ; case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; return ; case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; return ; case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len ) ; return ; case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; return ; } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; <StartBug> if (strlen( & tokenNames[p] ) < len) strncpy ( str , & tokenNames [ p ] , len ) ; else strncpy (str , & tokenNames[p] , strlen(&tokenNames[p])); <EndBug> return ; } <StartBug> assert ( len >= 10 ) ; <EndBug> espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }",14,920,-28.51804647582825,-0.030997876604161142
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
<StartBug> void jslTokenAsString ( int token , char * str , size_t len ) { <EndBug> if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { <StartBug> case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; return ; <EndBug> <StartBug> case LEX_ID : strncpy ( str , ""ID"" , len ) ; return ; <EndBug> <StartBug> case LEX_INT : strncpy ( str , ""INT"" , len ) ; return ; <EndBug> <StartBug> case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; return ; <EndBug> <StartBug> case LEX_STR : strncpy ( str , ""STRING"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len ) ; return ; <EndBug> <StartBug> case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; return ; <EndBug> <StartBug> case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; return ; <EndBug> } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; <StartBug> strncpy ( str , & tokenNames [ p ] , len ) ; <EndBug> return ; } <StartBug> assert ( len >= 10 ) ; <EndBug> espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }
Fixed code:","
<StartBug>void jslTokenAsString ( int token , char * str , size_t len ) { 
    if ( token > 32 && token < 128 ) { 
        assert ( len >= 4 ) ; 
        str [ 0 ] = '\\'' ; 
        str [ 1 ] = ( char ) token ; 
        str [ 2 ] = '\\'' ; 
        str [ 3 ] = 0 ; 
        return ; 
    } 
    switch ( token ) { 
        case LEX_EOF : strlcpy ( str , ""EOF"" , len ) ; return ; 
        case LEX_ID : strlcpy ( str , ""ID"" , len ) ; return ; 
        case LEX_INT : strlcpy ( str , ""INT"" , len ) ; return ; 
        case LEX_FLOAT : strlcpy ( str , ""FLOAT"" , len ) ; return ; 
        case LEX_STR : strlcpy ( str , ""STRING"" , len ) ; return ; 
        case LEX_UNFINISHED_STR : strlcpy ( str , ""UNFINISHED STRING"" , len ) ; return ; 
        case LEX_TEMPLATE_LITERAL : strlcpy ( str , ""TEMPLATE LITERAL"" , len ) ; return ; 
        case LEX_UNFINISHED_TEMPLATE_LITERAL : strlcpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; return ; 
        case LEX_REGEX : strlcpy ( str , ""REGEX"" , len ) ; return ; 
        case LEX_UNFINISHED_REGEX : strlcpy ( str , ""UNFINISHED REGEX"" , len ) ; return ; 
        case LEX_UNFINISHED_COMMENT : strlcpy ( str , ""UNFINISHED COMMENT"" , len ) ; return ; 
    } 
    if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { 
        const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; 
        unsigned int p = 0 ; 
        int n = token - _LEX_OPERATOR_START ; 
        while ( n > 0 && p < sizeof ( tokenNames ) ) { 
            while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; 
            p ++ ; n -- ; 
        } 
        assert ( n == 0 ) ; 
        strlcpy ( str , & tokenNames [ p ] , len ) ; 
        return ; 
    } 
    assert ( len >= 10 ) ; 
    espruino_snprintf ( str , len , ""?[%d]"" , token ) ; 
} <EndBug>",14,973,-19.285422464797318,-0.01982057807276189
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
<StartBug> void jslTokenAsString ( int token , char * str , size_t len ) { <EndBug> if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { <StartBug> case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; return ; <EndBug> <StartBug> case LEX_ID : strncpy ( str , ""ID"" , len ) ; return ; <EndBug> <StartBug> case LEX_INT : strncpy ( str , ""INT"" , len ) ; return ; <EndBug> <StartBug> case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; return ; <EndBug> <StartBug> case LEX_STR : strncpy ( str , ""STRING"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len ) ; return ; <EndBug> <StartBug> case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; return ; <EndBug> <StartBug> case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; return ; <EndBug> } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; <StartBug> strncpy ( str , & tokenNames [ p ] , len ) ; <EndBug> return ; } <StartBug> assert ( len >= 10 ) ; <EndBug> espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }
Fixed code:","
void jslTokenAsString ( int token , char * str , size_t len ) { if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { case LEX_EOF : strncpy ( str , ""EOF"" , len-1 ) ; return ; case LEX_ID : strncpy ( str , ""ID"" , len-1 ) ; return ; case LEX_INT : strncpy ( str , ""INT"" , len-1 ) ; return ; case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len-1 ) ; return ; case LEX_STR : strncpy ( str , ""STRING"" , len-1 ) ; return ; case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len-1 ) ; return ; case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len-1 ) ; return ; case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len-1 ) ; return ; case LEX_REGEX : strncpy ( str , ""REGEX"" , len-1 ) ; return ; case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len-1 ) ; return ; case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len-1 ) ; return ; } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; strncpy ( str , & tokenNames [ p ] , len-1 ) ; return ; } assert ( len >= 10 ) ; espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }",14,882,-4.441944014257841,-0.005036217703240182
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
<StartBug> void jslTokenAsString ( int token , char * str , size_t len ) { <EndBug> if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { <StartBug> case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; return ; <EndBug> <StartBug> case LEX_ID : strncpy ( str , ""ID"" , len ) ; return ; <EndBug> <StartBug> case LEX_INT : strncpy ( str , ""INT"" , len ) ; return ; <EndBug> <StartBug> case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; return ; <EndBug> <StartBug> case LEX_STR : strncpy ( str , ""STRING"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len ) ; return ; <EndBug> <StartBug> case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; return ; <EndBug> <StartBug> case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; return ; <EndBug> } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; <StartBug> strncpy ( str , & tokenNames [ p ] , len ) ; <EndBug> return ; } <StartBug> assert ( len >= 10 ) ; <EndBug> espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }
Fixed code:","
void jslTokenAsString ( int token , char * str , size_t len ) { if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; return ; case LEX_ID : strncpy ( str , ""ID"" , len ) ; return ; case LEX_INT : strncpy ( str , ""INT"" , len ) ; return ; case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; return ; case LEX_STR : strncpy ( str , ""STRING"" , len ) ; return ; case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len ) ; return ; case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; return ; case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; return ; case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; return ; case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len ) ; return ; case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; return ; } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; strncpy ( str , & tokenNames [ p ] , ( len - 1 ) ) ; str [ len - 1 ] = '\0' ; return ; } assert ( len >= 10 ) ; espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }",14,874,-10.66176335603033,-0.012198813908501522
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
<StartBug> void jslTokenAsString ( int token , char * str , size_t len ) { <EndBug> if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { <StartBug> case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; return ; <EndBug> <StartBug> case LEX_ID : strncpy ( str , ""ID"" , len ) ; return ; <EndBug> <StartBug> case LEX_INT : strncpy ( str , ""INT"" , len ) ; return ; <EndBug> <StartBug> case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; return ; <EndBug> <StartBug> case LEX_STR : strncpy ( str , ""STRING"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len ) ; return ; <EndBug> <StartBug> case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; return ; <EndBug> <StartBug> case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; return ; <EndBug> } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; <StartBug> strncpy ( str , & tokenNames [ p ] , len ) ; <EndBug> return ; } <StartBug> assert ( len >= 10 ) ; <EndBug> espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }
Fixed code:","
<StartBug> void jslTokenAsString ( int token , char * str , size_t len ) { <EndBug> if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { <StartBug> case LEX_EOF : strncpy ( str , ""EOF"" , len-1 ) ; return ; <EndBug> <StartBug> case LEX_ID : strncpy ( str , ""ID"" , len-1 ) ; return ; <EndBug> <StartBug> case LEX_INT : strncpy ( str , ""INT"" , len-1 ) ; return ; <EndBug> <StartBug> case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len-1 ) ; return ; <EndBug> <StartBug> case LEX_STR : strncpy ( str , ""STRING"" , len-1 ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len-1 ) ; return ; <EndBug> <StartBug> case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len-1 ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len-1 ) ; return ; <EndBug> <StartBug> case LEX_REGEX : strncpy ( str , ""REGEX"" , len-1 ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len-1 ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len-1 ) ; return ; <EndBug> } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; <StartBug> strncpy ( str , & tokenNames [ p ] , len-1 ) ; <EndBug> return ; } <StartBug> assert ( len >= 10 ) ; <EndBug> espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }",14,994,-2.785635421349913,-0.0028024501220824073
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
<StartBug> void jslTokenAsString ( int token , char * str , size_t len ) { <EndBug> if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { <StartBug> case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; return ; <EndBug> <StartBug> case LEX_ID : strncpy ( str , ""ID"" , len ) ; return ; <EndBug> <StartBug> case LEX_INT : strncpy ( str , ""INT"" , len ) ; return ; <EndBug> <StartBug> case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; return ; <EndBug> <StartBug> case LEX_STR : strncpy ( str , ""STRING"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len ) ; return ; <EndBug> <StartBug> case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; return ; <EndBug> <StartBug> case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; return ; <EndBug> } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; <StartBug> strncpy ( str , & tokenNames [ p ] , len ) ; <EndBug> return ; } <StartBug> assert ( len >= 10 ) ; <EndBug> espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }
Fixed code:","
void jslTokenAsString ( int token , char * str , size_t len ) { if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { case LEX_EOF : strncpy ( str , ""EOF"" , len - 1 ) ; return ; 

case LEX_ID : strncpy ( str , ""ID"" , len - 1 ) ; return ; 

case LEX_INT : strncpy ( str , ""INT"" , len - 1 ) ; return ; 

case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len - 1 ) ; return ; 

case LEX_STR : strncpy ( str , ""STRING"" , len - 1 ) ; return ; 

case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len - 1 ) ; return ; 

case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len - 1 ) ; return ; 

case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len - 1 ) ; return ; 

case LEX_REGEX : strncpy ( str , ""REGEX"" , len - 1 ) ; return ; 

case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len - 1 ) ; return ; 

case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len - 1 ) ; return ; 
} if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; strncpy ( str , & tokenNames [ p ] , len - 1 ) ; return ; } assert ( len >= 10 ) ; espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }",14,914,-8.192520313441731,-0.008963370145997518
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
<StartBug> void jslTokenAsString ( int token , char * str , size_t len ) { <EndBug> if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { <StartBug> case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; return ; <EndBug> <StartBug> case LEX_ID : strncpy ( str , ""ID"" , len ) ; return ; <EndBug> <StartBug> case LEX_INT : strncpy ( str , ""INT"" , len ) ; return ; <EndBug> <StartBug> case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; return ; <EndBug> <StartBug> case LEX_STR : strncpy ( str , ""STRING"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len ) ; return ; <EndBug> <StartBug> case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; return ; <EndBug> <StartBug> case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; return ; <EndBug> } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; <StartBug> strncpy ( str , & tokenNames [ p ] , len ) ; <EndBug> return ; } <StartBug> assert ( len >= 10 ) ; <EndBug> espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }
Fixed code:","
void jslTokenAsString ( int token , char * str , size_t len ) { 
if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } 
switch ( token ) {
case LEX_EOF : strncpy ( str , ""EOF"" , len - 1 ) ; return ;
case LEX_ID : strncpy ( str , ""ID"" , len - 1 ) ; return ;
case LEX_INT : strncpy ( str , ""INT"" , len - 1 ) ; return ;
case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len - 1 ) ; return ; 
case LEX_STR : strncpy ( str , ""STRING"" , len - 1 ) ; return ;
case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len - 1 ) ; return ; 
case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len - 1 ) ; return ; 
case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len - 1 ) ; return ;
case LEX_REGEX : strncpy ( str , ""REGEX"" , len - 1 ) ; return ;
case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len - 1 ) ; return ;
case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len - 1 ) ; return ;
} 
if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { 
const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; 
unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; 
while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } 
assert ( n == 0 ) ; 
strncpy ( str , & tokenNames [ p ] , len - 1 ) ;
return ; 
} 
assert ( len >= 10 ) ; 
espruino_snprintf ( str , len , ""?[%d]"" , token ) ; 
}",14,922,-29.357922677999557,-0.03184156472668065
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
<StartBug> void jslTokenAsString ( int token , char * str , size_t len ) { <EndBug> if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { <StartBug> case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; return ; <EndBug> <StartBug> case LEX_ID : strncpy ( str , ""ID"" , len ) ; return ; <EndBug> <StartBug> case LEX_INT : strncpy ( str , ""INT"" , len ) ; return ; <EndBug> <StartBug> case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; return ; <EndBug> <StartBug> case LEX_STR : strncpy ( str , ""STRING"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len ) ; return ; <EndBug> <StartBug> case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; return ; <EndBug> <StartBug> case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; return ; <EndBug> } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; <StartBug> strncpy ( str , & tokenNames [ p ] , len ) ; <EndBug> return ; } <StartBug> assert ( len >= 10 ) ; <EndBug> espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }
Fixed code:","
<StartBug> void jslTokenAsString ( int token , char * str , size_t len ) { <EndBug> if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { <StartBug> case LEX_EOF : strncpy ( str , ""EOF"" , len-1 ) ; return ; <EndBug> <StartBug> case LEX_ID : strncpy ( str , ""ID"" , len-1 ) ; return ; <EndBug> <StartBug> case LEX_INT : strncpy ( str , ""INT"" , len-1 ) ; return ; <EndBug> <StartBug> case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len-1 ) ; return ; <EndBug> <StartBug> case LEX_STR : strncpy ( str , ""STRING"" , len-1 ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len-1 ) ; return ; <EndBug> <StartBug> case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len-1 ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len-1 ) ; return ; <EndBug> <StartBug> case LEX_REGEX : strncpy ( str , ""REGEX"" , len-1 ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len-1 ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len-1 ) ; return ; <EndBug> } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; <StartBug> strncpy ( str , & tokenNames [ p ] , len-1 ) ; str[len-1] = '\0'; <EndBug> return ; } <StartBug> assert ( len >= 10 ) ; <EndBug> espruino_snprintf ( str , len , ""?[%d]""",14,1000,-6.094810043857575,-0.0060948100438575755
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
<StartBug> void jslTokenAsString ( int token , char * str , size_t len ) { <EndBug> if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { <StartBug> case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; return ; <EndBug> <StartBug> case LEX_ID : strncpy ( str , ""ID"" , len ) ; return ; <EndBug> <StartBug> case LEX_INT : strncpy ( str , ""INT"" , len ) ; return ; <EndBug> <StartBug> case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; return ; <EndBug> <StartBug> case LEX_STR : strncpy ( str , ""STRING"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len ) ; return ; <EndBug> <StartBug> case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; return ; <EndBug> <StartBug> case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; return ; <EndBug> } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; <StartBug> strncpy ( str , & tokenNames [ p ] , len ) ; <EndBug> return ; } <StartBug> assert ( len >= 10 ) ; <EndBug> espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }
Fixed code:","
void jslTokenAsString ( int token , char * str , size_t len ) { if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { case LEX_EOF : <StartBug> strncpy ( str , ""EOF"" , len - 1 ) ; <EndBug> str[len - 1] = 0; return ; case LEX_ID : <StartBug> strncpy ( str , ""ID"" , len - 1 ) ; <EndBug> str[len - 1] = 0; return ; case LEX_INT : <StartBug> strncpy ( str , ""INT"" , len - 1 ) ; <EndBug> str[len - 1] = 0; return ; case LEX_FLOAT : <StartBug> strncpy ( str , ""FLOAT"" , len - 1 ) ; <EndBug> str[len - 1] = 0; return ; case LEX_STR : <StartBug> strncpy ( str , ""STRING"" , len - 1 ) ; <EndBug> str[len - 1] = 0; return ; case LEX_UNFINISHED_STR : <StartBug> strncpy ( str , ""UNFINISHED STRING"" , len - 1 ) ; <EndBug> str[len - 1] = 0; return ; case LEX_TEMPLATE_LITERAL : <StartBug> strncpy ( str , ""TEMPLATE LITERAL"" , len - 1 ) ; <EndBug> str[len - 1] = 0; return ; case LEX_UNFINISHED_TEMPLATE_LITERAL : <StartBug> strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len - 1 ) ; <EndBug> str[len - 1] = 0; return ; case LEX_REGEX : <StartBug> strncpy ( str , ""REGEX"" , len - 1 ) ; <EndBug> str[len - 1] = 0; return ; case LEX_UNFINISHED_REGEX : <StartBug> strncpy ( str , ""UNFINISHED REGEX"" , len - 1 ) ; <EndBug> str[len - 1] = 0; return ; case LEX_UNFINISHED_COMMENT : <StartBug> strncpy ( str , ""UNFINISHED COMMENT"" , len - 1 ) ; <EndBug> str[len - 1] = 0; return ; } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames",14,1000,-10.484542684167298,-0.010484542684167299
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
<StartBug> void jslTokenAsString ( int token , char * str , size_t len ) { <EndBug> if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { <StartBug> case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; return ; <EndBug> <StartBug> case LEX_ID : strncpy ( str , ""ID"" , len ) ; return ; <EndBug> <StartBug> case LEX_INT : strncpy ( str , ""INT"" , len ) ; return ; <EndBug> <StartBug> case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; return ; <EndBug> <StartBug> case LEX_STR : strncpy ( str , ""STRING"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len ) ; return ; <EndBug> <StartBug> case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; return ; <EndBug> <StartBug> case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; return ; <EndBug> } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; <StartBug> strncpy ( str , & tokenNames [ p ] , len ) ; <EndBug> return ; } <StartBug> assert ( len >= 10 ) ; <EndBug> espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }
Fixed code:","
<StartBug> void jslTokenAsString ( int token , char * str , size_t len ) { <EndBug> if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { <StartBug> case LEX_EOF : strncpy ( str , ""EOF"" , len-1 ) ; return ; <EndBug> <StartBug> case LEX_ID : strncpy ( str , ""ID"" , len-1 ) ; return ; <EndBug> <StartBug> case LEX_INT : strncpy ( str , ""INT"" , len-1 ) ; return ; <EndBug> <StartBug> case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len-1 ) ; return ; <EndBug> <StartBug> case LEX_STR : strncpy ( str , ""STRING"" , len-1 ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len-1 ) ; return ; <EndBug> <StartBug> case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len-1 ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len-1 ) ; return ; <EndBug> <StartBug> case LEX_REGEX : strncpy ( str , ""REGEX"" , len-1 ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len-1 ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len-1 ) ; return ; <EndBug> } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; <StartBug> strncpy ( str , & tokenNames [ p ] , len-1 ) ; <EndBug> return ; } <StartBug> assert ( len >= 10 ) ; <EndBug> espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }",14,994,-2.845928527991576,-0.002863107171017682
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
<StartBug> void jslTokenAsString ( int token , char * str , size_t len ) { <EndBug> if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { <StartBug> case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; return ; <EndBug> <StartBug> case LEX_ID : strncpy ( str , ""ID"" , len ) ; return ; <EndBug> <StartBug> case LEX_INT : strncpy ( str , ""INT"" , len ) ; return ; <EndBug> <StartBug> case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; return ; <EndBug> <StartBug> case LEX_STR : strncpy ( str , ""STRING"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len ) ; return ; <EndBug> <StartBug> case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; return ; <EndBug> <StartBug> case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; return ; <EndBug> } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; <StartBug> strncpy ( str , & tokenNames [ p ] , len ) ; <EndBug> return ; } <StartBug> assert ( len >= 10 ) ; <EndBug> espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }
Fixed code:","
<StartBug> void jslTokenAsString ( int token , char * str , size_t len ) { <EndBug> if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { case LEX_EOF : <StartBug> strncpy ( str , ""EOF"" , len - 1 ) ; <EndBug> str[len - 1] = '\0'; <StartBug> return ; <EndBug> case LEX_ID : <StartBug> strncpy ( str , ""ID"" , len - 1 ) ; <EndBug> str[len - 1] = '\0'; <StartBug> return ; <EndBug> case LEX_INT : <StartBug> strncpy ( str , ""INT"" , len - 1 ) ; <EndBug> str[len - 1] = '\0'; <StartBug> return ; <EndBug> case LEX_FLOAT : <StartBug> strncpy ( str , ""FLOAT"" , len - 1 ) ; <EndBug> str[len - 1] = '\0'; <StartBug> return ; <EndBug> case LEX_STR : <StartBug> strncpy ( str , ""STRING"" , len - 1 ) ; <EndBug> str[len - 1] = '\0'; <StartBug> return ; <EndBug> case LEX_UNFINISHED_STR : <StartBug> strncpy ( str , ""UNFINISHED STRING"" , len - 1 ) ; <EndBug> str[len - 1] = '\0'; <StartBug> return ; <EndBug> case LEX_TEMPLATE_LITERAL : <StartBug> strncpy ( str , ""TEMPLATE LITERAL"" , len - 1 ) ; <EndBug> str[len - 1] = '\0'; <StartBug> return ; <EndBug> case LEX_UNFINISHED_TEMPLATE_LITERAL : <StartBug> strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len - 1 ) ; <EndBug> str[len - 1] = '\0'; <StartBug> return ; <EndBug> case LEX_REGEX : <StartBug> strncpy ( str , ""REGEX"" , len - 1 ) ; <EndBug> str[len - 1] = '\0'; <StartBug> return ; <EndBug> case LEX_UNFINISHED_REGEX : <StartBug> strncpy ( str , ""UNFINISHED REGEX"" , len - 1 ) ; <EndBug> str[len - 1] = '\0'; <StartBug> return ; <EndBug> case LEX_UNFINISHED_COMMENT : <StartBug> strncpy ( str , ""UNFINISHED COMMENT"" , len - 1 ) ; <EndBug> str[len - 1] = '\0'; <StartBug> return ; <EndBug> } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in",14,1000,-9.034350025767974,-0.009034350025767975
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
<StartBug> void jslTokenAsString ( int token , char * str , size_t len ) { <EndBug> if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { <StartBug> case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; return ; <EndBug> <StartBug> case LEX_ID : strncpy ( str , ""ID"" , len ) ; return ; <EndBug> <StartBug> case LEX_INT : strncpy ( str , ""INT"" , len ) ; return ; <EndBug> <StartBug> case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; return ; <EndBug> <StartBug> case LEX_STR : strncpy ( str , ""STRING"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len ) ; return ; <EndBug> <StartBug> case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; return ; <EndBug> <StartBug> case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; return ; <EndBug> } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; <StartBug> strncpy ( str , & tokenNames [ p ] , len ) ; <EndBug> return ; } <StartBug> assert ( len >= 10 ) ; <EndBug> espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }
Fixed code:","
<StartBug> void jslTokenAsString ( int token , char * str , size_t len ) { <EndBug> if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { <StartBug> case LEX_EOF : if(len >= 3) strncpy ( str , ""EOF"" , len ) ; return ; <EndBug> <StartBug> case LEX_ID : if(len >= 2) strncpy ( str , ""ID"" , len ) ; return ; <EndBug> <StartBug> case LEX_INT : if(len >= 3) strncpy ( str , ""INT"" , len ) ; return ; <EndBug> <StartBug> case LEX_FLOAT : if(len >= 5) strncpy ( str , ""FLOAT"" , len ) ; return ; <EndBug> <StartBug> case LEX_STR : if(len >= 6) strncpy ( str , ""STRING"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_STR : if(len >= 16) strncpy ( str , ""UNFINISHED STRING"" , len ) ; return ; <EndBug> <StartBug> case LEX_TEMPLATE_LITERAL : if(len >= 16) strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_TEMPLATE_LITERAL : if(len >= 26) strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; return ; <EndBug> <StartBug> case LEX_REGEX : if(len >= 5) strncpy ( str , ""REGEX"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_REGEX : if(len >= 17) strncpy ( str , ""UNFINISHED REGEX"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_COMMENT : if(len >= 19) strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; return ; <EndBug> } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; <StartBug> size_t token_len = strlen(&tokenNames[p]); if(len >= token_len) str",14,1000,-19.046840899516106,-0.019046840899516106
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
<StartBug> void jslTokenAsString ( int token , char * str , size_t len ) { <EndBug> if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { <StartBug> case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; return ; <EndBug> <StartBug> case LEX_ID : strncpy ( str , ""ID"" , len ) ; return ; <EndBug> <StartBug> case LEX_INT : strncpy ( str , ""INT"" , len ) ; return ; <EndBug> <StartBug> case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; return ; <EndBug> <StartBug> case LEX_STR : strncpy ( str , ""STRING"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len ) ; return ; <EndBug> <StartBug> case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; return ; <EndBug> <StartBug> case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; return ; <EndBug> } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; <StartBug> strncpy ( str , & tokenNames [ p ] , len ) ; <EndBug> return ; } <StartBug> assert ( len >= 10 ) ; <EndBug> espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }
Fixed code:","
void jslTokenAsString ( int token , char * str , size_t len ) { if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { case LEX_EOF : strncpy ( str , ""EOF"" , len-1 ) ; return ; case LEX_ID : strncpy ( str , ""ID"" , len-1 ) ; return ; case LEX_INT : strncpy ( str , ""INT"" , len-1 ) ; return ; case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len-1 ) ; return ; case LEX_STR : strncpy ( str , ""STRING"" , len-1 ) ; return ; case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len-1 ) ; return ; case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len-1 ) ; return ; case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len-1 ) ; return ; case LEX_REGEX : strncpy ( str , ""REGEX"" , len-1 ) ; return ; case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len-1 ) ; return ; case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len-1 ) ; return ; } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; strncpy ( str , & tokenNames [ p ] , len-1 ) ; return ; } assert ( len >= 10 ) ; espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }",14,882,-4.441944014257841,-0.005036217703240182
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
<StartBug> void jslTokenAsString ( int token , char * str , size_t len ) { <EndBug> if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { <StartBug> case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; return ; <EndBug> <StartBug> case LEX_ID : strncpy ( str , ""ID"" , len ) ; return ; <EndBug> <StartBug> case LEX_INT : strncpy ( str , ""INT"" , len ) ; return ; <EndBug> <StartBug> case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; return ; <EndBug> <StartBug> case LEX_STR : strncpy ( str , ""STRING"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len ) ; return ; <EndBug> <StartBug> case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; return ; <EndBug> <StartBug> case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; return ; <EndBug> } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; <StartBug> strncpy ( str , & tokenNames [ p ] , len ) ; <EndBug> return ; } <StartBug> assert ( len >= 10 ) ; <EndBug> espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }
Fixed code:"," 
<StartBug> void jslTokenAsString ( int token , char * str , size_t len ) { <EndBug> if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { <StartBug> case LEX_EOF : strncpy ( str , ""EOF"" , len - 1 ) ; return ; <EndBug> <StartBug> case LEX_ID : strncpy ( str , ""ID"" , len - 1 ) ; return ; <EndBug> <StartBug> case LEX_INT : strncpy ( str , ""INT"" , len - 1 ) ; return ; <EndBug> <StartBug> case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len - 1 ) ; return ; <EndBug> <StartBug> case LEX_STR : strncpy ( str , ""STRING"" , len - 1 ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len - 1 ) ; return ; <EndBug> <StartBug> case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len - 1 ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len - 1 ) ; return ; <EndBug> <StartBug> case LEX_REGEX : strncpy ( str , ""REGEX"" , len - 1 ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len - 1 ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len - 1 ) ; return ; <EndBug> } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; <StartBug> strncpy ( str , & tokenNames [ p ] , len - 1 ) ; <EndBug> return ; } <StartBug> assert ( len >= 10 ) ; <EndBug> espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }",14,995,-5.350919958664945,-0.005377809003683362
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
<StartBug> void jslTokenAsString ( int token , char * str , size_t len ) { <EndBug> if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { <StartBug> case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; return ; <EndBug> <StartBug> case LEX_ID : strncpy ( str , ""ID"" , len ) ; return ; <EndBug> <StartBug> case LEX_INT : strncpy ( str , ""INT"" , len ) ; return ; <EndBug> <StartBug> case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; return ; <EndBug> <StartBug> case LEX_STR : strncpy ( str , ""STRING"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len ) ; return ; <EndBug> <StartBug> case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; return ; <EndBug> <StartBug> case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; return ; <EndBug> } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; <StartBug> strncpy ( str , & tokenNames [ p ] , len ) ; <EndBug> return ; } <StartBug> assert ( len >= 10 ) ; <EndBug> espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }
Fixed code:","
<StartBug> void jslTokenAsString ( int token , char * str , size_t len ) { <EndBug> if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { <StartBug> case LEX_EOF : strncpy ( str , ""EOF"" , len-1 ) ; return ; <EndBug> <StartBug> case LEX_ID : strncpy ( str , ""ID"" , len-1 ) ; return ; <EndBug> <StartBug> case LEX_INT : strncpy ( str , ""INT"" , len-1 ) ; return ; <EndBug> <StartBug> case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len-1 ) ; return ; <EndBug> <StartBug> case LEX_STR : strncpy ( str , ""STRING"" , len-1 ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len-1 ) ; return ; <EndBug> <StartBug> case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len-1 ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len-1 ) ; return ; <EndBug> <StartBug> case LEX_REGEX : strncpy ( str , ""REGEX"" , len-1 ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len-1 ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len-1 ) ; return ; <EndBug> } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; <StartBug> strncpy ( str , & tokenNames [ p ] , len-1 ) ; <EndBug> return ; } <StartBug> assert ( len >= 11 ) ; <EndBug> espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }",14,994,-4.434343440194802,-0.0044611101007995995
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
<StartBug> void jslTokenAsString ( int token , char * str , size_t len ) { <EndBug> if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { <StartBug> case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; return ; <EndBug> <StartBug> case LEX_ID : strncpy ( str , ""ID"" , len ) ; return ; <EndBug> <StartBug> case LEX_INT : strncpy ( str , ""INT"" , len ) ; return ; <EndBug> <StartBug> case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; return ; <EndBug> <StartBug> case LEX_STR : strncpy ( str , ""STRING"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len ) ; return ; <EndBug> <StartBug> case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; return ; <EndBug> <StartBug> case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; return ; <EndBug> } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; <StartBug> strncpy ( str , & tokenNames [ p ] , len ) ; <EndBug> return ; } <StartBug> assert ( len >= 10 ) ; <EndBug> espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }
Fixed code:","
<StartBug> void jslTokenAsString ( int token , char * str , size_t len ) { <EndBug> if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { <StartBug> case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; return ; <EndBug> <StartBug> case LEX_ID : strncpy ( str , ""ID"" , len ) ; return ; <EndBug> <StartBug> case LEX_INT : strncpy ( str , ""INT"" , len ) ; return ; <EndBug> <StartBug> case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; return ; <EndBug> <StartBug> case LEX_STR : strncpy ( str , ""STRING"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len ) ; return ; <EndBug> <StartBug> case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; return ; <EndBug> <StartBug> case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; return ; <EndBug> } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; <StartBug> snprintf ( str , len , ""%s"" , & tokenNames [ p ] ) ; <EndBug> return ; } <StartBug> assert ( len >= 10 ) ; <EndBug> espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }",14,973,-10.089676198889265,-0.01036965693616574
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
<StartBug> void jslTokenAsString ( int token , char * str , size_t len ) { <EndBug> if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { <StartBug> case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; return ; <EndBug> <StartBug> case LEX_ID : strncpy ( str , ""ID"" , len ) ; return ; <EndBug> <StartBug> case LEX_INT : strncpy ( str , ""INT"" , len ) ; return ; <EndBug> <StartBug> case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; return ; <EndBug> <StartBug> case LEX_STR : strncpy ( str , ""STRING"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len ) ; return ; <EndBug> <StartBug> case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; return ; <EndBug> <StartBug> case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; return ; <EndBug> } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; <StartBug> strncpy ( str , & tokenNames [ p ] , len ) ; <EndBug> return ; } <StartBug> assert ( len >= 10 ) ; <EndBug> espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }
Fixed code:","
void jslTokenAsString ( int token , char * str , size_t len ) { if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { case LEX_EOF : strncpy ( str , ""EOF"" , len - 1 ) ; return ; case LEX_ID : strncpy ( str , ""ID"" , len - 1 ) ; return ; case LEX_INT : strncpy ( str , ""INT"" , len - 1 ) ; return ; case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len - 1 ) ; return ; case LEX_STR : strncpy ( str , ""STRING"" , len - 1 ) ; return ; case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len - 1 ) ; return ; case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len - 1 ) ; return ; case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len - 1 ) ; return ; case LEX_REGEX : strncpy ( str , ""REGEX"" , len - 1 ) ; return ; case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len - 1 ) ; return ; case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len - 1 ) ; return ; } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; strncpy ( str , & tokenNames [ p ] , len - 1 ) ; return ; } assert ( len >= 10 ) ; espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }",14,882,-3.625494048258632,-0.004110537469680989
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
<StartBug> void jslTokenAsString ( int token , char * str , size_t len ) { <EndBug> if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { <StartBug> case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; return ; <EndBug> <StartBug> case LEX_ID : strncpy ( str , ""ID"" , len ) ; return ; <EndBug> <StartBug> case LEX_INT : strncpy ( str , ""INT"" , len ) ; return ; <EndBug> <StartBug> case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; return ; <EndBug> <StartBug> case LEX_STR : strncpy ( str , ""STRING"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len ) ; return ; <EndBug> <StartBug> case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; return ; <EndBug> <StartBug> case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; return ; <EndBug> } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; <StartBug> strncpy ( str , & tokenNames [ p ] , len ) ; <EndBug> return ; } <StartBug> assert ( len >= 10 ) ; <EndBug> espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }
Fixed code:","
<StartBug> void jslTokenAsString ( int token , char * str , size_t len ) { <EndBug> if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { <StartBug> case LEX_EOF : strncpy ( str , ""EOF"" , len-1 ) ; str[len-1] = '\0'; return ; <EndBug> <StartBug> case LEX_ID : strncpy ( str , ""ID"" , len-1 ) ; str[len-1] = '\0'; return ; <EndBug> <StartBug> case LEX_INT : strncpy ( str , ""INT"" , len-1 ) ; str[len-1] = '\0'; return ; <EndBug> <StartBug> case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len-1 ) ; str[len-1] = '\0'; return ; <EndBug> <StartBug> case LEX_STR : strncpy ( str , ""STRING"" , len-1 ) ; str[len-1] = '\0'; return ; <EndBug> <StartBug> case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len-1 ) ; str[len-1] = '\0'; return ; <EndBug> <StartBug> case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len-1 ) ; str[len-1] = '\0'; return ; <EndBug> <StartBug> case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len-1 ) ; str[len-1] = '\0'; return ; <EndBug> <StartBug> case LEX_REGEX : strncpy ( str , ""REGEX"" , len-1 ) ; str[len-1] = '\0'; return ; <EndBug> <StartBug> case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len-1 ) ; str[len-1] = '\0'; return ; <EndBug> <StartBug> case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len-1 ) ; str[len-1] = '\0'; return ; <EndBug> } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START",14,1000,-4.52343354438975,-0.00452343354438975
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
<StartBug> void jslTokenAsString ( int token , char * str , size_t len ) { <EndBug> if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { <StartBug> case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; return ; <EndBug> <StartBug> case LEX_ID : strncpy ( str , ""ID"" , len ) ; return ; <EndBug> <StartBug> case LEX_INT : strncpy ( str , ""INT"" , len ) ; return ; <EndBug> <StartBug> case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; return ; <EndBug> <StartBug> case LEX_STR : strncpy ( str , ""STRING"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len ) ; return ; <EndBug> <StartBug> case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; return ; <EndBug> <StartBug> case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; return ; <EndBug> } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; <StartBug> strncpy ( str , & tokenNames [ p ] , len ) ; <EndBug> return ; } <StartBug> assert ( len >= 10 ) ; <EndBug> espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }
Fixed code:","
void jslTokenAsString ( int token , char * str , size_t len ) { 
if ( token > 32 && token < 128 ) { 
assert ( len >= 4 ) ; 
str [ 0 ] = '\\'' ; 
str [ 1 ] = ( char ) token ; 
str [ 2 ] = '\\'' ; 
str [ 3 ] = 0 ; 
return ; 
} 
switch ( token ) { 
case LEX_EOF : 
strncpy ( str , ""EOF"" , len-1) ; 
return ; 
case LEX_ID : 
strncpy ( str , ""ID"" , len-1) ; 
return ; 
case LEX_INT : 
strncpy ( str , ""INT"" , len-1) ; 
return ; 
case LEX_FLOAT : 
strncpy ( str , ""FLOAT"" , len-1) ; 
return ; 
case LEX_STR : 
strncpy ( str , ""STRING"" , len-1) ; 
return ; 
case LEX_UNFINISHED_STR : 
strncpy ( str , ""UNFINISHED STRING"" , len-1) ; 
return ; 
case LEX_TEMPLATE_LITERAL : 
strncpy ( str , ""TEMPLATE LITERAL"" , len-1) ; 
return ; 
case LEX_UNFINISHED_TEMPLATE_LITERAL : 
strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len-1) ; 
return ; 
case LEX_REGEX : 
strncpy ( str , ""REGEX"" , len-1) ; 
return ; 
case LEX_UNFINISHED_REGEX : 
strncpy ( str , ""UNFINISHED REGEX"" , len-1) ; 
return ; 
case LEX_UNFINISHED_COMMENT : 
strncpy ( str , ""UNFINISHED COMMENT"" , len-1) ; 
return ; 
} 
if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { 
const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; 
unsigned int p = 0 ; 
int n = token - _LEX_OPERATOR_START ; 
while ( n > 0 && p < sizeof ( tokenNames ) ) { 
while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; 
p ++ ; 
n -- ; 
} 
assert ( n == 0 ) ; 
strncpy ( str , & tokenNames [ p ] , len-1) ; 
return ; 
} 
assert ( len >= 10 ) ; 
espruino_snprintf ( str , len , ""?[%d]"" , token ) ; 
}",14,1000,-11.183298597510651,-0.011183298597510652
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
<StartBug> void jslTokenAsString ( int token , char * str , size_t len ) { <EndBug> if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { <StartBug> case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; return ; <EndBug> <StartBug> case LEX_ID : strncpy ( str , ""ID"" , len ) ; return ; <EndBug> <StartBug> case LEX_INT : strncpy ( str , ""INT"" , len ) ; return ; <EndBug> <StartBug> case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; return ; <EndBug> <StartBug> case LEX_STR : strncpy ( str , ""STRING"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len ) ; return ; <EndBug> <StartBug> case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; return ; <EndBug> <StartBug> case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; return ; <EndBug> } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; <StartBug> strncpy ( str , & tokenNames [ p ] , len ) ; <EndBug> return ; } <StartBug> assert ( len >= 10 ) ; <EndBug> espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }
Fixed code:","
<StartBug> void jslTokenAsString ( int token , char * str , size_t len ) { <EndBug> if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { <StartBug> case LEX_EOF : strncpy ( str , ""EOF"" , len - 1 ) ; str[len - 1] = 0; return ; <EndBug> <StartBug> case LEX_ID : strncpy ( str , ""ID"" , len - 1 ) ; str[len - 1] = 0; return ; <EndBug> <StartBug> case LEX_INT : strncpy ( str , ""INT"" , len - 1 ) ; str[len - 1] = 0; return ; <EndBug> <StartBug> case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len - 1 ) ; str[len - 1] = 0; return ; <EndBug> <StartBug> case LEX_STR : strncpy ( str , ""STRING"" , len - 1 ) ; str[len - 1] = 0; return ; <EndBug> <StartBug> case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len - 1 ) ; str[len - 1] = 0; return ; <EndBug> <StartBug> case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len - 1 ) ; str[len - 1] = 0; return ; <EndBug> <StartBug> case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len - 1 ) ; str[len - 1] = 0; return ; <EndBug> <StartBug> case LEX_REGEX : strncpy ( str , ""REGEX"" , len - 1 ) ; str[len - 1] = 0; return ; <EndBug> <StartBug> case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len - 1 ) ; str[len - 1] = 0; return ; <EndBug> <StartBug> case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len - 1 ) ; str[len - 1] = 0; return ; <EndBug> } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p",14,1000,-6.80520879578604,-0.0068052087957860405
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
<StartBug> void jslTokenAsString ( int token , char * str , size_t len ) { <EndBug> if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { <StartBug> case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; return ; <EndBug> <StartBug> case LEX_ID : strncpy ( str , ""ID"" , len ) ; return ; <EndBug> <StartBug> case LEX_INT : strncpy ( str , ""INT"" , len ) ; return ; <EndBug> <StartBug> case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; return ; <EndBug> <StartBug> case LEX_STR : strncpy ( str , ""STRING"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len ) ; return ; <EndBug> <StartBug> case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; return ; <EndBug> <StartBug> case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; return ; <EndBug> } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; <StartBug> strncpy ( str , & tokenNames [ p ] , len ) ; <EndBug> return ; } <StartBug> assert ( len >= 10 ) ; <EndBug> espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }
Fixed code:","
<StartBug> void jslTokenAsString ( int token , char * str , size_t len ) { <EndBug> if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { <StartBug> case LEX_EOF : strncpy ( str , ""EOF"" , len-1 ) ; return ; <EndBug> <StartBug> case LEX_ID : strncpy ( str , ""ID"" , len-1 ) ; return ; <EndBug> <StartBug> case LEX_INT : strncpy ( str , ""INT"" , len-1 ) ; return ; <EndBug> <StartBug> case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len-1 ) ; return ; <EndBug> <StartBug> case LEX_STR : strncpy ( str , ""STRING"" , len-1 ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len-1 ) ; return ; <EndBug> <StartBug> case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len-1 ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len-1 ) ; return ; <EndBug> <StartBug> case LEX_REGEX : strncpy ( str , ""REGEX"" , len-1 ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len-1 ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len-1 ) ; return ; <EndBug> } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; <StartBug> strncpy ( str , & tokenNames [ p ] , len-1 ) ; <EndBug> return ; } <StartBug> assert ( len >= 10 ) ; <EndBug> espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }",14,994,-2.735247988613352,-0.0027517585398524665
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
<StartBug> void jslTokenAsString ( int token , char * str , size_t len ) { <EndBug> if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { <StartBug> case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; return ; <EndBug> <StartBug> case LEX_ID : strncpy ( str , ""ID"" , len ) ; return ; <EndBug> <StartBug> case LEX_INT : strncpy ( str , ""INT"" , len ) ; return ; <EndBug> <StartBug> case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; return ; <EndBug> <StartBug> case LEX_STR : strncpy ( str , ""STRING"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len ) ; return ; <EndBug> <StartBug> case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; return ; <EndBug> <StartBug> case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; return ; <EndBug> } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; <StartBug> strncpy ( str , & tokenNames [ p ] , len ) ; <EndBug> return ; } <StartBug> assert ( len >= 10 ) ; <EndBug> espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }
Fixed code:","
<StartBug> void jslTokenAsString ( int token , char * str , size_t len ) { <EndBug> if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { <StartBug> case LEX_EOF : strncpy ( str , ""EOF"" , len - 1 ) ; return ; <EndBug> <StartBug> case LEX_ID : strncpy ( str , ""ID"" , len - 1 ) ; return ; <EndBug> <StartBug> case LEX_INT : strncpy ( str , ""INT"" , len - 1 ) ; return ; <EndBug> <StartBug> case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len - 1 ) ; return ; <EndBug> <StartBug> case LEX_STR : strncpy ( str , ""STRING"" , len - 1 ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len - 1 ) ; return ; <EndBug> <StartBug> case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len - 1 ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len - 1 ) ; return ; <EndBug> <StartBug> case LEX_REGEX : strncpy ( str , ""REGEX"" , len - 1 ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len - 1 ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len - 1 ) ; return ; <EndBug> } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; <StartBug> strncpy ( str , & tokenNames [ p ] , len - 1 ) ; <EndBug> return ; } <StartBug> assert ( len >= 11 ) ; <EndBug> espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }",14,994,-3.888615912846454,-0.003912088443507499
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
<StartBug> void jslTokenAsString ( int token , char * str , size_t len ) { <EndBug> if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { <StartBug> case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; return ; <EndBug> <StartBug> case LEX_ID : strncpy ( str , ""ID"" , len ) ; return ; <EndBug> <StartBug> case LEX_INT : strncpy ( str , ""INT"" , len ) ; return ; <EndBug> <StartBug> case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; return ; <EndBug> <StartBug> case LEX_STR : strncpy ( str , ""STRING"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len ) ; return ; <EndBug> <StartBug> case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; return ; <EndBug> <StartBug> case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; return ; <EndBug> } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; <StartBug> strncpy ( str , & tokenNames [ p ] , len ) ; <EndBug> return ; } <StartBug> assert ( len >= 10 ) ; <EndBug> espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }
Fixed code:","
void jslTokenAsString ( int token , char * str , size_t len ) { 
if ( token > 32 && token < 128 ) { 
assert ( len >= 4 ) ; 
str [ 0 ] = '\\'' ; 
str [ 1 ] = ( char ) token ; 
str [ 2 ] = '\\'' ; 
str [ 3 ] = 0 ; 
return ; 
} 

switch ( token ) { 
case LEX_EOF : 
strncpy ( str , ""EOF"" , len-1 ) ; 
return ; 

case LEX_ID : 
strncpy ( str , ""ID"" , len-1 ) ; 
return ; 

case LEX_INT : 
strncpy ( str , ""INT"" , len-1 ) ; 
return ; 

case LEX_FLOAT : 
strncpy ( str , ""FLOAT"" , len-1 ) ; 
return ; 

case LEX_STR : 
strncpy ( str , ""STRING"" , len-1 ) ; 
return ; 

case LEX_UNFINISHED_STR : 
strncpy ( str , ""UNFINISHED STRING"" , len-1 ) ; 
return ; 

case LEX_TEMPLATE_LITERAL : 
strncpy ( str , ""TEMPLATE LITERAL"" , len-1 ) ; 
return ; 

case LEX_UNFINISHED_TEMPLATE_LITERAL : 
strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len-1 ) ; 
return ; 

case LEX_REGEX : 
strncpy ( str , ""REGEX"" , len-1 ) ; 
return ; 

case LEX_UNFINISHED_REGEX : 
strncpy ( str , ""UNFINISHED REGEX"" , len-1 ) ; 
return ; 

case LEX_UNFINISHED_COMMENT : 
strncpy ( str , ""UNFINISHED COMMENT"" , len-1 ) ; 
return ; 
} 

if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { 
const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; 
unsigned int p = 0 ; 
int n = token - _LEX_OPERATOR_START ; 
while ( n > 0 && p < sizeof ( tokenNames ) ) { 
while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; 
p ++ ; 
n -- ; 
} 

assert ( n == 0 ) ; 
strncpy ( str , & tokenNames [ p ] , len-1 ) ; 
return ; 
} 

assert ( len >= 10 ) ; 
espruino_snprintf ( str , len",14,1000,-13.881686724646496,-0.013881686724646496
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
<StartBug> void jslTokenAsString ( int token , char * str , size_t len ) { <EndBug> if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { <StartBug> case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; return ; <EndBug> <StartBug> case LEX_ID : strncpy ( str , ""ID"" , len ) ; return ; <EndBug> <StartBug> case LEX_INT : strncpy ( str , ""INT"" , len ) ; return ; <EndBug> <StartBug> case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; return ; <EndBug> <StartBug> case LEX_STR : strncpy ( str , ""STRING"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len ) ; return ; <EndBug> <StartBug> case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; return ; <EndBug> <StartBug> case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; return ; <EndBug> } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; <StartBug> strncpy ( str , & tokenNames [ p ] , len ) ; <EndBug> return ; } <StartBug> assert ( len >= 10 ) ; <EndBug> espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }
Fixed code:","
<StartBug> void jslTokenAsString ( int token , char * str , size_t len ) { <EndBug> if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { <StartBug> case LEX_EOF : strncpy ( str , ""EOF"" , len - 1 ) ; return ; <EndBug> <StartBug> case LEX_ID : strncpy ( str , ""ID"" , len - 1 ) ; return ; <EndBug> <StartBug> case LEX_INT : strncpy ( str , ""INT"" , len - 1 ) ; return ; <EndBug> <StartBug> case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len - 1 ) ; return ; <EndBug> <StartBug> case LEX_STR : strncpy ( str , ""STRING"" , len - 1 ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len - 1 ) ; return ; <EndBug> <StartBug> case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len - 1 ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len - 1 ) ; return ; <EndBug> <StartBug> case LEX_REGEX : strncpy ( str , ""REGEX"" , len - 1 ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len - 1 ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len - 1 ) ; return ; <EndBug> } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; <StartBug> strncpy ( str , & tokenNames [ p ] , len - 1 ) ; <EndBug> return ; } <StartBug> assert ( len >= 11 ) ; <EndBug> espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }",14,994,-3.888615912846454,-0.003912088443507499
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
<StartBug> void jslTokenAsString ( int token , char * str , size_t len ) { <EndBug> if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { <StartBug> case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; return ; <EndBug> <StartBug> case LEX_ID : strncpy ( str , ""ID"" , len ) ; return ; <EndBug> <StartBug> case LEX_INT : strncpy ( str , ""INT"" , len ) ; return ; <EndBug> <StartBug> case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; return ; <EndBug> <StartBug> case LEX_STR : strncpy ( str , ""STRING"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len ) ; return ; <EndBug> <StartBug> case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; return ; <EndBug> <StartBug> case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; return ; <EndBug> } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; <StartBug> strncpy ( str , & tokenNames [ p ] , len ) ; <EndBug> return ; } <StartBug> assert ( len >= 10 ) ; <EndBug> espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }
Fixed code:","
<StartBug> void jslTokenAsString ( int token , char * str , size_t len ) { <EndBug> if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { <StartBug> case LEX_EOF : strncpy ( str , ""EOF"" , len-1 ) ; return ; <EndBug> <StartBug> case LEX_ID : strncpy ( str , ""ID"" , len-1 ) ; return ; <EndBug> <StartBug> case LEX_INT : strncpy ( str , ""INT"" , len-1 ) ; return ; <EndBug> <StartBug> case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len-1 ) ; return ; <EndBug> <StartBug> case LEX_STR : strncpy ( str , ""STRING"" , len-1 ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len-1 ) ; return ; <EndBug> <StartBug> case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len-1 ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len-1 ) ; return ; <EndBug> <StartBug> case LEX_REGEX : strncpy ( str , ""REGEX"" , len-1 ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len-1 ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len-1 ) ; return ; <EndBug> } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; <StartBug> strncpy ( str , & tokenNames [ p ] , len-1 ) ; <EndBug> return ; } <StartBug> assert ( len >= 10 ) ; <EndBug> espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }",14,994,-2.735247988613352,-0.0027517585398524665
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
<StartBug> void jslTokenAsString ( int token , char * str , size_t len ) { <EndBug> if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { <StartBug> case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; return ; <EndBug> <StartBug> case LEX_ID : strncpy ( str , ""ID"" , len ) ; return ; <EndBug> <StartBug> case LEX_INT : strncpy ( str , ""INT"" , len ) ; return ; <EndBug> <StartBug> case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; return ; <EndBug> <StartBug> case LEX_STR : strncpy ( str , ""STRING"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len ) ; return ; <EndBug> <StartBug> case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; return ; <EndBug> <StartBug> case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; return ; <EndBug> } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; <StartBug> strncpy ( str , & tokenNames [ p ] , len ) ; <EndBug> return ; } <StartBug> assert ( len >= 10 ) ; <EndBug> espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }
Fixed code:","

void jslTokenAsString ( int token , char * str , size_t len ) { 
 if ( token > 32 && token < 128 ) { 
  assert ( len >= 4 ) ; 
  str [ 0 ] = '\\'' ; 
  str [ 1 ] = ( char ) token ; 
  str [ 2 ] = '\\'' ; 
  str [ 3 ] = 0 ; 
  return ; 
 } 
 switch ( token ) { 
  case LEX_EOF : 
   strncpy ( str , ""EOF"" , (len<4) ? len : 4 ) ; 
   return ; 
  case LEX_ID : 
   strncpy ( str , ""ID"" , (len<3) ? len : 3 ) ; 
   return ; 
  case LEX_INT : 
   strncpy ( str , ""INT"" , (len<4) ? len : 4 ) ; 
   return ; 
  case LEX_FLOAT : 
   strncpy ( str , ""FLOAT"" , (len<6) ? len : 6 ) ; 
   return ; 
  case LEX_STR : 
   strncpy ( str , ""STRING"" , (len<7) ? len : 7 ) ; 
   return ; 
  case LEX_UNFINISHED_STR : 
   strncpy ( str , ""UNFINISHED STRING"" , (len<17) ? len : 17 ) ; 
   return ; 
  case LEX_TEMPLATE_LITERAL : 
   strncpy ( str , ""TEMPLATE LITERAL"" , (len<17) ? len : 17 ) ; 
   return ; 
  case LEX_UNFINISHED_TEMPLATE_LITERAL : 
   strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , (len<27) ? len : 27 ) ; 
   return ; 
  case LEX_REGEX : 
   strncpy ( str , ""REGEX"" , (len<6) ? len : 6 ) ; 
   return ; 
  case LEX_UNFINISHED_REGEX : 
   strncpy ( str , ""UNFINISHED REGEX"" , (len<17) ? len : 17 ) ; 
   return ; 
  case LEX_UNFINISHED_COMMENT : 
   strncpy ( str , ""UNFINISHED COMMENT"" , (len<20) ? len : 20 ) ; 
   return ; 
 } 
 if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { 
  const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; 
  unsigned int p = 0 ; 
  int n = token - _LEX_OPERATOR_START ; 
  while ( n > 0 && p < sizeof (",14,1000,-21.9897181451289,-0.0219897181451289
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
<StartBug> void jslTokenAsString ( int token , char * str , size_t len ) { <EndBug> if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { <StartBug> case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; return ; <EndBug> <StartBug> case LEX_ID : strncpy ( str , ""ID"" , len ) ; return ; <EndBug> <StartBug> case LEX_INT : strncpy ( str , ""INT"" , len ) ; return ; <EndBug> <StartBug> case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; return ; <EndBug> <StartBug> case LEX_STR : strncpy ( str , ""STRING"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len ) ; return ; <EndBug> <StartBug> case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; return ; <EndBug> <StartBug> case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; return ; <EndBug> } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; <StartBug> strncpy ( str , & tokenNames [ p ] , len ) ; <EndBug> return ; } <StartBug> assert ( len >= 10 ) ; <EndBug> espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }
Fixed code:","
<StartBug> void jslTokenAsString ( int token , char * str , size_t len ) { <EndBug> if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { case LEX_EOF : <StartBug> snprintf(str, len, ""EOF""); <EndBug> return ; case LEX_ID : <StartBug> snprintf(str, len, ""ID""); <EndBug> return ; case LEX_INT : <StartBug> snprintf(str, len, ""INT""); <EndBug> return ; case LEX_FLOAT : <StartBug> snprintf(str, len, ""FLOAT""); <EndBug> return ; case LEX_STR : <StartBug> snprintf(str, len, ""STRING""); <EndBug> return ; case LEX_UNFINISHED_STR : <StartBug> snprintf(str, len, ""UNFINISHED STRING""); <EndBug> return ; case LEX_TEMPLATE_LITERAL : <StartBug> snprintf(str, len, ""TEMPLATE LITERAL""); <EndBug> return ; case LEX_UNFINISHED_TEMPLATE_LITERAL : <StartBug> snprintf(str, len, ""UNFINISHED TEMPLATE LITERAL""); <EndBug> return ; case LEX_REGEX : <StartBug> snprintf(str, len, ""REGEX""); <EndBug> return ; case LEX_UNFINISHED_REGEX : <StartBug> snprintf(str, len, ""UNFINISHED REGEX""); <EndBug> return ; case LEX_UNFINISHED_COMMENT : <StartBug> snprintf(str, len, ""UNFINISHED COMMENT""); <EndBug> return ; } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; <StartBug> snprintf( str, len, &tokenNames[p]); <EndBug> return ; } <StartBug> assert ( len >= 10 ) ; <EndBug> espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }",14,934,-16.31162786799899,-0.01746426966595181
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
<StartBug> void jslTokenAsString ( int token , char * str , size_t len ) { <EndBug> if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { <StartBug> case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; return ; <EndBug> <StartBug> case LEX_ID : strncpy ( str , ""ID"" , len ) ; return ; <EndBug> <StartBug> case LEX_INT : strncpy ( str , ""INT"" , len ) ; return ; <EndBug> <StartBug> case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; return ; <EndBug> <StartBug> case LEX_STR : strncpy ( str , ""STRING"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len ) ; return ; <EndBug> <StartBug> case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; return ; <EndBug> <StartBug> case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; return ; <EndBug> } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; <StartBug> strncpy ( str , & tokenNames [ p ] , len ) ; <EndBug> return ; } <StartBug> assert ( len >= 10 ) ; <EndBug> espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }
Fixed code:","
<StartBug> void jslTokenAsString ( int token , char * str , size_t len ) { <EndBug> if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { <StartBug> case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; str[len-1] = '\0'; return ; <EndBug> <StartBug> case LEX_ID : strncpy ( str , ""ID"" , len ) ; str[len-1] = '\0'; return ; <EndBug> <StartBug> case LEX_INT : strncpy ( str , ""INT"" , len ) ; str[len-1] = '\0'; return ; <EndBug> <StartBug> case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; str[len-1] = '\0'; return ; <EndBug> <StartBug> case LEX_STR : strncpy ( str , ""STRING"" , len ) ; str[len-1] = '\0'; return ; <EndBug> <StartBug> case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len ) ; str[len-1] = '\0'; return ; <EndBug> <StartBug> case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; str[len-1] = '\0'; return ; <EndBug> <StartBug> case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; str[len-1] = '\0'; return ; <EndBug> <StartBug> case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; str[len-1] = '\0'; return ; <EndBug> <StartBug> case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len ) ; str[len-1] = '\0'; return ; <EndBug> <StartBug> case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; str[len-1] = '\0'; return ; <EndBug> } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p",14,1000,-5.437590854341553,-0.005437590854341553
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
<StartBug> void jslTokenAsString ( int token , char * str , size_t len ) { <EndBug> if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { <StartBug> case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; return ; <EndBug> <StartBug> case LEX_ID : strncpy ( str , ""ID"" , len ) ; return ; <EndBug> <StartBug> case LEX_INT : strncpy ( str , ""INT"" , len ) ; return ; <EndBug> <StartBug> case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; return ; <EndBug> <StartBug> case LEX_STR : strncpy ( str , ""STRING"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len ) ; return ; <EndBug> <StartBug> case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; return ; <EndBug> <StartBug> case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; return ; <EndBug> } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; <StartBug> strncpy ( str , & tokenNames [ p ] , len ) ; <EndBug> return ; } <StartBug> assert ( len >= 10 ) ; <EndBug> espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }
Fixed code:","
<StartBug> void jslTokenAsString ( int token , char * str , size_t len ) { <EndBug> if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { <StartBug> case LEX_EOF : strncpy ( str , ""EOF"" , len-1 ) ; return ; <EndBug> <StartBug> case LEX_ID : strncpy ( str , ""ID"" , len-1 ) ; return ; <EndBug> <StartBug> case LEX_INT : strncpy ( str , ""INT"" , len-1 ) ; return ; <EndBug> <StartBug> case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len-1 ) ; return ; <EndBug> <StartBug> case LEX_STR : strncpy ( str , ""STRING"" , len-1 ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len-1 ) ; return ; <EndBug> <StartBug> case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len-1 ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len-1 ) ; return ; <EndBug> <StartBug> case LEX_REGEX : strncpy ( str , ""REGEX"" , len-1 ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len-1 ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len-1 ) ; return ; <EndBug> } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; <StartBug> strncpy ( str , & tokenNames [ p ] , len-1 ) ; <EndBug> return ; } <StartBug> assert ( len >= 10 ) ; <EndBug> espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }",14,994,-2.735247988613352,-0.0027517585398524665
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
<StartBug> void jslTokenAsString ( int token , char * str , size_t len ) { <EndBug> if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { <StartBug> case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; return ; <EndBug> <StartBug> case LEX_ID : strncpy ( str , ""ID"" , len ) ; return ; <EndBug> <StartBug> case LEX_INT : strncpy ( str , ""INT"" , len ) ; return ; <EndBug> <StartBug> case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; return ; <EndBug> <StartBug> case LEX_STR : strncpy ( str , ""STRING"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len ) ; return ; <EndBug> <StartBug> case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; return ; <EndBug> <StartBug> case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; return ; <EndBug> } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; <StartBug> strncpy ( str , & tokenNames [ p ] , len ) ; <EndBug> return ; } <StartBug> assert ( len >= 10 ) ; <EndBug> espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }
Fixed code:","
<StartBug> void jslTokenAsString ( int token , char * str , size_t len ) { <EndBug> if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { <StartBug> case LEX_EOF : strncpy ( str , ""EOF"" , len-1 ) ; return ; <EndBug> <StartBug> case LEX_ID : strncpy ( str , ""ID"" , len-1 ) ; return ; <EndBug> <StartBug> case LEX_INT : strncpy ( str , ""INT"" , len-1 ) ; return ; <EndBug> <StartBug> case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len-1 ) ; return ; <EndBug> <StartBug> case LEX_STR : strncpy ( str , ""STRING"" , len-1 ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len-1 ) ; return ; <EndBug> <StartBug> case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len-1 ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len-1 ) ; return ; <EndBug> <StartBug> case LEX_REGEX : strncpy ( str , ""REGEX"" , len-1 ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len-1 ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len-1 ) ; return ; <EndBug> } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; <StartBug> strncpy ( str , & tokenNames [ p ] , len-1 ) ; <EndBug> return ; } <StartBug> assert ( len >= 10 ) ; <EndBug> espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }",14,994,-2.7789027886357016,-0.0027956768497341064
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
<StartBug> void jslTokenAsString ( int token , char * str , size_t len ) { <EndBug> if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { <StartBug> case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; return ; <EndBug> <StartBug> case LEX_ID : strncpy ( str , ""ID"" , len ) ; return ; <EndBug> <StartBug> case LEX_INT : strncpy ( str , ""INT"" , len ) ; return ; <EndBug> <StartBug> case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; return ; <EndBug> <StartBug> case LEX_STR : strncpy ( str , ""STRING"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len ) ; return ; <EndBug> <StartBug> case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; return ; <EndBug> <StartBug> case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; return ; <EndBug> } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; <StartBug> strncpy ( str , & tokenNames [ p ] , len ) ; <EndBug> return ; } <StartBug> assert ( len >= 10 ) ; <EndBug> espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }
Fixed code:","
void jslTokenAsString ( int token , char * str , size_t len ) { if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { case LEX_EOF : strncpy ( str , ""EOF"" , len-1 ) ; return ; case LEX_ID : strncpy ( str , ""ID"" , len-1 ) ; return ; case LEX_INT : strncpy ( str , ""INT"" , len-1 ) ; return ; case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len-1 ) ; return ; case LEX_STR : strncpy ( str , ""STRING"" , len-1 ) ; return ; case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len-1 ) ; return ; case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len-1 ) ; return ; case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len-1 ) ; return ; case LEX_REGEX : strncpy ( str , ""REGEX"" , len-1 ) ; return ; case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len-1 ) ; return ; case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len-1 ) ; return ; } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; strncpy ( str , & tokenNames [ p ] , len-1 ) ; return ; } assert ( len >= 10 ) ; espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }",14,882,-4.428244144371821,-0.005020684970943107
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
<StartBug> void jslTokenAsString ( int token , char * str , size_t len ) { <EndBug> if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { <StartBug> case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; return ; <EndBug> <StartBug> case LEX_ID : strncpy ( str , ""ID"" , len ) ; return ; <EndBug> <StartBug> case LEX_INT : strncpy ( str , ""INT"" , len ) ; return ; <EndBug> <StartBug> case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; return ; <EndBug> <StartBug> case LEX_STR : strncpy ( str , ""STRING"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len ) ; return ; <EndBug> <StartBug> case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; return ; <EndBug> <StartBug> case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; return ; <EndBug> } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; <StartBug> strncpy ( str , & tokenNames [ p ] , len ) ; <EndBug> return ; } <StartBug> assert ( len >= 10 ) ; <EndBug> espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }
Fixed code:","
<StartBug> void jslTokenAsString ( int token , char * str , size_t len ) { <EndBug> if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { <StartBug> case LEX_EOF : strncpy ( str , ""EOF"" , len - 1 ) ; return ; <EndBug> <StartBug> case LEX_ID : strncpy ( str , ""ID"" , len - 1 ) ; return ; <EndBug> <StartBug> case LEX_INT : strncpy ( str , ""INT"" , len - 1 ) ; return ; <EndBug> <StartBug> case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len - 1 ) ; return ; <EndBug> <StartBug> case LEX_STR : strncpy ( str , ""STRING"" , len - 1 ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len - 1 ) ; return ; <EndBug> <StartBug> case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len - 1 ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len - 1 ) ; return ; <EndBug> <StartBug> case LEX_REGEX : strncpy ( str , ""REGEX"" , len - 1 ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len - 1 ) ; return ; <EndBug> <StartBug> case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len - 1 ) ; return ; <EndBug> } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; <StartBug> strncpy ( str , & tokenNames [ p ] , len - 1 ) ; <EndBug> return ; } <StartBug> assert ( len >= 10 ) ; <EndBug> espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }",14,994,-3.8768672782086333,-0.0039002688915579812
