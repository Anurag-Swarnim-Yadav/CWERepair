Original code,Plausible Program,Total Tokens,Sum Entropy,Mean Entropy
"The Original Code is vulnerable to CWE-77: Improper Neutralization of Special Elements used in a Command ('Command Injection'). Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } <StartBug>run_cmd ( tty_fd , xfr_cmd , fname , NULL ) ;<EndBug> free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }
Fixed code:"," int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } <StartBug> 
    char *command;
    size_t len;
    len = strlen(xfr_cmd)+strlen(fname)+2;
    command = (char*)malloc(len);
    snprintf(command, len, ""%s %s"", xfr_cmd, fname);
    run_cmd(tty_fd, command, NULL);
    free(command);
<EndBug> free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }",1459,-29.322728604279952,-0.020097826322330332
"The Original Code is vulnerable to CWE-77: Improper Neutralization of Special Elements used in a Command ('Command Injection'). Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } <StartBug>run_cmd ( tty_fd , xfr_cmd , fname , NULL ) ;<EndBug> free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }
Fixed code:"," int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } <StartBug>run_cmd_safe ( tty_fd , xfr_cmd , fname , NULL ) ;<EndBug> free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }",1392,-5.4555733520359455,-0.00391923372991088
"The Original Code is vulnerable to CWE-77: Improper Neutralization of Special Elements used in a Command ('Command Injection'). Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } <StartBug>run_cmd ( tty_fd , xfr_cmd , fname , NULL ) ;<EndBug> free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }
Fixed code:","
int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } 
// Escape any special characters
fname = shell_escape(fname);
// Run the command with escaped arguments
run_cmd ( tty_fd , xfr_cmd , fname , NULL ) ;

free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }",1412,-29.70192284681507,-0.021035356123806706
"The Original Code is vulnerable to CWE-77: Improper Neutralization of Special Elements used in a Command ('Command Injection'). Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } <StartBug>run_cmd ( tty_fd , xfr_cmd , fname , NULL ) ;<EndBug> free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }
Fixed code:"," int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } <StartBug>char* sanitizedCommand[strlen(xfr_cmd)+strlen(fname)+1]; sprintf(sanitizedCommand, ""%s %s"", xfr_cmd, fname); run_cmd ( tty_fd , sanitizedCommand , NULL ) ;<EndBug> free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }",1428,-16.613580176282092,-0.011634159787312389
"The Original Code is vulnerable to CWE-77: Improper Neutralization of Special Elements used in a Command ('Command Injection'). Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } <StartBug>run_cmd ( tty_fd , xfr_cmd , fname , NULL ) ;<EndBug> free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }
Fixed code:"," int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } <StartBug>char s[100]; 
sprintf(s, ""%s %s"", xfr_cmd, fname); 
system(s);<EndBug> free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }",1401,-19.213337311489905,-0.01371401663917909
"The Original Code is vulnerable to CWE-77: Improper Neutralization of Special Elements used in a Command ('Command Injection'). Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } <StartBug>run_cmd ( tty_fd , xfr_cmd , fname , NULL ) ;<EndBug> free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }
Fixed code:"," int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } <StartBug>char *sanitized_cmd = shell_escape(xfr_cmd); run_cmd ( tty_fd , sanitized_cmd , fname , NULL ) ;<EndBug> free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }",1406,-14.793615125539546,-0.01052177462698403
"The Original Code is vulnerable to CWE-77: Improper Neutralization of Special Elements used in a Command ('Command Injection'). Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } <StartBug>run_cmd ( tty_fd , xfr_cmd , fname , NULL ) ;<EndBug> free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }
Fixed code:"," int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } <StartBug>char * xfr_cmd_esc; xfr_cmd_esc = malloc(strlen(xfr_cmd) * 2 + 1); mysql_real_escape_string(xfr_cmd_esc, xfr_cmd); run_cmd ( tty_fd , xfr_cmd_esc , fname , NULL ) ; free(xfr_cmd_esc);<EndBug> free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }",1453,-20.256715847916894,-0.013941304781773498
"The Original Code is vulnerable to CWE-77: Improper Neutralization of Special Elements used in a Command ('Command Injection'). Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } <StartBug>run_cmd ( tty_fd , xfr_cmd , fname , NULL ) ;<EndBug> free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }
Fixed code:"," int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } <StartBug>char* cmd_args[2];  cmd_args[0] = xfr_cmd;  cmd_args[1] = fname;  run_cmd ( tty_fd , cmd_args , NULL ) ;<EndBug> free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }",1419,-16.86462807373943,-0.011884868269020034
"The Original Code is vulnerable to CWE-77: Improper Neutralization of Special Elements used in a Command ('Command Injection'). Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } <StartBug>run_cmd ( tty_fd , xfr_cmd , fname , NULL ) ;<EndBug> free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }
Fixed code:"," int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } 
char * fixed_xfr_cmd = string_replace_char(xfr_cmd);
<StartBug>run_cmd ( tty_fd , fixed_xfr_cmd , fname , NULL ) ;<EndBug> free ( fname ) ; free (fixed_xfr_cmd); break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }

char *string_replace_char(const char *xfr_cmd) {
  char *p = 0;
  
  int j = 0;
  p = malloc(strlen(xfr_cmd) + 1); 
  for (int i = 0; i < strlen(xfr_cmd); i++) {

    switch (xfr_cmd[i]) {
      //Allowable special characters
      case '?':
      case '.':
      case '/':
      case '_': 
      case '-': 
        p[j++] = xfr_cmd[i];
      break;

      //All other characters
      default:
        if (isalnum(xfr_cmd[i]))
           p[j++] = xfr_cmd[i];       
      break;
    }
  }

  p[j] = '\0';

  return p;
}",1639,-142.02457047078786,-0.08665318515606336
"The Original Code is vulnerable to CWE-77: Improper Neutralization of Special Elements used in a Command ('Command Injection'). Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } <StartBug>run_cmd ( tty_fd , xfr_cmd , fname , NULL ) ;<EndBug> free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }
Fixed code:"," int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } run_cmd ( tty_fd , xfr_cmd , fname , NULL ) ; char** cmd; cmd = malloc(sizeof(char*)*3); int i; for(i = 0; i < 2; i++) { cmd[i] = malloc(sizeof(char)*strlen(xfr_cmd)); strcpy(cmd[i], xfr_cmd); } cmd[i] = NULL; execv(cmd[0], cmd); for(i = 0; i < 2; i++) { free(cmd[i]); } free(cmd); free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }",1490,-47.05204422253492,-0.031578553169486524
"The Original Code is vulnerable to CWE-77: Improper Neutralization of Special Elements used in a Command ('Command Injection'). Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } <StartBug>run_cmd ( tty_fd , xfr_cmd , fname , NULL ) ;<EndBug> free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }
Fixed code:"," int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : 
term_set_hupcl ( tty_fd , 0 ) ; 
term_flush ( tty_fd ) ; 
term_apply ( tty_fd ) ; 
term_erase ( tty_fd ) ; 
return 1 ; 
case KEY_STATUS : 
show_status ( dtr_up ) ; 
break ; 
case KEY_PULSE : 
fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; 
if ( term_pulse_dtr ( tty_fd ) < 0 ) 
fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; 
break ; 
case KEY_TOGGLE : 
if ( dtr_up ) 
r = term_lower_dtr ( tty_fd ) ; 
else 
r = term_raise_dtr ( tty_fd ) ; 
if ( r >= 0 ) 
dtr_up = ! dtr_up ; 
fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; 
break ; 
case KEY_BAUD_UP : 
case KEY_BAUD_DN : 
if ( c == KEY_BAUD_UP ) 
opts . baud = baud_up ( opts . baud ) ; 
else 
opts . baud = baud_down ( opts . baud ) ; 
term_set_baudrate ( tty_fd , opts . baud ) ; 
tty_q . len = 0 ; 
term_flush ( tty_fd ) ; 
term_apply ( tty_fd ) ; 
newbaud = term_get_baudrate ( tty_fd , NULL ) ; 
if ( opts . baud != newbaud ) { 
fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; 
} 
else { 
fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; 
} 
set_tty_write_sz ( newbaud ) ; 
break ; 
case KEY_FLOW : 
opts . flow = flow_next ( opts . flow ) ; 
term_set_flowcntrl ( tty_fd , opts . flow ) ; 
tty_q . len = 0 ; 
term_flush ( tty_fd ) ; 
term_apply ( tty_fd ) ; 
newflow = term_get_flowcntrl ( tty_fd ) ; 
if ( opts . flow != newflow ) { 
fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; 
} 
else { 
fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; 
} 
break ; 
case KEY_PARITY : 
opts . parity = parity_next ( opts . parity ) ; 
term_set_parity ( tty_fd , opts . parity ) ; 
tty_q . len = 0 ; 
term_flush ( tty_fd ) ; 
term_apply ( tty_fd ) ; 
newparity = term_get_parity ( tty_fd ) ; 
if ( opts . parity != newparity ) { 
fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; 
} 
else { 
fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; 
} 
break ; 
case KEY_BITS : 
opts . databits = bits_next ( opts . databits ) ; 
term_set_databits ( tty_fd , opts . databits ) ; 
tty_q . len = 0 ; 
term_flush ( tty_fd ) ; 
term_apply ( tty_fd ) ; 
newbits = term_get_databits ( tty_fd ) ; 
if ( opts . databits != newbits ) { 
fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; 
} 
else { 
fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; 
} 
break ; 
case KEY_LECHO : 
opts . lecho = ! opts . lecho ; 
fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; 
break ; 
case KEY_SEND : 
case KEY_RECEIVE : 
xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; 
if ( xfr_cmd [ 0 ] == '\\0' ) { 
fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; 
break ; 
} 
fname = read_filename ( ) ; 
if ( fname == NULL ) { 
fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; 
break ; 
} 
<StartBug>
char *cmd = NULL;
asprintf(&cmd,""%s %s"",xfr_cmd,fname);
run_cmd ( tty_fd , cmd , NULL ) ;
free(cmd);
<EndBug>
free ( fname ) ; 
break ; 
case KEY_BREAK : 
term_break ( tty_fd ) ; 
fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; 
break ; 
default : 
break ; 
} 
return 0 ; 
}",1619,-27.572134598328308,-0.01703034873275374
"The Original Code is vulnerable to CWE-77: Improper Neutralization of Special Elements used in a Command ('Command Injection'). Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } <StartBug>run_cmd ( tty_fd , xfr_cmd , fname , NULL ) ;<EndBug> free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }
Fixed code:"," int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } 
<StartBug>char *args[2];
args[0] = xfr_cmd;
args[1] = fname;
run_cmd_args(tty_fd, xfr_cmd, args)<EndBug>;
free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }",1418,-25.16778355432195,-0.017748789530551447
"The Original Code is vulnerable to CWE-77: Improper Neutralization of Special Elements used in a Command ('Command Injection'). Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } <StartBug>run_cmd ( tty_fd , xfr_cmd , fname , NULL ) ;<EndBug> free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }
Fixed code:"," int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } <StartBug> 

char** args = parse_args(xfr_cmd);
run_cmd ( tty_fd , args[0] , args[1] , args[2] ) ;
free(args);
<EndBug>
free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }",1419,-31.396303337159097,-0.022125654219280547
"The Original Code is vulnerable to CWE-77: Improper Neutralization of Special Elements used in a Command ('Command Injection'). Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } <StartBug>run_cmd ( tty_fd , xfr_cmd , fname , NULL ) ;<EndBug> free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }
Fixed code:","
int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } 

//Run command with shell escapes
char * cmdFormat = ""/bin/sh -c \""%s %s\"""";
char *cmdComplete = malloc(strlen(cmdFormat) + strlen(xfr_cmd) + strlen(fname));
sprintf(cmdComplete, cmdFormat, xfr_cmd, fname);

run_cmd ( tty_fd , cmdComplete , NULL ) ;

free ( fname ) ;
free(cmdComplete);
break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }",1466,-56.68641609638928,-0.03866740524992447
"The Original Code is vulnerable to CWE-77: Improper Neutralization of Special Elements used in a Command ('Command Injection'). Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } <StartBug>run_cmd ( tty_fd , xfr_cmd , fname , NULL ) ;<EndBug> free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }
Fixed code:"," int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } <StartBug>char* cmd[4]; cmd[0] = ""sh""; cmd[1] = ""-c""; cmd[2] = xfr_cmd; cmd[3] = fname; cmd[4] = NULL;run_cmd ( tty_fd , cmd[0], cmd[1], cmd[2], cmd[3], cmd[4] ) ;<EndBug> free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }",1448,-17.600794248734285,-0.012155244646915944
"The Original Code is vulnerable to CWE-77: Improper Neutralization of Special Elements used in a Command ('Command Injection'). Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } <StartBug>run_cmd ( tty_fd , xfr_cmd , fname , NULL ) ;<EndBug> free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }
Fixed code:"," int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } <StartBug>if(strstr(xfr_cmd, fname) == NULL){ return -1; } run_cmd ( tty_fd , xfr_cmd , fname , NULL ) ;<EndBug> free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }",1411,-18.502952029885154,-0.013113360758246035
"The Original Code is vulnerable to CWE-77: Improper Neutralization of Special Elements used in a Command ('Command Injection'). Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } <StartBug>run_cmd ( tty_fd , xfr_cmd , fname , NULL ) ;<EndBug> free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }
Fixed code:"," int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } <StartBug>char * filtered_fname = NULL; filtered_fname = filter_dangerous_characters(fname); if(filtered_fname == NULL) { fd_printf ( STO , ""*** could not filter dangerous characters ***\\r\\n"" ) ; break ; } run_cmd ( tty_fd , xfr_cmd , filtered_fname , NULL ) ; free(filtered_fname);<EndBug> free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; } 

char * filter_dangerous_characters(char * fname) {
    int length = strlen(fname);
    char * filtered_fname = malloc(length + 1);
    int i = 0;
    for(i = 0; i < length; i++) {
        if(fname[i] == ';' || fname[i] == '|' || fname[i] == '&' || fname[i] == '$') {
            free(filtered_fname);
            return NULL;
        }
        filtered_fname[i] = fname[i];
    }
    filtered_fname[length] = '\0';
    return filtered_fname;
}",1634,-63.08918154939504,-0.03861027022606796
"The Original Code is vulnerable to CWE-77: Improper Neutralization of Special Elements used in a Command ('Command Injection'). Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } <StartBug>run_cmd ( tty_fd , xfr_cmd , fname , NULL ) ;<EndBug> free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }
Fixed code:"," int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } <StartBug>char *xfr_cmd_copy = strdup(xfr_cmd); char *xfr_cmd_argv[2] = {xfr_cmd_copy, fname}; run_cmd(tty_fd, xfr_cmd_argv, NULL); free(xfr_cmd_copy);<EndBug> free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }",1439,-21.46533521999491,-0.014916841709516963
"The Original Code is vulnerable to CWE-77: Improper Neutralization of Special Elements used in a Command ('Command Injection'). Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } <StartBug>run_cmd ( tty_fd , xfr_cmd , fname , NULL ) ;<EndBug> free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }
Fixed code:"," int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } <StartBug>char *xfr_cmd_temp; xfr_cmd_temp = malloc(strlen(xfr_cmd) + 1); strcpy(xfr_cmd_temp, xfr_cmd); char *fname_temp; fname_temp = malloc(strlen(fname) + 1); strcpy(fname_temp, fname); char *args[] = {xfr_cmd_temp, fname_temp, NULL}; run_cmd ( tty_fd , xfr_cmd_temp , fname_temp , args) ;<EndBug> free(xfr_cmd_temp); free(fname_temp); free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }",1512,-28.68643561056875,-0.018972510324450232
"The Original Code is vulnerable to CWE-77: Improper Neutralization of Special Elements used in a Command ('Command Injection'). Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } <StartBug>run_cmd ( tty_fd , xfr_cmd , fname , NULL ) ;<EndBug> free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }
Fixed code:"," int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } <StartBug>char** args = NULL;int argc = makeargv(xfr_cmd, "" "", &args);run_cmd ( tty_fd , args[0] , fname , args ) ;<EndBug> free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }",1414,-22.27709969992968,-0.0157546673974043
"The Original Code is vulnerable to CWE-77: Improper Neutralization of Special Elements used in a Command ('Command Injection'). Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } <StartBug>run_cmd ( tty_fd , xfr_cmd , fname , NULL ) ;<EndBug> free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }
Fixed code:"," int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } <StartBug> char *p; char *argv[4]; char *cmd; int i; cmd = malloc(strlen(xfr_cmd)+strlen(fname)+5); strcpy(cmd, xfr_cmd); i = 0; for (p = strtok(cmd, "" ""); p; p = strtok(NULL, "" "")) { argv[i++] = p; } argv[i++] = fname; argv[i] = NULL; run_cmd_safe(tty_fd, argv);<EndBug> free ( fname ) ; free(cmd); break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }",1496,-52.70095008180874,-0.03522790780869568
"The Original Code is vulnerable to CWE-77: Improper Neutralization of Special Elements used in a Command ('Command Injection'). Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } <StartBug>run_cmd ( tty_fd , xfr_cmd , fname , NULL ) ;<EndBug> free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }
Fixed code:","
int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } char *cmd[3]; cmd[0] = xfr_cmd; cmd[1] = fname; cmd[2] = NULL; <StartBug> execvp(cmd[0], cmd); <EndBug> free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }",1411,-13.222382208196574,-0.009370929984547537
"The Original Code is vulnerable to CWE-77: Improper Neutralization of Special Elements used in a Command ('Command Injection'). Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } <StartBug>run_cmd ( tty_fd , xfr_cmd , fname , NULL ) ;<EndBug> free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }
Fixed code:"," int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } <StartBug>char * cmd [3]; cmd[0] = xfr_cmd; cmd[1] = fname; cmd[2] = NULL; run_cmd(tty_fd, cmd);<EndBug>  free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }",1412,-17.627377391829555,-0.012483978322825464
"The Original Code is vulnerable to CWE-77: Improper Neutralization of Special Elements used in a Command ('Command Injection'). Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } <StartBug>run_cmd ( tty_fd , xfr_cmd , fname , NULL ) ;<EndBug> free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }
Fixed code:","
int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } <StartBug>char* escaped_filename = escape_special_chars(fname); run_cmd ( tty_fd , xfr_cmd , escaped_filename , NULL ) ; free(escaped_filename);<EndBug> free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; } 
char* escape_special_chars(char* fname) {
    
    // Use a dynamic array to store the escaped string
    char *escaped_filename = calloc(strlen(fname) * 2 + 1, sizeof(char));
    char *escaped_filename_ptr = escaped_filename;

    // Escape each character of the original string
    for (int i = 0; i < strlen(fname); i++) {
        switch (fname[i]) {
            case '\'':
            case '\""':
            case '\\':
            case ' ':
            case ';':
            case '&':
            case '|':
            case '#':
            case '$':
            case '!':
            case '(':
            case ')':
            case '{':
            case '}':
            case '?':
            case '*':
            case '[':
            case ']':
            case '^':
            case '%':
            case '<':
            case '>':
            case '`':
                // If a special character is found, escape it
                *escaped_filename_ptr = '\\';
                escaped_filename_ptr++;
            default:
                // Copy the current character to the escaped string
                *escaped_filename_ptr = fname[i];
                escaped_filename_ptr++;
        }
    }

    return escaped_filename;
}",1751,-113.88301816262958,-0.06503884532417452
"The Original Code is vulnerable to CWE-77: Improper Neutralization of Special Elements used in a Command ('Command Injection'). Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } <StartBug>run_cmd ( tty_fd , xfr_cmd , fname , NULL ) ;<EndBug> free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }
Fixed code:"," int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; }<StartBug> char *esc_fname[strlen(fname) * 2 + 1]; sqlite3_snprintf(esc_fname, strlen(fname) * 2 + 1, ""%q"", fname); run_cmd ( tty_fd , xfr_cmd , esc_fname , NULL ) ;<EndBug> free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }",1439,-24.936120493898464,-0.017328784220916237
"The Original Code is vulnerable to CWE-77: Improper Neutralization of Special Elements used in a Command ('Command Injection'). Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } <StartBug>run_cmd ( tty_fd , xfr_cmd , fname , NULL ) ;<EndBug> free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }
Fixed code:"," int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } <StartBug>char* sys_command[1024]; 
        sprintf(sys_command, ""%s %s"", xfr_cmd, fname); 
        system(sys_command);<EndBug> 
        free ( fname ) ; 
        break ; 
    case KEY_BREAK : 
        term_break ( tty_fd ) ; 
        fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; 
        break ; 
    default : 
        break ; 
    } 
    return 0 ; 
}",1442,-34.79231284765691,-0.02412781750877733
"The Original Code is vulnerable to CWE-77: Improper Neutralization of Special Elements used in a Command ('Command Injection'). Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } <StartBug>run_cmd ( tty_fd , xfr_cmd , fname , NULL ) ;<EndBug> free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }
Fixed code:"," int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } <StartBug>char* xfr_cmd_copy=(char*)malloc(strlen(xfr_cmd)+1);strcpy(xfr_cmd_copy,xfr_cmd);run_cmd ( tty_fd , xfr_cmd_copy , fname , NULL ) ; free(xfr_cmd_copy);<EndBug> free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }",1441,-20.95471703661233,-0.014541788366837147
"The Original Code is vulnerable to CWE-77: Improper Neutralization of Special Elements used in a Command ('Command Injection'). Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } <StartBug>run_cmd ( tty_fd , xfr_cmd , fname , NULL ) ;<EndBug> free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }
Fixed code:"," int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } <StartBug> char** array; array = malloc(2 * sizeof(char*)); array[0] = xfr_cmd; array[1] = fname; if ( array[0] != NULL && array[1] != NULL){ run_cmd ( tty_fd , array[0], array[1], NULL ) ;} free(array);<EndBug> free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }",1445,-32.81384866096338,-0.02270854578613383
"The Original Code is vulnerable to CWE-77: Improper Neutralization of Special Elements used in a Command ('Command Injection'). Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } <StartBug>run_cmd ( tty_fd , xfr_cmd , fname , NULL ) ;<EndBug> free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }
Fixed code:"," int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } <StartBug>char cmd_buff[1024]; snprintf(cmd_buff, 1024, ""%s %s"", xfr_cmd, fname); run_cmd(tty_fd, cmd_buff, NULL, NULL);<EndBug> free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }",1415,-18.226336163517246,-0.012880802942415014
"The Original Code is vulnerable to CWE-77: Improper Neutralization of Special Elements used in a Command ('Command Injection'). Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } <StartBug>run_cmd ( tty_fd , xfr_cmd , fname , NULL ) ;<EndBug> free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }
Fixed code:","
int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } <StartBug> char *cmd = (char *) malloc (strlen(fname)+strlen(xfr_cmd)+1); strcpy (cmd, xfr_cmd); strcat (cmd, fname); run_cmd ( tty_fd , cmd , NULL ); free(cmd);<EndBug> free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }",1433,-32.02382316568136,-0.022347399278214483
"The Original Code is vulnerable to CWE-77: Improper Neutralization of Special Elements used in a Command ('Command Injection'). Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } <StartBug>run_cmd ( tty_fd , xfr_cmd , fname , NULL ) ;<EndBug> free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }
Fixed code:"," int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } <StartBug>int len = strlen(xfr_cmd) + strlen(fname) + 1; char cmd[len]; sprintf(cmd, ""%s %s"", xfr_cmd, fname); system(cmd);<EndBug> free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }",1418,-13.995754869490446,-0.00987006690373092
"The Original Code is vulnerable to CWE-77: Improper Neutralization of Special Elements used in a Command ('Command Injection'). Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } <StartBug>run_cmd ( tty_fd , xfr_cmd , fname , NULL ) ;<EndBug> free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }
Fixed code:"," int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } <StartBug> char * cmd = new char[strlen(xfr_cmd) + strlen(fname) + 1]; strcpy(cmd, xfr_cmd); strcat(cmd, fname); run_cmd ( tty_fd , cmd , NULL ) ; delete[] cmd ;<EndBug> free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }",1432,-20.363458494956735,-0.014220292245081518
"The Original Code is vulnerable to CWE-77: Improper Neutralization of Special Elements used in a Command ('Command Injection'). Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } <StartBug>run_cmd ( tty_fd , xfr_cmd , fname , NULL ) ;<EndBug> free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }
Fixed code:"," int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; }<StartBug> if ( xfr_cmd[0] == '\\' ) { fd_printf(STO, ""*** Invalid command ***\\r\\n""); break; } <EndBug> run_cmd ( tty_fd , xfr_cmd , fname , NULL ) ; free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }",1426,-24.946400673052086,-0.017493969616446062
"The Original Code is vulnerable to CWE-77: Improper Neutralization of Special Elements used in a Command ('Command Injection'). Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } <StartBug>run_cmd ( tty_fd , xfr_cmd , fname , NULL ) ;<EndBug> free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }
Fixed code:"," int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } char buff[256]; memset(buff, 0, 256); snprintf(buff, sizeof(buff)-1, ""%s %s"", xfr_cmd, fname); <StartBug>run_cmd ( tty_fd , buff , NULL ) ;<EndBug> free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }",1422,-19.207731411562943,-0.013507546702927526
"The Original Code is vulnerable to CWE-77: Improper Neutralization of Special Elements used in a Command ('Command Injection'). Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } <StartBug>run_cmd ( tty_fd , xfr_cmd , fname , NULL ) ;<EndBug> free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }
Fixed code:"," int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } char * xfr_cmd_esc = malloc(strlen(xfr_cmd) + 1); strcpy(xfr_cmd_esc, xfr_cmd); for (size_t i = 0; i < strlen(xfr_cmd_esc); i++) { if (xfr_cmd_esc[i] == ';' || xfr_cmd_esc[i] == '|' || xfr_cmd_esc[i] == '&' || xfr_cmd_esc[i] == '$') { xfr_cmd_esc[i] = '\0'; } } <StartBug>run_cmd ( tty_fd , xfr_cmd_esc , fname , NULL ) ;<EndBug> free ( fname ); free(xfr_cmd_esc); break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }",1537,-31.754671839713374,-0.020660163851472593
"The Original Code is vulnerable to CWE-77: Improper Neutralization of Special Elements used in a Command ('Command Injection'). Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } <StartBug>run_cmd ( tty_fd , xfr_cmd , fname , NULL ) ;<EndBug> free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }
Fixed code:","
int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } <StartBug>char * cmd = NULL; size_t cmd_len = 0; if (opts.send_cmd) { cmd_len = strlen(opts.send_cmd) + strlen(fname) + 1; cmd = malloc(cmd_len); if (cmd) { snprintf(cmd, cmd_len, ""%s %s"", opts.send_cmd, fname); run_cmd(tty_fd, cmd, NULL); free(cmd); } else { fd_printf(STO, ""\\r\\n *** failed to allocate memory for command ***\\r\\n""); } } <EndBug> free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }",1505,-48.73821147777415,-0.03238419367293963
"The Original Code is vulnerable to CWE-77: Improper Neutralization of Special Elements used in a Command ('Command Injection'). Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } <StartBug>run_cmd ( tty_fd , xfr_cmd , fname , NULL ) ;<EndBug> free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }
Fixed code:"," int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } <StartBug>char *cmd[3] = {NULL, NULL, NULL}; cmd[0] = xfr_cmd; cmd[1] = fname; cmd[2] = NULL; run_cmd(tty_fd, cmd);<EndBug> free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }",1419,-16.16920324368975,-0.011394787345799684
"The Original Code is vulnerable to CWE-77: Improper Neutralization of Special Elements used in a Command ('Command Injection'). Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } <StartBug>run_cmd ( tty_fd , xfr_cmd , fname , NULL ) ;<EndBug> free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }
Fixed code:"," int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } <StartBug>char *xfr_cmd_esc = shell_escape(xfr_cmd); run_cmd ( tty_fd , xfr_cmd_esc , fname , NULL ) ; free(xfr_cmd_esc);<EndBug> free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }",1419,-10.527909591586948,-0.007419245660033085
"The Original Code is vulnerable to CWE-77: Improper Neutralization of Special Elements used in a Command ('Command Injection'). Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } <StartBug>run_cmd ( tty_fd , xfr_cmd , fname , NULL ) ;<EndBug> free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }
Fixed code:"," int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } <StartBug>char * args [3] = {NULL, fname, NULL}; run_cmd ( tty_fd , xfr_cmd , args[0], args[1], args[2] ) ;<EndBug> free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }",1413,-20.83730029540395,-0.014746850881389915
"The Original Code is vulnerable to CWE-77: Improper Neutralization of Special Elements used in a Command ('Command Injection'). Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } <StartBug>run_cmd ( tty_fd , xfr_cmd , fname , NULL ) ;<EndBug> free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }
Fixed code:","
int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } <StartBug>char * xfr_cmd_safe = malloc(strlen(xfr_cmd) + 1); strcpy(xfr_cmd_safe, xfr_cmd); char * fname_safe = malloc(strlen(fname) + 1); strcpy(fname_safe, fname); run_cmd ( tty_fd , xfr_cmd_safe , fname_safe , NULL ) ; free(xfr_cmd_safe); free(fname_safe);<EndBug> free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }",1481,-17.707424976605566,-0.011956397688457505
"The Original Code is vulnerable to CWE-77: Improper Neutralization of Special Elements used in a Command ('Command Injection'). Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } <StartBug>run_cmd ( tty_fd , xfr_cmd , fname , NULL ) ;<EndBug> free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }
Fixed code:"," int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } char ** xfr_cmd_args=NULL; <StartBug>run_cmd ( tty_fd , xfr_cmd , fname , xfr_cmd_args ) ;<EndBug> free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }",1406,-21.32933578404253,-0.015170224597469794
"The Original Code is vulnerable to CWE-77: Improper Neutralization of Special Elements used in a Command ('Command Injection'). Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } <StartBug>run_cmd ( tty_fd , xfr_cmd , fname , NULL ) ;<EndBug> free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }
Fixed code:"," int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } <StartBug> // Added sanitization of fname char sanitized_fname[strlen(fname)+1]; sanitize_input(fname, sanitized_fname, strlen(fname)+1); run_cmd ( tty_fd , xfr_cmd , sanitized_fname , NULL ) ;<EndBug> free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }",1439,-30.622731921973845,-0.021280564226528038
"The Original Code is vulnerable to CWE-77: Improper Neutralization of Special Elements used in a Command ('Command Injection'). Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } <StartBug>run_cmd ( tty_fd , xfr_cmd , fname , NULL ) ;<EndBug> free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }
Fixed code:"," int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } <StartBug>char * command[4]; command[0] = ""sh""; command[1] = ""-c""; command[2] = xfr_cmd; command[3] = fname; execvp(command[0],command);<EndBug> free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }",1419,-14.97183071646685,-0.010550973020765925
"The Original Code is vulnerable to CWE-77: Improper Neutralization of Special Elements used in a Command ('Command Injection'). Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } <StartBug>run_cmd ( tty_fd , xfr_cmd , fname , NULL ) ;<EndBug> free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }
Fixed code:"," 
int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } <StartBug>// Sanitize user input to prevent command injection 
        char *sanitized_fname = malloc(strlen(fname) + 1);
        if (sanitized_fname == NULL) {
            fd_printf(STO, ""*** allocation error ***\r\n"");
            break;
        }
        strncpy(sanitized_fname, fname, strlen(fname));
        sanitized_fname[strlen(fname)] = '\0';
        run_cmd(tty_fd, xfr_cmd, sanitized_fname, NULL);
        free(sanitized_fname);<EndBug>
        free(fname); 
        break;
    case KEY_BREAK: 
        term_break(tty_fd); 
        fd_printf(STO, ""\\r\\n*** break sent ***\\r\\n""); 
        break; 
    default: 
        break; 
    } 
    return 0; 
}",1543,-52.57357468256549,-0.03407231022849352
"The Original Code is vulnerable to CWE-77: Improper Neutralization of Special Elements used in a Command ('Command Injection'). Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } <StartBug>run_cmd ( tty_fd , xfr_cmd , fname , NULL ) ;<EndBug> free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }
Fixed code:"," int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } <StartBug>run_cmd_safe ( tty_fd , xfr_cmd , fname , NULL ) ;<EndBug> free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }",1392,-5.530788876229649,-0.003973267870854633
"The Original Code is vulnerable to CWE-77: Improper Neutralization of Special Elements used in a Command ('Command Injection'). Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } <StartBug>run_cmd ( tty_fd , xfr_cmd , fname , NULL ) ;<EndBug> free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }
Fixed code:"," int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } <StartBug>if (strcmp(xfr_cmd, ""send"") == 0) {run_cmd ( tty_fd , xfr_cmd , fname , NULL );}<EndBug> free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }",1407,-16.558782542251336,-0.011768857528252548
"The Original Code is vulnerable to CWE-77: Improper Neutralization of Special Elements used in a Command ('Command Injection'). Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } <StartBug>run_cmd ( tty_fd , xfr_cmd , fname , NULL ) ;<EndBug> free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }
Fixed code:"," int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } char *args[] = {xfr_cmd, fname, NULL}; <StartBug>run_cmd ( tty_fd , xfr_cmd , args ) ;<EndBug> free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }",1403,-12.75424417517405,-0.009090694351513934
"The Original Code is vulnerable to CWE-77: Improper Neutralization of Special Elements used in a Command ('Command Injection'). Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } <StartBug>run_cmd ( tty_fd , xfr_cmd , fname , NULL ) ;<EndBug> free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }
Fixed code:"," 
int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } <StartBug>char cmd[1024];snprintf(cmd, sizeof(cmd), ""%s %s"", xfr_cmd, fname);run_cmd ( tty_fd , cmd , NULL ) ;<EndBug> free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }",1413,-15.2139052033077,-0.010767094977570913
"The Original Code is vulnerable to CWE-77: Improper Neutralization of Special Elements used in a Command ('Command Injection'). Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } <StartBug>run_cmd ( tty_fd , xfr_cmd , fname , NULL ) ;<EndBug> free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }
Fixed code:"," int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } <StartBug> char* xfr_cmd_escaped = shell_escape(xfr_cmd); char* fname_escaped = shell_escape(fname); run_cmd ( tty_fd , xfr_cmd_escaped , fname_escaped , NULL ) ; free(xfr_cmd_escaped); free(fname_escaped); <EndBug> free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }",1448,-12.994412225620495,-0.008974041592279347
"The Original Code is vulnerable to CWE-77: Improper Neutralization of Special Elements used in a Command ('Command Injection'). Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } <StartBug>run_cmd ( tty_fd , xfr_cmd , fname , NULL ) ;<EndBug> free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }
Fixed code:"," int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } <StartBug>// Use fixed size array to restrict the command size to prevent buffer overflows char cmd_buf[256]; snprintf(cmd_buf, sizeof(cmd_buf), ""%s %s"", xfr_cmd, fname); run_cmd ( tty_fd , cmd_buf , NULL ) ;<EndBug> free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }",1434,-43.68088051854282,-0.030460865075692345
