Original code,Plausible Program,Total Tokens,Sum Entropy,Mean Entropy
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force && g . pipeout && g . decode != 2 && ! g . list ) ) { RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; if ( method != - 1 ) complain ( method < 0 ? ""%s is not compressed -- skipping"" : ""%s has unknown compression method -- skipping"" , g . inf ) ; return ; } if ( g . decode == 2 ) { if ( method == 8 ) infchk ( ) ; else { unlzw ( ) ; if ( g . list ) { g . in_tot -= 3 ; show_info ( method , 0 , g . out_tot , 0 ) ; } } RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } } if ( g . list ) { list_info ( ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( path == NULL || g . pipeout ) { g . outf = MALLOC ( strlen ( ""<stdout>"" ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; strcpy ( g . outf , ""<stdout>"" ) ; g . outd = 1 ; if ( ! g . decode && ! g . force && isatty ( g . outd ) ) bail ( ""trying to write compressed data to a terminal"" , "" (use -f to force)"" ) ; } else { <StartBug> char * to , * repl ; to = g . inf ; if ( g . decode && ( g . headis & 1 ) != 0 && g . hname != NULL ) {  to = g . hname ; len = strlen ( g . hname ) ; <EndBug> } <StartBug> repl = g . decode && strcmp ( to + len , "".tgz"" ) ? """" : "".tar"" ; g . outf = MALLOC ( len + ( g . decode ? strlen ( repl ) : strlen ( g . sufx ) ) + 1 ) ; <EndBug> if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; <StartBug> memcpy ( g . outf , to , len ) ; strcpy ( g . outf + len , g . decode ? repl : g . sufx ) ; <EndBug> g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY | ( g . force ? 0 : O_EXCL ) , 0600 ) ; if ( g . outd < 0 && errno == EEXIST && isatty ( 0 ) && g . verbosity ) { int ch , reply ; fprintf ( stderr , ""%s exists -- overwrite (y/n)? "" , g . outf ) ; fflush ( stderr ) ; reply = - 1 ; do { ch = getchar ( ) ; if ( reply < 0 && ch != ' ' && ch != '\\t' ) reply = ch == 'y' || ch == 'Y' ? 1 : 0 ; } while ( ch != EOF && ch != '\\n' && ch != '\\r' ) ; if ( reply == 1 ) g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY , 0600 ) ; } if ( g . outd < 0 && errno == EEXIST ) { complain ( ""%s exists -- skipping"" , g . outf ) ; RELEASE ( g . outf ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( g . outd < 0 ) bail ( ""write error on "" , g . outf ) ; } SET_BINARY_MODE ( g . outd ) ; RELEASE ( g . hname ) ; if ( g . verbosity > 1 ) fprintf ( stderr , ""%s to %s "" , g . inf , g . outf ) ; if ( g . decode ) { if ( method == 8 ) infchk ( ) ; else if ( method == 257 ) unlzw ( ) ; else cat ( ) ; } # ifndef NOTHREAD else if ( g . procs > 1 ) parallel_compress ( ) ; # endif else single_compress ( 0 ) ; if ( g . verbosity > 1 ) { putc ( '\\n' , stderr ) ; fflush ( stderr ) ; } if ( g . ind != 0 ) close ( g . ind ) ; if ( g . outd != 1 ) { if ( close ( g . outd ) ) bail ( ""write error on "" , g . outf ) ; g . outd = - 1 ; if ( g . ind != 0 ) { copymeta ( g . inf , g . outf ) ; if ( ! g . keep ) unlink ( g . inf ) ; } if ( g . decode && ( g . headis & 2 ) != 0 && g . stamp ) touch ( g . outf , g . stamp ) ; } RELEASE ( g . outf ) ; }
Fixed code:","

local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { <StartBug> char fullPath[1024]; snprintf(fullPath, sizeof(fullPath), ""%s%s"", g.inf, item); strncpy ( g . inf , fullPath , sizeof ( g . inf ) ) ; <EndBug> if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! (",1450,-14.27577832682198,-0.009845364363325504
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force && g . pipeout && g . decode != 2 && ! g . list ) ) { RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; if ( method != - 1 ) complain ( method < 0 ? ""%s is not compressed -- skipping"" : ""%s has unknown compression method -- skipping"" , g . inf ) ; return ; } if ( g . decode == 2 ) { if ( method == 8 ) infchk ( ) ; else { unlzw ( ) ; if ( g . list ) { g . in_tot -= 3 ; show_info ( method , 0 , g . out_tot , 0 ) ; } } RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } } if ( g . list ) { list_info ( ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( path == NULL || g . pipeout ) { g . outf = MALLOC ( strlen ( ""<stdout>"" ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; strcpy ( g . outf , ""<stdout>"" ) ; g . outd = 1 ; if ( ! g . decode && ! g . force && isatty ( g . outd ) ) bail ( ""trying to write compressed data to a terminal"" , "" (use -f to force)"" ) ; } else { <StartBug> char * to , * repl ; to = g . inf ; if ( g . decode && ( g . headis & 1 ) != 0 && g . hname != NULL ) {  to = g . hname ; len = strlen ( g . hname ) ; <EndBug> } <StartBug> repl = g . decode && strcmp ( to + len , "".tgz"" ) ? """" : "".tar"" ; g . outf = MALLOC ( len + ( g . decode ? strlen ( repl ) : strlen ( g . sufx ) ) + 1 ) ; <EndBug> if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; <StartBug> memcpy ( g . outf , to , len ) ; strcpy ( g . outf + len , g . decode ? repl : g . sufx ) ; <EndBug> g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY | ( g . force ? 0 : O_EXCL ) , 0600 ) ; if ( g . outd < 0 && errno == EEXIST && isatty ( 0 ) && g . verbosity ) { int ch , reply ; fprintf ( stderr , ""%s exists -- overwrite (y/n)? "" , g . outf ) ; fflush ( stderr ) ; reply = - 1 ; do { ch = getchar ( ) ; if ( reply < 0 && ch != ' ' && ch != '\\t' ) reply = ch == 'y' || ch == 'Y' ? 1 : 0 ; } while ( ch != EOF && ch != '\\n' && ch != '\\r' ) ; if ( reply == 1 ) g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY , 0600 ) ; } if ( g . outd < 0 && errno == EEXIST ) { complain ( ""%s exists -- skipping"" , g . outf ) ; RELEASE ( g . outf ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( g . outd < 0 ) bail ( ""write error on "" , g . outf ) ; } SET_BINARY_MODE ( g . outd ) ; RELEASE ( g . hname ) ; if ( g . verbosity > 1 ) fprintf ( stderr , ""%s to %s "" , g . inf , g . outf ) ; if ( g . decode ) { if ( method == 8 ) infchk ( ) ; else if ( method == 257 ) unlzw ( ) ; else cat ( ) ; } # ifndef NOTHREAD else if ( g . procs > 1 ) parallel_compress ( ) ; # endif else single_compress ( 0 ) ; if ( g . verbosity > 1 ) { putc ( '\\n' , stderr ) ; fflush ( stderr ) ; } if ( g . ind != 0 ) close ( g . ind ) ; if ( g . outd != 1 ) { if ( close ( g . outd ) ) bail ( ""write error on "" , g . outf ) ; g . outd = - 1 ; if ( g . ind != 0 ) { copymeta ( g . inf , g . outf ) ; if ( ! g . keep ) unlink ( g . inf ) ; } if ( g . decode && ( g . headis & 2 ) != 0 && g . stamp ) touch ( g . outf , g . stamp ) ; } RELEASE ( g . outf ) ; }
Fixed code:","
local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; 
if ( here == NULL ) return ; hold = 512 ; 

roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } <StartBug> // check if path is absolute if ( g . inf [ 0 ] != '/' ) { char absolute_path [ 2048 ] ; realpath ( g . inf , absolute_path ) ; strcpy ( g . inf , absolute_path ) ; } <EndBug> process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ;",1450,-46.07084583533542,-0.03177299712781753
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force && g . pipeout && g . decode != 2 && ! g . list ) ) { RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; if ( method != - 1 ) complain ( method < 0 ? ""%s is not compressed -- skipping"" : ""%s has unknown compression method -- skipping"" , g . inf ) ; return ; } if ( g . decode == 2 ) { if ( method == 8 ) infchk ( ) ; else { unlzw ( ) ; if ( g . list ) { g . in_tot -= 3 ; show_info ( method , 0 , g . out_tot , 0 ) ; } } RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } } if ( g . list ) { list_info ( ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( path == NULL || g . pipeout ) { g . outf = MALLOC ( strlen ( ""<stdout>"" ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; strcpy ( g . outf , ""<stdout>"" ) ; g . outd = 1 ; if ( ! g . decode && ! g . force && isatty ( g . outd ) ) bail ( ""trying to write compressed data to a terminal"" , "" (use -f to force)"" ) ; } else { <StartBug> char * to , * repl ; to = g . inf ; if ( g . decode && ( g . headis & 1 ) != 0 && g . hname != NULL ) {  to = g . hname ; len = strlen ( g . hname ) ; <EndBug> } <StartBug> repl = g . decode && strcmp ( to + len , "".tgz"" ) ? """" : "".tar"" ; g . outf = MALLOC ( len + ( g . decode ? strlen ( repl ) : strlen ( g . sufx ) ) + 1 ) ; <EndBug> if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; <StartBug> memcpy ( g . outf , to , len ) ; strcpy ( g . outf + len , g . decode ? repl : g . sufx ) ; <EndBug> g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY | ( g . force ? 0 : O_EXCL ) , 0600 ) ; if ( g . outd < 0 && errno == EEXIST && isatty ( 0 ) && g . verbosity ) { int ch , reply ; fprintf ( stderr , ""%s exists -- overwrite (y/n)? "" , g . outf ) ; fflush ( stderr ) ; reply = - 1 ; do { ch = getchar ( ) ; if ( reply < 0 && ch != ' ' && ch != '\\t' ) reply = ch == 'y' || ch == 'Y' ? 1 : 0 ; } while ( ch != EOF && ch != '\\n' && ch != '\\r' ) ; if ( reply == 1 ) g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY , 0600 ) ; } if ( g . outd < 0 && errno == EEXIST ) { complain ( ""%s exists -- skipping"" , g . outf ) ; RELEASE ( g . outf ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( g . outd < 0 ) bail ( ""write error on "" , g . outf ) ; } SET_BINARY_MODE ( g . outd ) ; RELEASE ( g . hname ) ; if ( g . verbosity > 1 ) fprintf ( stderr , ""%s to %s "" , g . inf , g . outf ) ; if ( g . decode ) { if ( method == 8 ) infchk ( ) ; else if ( method == 257 ) unlzw ( ) ; else cat ( ) ; } # ifndef NOTHREAD else if ( g . procs > 1 ) parallel_compress ( ) ; # endif else single_compress ( 0 ) ; if ( g . verbosity > 1 ) { putc ( '\\n' , stderr ) ; fflush ( stderr ) ; } if ( g . ind != 0 ) close ( g . ind ) ; if ( g . outd != 1 ) { if ( close ( g . outd ) ) bail ( ""write error on "" , g . outf ) ; g . outd = - 1 ; if ( g . ind != 0 ) { copymeta ( g . inf , g . outf ) ; if ( ! g . keep ) unlink ( g . inf ) ; } if ( g . decode && ( g . headis & 2 ) != 0 && g . stamp ) touch ( g . outf , g . stamp ) ; } RELEASE ( g . outf ) ; }
Fixed code:"," 

local void process(char* path) {
	int method = -1;
	size_t len;
	struct stat st;
	static char* sufs[] = {"".z"", ""-z"", ""_z"", "".Z"", "".gz"", ""-gz"", "".zz"", ""-zz"", "".zip"", "".ZIP"", "".tgz"", NULL};
	if (path == NULL) {
		strcpy(g.inf, ""<stdin>"");
		g.ind = 0;
		g.name = NULL;
		g.mtime = g.headis & 2 ? (fstat(g.ind, &st) ? time(NULL) : st.st_mtime) : 0;
		len = 0;
	}
	else {
		if (path != g.inf) {
			strncpy(g.inf, path, sizeof(g.inf));
			if (g.inf[sizeof(g.inf) - 1]) bail(""name too long: "", path);
		}
		len = strlen(g.inf);
		if (lstat(g.inf, &st)) {
			if (errno == ENOENT && (g.list || g.decode)) {
				char** try = sufs;
				do {
					if (*try == NULL || len + strlen(*try) >= sizeof(g.inf)) break;
					strcpy(g.inf + len, *try++);
					errno = 0;
				} while (lstat(g.inf, &st) && errno == ENOENT);
			}
			#ifdef EOVERFLOW
			if (errno == EOVERFLOW || errno == EFBIG)
				bail(g.inf, "" too large -- not compiled with large file support"");
			#endif
			if (errno) {
				g.inf[len] = 0;
				complain(""%s does not exist -- skipping"", g.inf);
				return;
			}
			len = strlen(g.inf);
		}
		if ((st.st_mode & S_IFMT) != S_IFREG && (st.st_mode & S_IFMT) != S_IFLNK &&
			(st.st_mode & S_IFMT) != S_IFDIR) {
			complain(""%s is a special file or device -- skipping"", g.inf);
			return;
		}
		if ((st.st_mode & S_IFMT) == S_IFLNK && !g.force && !g.pipeout) {
			complain(""%s is a symbolic link -- skipping"", g.inf);
			return;
		}
		if ((st.st_mode & S_IFMT) == S_IFDIR && !g.recurse) {
			complain(""%s is a directory -- skipping"", g.inf);
			return;
		}
		if ((st.st_mode & S_IFMT) == S_IFDIR) {
			char *roll, *item, *cut, *base, *bigger;
			size_t len, hold;
			DIR* here;
			struct dirent* next;
			here = opendir(g.inf);
			if (here == NULL) return;
			hold = 512;
			roll = MALLOC(hold);
			if (roll == NULL) bail(""not enough memory"", """");
			*roll = 0;
			item = roll;
			while ((next = readdir(here)) != NULL) {
				if (next->d_name[0] == 0 || (next->d_name[0] == '.' &&
											 (next->d_name[1] == 0 ||
											  (next->d_name[1] == '.' &&
											   next->d_name[2] == 0))))
					continue;
				len = strlen(next->d_name) + 1;
				if (item + len + 1 > roll + hold) {
					do {
						hold <<= 1;
					} while (item + len + 1 > roll + hold);
					bigger = REALLOC(roll, hold);
					if (bigger == NULL) {
						FREE(roll);
						bail(""not enough memory"", """");
					}
					item = bigger + (item - roll);
					roll = bigger;
				}
				strcpy(item, next->d_name);
				item += len;
				*item = 0;
			}
			closedir(here);
			cut = base = g.inf + strlen(g.inf);
			if (base > g.inf && base[-1] != (unsigned char)'/') {
				if ((size_t)(base - g.inf) >= sizeof(g.inf)) bail(""path too long"", g.inf);
				*base++ = '/';
			}
			item = roll;
			while (*item) { 
				//Fixing the Path Traversal vulnerability
				if (*item == '.' && item[1] == '.') {
					complain(""%s is a unsafe directory -- skipping"", g.inf);
					item += strlen(item) + 1;
",1450,-67.74975581556201,-0.0467239695279738
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force && g . pipeout && g . decode != 2 && ! g . list ) ) { RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; if ( method != - 1 ) complain ( method < 0 ? ""%s is not compressed -- skipping"" : ""%s has unknown compression method -- skipping"" , g . inf ) ; return ; } if ( g . decode == 2 ) { if ( method == 8 ) infchk ( ) ; else { unlzw ( ) ; if ( g . list ) { g . in_tot -= 3 ; show_info ( method , 0 , g . out_tot , 0 ) ; } } RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } } if ( g . list ) { list_info ( ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( path == NULL || g . pipeout ) { g . outf = MALLOC ( strlen ( ""<stdout>"" ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; strcpy ( g . outf , ""<stdout>"" ) ; g . outd = 1 ; if ( ! g . decode && ! g . force && isatty ( g . outd ) ) bail ( ""trying to write compressed data to a terminal"" , "" (use -f to force)"" ) ; } else { <StartBug> char * to , * repl ; to = g . inf ; if ( g . decode && ( g . headis & 1 ) != 0 && g . hname != NULL ) {  to = g . hname ; len = strlen ( g . hname ) ; <EndBug> } <StartBug> repl = g . decode && strcmp ( to + len , "".tgz"" ) ? """" : "".tar"" ; g . outf = MALLOC ( len + ( g . decode ? strlen ( repl ) : strlen ( g . sufx ) ) + 1 ) ; <EndBug> if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; <StartBug> memcpy ( g . outf , to , len ) ; strcpy ( g . outf + len , g . decode ? repl : g . sufx ) ; <EndBug> g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY | ( g . force ? 0 : O_EXCL ) , 0600 ) ; if ( g . outd < 0 && errno == EEXIST && isatty ( 0 ) && g . verbosity ) { int ch , reply ; fprintf ( stderr , ""%s exists -- overwrite (y/n)? "" , g . outf ) ; fflush ( stderr ) ; reply = - 1 ; do { ch = getchar ( ) ; if ( reply < 0 && ch != ' ' && ch != '\\t' ) reply = ch == 'y' || ch == 'Y' ? 1 : 0 ; } while ( ch != EOF && ch != '\\n' && ch != '\\r' ) ; if ( reply == 1 ) g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY , 0600 ) ; } if ( g . outd < 0 && errno == EEXIST ) { complain ( ""%s exists -- skipping"" , g . outf ) ; RELEASE ( g . outf ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( g . outd < 0 ) bail ( ""write error on "" , g . outf ) ; } SET_BINARY_MODE ( g . outd ) ; RELEASE ( g . hname ) ; if ( g . verbosity > 1 ) fprintf ( stderr , ""%s to %s "" , g . inf , g . outf ) ; if ( g . decode ) { if ( method == 8 ) infchk ( ) ; else if ( method == 257 ) unlzw ( ) ; else cat ( ) ; } # ifndef NOTHREAD else if ( g . procs > 1 ) parallel_compress ( ) ; # endif else single_compress ( 0 ) ; if ( g . verbosity > 1 ) { putc ( '\\n' , stderr ) ; fflush ( stderr ) ; } if ( g . ind != 0 ) close ( g . ind ) ; if ( g . outd != 1 ) { if ( close ( g . outd ) ) bail ( ""write error on "" , g . outf ) ; g . outd = - 1 ; if ( g . ind != 0 ) { copymeta ( g . inf , g . outf ) ; if ( ! g . keep ) unlink ( g . inf ) ; } if ( g . decode && ( g . headis & 2 ) != 0 && g . stamp ) touch ( g . outf , g . stamp ) ; } RELEASE ( g . outf ) ; }
Fixed code:"," local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; <StartBug> if ( realpath ( g . inf , g . inf ) == NULL ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } <EndBug> if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { <StartBug> char tmp [ PATH_MAX ] ; char * fullPath ; strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } strcpy ( tmp , g . inf ) ; fullPath = realpath ( tmp , NULL ) ; if ( fullPath == NULL ) { complain ( ""Path traversal detected. Skipping file"" , g . inf ) ; continue ; } /* fullPath is a canonicalized absolute pathname. */ <EndBug> process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on",1450,-68.78456621961197,-0.047437631875594466
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force && g . pipeout && g . decode != 2 && ! g . list ) ) { RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; if ( method != - 1 ) complain ( method < 0 ? ""%s is not compressed -- skipping"" : ""%s has unknown compression method -- skipping"" , g . inf ) ; return ; } if ( g . decode == 2 ) { if ( method == 8 ) infchk ( ) ; else { unlzw ( ) ; if ( g . list ) { g . in_tot -= 3 ; show_info ( method , 0 , g . out_tot , 0 ) ; } } RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } } if ( g . list ) { list_info ( ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( path == NULL || g . pipeout ) { g . outf = MALLOC ( strlen ( ""<stdout>"" ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; strcpy ( g . outf , ""<stdout>"" ) ; g . outd = 1 ; if ( ! g . decode && ! g . force && isatty ( g . outd ) ) bail ( ""trying to write compressed data to a terminal"" , "" (use -f to force)"" ) ; } else { <StartBug> char * to , * repl ; to = g . inf ; if ( g . decode && ( g . headis & 1 ) != 0 && g . hname != NULL ) {  to = g . hname ; len = strlen ( g . hname ) ; <EndBug> } <StartBug> repl = g . decode && strcmp ( to + len , "".tgz"" ) ? """" : "".tar"" ; g . outf = MALLOC ( len + ( g . decode ? strlen ( repl ) : strlen ( g . sufx ) ) + 1 ) ; <EndBug> if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; <StartBug> memcpy ( g . outf , to , len ) ; strcpy ( g . outf + len , g . decode ? repl : g . sufx ) ; <EndBug> g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY | ( g . force ? 0 : O_EXCL ) , 0600 ) ; if ( g . outd < 0 && errno == EEXIST && isatty ( 0 ) && g . verbosity ) { int ch , reply ; fprintf ( stderr , ""%s exists -- overwrite (y/n)? "" , g . outf ) ; fflush ( stderr ) ; reply = - 1 ; do { ch = getchar ( ) ; if ( reply < 0 && ch != ' ' && ch != '\\t' ) reply = ch == 'y' || ch == 'Y' ? 1 : 0 ; } while ( ch != EOF && ch != '\\n' && ch != '\\r' ) ; if ( reply == 1 ) g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY , 0600 ) ; } if ( g . outd < 0 && errno == EEXIST ) { complain ( ""%s exists -- skipping"" , g . outf ) ; RELEASE ( g . outf ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( g . outd < 0 ) bail ( ""write error on "" , g . outf ) ; } SET_BINARY_MODE ( g . outd ) ; RELEASE ( g . hname ) ; if ( g . verbosity > 1 ) fprintf ( stderr , ""%s to %s "" , g . inf , g . outf ) ; if ( g . decode ) { if ( method == 8 ) infchk ( ) ; else if ( method == 257 ) unlzw ( ) ; else cat ( ) ; } # ifndef NOTHREAD else if ( g . procs > 1 ) parallel_compress ( ) ; # endif else single_compress ( 0 ) ; if ( g . verbosity > 1 ) { putc ( '\\n' , stderr ) ; fflush ( stderr ) ; } if ( g . ind != 0 ) close ( g . ind ) ; if ( g . outd != 1 ) { if ( close ( g . outd ) ) bail ( ""write error on "" , g . outf ) ; g . outd = - 1 ; if ( g . ind != 0 ) { copymeta ( g . inf , g . outf ) ; if ( ! g . keep ) unlink ( g . inf ) ; } if ( g . decode && ( g . headis & 2 ) != 0 && g . stamp ) touch ( g . outf , g . stamp ) ; } RELEASE ( g . outf ) ; }
Fixed code:"," local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { <StartBug> //Check for directory traversal if ( path [ 0 ] == '/' ) bail ( ""Directory traversal not allowed"" , path ) ; if ( strstr ( path , ""../"" ) != NULL || strstr ( path , ""/.."" ) != NULL ) bail ( ""Directory traversal not allowed"" , path ) ; <EndBug> if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } <StartBug> //Check for directory traversal if ( next -> d_name [ 0 ] == '/' ) bail ( ""Directory traversal not allowed"" , next -> d_name ) ; if ( strstr ( next -> d_name , ""../"" ) != NULL || strstr ( next -> d_name , ""/.."" ) != NULL ) bail ( ""Directory traversal not allowed"" , next -> d_name ) ; <EndBug> strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf",1450,-38.93781846783904,-0.026853667908854507
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force && g . pipeout && g . decode != 2 && ! g . list ) ) { RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; if ( method != - 1 ) complain ( method < 0 ? ""%s is not compressed -- skipping"" : ""%s has unknown compression method -- skipping"" , g . inf ) ; return ; } if ( g . decode == 2 ) { if ( method == 8 ) infchk ( ) ; else { unlzw ( ) ; if ( g . list ) { g . in_tot -= 3 ; show_info ( method , 0 , g . out_tot , 0 ) ; } } RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } } if ( g . list ) { list_info ( ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( path == NULL || g . pipeout ) { g . outf = MALLOC ( strlen ( ""<stdout>"" ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; strcpy ( g . outf , ""<stdout>"" ) ; g . outd = 1 ; if ( ! g . decode && ! g . force && isatty ( g . outd ) ) bail ( ""trying to write compressed data to a terminal"" , "" (use -f to force)"" ) ; } else { <StartBug> char * to , * repl ; to = g . inf ; if ( g . decode && ( g . headis & 1 ) != 0 && g . hname != NULL ) {  to = g . hname ; len = strlen ( g . hname ) ; <EndBug> } <StartBug> repl = g . decode && strcmp ( to + len , "".tgz"" ) ? """" : "".tar"" ; g . outf = MALLOC ( len + ( g . decode ? strlen ( repl ) : strlen ( g . sufx ) ) + 1 ) ; <EndBug> if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; <StartBug> memcpy ( g . outf , to , len ) ; strcpy ( g . outf + len , g . decode ? repl : g . sufx ) ; <EndBug> g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY | ( g . force ? 0 : O_EXCL ) , 0600 ) ; if ( g . outd < 0 && errno == EEXIST && isatty ( 0 ) && g . verbosity ) { int ch , reply ; fprintf ( stderr , ""%s exists -- overwrite (y/n)? "" , g . outf ) ; fflush ( stderr ) ; reply = - 1 ; do { ch = getchar ( ) ; if ( reply < 0 && ch != ' ' && ch != '\\t' ) reply = ch == 'y' || ch == 'Y' ? 1 : 0 ; } while ( ch != EOF && ch != '\\n' && ch != '\\r' ) ; if ( reply == 1 ) g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY , 0600 ) ; } if ( g . outd < 0 && errno == EEXIST ) { complain ( ""%s exists -- skipping"" , g . outf ) ; RELEASE ( g . outf ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( g . outd < 0 ) bail ( ""write error on "" , g . outf ) ; } SET_BINARY_MODE ( g . outd ) ; RELEASE ( g . hname ) ; if ( g . verbosity > 1 ) fprintf ( stderr , ""%s to %s "" , g . inf , g . outf ) ; if ( g . decode ) { if ( method == 8 ) infchk ( ) ; else if ( method == 257 ) unlzw ( ) ; else cat ( ) ; } # ifndef NOTHREAD else if ( g . procs > 1 ) parallel_compress ( ) ; # endif else single_compress ( 0 ) ; if ( g . verbosity > 1 ) { putc ( '\\n' , stderr ) ; fflush ( stderr ) ; } if ( g . ind != 0 ) close ( g . ind ) ; if ( g . outd != 1 ) { if ( close ( g . outd ) ) bail ( ""write error on "" , g . outf ) ; g . outd = - 1 ; if ( g . ind != 0 ) { copymeta ( g . inf , g . outf ) ; if ( ! g . keep ) unlink ( g . inf ) ; } if ( g . decode && ( g . headis & 2 ) != 0 && g . stamp ) touch ( g . outf , g . stamp ) ; } RELEASE ( g . outf ) ; }
Fixed code:"," 

local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { <StartBug> char fullPath[strlen(g.inf)+strlen(item)+1];  //Added for CWE-22 Fix 
strcpy(fullPath, g.inf);
strcat(fullPath, item);
strncpy ( g . inf , fullPath , sizeof ( g . inf ) ) ; <EndBug> if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init (",1450,-36.352679592273034,-0.025070813511912437
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force && g . pipeout && g . decode != 2 && ! g . list ) ) { RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; if ( method != - 1 ) complain ( method < 0 ? ""%s is not compressed -- skipping"" : ""%s has unknown compression method -- skipping"" , g . inf ) ; return ; } if ( g . decode == 2 ) { if ( method == 8 ) infchk ( ) ; else { unlzw ( ) ; if ( g . list ) { g . in_tot -= 3 ; show_info ( method , 0 , g . out_tot , 0 ) ; } } RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } } if ( g . list ) { list_info ( ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( path == NULL || g . pipeout ) { g . outf = MALLOC ( strlen ( ""<stdout>"" ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; strcpy ( g . outf , ""<stdout>"" ) ; g . outd = 1 ; if ( ! g . decode && ! g . force && isatty ( g . outd ) ) bail ( ""trying to write compressed data to a terminal"" , "" (use -f to force)"" ) ; } else { <StartBug> char * to , * repl ; to = g . inf ; if ( g . decode && ( g . headis & 1 ) != 0 && g . hname != NULL ) {  to = g . hname ; len = strlen ( g . hname ) ; <EndBug> } <StartBug> repl = g . decode && strcmp ( to + len , "".tgz"" ) ? """" : "".tar"" ; g . outf = MALLOC ( len + ( g . decode ? strlen ( repl ) : strlen ( g . sufx ) ) + 1 ) ; <EndBug> if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; <StartBug> memcpy ( g . outf , to , len ) ; strcpy ( g . outf + len , g . decode ? repl : g . sufx ) ; <EndBug> g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY | ( g . force ? 0 : O_EXCL ) , 0600 ) ; if ( g . outd < 0 && errno == EEXIST && isatty ( 0 ) && g . verbosity ) { int ch , reply ; fprintf ( stderr , ""%s exists -- overwrite (y/n)? "" , g . outf ) ; fflush ( stderr ) ; reply = - 1 ; do { ch = getchar ( ) ; if ( reply < 0 && ch != ' ' && ch != '\\t' ) reply = ch == 'y' || ch == 'Y' ? 1 : 0 ; } while ( ch != EOF && ch != '\\n' && ch != '\\r' ) ; if ( reply == 1 ) g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY , 0600 ) ; } if ( g . outd < 0 && errno == EEXIST ) { complain ( ""%s exists -- skipping"" , g . outf ) ; RELEASE ( g . outf ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( g . outd < 0 ) bail ( ""write error on "" , g . outf ) ; } SET_BINARY_MODE ( g . outd ) ; RELEASE ( g . hname ) ; if ( g . verbosity > 1 ) fprintf ( stderr , ""%s to %s "" , g . inf , g . outf ) ; if ( g . decode ) { if ( method == 8 ) infchk ( ) ; else if ( method == 257 ) unlzw ( ) ; else cat ( ) ; } # ifndef NOTHREAD else if ( g . procs > 1 ) parallel_compress ( ) ; # endif else single_compress ( 0 ) ; if ( g . verbosity > 1 ) { putc ( '\\n' , stderr ) ; fflush ( stderr ) ; } if ( g . ind != 0 ) close ( g . ind ) ; if ( g . outd != 1 ) { if ( close ( g . outd ) ) bail ( ""write error on "" , g . outf ) ; g . outd = - 1 ; if ( g . ind != 0 ) { copymeta ( g . inf , g . outf ) ; if ( ! g . keep ) unlink ( g . inf ) ; } if ( g . decode && ( g . headis & 2 ) != 0 && g . stamp ) touch ( g . outf , g . stamp ) ; } RELEASE ( g . outf ) ; }
Fixed code:"," local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; // CWE-22 Fix <StartBug> if ( ! realpath ( g . inf , g . inf ) ) bail ( ""Unable to resolve real path"" , path ) ; len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { // CWE-22 Fix <EndBug> if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { // CWE-22 Fix <StartBug> char resolved_path [ PATH_MAX ] ; snprintf ( resolved_path , sizeof ( resolved_path ) , ""%s%s"" , g . inf , item ) ; if ( ! realpath ( resolved_path , g . inf ) ) bail ( ""Unable to resolve real path"" , path ) ; <EndBug> strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read",1450,-49.20093442049347,-0.03393167891068515
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force && g . pipeout && g . decode != 2 && ! g . list ) ) { RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; if ( method != - 1 ) complain ( method < 0 ? ""%s is not compressed -- skipping"" : ""%s has unknown compression method -- skipping"" , g . inf ) ; return ; } if ( g . decode == 2 ) { if ( method == 8 ) infchk ( ) ; else { unlzw ( ) ; if ( g . list ) { g . in_tot -= 3 ; show_info ( method , 0 , g . out_tot , 0 ) ; } } RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } } if ( g . list ) { list_info ( ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( path == NULL || g . pipeout ) { g . outf = MALLOC ( strlen ( ""<stdout>"" ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; strcpy ( g . outf , ""<stdout>"" ) ; g . outd = 1 ; if ( ! g . decode && ! g . force && isatty ( g . outd ) ) bail ( ""trying to write compressed data to a terminal"" , "" (use -f to force)"" ) ; } else { <StartBug> char * to , * repl ; to = g . inf ; if ( g . decode && ( g . headis & 1 ) != 0 && g . hname != NULL ) {  to = g . hname ; len = strlen ( g . hname ) ; <EndBug> } <StartBug> repl = g . decode && strcmp ( to + len , "".tgz"" ) ? """" : "".tar"" ; g . outf = MALLOC ( len + ( g . decode ? strlen ( repl ) : strlen ( g . sufx ) ) + 1 ) ; <EndBug> if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; <StartBug> memcpy ( g . outf , to , len ) ; strcpy ( g . outf + len , g . decode ? repl : g . sufx ) ; <EndBug> g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY | ( g . force ? 0 : O_EXCL ) , 0600 ) ; if ( g . outd < 0 && errno == EEXIST && isatty ( 0 ) && g . verbosity ) { int ch , reply ; fprintf ( stderr , ""%s exists -- overwrite (y/n)? "" , g . outf ) ; fflush ( stderr ) ; reply = - 1 ; do { ch = getchar ( ) ; if ( reply < 0 && ch != ' ' && ch != '\\t' ) reply = ch == 'y' || ch == 'Y' ? 1 : 0 ; } while ( ch != EOF && ch != '\\n' && ch != '\\r' ) ; if ( reply == 1 ) g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY , 0600 ) ; } if ( g . outd < 0 && errno == EEXIST ) { complain ( ""%s exists -- skipping"" , g . outf ) ; RELEASE ( g . outf ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( g . outd < 0 ) bail ( ""write error on "" , g . outf ) ; } SET_BINARY_MODE ( g . outd ) ; RELEASE ( g . hname ) ; if ( g . verbosity > 1 ) fprintf ( stderr , ""%s to %s "" , g . inf , g . outf ) ; if ( g . decode ) { if ( method == 8 ) infchk ( ) ; else if ( method == 257 ) unlzw ( ) ; else cat ( ) ; } # ifndef NOTHREAD else if ( g . procs > 1 ) parallel_compress ( ) ; # endif else single_compress ( 0 ) ; if ( g . verbosity > 1 ) { putc ( '\\n' , stderr ) ; fflush ( stderr ) ; } if ( g . ind != 0 ) close ( g . ind ) ; if ( g . outd != 1 ) { if ( close ( g . outd ) ) bail ( ""write error on "" , g . outf ) ; g . outd = - 1 ; if ( g . ind != 0 ) { copymeta ( g . inf , g . outf ) ; if ( ! g . keep ) unlink ( g . inf ) ; } if ( g . decode && ( g . headis & 2 ) != 0 && g . stamp ) touch ( g . outf , g . stamp ) ; } RELEASE ( g . outf ) ; }
Fixed code:"," local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; <StartBug> char real_path [ PATH_MAX ] ; realpath ( g . inf , real_path ) ; if ( lstat ( real_path , & st ) ) { <EndBug> if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == -",1450,-10.75416657166884,-0.007416666601150924
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force && g . pipeout && g . decode != 2 && ! g . list ) ) { RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; if ( method != - 1 ) complain ( method < 0 ? ""%s is not compressed -- skipping"" : ""%s has unknown compression method -- skipping"" , g . inf ) ; return ; } if ( g . decode == 2 ) { if ( method == 8 ) infchk ( ) ; else { unlzw ( ) ; if ( g . list ) { g . in_tot -= 3 ; show_info ( method , 0 , g . out_tot , 0 ) ; } } RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } } if ( g . list ) { list_info ( ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( path == NULL || g . pipeout ) { g . outf = MALLOC ( strlen ( ""<stdout>"" ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; strcpy ( g . outf , ""<stdout>"" ) ; g . outd = 1 ; if ( ! g . decode && ! g . force && isatty ( g . outd ) ) bail ( ""trying to write compressed data to a terminal"" , "" (use -f to force)"" ) ; } else { <StartBug> char * to , * repl ; to = g . inf ; if ( g . decode && ( g . headis & 1 ) != 0 && g . hname != NULL ) {  to = g . hname ; len = strlen ( g . hname ) ; <EndBug> } <StartBug> repl = g . decode && strcmp ( to + len , "".tgz"" ) ? """" : "".tar"" ; g . outf = MALLOC ( len + ( g . decode ? strlen ( repl ) : strlen ( g . sufx ) ) + 1 ) ; <EndBug> if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; <StartBug> memcpy ( g . outf , to , len ) ; strcpy ( g . outf + len , g . decode ? repl : g . sufx ) ; <EndBug> g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY | ( g . force ? 0 : O_EXCL ) , 0600 ) ; if ( g . outd < 0 && errno == EEXIST && isatty ( 0 ) && g . verbosity ) { int ch , reply ; fprintf ( stderr , ""%s exists -- overwrite (y/n)? "" , g . outf ) ; fflush ( stderr ) ; reply = - 1 ; do { ch = getchar ( ) ; if ( reply < 0 && ch != ' ' && ch != '\\t' ) reply = ch == 'y' || ch == 'Y' ? 1 : 0 ; } while ( ch != EOF && ch != '\\n' && ch != '\\r' ) ; if ( reply == 1 ) g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY , 0600 ) ; } if ( g . outd < 0 && errno == EEXIST ) { complain ( ""%s exists -- skipping"" , g . outf ) ; RELEASE ( g . outf ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( g . outd < 0 ) bail ( ""write error on "" , g . outf ) ; } SET_BINARY_MODE ( g . outd ) ; RELEASE ( g . hname ) ; if ( g . verbosity > 1 ) fprintf ( stderr , ""%s to %s "" , g . inf , g . outf ) ; if ( g . decode ) { if ( method == 8 ) infchk ( ) ; else if ( method == 257 ) unlzw ( ) ; else cat ( ) ; } # ifndef NOTHREAD else if ( g . procs > 1 ) parallel_compress ( ) ; # endif else single_compress ( 0 ) ; if ( g . verbosity > 1 ) { putc ( '\\n' , stderr ) ; fflush ( stderr ) ; } if ( g . ind != 0 ) close ( g . ind ) ; if ( g . outd != 1 ) { if ( close ( g . outd ) ) bail ( ""write error on "" , g . outf ) ; g . outd = - 1 ; if ( g . ind != 0 ) { copymeta ( g . inf , g . outf ) ; if ( ! g . keep ) unlink ( g . inf ) ; } if ( g . decode && ( g . headis & 2 ) != 0 && g . stamp ) touch ( g . outf , g . stamp ) ; } RELEASE ( g . outf ) ; }
Fixed code:","
local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { 
<StartBug>
// This block of code ensures that the path is restricted to a certain directory, so that it cannot access files in other directories
char canonicalPath[PATH_MAX];
realpath(path, canonicalPath);
if (strncmp(canonicalPath, g.inf, sizeof(g.inf)) != 0) {
    bail(""path traversal detected"", canonicalPath);
}
<EndBug>

if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { 
<StartBug>
// This block of code ensures that the path is restricted to a certain directory, so that it cannot access files in other directories
char canonicalPath[PATH_MAX];
strncpy(canonicalPath, g.inf, sizeof(g.inf));
strncat(canonicalPath, item, sizeof(g.inf));
realpath(canonicalPath, canonicalPath);
if (strncmp(canonicalPath, g.inf, sizeof(g.inf)) != 0) {
    bail(""path traversal detected"", canonicalPath);
}
<EndBug>

strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 &&",1450,-76.07680953982678,-0.05246676519988054
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force && g . pipeout && g . decode != 2 && ! g . list ) ) { RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; if ( method != - 1 ) complain ( method < 0 ? ""%s is not compressed -- skipping"" : ""%s has unknown compression method -- skipping"" , g . inf ) ; return ; } if ( g . decode == 2 ) { if ( method == 8 ) infchk ( ) ; else { unlzw ( ) ; if ( g . list ) { g . in_tot -= 3 ; show_info ( method , 0 , g . out_tot , 0 ) ; } } RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } } if ( g . list ) { list_info ( ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( path == NULL || g . pipeout ) { g . outf = MALLOC ( strlen ( ""<stdout>"" ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; strcpy ( g . outf , ""<stdout>"" ) ; g . outd = 1 ; if ( ! g . decode && ! g . force && isatty ( g . outd ) ) bail ( ""trying to write compressed data to a terminal"" , "" (use -f to force)"" ) ; } else { <StartBug> char * to , * repl ; to = g . inf ; if ( g . decode && ( g . headis & 1 ) != 0 && g . hname != NULL ) {  to = g . hname ; len = strlen ( g . hname ) ; <EndBug> } <StartBug> repl = g . decode && strcmp ( to + len , "".tgz"" ) ? """" : "".tar"" ; g . outf = MALLOC ( len + ( g . decode ? strlen ( repl ) : strlen ( g . sufx ) ) + 1 ) ; <EndBug> if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; <StartBug> memcpy ( g . outf , to , len ) ; strcpy ( g . outf + len , g . decode ? repl : g . sufx ) ; <EndBug> g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY | ( g . force ? 0 : O_EXCL ) , 0600 ) ; if ( g . outd < 0 && errno == EEXIST && isatty ( 0 ) && g . verbosity ) { int ch , reply ; fprintf ( stderr , ""%s exists -- overwrite (y/n)? "" , g . outf ) ; fflush ( stderr ) ; reply = - 1 ; do { ch = getchar ( ) ; if ( reply < 0 && ch != ' ' && ch != '\\t' ) reply = ch == 'y' || ch == 'Y' ? 1 : 0 ; } while ( ch != EOF && ch != '\\n' && ch != '\\r' ) ; if ( reply == 1 ) g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY , 0600 ) ; } if ( g . outd < 0 && errno == EEXIST ) { complain ( ""%s exists -- skipping"" , g . outf ) ; RELEASE ( g . outf ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( g . outd < 0 ) bail ( ""write error on "" , g . outf ) ; } SET_BINARY_MODE ( g . outd ) ; RELEASE ( g . hname ) ; if ( g . verbosity > 1 ) fprintf ( stderr , ""%s to %s "" , g . inf , g . outf ) ; if ( g . decode ) { if ( method == 8 ) infchk ( ) ; else if ( method == 257 ) unlzw ( ) ; else cat ( ) ; } # ifndef NOTHREAD else if ( g . procs > 1 ) parallel_compress ( ) ; # endif else single_compress ( 0 ) ; if ( g . verbosity > 1 ) { putc ( '\\n' , stderr ) ; fflush ( stderr ) ; } if ( g . ind != 0 ) close ( g . ind ) ; if ( g . outd != 1 ) { if ( close ( g . outd ) ) bail ( ""write error on "" , g . outf ) ; g . outd = - 1 ; if ( g . ind != 0 ) { copymeta ( g . inf , g . outf ) ; if ( ! g . keep ) unlink ( g . inf ) ; } if ( g . decode && ( g . headis & 2 ) != 0 && g . stamp ) touch ( g . outf , g . stamp ) ; } RELEASE ( g . outf ) ; }
Fixed code:","
local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { <StartBug> // Ensures pathname is limited to the current directory by using realpath() to normalize the pathname. char tmppath[PATH_MAX]; realpath(g.inf, tmppath); strncpy ( g . inf , tmppath, sizeof ( g . inf ) - ( base - g . inf ) ) ; <EndBug> if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in",1450,-47.54283632301676,-0.03278816298139087
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force && g . pipeout && g . decode != 2 && ! g . list ) ) { RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; if ( method != - 1 ) complain ( method < 0 ? ""%s is not compressed -- skipping"" : ""%s has unknown compression method -- skipping"" , g . inf ) ; return ; } if ( g . decode == 2 ) { if ( method == 8 ) infchk ( ) ; else { unlzw ( ) ; if ( g . list ) { g . in_tot -= 3 ; show_info ( method , 0 , g . out_tot , 0 ) ; } } RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } } if ( g . list ) { list_info ( ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( path == NULL || g . pipeout ) { g . outf = MALLOC ( strlen ( ""<stdout>"" ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; strcpy ( g . outf , ""<stdout>"" ) ; g . outd = 1 ; if ( ! g . decode && ! g . force && isatty ( g . outd ) ) bail ( ""trying to write compressed data to a terminal"" , "" (use -f to force)"" ) ; } else { <StartBug> char * to , * repl ; to = g . inf ; if ( g . decode && ( g . headis & 1 ) != 0 && g . hname != NULL ) {  to = g . hname ; len = strlen ( g . hname ) ; <EndBug> } <StartBug> repl = g . decode && strcmp ( to + len , "".tgz"" ) ? """" : "".tar"" ; g . outf = MALLOC ( len + ( g . decode ? strlen ( repl ) : strlen ( g . sufx ) ) + 1 ) ; <EndBug> if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; <StartBug> memcpy ( g . outf , to , len ) ; strcpy ( g . outf + len , g . decode ? repl : g . sufx ) ; <EndBug> g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY | ( g . force ? 0 : O_EXCL ) , 0600 ) ; if ( g . outd < 0 && errno == EEXIST && isatty ( 0 ) && g . verbosity ) { int ch , reply ; fprintf ( stderr , ""%s exists -- overwrite (y/n)? "" , g . outf ) ; fflush ( stderr ) ; reply = - 1 ; do { ch = getchar ( ) ; if ( reply < 0 && ch != ' ' && ch != '\\t' ) reply = ch == 'y' || ch == 'Y' ? 1 : 0 ; } while ( ch != EOF && ch != '\\n' && ch != '\\r' ) ; if ( reply == 1 ) g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY , 0600 ) ; } if ( g . outd < 0 && errno == EEXIST ) { complain ( ""%s exists -- skipping"" , g . outf ) ; RELEASE ( g . outf ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( g . outd < 0 ) bail ( ""write error on "" , g . outf ) ; } SET_BINARY_MODE ( g . outd ) ; RELEASE ( g . hname ) ; if ( g . verbosity > 1 ) fprintf ( stderr , ""%s to %s "" , g . inf , g . outf ) ; if ( g . decode ) { if ( method == 8 ) infchk ( ) ; else if ( method == 257 ) unlzw ( ) ; else cat ( ) ; } # ifndef NOTHREAD else if ( g . procs > 1 ) parallel_compress ( ) ; # endif else single_compress ( 0 ) ; if ( g . verbosity > 1 ) { putc ( '\\n' , stderr ) ; fflush ( stderr ) ; } if ( g . ind != 0 ) close ( g . ind ) ; if ( g . outd != 1 ) { if ( close ( g . outd ) ) bail ( ""write error on "" , g . outf ) ; g . outd = - 1 ; if ( g . ind != 0 ) { copymeta ( g . inf , g . outf ) ; if ( ! g . keep ) unlink ( g . inf ) ; } if ( g . decode && ( g . headis & 2 ) != 0 && g . stamp ) touch ( g . outf , g . stamp ) ; } RELEASE ( g . outf ) ; }
Fixed code:"," local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path ! = g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; <StartBug> char realpath [ PATH_MAX ] ; if ( realpath ( g . inf , realpath ) ! = NULL ) { strncpy ( g . inf , realpath , sizeof ( g . inf ) ) ; if ( lstat ( g . inf , & st ) ) <EndBug> { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) ! = S_IFREG && ( st . st_mode & S_IFMT ) ! = S_IFLNK && ( st . st_mode & S_IFMT ) ! = S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) ! = NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] ! = ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } <StartBug> char realpath [ PATH_MAX ] ; if ( realpath ( g . inf , realpath ) != NULL ) { process ( realpath ) ; } <EndBug> item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_m",1450,-32.45054953304084,-0.022379689333131614
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force && g . pipeout && g . decode != 2 && ! g . list ) ) { RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; if ( method != - 1 ) complain ( method < 0 ? ""%s is not compressed -- skipping"" : ""%s has unknown compression method -- skipping"" , g . inf ) ; return ; } if ( g . decode == 2 ) { if ( method == 8 ) infchk ( ) ; else { unlzw ( ) ; if ( g . list ) { g . in_tot -= 3 ; show_info ( method , 0 , g . out_tot , 0 ) ; } } RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } } if ( g . list ) { list_info ( ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( path == NULL || g . pipeout ) { g . outf = MALLOC ( strlen ( ""<stdout>"" ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; strcpy ( g . outf , ""<stdout>"" ) ; g . outd = 1 ; if ( ! g . decode && ! g . force && isatty ( g . outd ) ) bail ( ""trying to write compressed data to a terminal"" , "" (use -f to force)"" ) ; } else { <StartBug> char * to , * repl ; to = g . inf ; if ( g . decode && ( g . headis & 1 ) != 0 && g . hname != NULL ) {  to = g . hname ; len = strlen ( g . hname ) ; <EndBug> } <StartBug> repl = g . decode && strcmp ( to + len , "".tgz"" ) ? """" : "".tar"" ; g . outf = MALLOC ( len + ( g . decode ? strlen ( repl ) : strlen ( g . sufx ) ) + 1 ) ; <EndBug> if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; <StartBug> memcpy ( g . outf , to , len ) ; strcpy ( g . outf + len , g . decode ? repl : g . sufx ) ; <EndBug> g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY | ( g . force ? 0 : O_EXCL ) , 0600 ) ; if ( g . outd < 0 && errno == EEXIST && isatty ( 0 ) && g . verbosity ) { int ch , reply ; fprintf ( stderr , ""%s exists -- overwrite (y/n)? "" , g . outf ) ; fflush ( stderr ) ; reply = - 1 ; do { ch = getchar ( ) ; if ( reply < 0 && ch != ' ' && ch != '\\t' ) reply = ch == 'y' || ch == 'Y' ? 1 : 0 ; } while ( ch != EOF && ch != '\\n' && ch != '\\r' ) ; if ( reply == 1 ) g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY , 0600 ) ; } if ( g . outd < 0 && errno == EEXIST ) { complain ( ""%s exists -- skipping"" , g . outf ) ; RELEASE ( g . outf ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( g . outd < 0 ) bail ( ""write error on "" , g . outf ) ; } SET_BINARY_MODE ( g . outd ) ; RELEASE ( g . hname ) ; if ( g . verbosity > 1 ) fprintf ( stderr , ""%s to %s "" , g . inf , g . outf ) ; if ( g . decode ) { if ( method == 8 ) infchk ( ) ; else if ( method == 257 ) unlzw ( ) ; else cat ( ) ; } # ifndef NOTHREAD else if ( g . procs > 1 ) parallel_compress ( ) ; # endif else single_compress ( 0 ) ; if ( g . verbosity > 1 ) { putc ( '\\n' , stderr ) ; fflush ( stderr ) ; } if ( g . ind != 0 ) close ( g . ind ) ; if ( g . outd != 1 ) { if ( close ( g . outd ) ) bail ( ""write error on "" , g . outf ) ; g . outd = - 1 ; if ( g . ind != 0 ) { copymeta ( g . inf , g . outf ) ; if ( ! g . keep ) unlink ( g . inf ) ; } if ( g . decode && ( g . headis & 2 ) != 0 && g . stamp ) touch ( g . outf , g . stamp ) ; } RELEASE ( g . outf ) ; }
Fixed code:","

local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; <StartBug> if ( realpath ( g . inf , g . inf ) == NULL ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; <EndBug> if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if (",1450,-10.596485057589353,-0.007307920729371968
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force && g . pipeout && g . decode != 2 && ! g . list ) ) { RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; if ( method != - 1 ) complain ( method < 0 ? ""%s is not compressed -- skipping"" : ""%s has unknown compression method -- skipping"" , g . inf ) ; return ; } if ( g . decode == 2 ) { if ( method == 8 ) infchk ( ) ; else { unlzw ( ) ; if ( g . list ) { g . in_tot -= 3 ; show_info ( method , 0 , g . out_tot , 0 ) ; } } RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } } if ( g . list ) { list_info ( ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( path == NULL || g . pipeout ) { g . outf = MALLOC ( strlen ( ""<stdout>"" ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; strcpy ( g . outf , ""<stdout>"" ) ; g . outd = 1 ; if ( ! g . decode && ! g . force && isatty ( g . outd ) ) bail ( ""trying to write compressed data to a terminal"" , "" (use -f to force)"" ) ; } else { <StartBug> char * to , * repl ; to = g . inf ; if ( g . decode && ( g . headis & 1 ) != 0 && g . hname != NULL ) {  to = g . hname ; len = strlen ( g . hname ) ; <EndBug> } <StartBug> repl = g . decode && strcmp ( to + len , "".tgz"" ) ? """" : "".tar"" ; g . outf = MALLOC ( len + ( g . decode ? strlen ( repl ) : strlen ( g . sufx ) ) + 1 ) ; <EndBug> if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; <StartBug> memcpy ( g . outf , to , len ) ; strcpy ( g . outf + len , g . decode ? repl : g . sufx ) ; <EndBug> g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY | ( g . force ? 0 : O_EXCL ) , 0600 ) ; if ( g . outd < 0 && errno == EEXIST && isatty ( 0 ) && g . verbosity ) { int ch , reply ; fprintf ( stderr , ""%s exists -- overwrite (y/n)? "" , g . outf ) ; fflush ( stderr ) ; reply = - 1 ; do { ch = getchar ( ) ; if ( reply < 0 && ch != ' ' && ch != '\\t' ) reply = ch == 'y' || ch == 'Y' ? 1 : 0 ; } while ( ch != EOF && ch != '\\n' && ch != '\\r' ) ; if ( reply == 1 ) g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY , 0600 ) ; } if ( g . outd < 0 && errno == EEXIST ) { complain ( ""%s exists -- skipping"" , g . outf ) ; RELEASE ( g . outf ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( g . outd < 0 ) bail ( ""write error on "" , g . outf ) ; } SET_BINARY_MODE ( g . outd ) ; RELEASE ( g . hname ) ; if ( g . verbosity > 1 ) fprintf ( stderr , ""%s to %s "" , g . inf , g . outf ) ; if ( g . decode ) { if ( method == 8 ) infchk ( ) ; else if ( method == 257 ) unlzw ( ) ; else cat ( ) ; } # ifndef NOTHREAD else if ( g . procs > 1 ) parallel_compress ( ) ; # endif else single_compress ( 0 ) ; if ( g . verbosity > 1 ) { putc ( '\\n' , stderr ) ; fflush ( stderr ) ; } if ( g . ind != 0 ) close ( g . ind ) ; if ( g . outd != 1 ) { if ( close ( g . outd ) ) bail ( ""write error on "" , g . outf ) ; g . outd = - 1 ; if ( g . ind != 0 ) { copymeta ( g . inf , g . outf ) ; if ( ! g . keep ) unlink ( g . inf ) ; } if ( g . decode && ( g . headis & 2 ) != 0 && g . stamp ) touch ( g . outf , g . stamp ) ; } RELEASE ( g . outf ) ; }
Fixed code:"," local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; #ifndef PATH_MAX if ( len >= PATH_MAX ) bail(""name too long: "", path); #endif if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= PATH_MAX ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= PATH_MAX ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , PATH_MAX - ( base - g . inf ) ) ; if ( g . inf [ PATH_MAX - 1 ] ) { strcpy ( g . inf + ( PATH_MAX - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force && g . pipeout && g . decode != 2 && ! g",1450,-21.763649821996008,-0.015009413670342074
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force && g . pipeout && g . decode != 2 && ! g . list ) ) { RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; if ( method != - 1 ) complain ( method < 0 ? ""%s is not compressed -- skipping"" : ""%s has unknown compression method -- skipping"" , g . inf ) ; return ; } if ( g . decode == 2 ) { if ( method == 8 ) infchk ( ) ; else { unlzw ( ) ; if ( g . list ) { g . in_tot -= 3 ; show_info ( method , 0 , g . out_tot , 0 ) ; } } RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } } if ( g . list ) { list_info ( ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( path == NULL || g . pipeout ) { g . outf = MALLOC ( strlen ( ""<stdout>"" ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; strcpy ( g . outf , ""<stdout>"" ) ; g . outd = 1 ; if ( ! g . decode && ! g . force && isatty ( g . outd ) ) bail ( ""trying to write compressed data to a terminal"" , "" (use -f to force)"" ) ; } else { <StartBug> char * to , * repl ; to = g . inf ; if ( g . decode && ( g . headis & 1 ) != 0 && g . hname != NULL ) {  to = g . hname ; len = strlen ( g . hname ) ; <EndBug> } <StartBug> repl = g . decode && strcmp ( to + len , "".tgz"" ) ? """" : "".tar"" ; g . outf = MALLOC ( len + ( g . decode ? strlen ( repl ) : strlen ( g . sufx ) ) + 1 ) ; <EndBug> if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; <StartBug> memcpy ( g . outf , to , len ) ; strcpy ( g . outf + len , g . decode ? repl : g . sufx ) ; <EndBug> g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY | ( g . force ? 0 : O_EXCL ) , 0600 ) ; if ( g . outd < 0 && errno == EEXIST && isatty ( 0 ) && g . verbosity ) { int ch , reply ; fprintf ( stderr , ""%s exists -- overwrite (y/n)? "" , g . outf ) ; fflush ( stderr ) ; reply = - 1 ; do { ch = getchar ( ) ; if ( reply < 0 && ch != ' ' && ch != '\\t' ) reply = ch == 'y' || ch == 'Y' ? 1 : 0 ; } while ( ch != EOF && ch != '\\n' && ch != '\\r' ) ; if ( reply == 1 ) g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY , 0600 ) ; } if ( g . outd < 0 && errno == EEXIST ) { complain ( ""%s exists -- skipping"" , g . outf ) ; RELEASE ( g . outf ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( g . outd < 0 ) bail ( ""write error on "" , g . outf ) ; } SET_BINARY_MODE ( g . outd ) ; RELEASE ( g . hname ) ; if ( g . verbosity > 1 ) fprintf ( stderr , ""%s to %s "" , g . inf , g . outf ) ; if ( g . decode ) { if ( method == 8 ) infchk ( ) ; else if ( method == 257 ) unlzw ( ) ; else cat ( ) ; } # ifndef NOTHREAD else if ( g . procs > 1 ) parallel_compress ( ) ; # endif else single_compress ( 0 ) ; if ( g . verbosity > 1 ) { putc ( '\\n' , stderr ) ; fflush ( stderr ) ; } if ( g . ind != 0 ) close ( g . ind ) ; if ( g . outd != 1 ) { if ( close ( g . outd ) ) bail ( ""write error on "" , g . outf ) ; g . outd = - 1 ; if ( g . ind != 0 ) { copymeta ( g . inf , g . outf ) ; if ( ! g . keep ) unlink ( g . inf ) ; } if ( g . decode && ( g . headis & 2 ) != 0 && g . stamp ) touch ( g . outf , g . stamp ) ; } RELEASE ( g . outf ) ; }
Fixed code:"," local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } <StartBug> char newpath [ sizeof ( g . inf ) ] ; strcpy ( newpath , g . inf ) ; if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { realpath ( newpath , g . inf ) ; complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } <EndBug> if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; <StartBug> realpath ( g . inf , newpath ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( newpath ) ; <EndBug> item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode )",1450,-31.552292816723995,-0.021760201942568273
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force && g . pipeout && g . decode != 2 && ! g . list ) ) { RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; if ( method != - 1 ) complain ( method < 0 ? ""%s is not compressed -- skipping"" : ""%s has unknown compression method -- skipping"" , g . inf ) ; return ; } if ( g . decode == 2 ) { if ( method == 8 ) infchk ( ) ; else { unlzw ( ) ; if ( g . list ) { g . in_tot -= 3 ; show_info ( method , 0 , g . out_tot , 0 ) ; } } RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } } if ( g . list ) { list_info ( ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( path == NULL || g . pipeout ) { g . outf = MALLOC ( strlen ( ""<stdout>"" ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; strcpy ( g . outf , ""<stdout>"" ) ; g . outd = 1 ; if ( ! g . decode && ! g . force && isatty ( g . outd ) ) bail ( ""trying to write compressed data to a terminal"" , "" (use -f to force)"" ) ; } else { <StartBug> char * to , * repl ; to = g . inf ; if ( g . decode && ( g . headis & 1 ) != 0 && g . hname != NULL ) {  to = g . hname ; len = strlen ( g . hname ) ; <EndBug> } <StartBug> repl = g . decode && strcmp ( to + len , "".tgz"" ) ? """" : "".tar"" ; g . outf = MALLOC ( len + ( g . decode ? strlen ( repl ) : strlen ( g . sufx ) ) + 1 ) ; <EndBug> if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; <StartBug> memcpy ( g . outf , to , len ) ; strcpy ( g . outf + len , g . decode ? repl : g . sufx ) ; <EndBug> g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY | ( g . force ? 0 : O_EXCL ) , 0600 ) ; if ( g . outd < 0 && errno == EEXIST && isatty ( 0 ) && g . verbosity ) { int ch , reply ; fprintf ( stderr , ""%s exists -- overwrite (y/n)? "" , g . outf ) ; fflush ( stderr ) ; reply = - 1 ; do { ch = getchar ( ) ; if ( reply < 0 && ch != ' ' && ch != '\\t' ) reply = ch == 'y' || ch == 'Y' ? 1 : 0 ; } while ( ch != EOF && ch != '\\n' && ch != '\\r' ) ; if ( reply == 1 ) g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY , 0600 ) ; } if ( g . outd < 0 && errno == EEXIST ) { complain ( ""%s exists -- skipping"" , g . outf ) ; RELEASE ( g . outf ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( g . outd < 0 ) bail ( ""write error on "" , g . outf ) ; } SET_BINARY_MODE ( g . outd ) ; RELEASE ( g . hname ) ; if ( g . verbosity > 1 ) fprintf ( stderr , ""%s to %s "" , g . inf , g . outf ) ; if ( g . decode ) { if ( method == 8 ) infchk ( ) ; else if ( method == 257 ) unlzw ( ) ; else cat ( ) ; } # ifndef NOTHREAD else if ( g . procs > 1 ) parallel_compress ( ) ; # endif else single_compress ( 0 ) ; if ( g . verbosity > 1 ) { putc ( '\\n' , stderr ) ; fflush ( stderr ) ; } if ( g . ind != 0 ) close ( g . ind ) ; if ( g . outd != 1 ) { if ( close ( g . outd ) ) bail ( ""write error on "" , g . outf ) ; g . outd = - 1 ; if ( g . ind != 0 ) { copymeta ( g . inf , g . outf ) ; if ( ! g . keep ) unlink ( g . inf ) ; } if ( g . decode && ( g . headis & 2 ) != 0 && g . stamp ) touch ( g . outf , g . stamp ) ; } RELEASE ( g . outf ) ; }
Fixed code:","
local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { 

<StartBug>
char fullpath[strlen(g.inf) + strlen(item) + 2];
strcpy(fullpath, g.inf);
strcat(fullpath, item);
strcat(fullpath, ""/"");

if ( realpath(fullpath, g.inf) == NULL ) {
    g.inf[len] = 0;
    complain(""%s does not exist -- skipping"", g.inf);
    return;
}

if(lstat(g.inf, &st)) {
    g.inf[len] = 0;
    complain(""%s does not exist -- skipping"", g.inf);
    return;
}
<EndBug>

process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET",1450,-41.17770229030357,-0.028398415372623154
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force && g . pipeout && g . decode != 2 && ! g . list ) ) { RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; if ( method != - 1 ) complain ( method < 0 ? ""%s is not compressed -- skipping"" : ""%s has unknown compression method -- skipping"" , g . inf ) ; return ; } if ( g . decode == 2 ) { if ( method == 8 ) infchk ( ) ; else { unlzw ( ) ; if ( g . list ) { g . in_tot -= 3 ; show_info ( method , 0 , g . out_tot , 0 ) ; } } RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } } if ( g . list ) { list_info ( ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( path == NULL || g . pipeout ) { g . outf = MALLOC ( strlen ( ""<stdout>"" ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; strcpy ( g . outf , ""<stdout>"" ) ; g . outd = 1 ; if ( ! g . decode && ! g . force && isatty ( g . outd ) ) bail ( ""trying to write compressed data to a terminal"" , "" (use -f to force)"" ) ; } else { <StartBug> char * to , * repl ; to = g . inf ; if ( g . decode && ( g . headis & 1 ) != 0 && g . hname != NULL ) {  to = g . hname ; len = strlen ( g . hname ) ; <EndBug> } <StartBug> repl = g . decode && strcmp ( to + len , "".tgz"" ) ? """" : "".tar"" ; g . outf = MALLOC ( len + ( g . decode ? strlen ( repl ) : strlen ( g . sufx ) ) + 1 ) ; <EndBug> if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; <StartBug> memcpy ( g . outf , to , len ) ; strcpy ( g . outf + len , g . decode ? repl : g . sufx ) ; <EndBug> g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY | ( g . force ? 0 : O_EXCL ) , 0600 ) ; if ( g . outd < 0 && errno == EEXIST && isatty ( 0 ) && g . verbosity ) { int ch , reply ; fprintf ( stderr , ""%s exists -- overwrite (y/n)? "" , g . outf ) ; fflush ( stderr ) ; reply = - 1 ; do { ch = getchar ( ) ; if ( reply < 0 && ch != ' ' && ch != '\\t' ) reply = ch == 'y' || ch == 'Y' ? 1 : 0 ; } while ( ch != EOF && ch != '\\n' && ch != '\\r' ) ; if ( reply == 1 ) g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY , 0600 ) ; } if ( g . outd < 0 && errno == EEXIST ) { complain ( ""%s exists -- skipping"" , g . outf ) ; RELEASE ( g . outf ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( g . outd < 0 ) bail ( ""write error on "" , g . outf ) ; } SET_BINARY_MODE ( g . outd ) ; RELEASE ( g . hname ) ; if ( g . verbosity > 1 ) fprintf ( stderr , ""%s to %s "" , g . inf , g . outf ) ; if ( g . decode ) { if ( method == 8 ) infchk ( ) ; else if ( method == 257 ) unlzw ( ) ; else cat ( ) ; } # ifndef NOTHREAD else if ( g . procs > 1 ) parallel_compress ( ) ; # endif else single_compress ( 0 ) ; if ( g . verbosity > 1 ) { putc ( '\\n' , stderr ) ; fflush ( stderr ) ; } if ( g . ind != 0 ) close ( g . ind ) ; if ( g . outd != 1 ) { if ( close ( g . outd ) ) bail ( ""write error on "" , g . outf ) ; g . outd = - 1 ; if ( g . ind != 0 ) { copymeta ( g . inf , g . outf ) ; if ( ! g . keep ) unlink ( g . inf ) ; } if ( g . decode && ( g . headis & 2 ) != 0 && g . stamp ) touch ( g . outf , g . stamp ) ; } RELEASE ( g . outf ) ; }
Fixed code:"," 

local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } /*<StartBug>*/ /*Change this line of code to add a check against path traversal*/ char path[PATH_MAX]; if (realpath(g.inf, path) == NULL) { bail(""path traversal detected: "", g.inf); } process(path); /*</StartBug>*/  item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g .",1450,-69.63061323576326,-0.048021112576388456
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force && g . pipeout && g . decode != 2 && ! g . list ) ) { RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; if ( method != - 1 ) complain ( method < 0 ? ""%s is not compressed -- skipping"" : ""%s has unknown compression method -- skipping"" , g . inf ) ; return ; } if ( g . decode == 2 ) { if ( method == 8 ) infchk ( ) ; else { unlzw ( ) ; if ( g . list ) { g . in_tot -= 3 ; show_info ( method , 0 , g . out_tot , 0 ) ; } } RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } } if ( g . list ) { list_info ( ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( path == NULL || g . pipeout ) { g . outf = MALLOC ( strlen ( ""<stdout>"" ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; strcpy ( g . outf , ""<stdout>"" ) ; g . outd = 1 ; if ( ! g . decode && ! g . force && isatty ( g . outd ) ) bail ( ""trying to write compressed data to a terminal"" , "" (use -f to force)"" ) ; } else { <StartBug> char * to , * repl ; to = g . inf ; if ( g . decode && ( g . headis & 1 ) != 0 && g . hname != NULL ) {  to = g . hname ; len = strlen ( g . hname ) ; <EndBug> } <StartBug> repl = g . decode && strcmp ( to + len , "".tgz"" ) ? """" : "".tar"" ; g . outf = MALLOC ( len + ( g . decode ? strlen ( repl ) : strlen ( g . sufx ) ) + 1 ) ; <EndBug> if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; <StartBug> memcpy ( g . outf , to , len ) ; strcpy ( g . outf + len , g . decode ? repl : g . sufx ) ; <EndBug> g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY | ( g . force ? 0 : O_EXCL ) , 0600 ) ; if ( g . outd < 0 && errno == EEXIST && isatty ( 0 ) && g . verbosity ) { int ch , reply ; fprintf ( stderr , ""%s exists -- overwrite (y/n)? "" , g . outf ) ; fflush ( stderr ) ; reply = - 1 ; do { ch = getchar ( ) ; if ( reply < 0 && ch != ' ' && ch != '\\t' ) reply = ch == 'y' || ch == 'Y' ? 1 : 0 ; } while ( ch != EOF && ch != '\\n' && ch != '\\r' ) ; if ( reply == 1 ) g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY , 0600 ) ; } if ( g . outd < 0 && errno == EEXIST ) { complain ( ""%s exists -- skipping"" , g . outf ) ; RELEASE ( g . outf ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( g . outd < 0 ) bail ( ""write error on "" , g . outf ) ; } SET_BINARY_MODE ( g . outd ) ; RELEASE ( g . hname ) ; if ( g . verbosity > 1 ) fprintf ( stderr , ""%s to %s "" , g . inf , g . outf ) ; if ( g . decode ) { if ( method == 8 ) infchk ( ) ; else if ( method == 257 ) unlzw ( ) ; else cat ( ) ; } # ifndef NOTHREAD else if ( g . procs > 1 ) parallel_compress ( ) ; # endif else single_compress ( 0 ) ; if ( g . verbosity > 1 ) { putc ( '\\n' , stderr ) ; fflush ( stderr ) ; } if ( g . ind != 0 ) close ( g . ind ) ; if ( g . outd != 1 ) { if ( close ( g . outd ) ) bail ( ""write error on "" , g . outf ) ; g . outd = - 1 ; if ( g . ind != 0 ) { copymeta ( g . inf , g . outf ) ; if ( ! g . keep ) unlink ( g . inf ) ; } if ( g . decode && ( g . headis & 2 ) != 0 && g . stamp ) touch ( g . outf , g . stamp ) ; } RELEASE ( g . outf ) ; }
Fixed code:","
local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; <StartBug> if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' && ( size_t ) ( base - g . inf ) + 1 < sizeof ( g . inf ) ) { * base ++ = '/' ; } <EndBug> item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force && g . pipeout && g . decode != 2 && ! g . list ) ) { RELEASE ( g . hname ) ; if (",1450,-17.58821278248577,-0.012129801918955702
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force && g . pipeout && g . decode != 2 && ! g . list ) ) { RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; if ( method != - 1 ) complain ( method < 0 ? ""%s is not compressed -- skipping"" : ""%s has unknown compression method -- skipping"" , g . inf ) ; return ; } if ( g . decode == 2 ) { if ( method == 8 ) infchk ( ) ; else { unlzw ( ) ; if ( g . list ) { g . in_tot -= 3 ; show_info ( method , 0 , g . out_tot , 0 ) ; } } RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } } if ( g . list ) { list_info ( ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( path == NULL || g . pipeout ) { g . outf = MALLOC ( strlen ( ""<stdout>"" ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; strcpy ( g . outf , ""<stdout>"" ) ; g . outd = 1 ; if ( ! g . decode && ! g . force && isatty ( g . outd ) ) bail ( ""trying to write compressed data to a terminal"" , "" (use -f to force)"" ) ; } else { <StartBug> char * to , * repl ; to = g . inf ; if ( g . decode && ( g . headis & 1 ) != 0 && g . hname != NULL ) {  to = g . hname ; len = strlen ( g . hname ) ; <EndBug> } <StartBug> repl = g . decode && strcmp ( to + len , "".tgz"" ) ? """" : "".tar"" ; g . outf = MALLOC ( len + ( g . decode ? strlen ( repl ) : strlen ( g . sufx ) ) + 1 ) ; <EndBug> if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; <StartBug> memcpy ( g . outf , to , len ) ; strcpy ( g . outf + len , g . decode ? repl : g . sufx ) ; <EndBug> g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY | ( g . force ? 0 : O_EXCL ) , 0600 ) ; if ( g . outd < 0 && errno == EEXIST && isatty ( 0 ) && g . verbosity ) { int ch , reply ; fprintf ( stderr , ""%s exists -- overwrite (y/n)? "" , g . outf ) ; fflush ( stderr ) ; reply = - 1 ; do { ch = getchar ( ) ; if ( reply < 0 && ch != ' ' && ch != '\\t' ) reply = ch == 'y' || ch == 'Y' ? 1 : 0 ; } while ( ch != EOF && ch != '\\n' && ch != '\\r' ) ; if ( reply == 1 ) g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY , 0600 ) ; } if ( g . outd < 0 && errno == EEXIST ) { complain ( ""%s exists -- skipping"" , g . outf ) ; RELEASE ( g . outf ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( g . outd < 0 ) bail ( ""write error on "" , g . outf ) ; } SET_BINARY_MODE ( g . outd ) ; RELEASE ( g . hname ) ; if ( g . verbosity > 1 ) fprintf ( stderr , ""%s to %s "" , g . inf , g . outf ) ; if ( g . decode ) { if ( method == 8 ) infchk ( ) ; else if ( method == 257 ) unlzw ( ) ; else cat ( ) ; } # ifndef NOTHREAD else if ( g . procs > 1 ) parallel_compress ( ) ; # endif else single_compress ( 0 ) ; if ( g . verbosity > 1 ) { putc ( '\\n' , stderr ) ; fflush ( stderr ) ; } if ( g . ind != 0 ) close ( g . ind ) ; if ( g . outd != 1 ) { if ( close ( g . outd ) ) bail ( ""write error on "" , g . outf ) ; g . outd = - 1 ; if ( g . ind != 0 ) { copymeta ( g . inf , g . outf ) ; if ( ! g . keep ) unlink ( g . inf ) ; } if ( g . decode && ( g . headis & 2 ) != 0 && g . stamp ) touch ( g . outf , g . stamp ) ; } RELEASE ( g . outf ) ; }
Fixed code:"," local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; <StartBug> char absolute_path[PATH_MAX]; if(realpath(g.inf, absolute_path) == NULL) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } if ( lstat ( absolute_path , & st ) ) { <EndBug> if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } <StartBug> char absolute_path[PATH_MAX]; if(realpath(g.inf, absolute_path) != NULL) { process ( absolute_path ) ; } <EndBug> item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ?",1450,-23.514354190529936,-0.01621679599346892
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force && g . pipeout && g . decode != 2 && ! g . list ) ) { RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; if ( method != - 1 ) complain ( method < 0 ? ""%s is not compressed -- skipping"" : ""%s has unknown compression method -- skipping"" , g . inf ) ; return ; } if ( g . decode == 2 ) { if ( method == 8 ) infchk ( ) ; else { unlzw ( ) ; if ( g . list ) { g . in_tot -= 3 ; show_info ( method , 0 , g . out_tot , 0 ) ; } } RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } } if ( g . list ) { list_info ( ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( path == NULL || g . pipeout ) { g . outf = MALLOC ( strlen ( ""<stdout>"" ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; strcpy ( g . outf , ""<stdout>"" ) ; g . outd = 1 ; if ( ! g . decode && ! g . force && isatty ( g . outd ) ) bail ( ""trying to write compressed data to a terminal"" , "" (use -f to force)"" ) ; } else { <StartBug> char * to , * repl ; to = g . inf ; if ( g . decode && ( g . headis & 1 ) != 0 && g . hname != NULL ) {  to = g . hname ; len = strlen ( g . hname ) ; <EndBug> } <StartBug> repl = g . decode && strcmp ( to + len , "".tgz"" ) ? """" : "".tar"" ; g . outf = MALLOC ( len + ( g . decode ? strlen ( repl ) : strlen ( g . sufx ) ) + 1 ) ; <EndBug> if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; <StartBug> memcpy ( g . outf , to , len ) ; strcpy ( g . outf + len , g . decode ? repl : g . sufx ) ; <EndBug> g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY | ( g . force ? 0 : O_EXCL ) , 0600 ) ; if ( g . outd < 0 && errno == EEXIST && isatty ( 0 ) && g . verbosity ) { int ch , reply ; fprintf ( stderr , ""%s exists -- overwrite (y/n)? "" , g . outf ) ; fflush ( stderr ) ; reply = - 1 ; do { ch = getchar ( ) ; if ( reply < 0 && ch != ' ' && ch != '\\t' ) reply = ch == 'y' || ch == 'Y' ? 1 : 0 ; } while ( ch != EOF && ch != '\\n' && ch != '\\r' ) ; if ( reply == 1 ) g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY , 0600 ) ; } if ( g . outd < 0 && errno == EEXIST ) { complain ( ""%s exists -- skipping"" , g . outf ) ; RELEASE ( g . outf ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( g . outd < 0 ) bail ( ""write error on "" , g . outf ) ; } SET_BINARY_MODE ( g . outd ) ; RELEASE ( g . hname ) ; if ( g . verbosity > 1 ) fprintf ( stderr , ""%s to %s "" , g . inf , g . outf ) ; if ( g . decode ) { if ( method == 8 ) infchk ( ) ; else if ( method == 257 ) unlzw ( ) ; else cat ( ) ; } # ifndef NOTHREAD else if ( g . procs > 1 ) parallel_compress ( ) ; # endif else single_compress ( 0 ) ; if ( g . verbosity > 1 ) { putc ( '\\n' , stderr ) ; fflush ( stderr ) ; } if ( g . ind != 0 ) close ( g . ind ) ; if ( g . outd != 1 ) { if ( close ( g . outd ) ) bail ( ""write error on "" , g . outf ) ; g . outd = - 1 ; if ( g . ind != 0 ) { copymeta ( g . inf , g . outf ) ; if ( ! g . keep ) unlink ( g . inf ) ; } if ( g . decode && ( g . headis & 2 ) != 0 && g . stamp ) touch ( g . outf , g . stamp ) ; } RELEASE ( g . outf ) ; }
Fixed code:"," local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } <StartBug> char * realpath_buffer; realpath_buffer = realpath(g.inf, NULL); g.inf = realpath_buffer; <EndBug> if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } <StartBug> realpath_buffer = realpath(g.inf, NULL); g.inf = realpath_buffer; <EndBug> process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL",1450,-30.099474045130428,-0.020758257962158917
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force && g . pipeout && g . decode != 2 && ! g . list ) ) { RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; if ( method != - 1 ) complain ( method < 0 ? ""%s is not compressed -- skipping"" : ""%s has unknown compression method -- skipping"" , g . inf ) ; return ; } if ( g . decode == 2 ) { if ( method == 8 ) infchk ( ) ; else { unlzw ( ) ; if ( g . list ) { g . in_tot -= 3 ; show_info ( method , 0 , g . out_tot , 0 ) ; } } RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } } if ( g . list ) { list_info ( ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( path == NULL || g . pipeout ) { g . outf = MALLOC ( strlen ( ""<stdout>"" ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; strcpy ( g . outf , ""<stdout>"" ) ; g . outd = 1 ; if ( ! g . decode && ! g . force && isatty ( g . outd ) ) bail ( ""trying to write compressed data to a terminal"" , "" (use -f to force)"" ) ; } else { <StartBug> char * to , * repl ; to = g . inf ; if ( g . decode && ( g . headis & 1 ) != 0 && g . hname != NULL ) {  to = g . hname ; len = strlen ( g . hname ) ; <EndBug> } <StartBug> repl = g . decode && strcmp ( to + len , "".tgz"" ) ? """" : "".tar"" ; g . outf = MALLOC ( len + ( g . decode ? strlen ( repl ) : strlen ( g . sufx ) ) + 1 ) ; <EndBug> if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; <StartBug> memcpy ( g . outf , to , len ) ; strcpy ( g . outf + len , g . decode ? repl : g . sufx ) ; <EndBug> g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY | ( g . force ? 0 : O_EXCL ) , 0600 ) ; if ( g . outd < 0 && errno == EEXIST && isatty ( 0 ) && g . verbosity ) { int ch , reply ; fprintf ( stderr , ""%s exists -- overwrite (y/n)? "" , g . outf ) ; fflush ( stderr ) ; reply = - 1 ; do { ch = getchar ( ) ; if ( reply < 0 && ch != ' ' && ch != '\\t' ) reply = ch == 'y' || ch == 'Y' ? 1 : 0 ; } while ( ch != EOF && ch != '\\n' && ch != '\\r' ) ; if ( reply == 1 ) g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY , 0600 ) ; } if ( g . outd < 0 && errno == EEXIST ) { complain ( ""%s exists -- skipping"" , g . outf ) ; RELEASE ( g . outf ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( g . outd < 0 ) bail ( ""write error on "" , g . outf ) ; } SET_BINARY_MODE ( g . outd ) ; RELEASE ( g . hname ) ; if ( g . verbosity > 1 ) fprintf ( stderr , ""%s to %s "" , g . inf , g . outf ) ; if ( g . decode ) { if ( method == 8 ) infchk ( ) ; else if ( method == 257 ) unlzw ( ) ; else cat ( ) ; } # ifndef NOTHREAD else if ( g . procs > 1 ) parallel_compress ( ) ; # endif else single_compress ( 0 ) ; if ( g . verbosity > 1 ) { putc ( '\\n' , stderr ) ; fflush ( stderr ) ; } if ( g . ind != 0 ) close ( g . ind ) ; if ( g . outd != 1 ) { if ( close ( g . outd ) ) bail ( ""write error on "" , g . outf ) ; g . outd = - 1 ; if ( g . ind != 0 ) { copymeta ( g . inf , g . outf ) ; if ( ! g . keep ) unlink ( g . inf ) ; } if ( g . decode && ( g . headis & 2 ) != 0 && g . stamp ) touch ( g . outf , g . stamp ) ; } RELEASE ( g . outf ) ; }
Fixed code:"," local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } <StartBug> char real_path [ PATH_MAX ] ; if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * abs_path = realpath ( g . inf , real_path ) ; if ( abs_path == NULL ) { complain ( ""Invalid path -- skipping"" , g . inf ) ; return ; } <EndBug> if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; <StartBug> char real_path [ PATH_MAX ] ; char * abs_path = realpath ( g . inf , real_path ) ; if ( abs_path == NULL ) { complain ( ""Invalid path -- skipping"" , g . inf ) ; return ; } <EndBug> if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind <",1450,-35.3923238627636,-0.02440849921569903
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force && g . pipeout && g . decode != 2 && ! g . list ) ) { RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; if ( method != - 1 ) complain ( method < 0 ? ""%s is not compressed -- skipping"" : ""%s has unknown compression method -- skipping"" , g . inf ) ; return ; } if ( g . decode == 2 ) { if ( method == 8 ) infchk ( ) ; else { unlzw ( ) ; if ( g . list ) { g . in_tot -= 3 ; show_info ( method , 0 , g . out_tot , 0 ) ; } } RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } } if ( g . list ) { list_info ( ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( path == NULL || g . pipeout ) { g . outf = MALLOC ( strlen ( ""<stdout>"" ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; strcpy ( g . outf , ""<stdout>"" ) ; g . outd = 1 ; if ( ! g . decode && ! g . force && isatty ( g . outd ) ) bail ( ""trying to write compressed data to a terminal"" , "" (use -f to force)"" ) ; } else { <StartBug> char * to , * repl ; to = g . inf ; if ( g . decode && ( g . headis & 1 ) != 0 && g . hname != NULL ) {  to = g . hname ; len = strlen ( g . hname ) ; <EndBug> } <StartBug> repl = g . decode && strcmp ( to + len , "".tgz"" ) ? """" : "".tar"" ; g . outf = MALLOC ( len + ( g . decode ? strlen ( repl ) : strlen ( g . sufx ) ) + 1 ) ; <EndBug> if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; <StartBug> memcpy ( g . outf , to , len ) ; strcpy ( g . outf + len , g . decode ? repl : g . sufx ) ; <EndBug> g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY | ( g . force ? 0 : O_EXCL ) , 0600 ) ; if ( g . outd < 0 && errno == EEXIST && isatty ( 0 ) && g . verbosity ) { int ch , reply ; fprintf ( stderr , ""%s exists -- overwrite (y/n)? "" , g . outf ) ; fflush ( stderr ) ; reply = - 1 ; do { ch = getchar ( ) ; if ( reply < 0 && ch != ' ' && ch != '\\t' ) reply = ch == 'y' || ch == 'Y' ? 1 : 0 ; } while ( ch != EOF && ch != '\\n' && ch != '\\r' ) ; if ( reply == 1 ) g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY , 0600 ) ; } if ( g . outd < 0 && errno == EEXIST ) { complain ( ""%s exists -- skipping"" , g . outf ) ; RELEASE ( g . outf ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( g . outd < 0 ) bail ( ""write error on "" , g . outf ) ; } SET_BINARY_MODE ( g . outd ) ; RELEASE ( g . hname ) ; if ( g . verbosity > 1 ) fprintf ( stderr , ""%s to %s "" , g . inf , g . outf ) ; if ( g . decode ) { if ( method == 8 ) infchk ( ) ; else if ( method == 257 ) unlzw ( ) ; else cat ( ) ; } # ifndef NOTHREAD else if ( g . procs > 1 ) parallel_compress ( ) ; # endif else single_compress ( 0 ) ; if ( g . verbosity > 1 ) { putc ( '\\n' , stderr ) ; fflush ( stderr ) ; } if ( g . ind != 0 ) close ( g . ind ) ; if ( g . outd != 1 ) { if ( close ( g . outd ) ) bail ( ""write error on "" , g . outf ) ; g . outd = - 1 ; if ( g . ind != 0 ) { copymeta ( g . inf , g . outf ) ; if ( ! g . keep ) unlink ( g . inf ) ; } if ( g . decode && ( g . headis & 2 ) != 0 && g . stamp ) touch ( g . outf , g . stamp ) ; } RELEASE ( g . outf ) ; }
Fixed code:"," local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; <StartBug> char real_path [ sizeof ( g . inf ) ] ; realpath ( g . inf , real_path ) ; if ( lstat ( real_path , & st ) ) { <EndBug> if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } <StartBug> char real_path [ sizeof ( g . inf ) ] ; realpath ( g . inf , real_path ) ; process ( real_path ) ; <EndBug> item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if",1450,-12.412577829450598,-0.008560398503069378
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force && g . pipeout && g . decode != 2 && ! g . list ) ) { RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; if ( method != - 1 ) complain ( method < 0 ? ""%s is not compressed -- skipping"" : ""%s has unknown compression method -- skipping"" , g . inf ) ; return ; } if ( g . decode == 2 ) { if ( method == 8 ) infchk ( ) ; else { unlzw ( ) ; if ( g . list ) { g . in_tot -= 3 ; show_info ( method , 0 , g . out_tot , 0 ) ; } } RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } } if ( g . list ) { list_info ( ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( path == NULL || g . pipeout ) { g . outf = MALLOC ( strlen ( ""<stdout>"" ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; strcpy ( g . outf , ""<stdout>"" ) ; g . outd = 1 ; if ( ! g . decode && ! g . force && isatty ( g . outd ) ) bail ( ""trying to write compressed data to a terminal"" , "" (use -f to force)"" ) ; } else { <StartBug> char * to , * repl ; to = g . inf ; if ( g . decode && ( g . headis & 1 ) != 0 && g . hname != NULL ) {  to = g . hname ; len = strlen ( g . hname ) ; <EndBug> } <StartBug> repl = g . decode && strcmp ( to + len , "".tgz"" ) ? """" : "".tar"" ; g . outf = MALLOC ( len + ( g . decode ? strlen ( repl ) : strlen ( g . sufx ) ) + 1 ) ; <EndBug> if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; <StartBug> memcpy ( g . outf , to , len ) ; strcpy ( g . outf + len , g . decode ? repl : g . sufx ) ; <EndBug> g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY | ( g . force ? 0 : O_EXCL ) , 0600 ) ; if ( g . outd < 0 && errno == EEXIST && isatty ( 0 ) && g . verbosity ) { int ch , reply ; fprintf ( stderr , ""%s exists -- overwrite (y/n)? "" , g . outf ) ; fflush ( stderr ) ; reply = - 1 ; do { ch = getchar ( ) ; if ( reply < 0 && ch != ' ' && ch != '\\t' ) reply = ch == 'y' || ch == 'Y' ? 1 : 0 ; } while ( ch != EOF && ch != '\\n' && ch != '\\r' ) ; if ( reply == 1 ) g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY , 0600 ) ; } if ( g . outd < 0 && errno == EEXIST ) { complain ( ""%s exists -- skipping"" , g . outf ) ; RELEASE ( g . outf ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( g . outd < 0 ) bail ( ""write error on "" , g . outf ) ; } SET_BINARY_MODE ( g . outd ) ; RELEASE ( g . hname ) ; if ( g . verbosity > 1 ) fprintf ( stderr , ""%s to %s "" , g . inf , g . outf ) ; if ( g . decode ) { if ( method == 8 ) infchk ( ) ; else if ( method == 257 ) unlzw ( ) ; else cat ( ) ; } # ifndef NOTHREAD else if ( g . procs > 1 ) parallel_compress ( ) ; # endif else single_compress ( 0 ) ; if ( g . verbosity > 1 ) { putc ( '\\n' , stderr ) ; fflush ( stderr ) ; } if ( g . ind != 0 ) close ( g . ind ) ; if ( g . outd != 1 ) { if ( close ( g . outd ) ) bail ( ""write error on "" , g . outf ) ; g . outd = - 1 ; if ( g . ind != 0 ) { copymeta ( g . inf , g . outf ) ; if ( ! g . keep ) unlink ( g . inf ) ; } if ( g . decode && ( g . headis & 2 ) != 0 && g . stamp ) touch ( g . outf , g . stamp ) ; } RELEASE ( g . outf ) ; }
Fixed code:"," local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do {  <StartBug> if ( * try == NULL || strstr ( * try, "".."") || strstr ( * try, ""//"") || len + strlen ( * try ) >= sizeof ( g . inf ) ) { <EndBug> break ; } strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } <StartBug> if (strstr (next->d_name, "".."") || strstr (next->d_name, ""//"")) { <EndBug> continue ; } <StartBug> strcpy ( item , next -> d_name ) ; <EndBug> item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { <StartBug> strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] || strstr ( g . inf,"".."") || strstr ( g . inf, ""//"") ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } <EndBug> process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g .",1450,-56.37988126346756,-0.0388826767334259
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force && g . pipeout && g . decode != 2 && ! g . list ) ) { RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; if ( method != - 1 ) complain ( method < 0 ? ""%s is not compressed -- skipping"" : ""%s has unknown compression method -- skipping"" , g . inf ) ; return ; } if ( g . decode == 2 ) { if ( method == 8 ) infchk ( ) ; else { unlzw ( ) ; if ( g . list ) { g . in_tot -= 3 ; show_info ( method , 0 , g . out_tot , 0 ) ; } } RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } } if ( g . list ) { list_info ( ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( path == NULL || g . pipeout ) { g . outf = MALLOC ( strlen ( ""<stdout>"" ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; strcpy ( g . outf , ""<stdout>"" ) ; g . outd = 1 ; if ( ! g . decode && ! g . force && isatty ( g . outd ) ) bail ( ""trying to write compressed data to a terminal"" , "" (use -f to force)"" ) ; } else { <StartBug> char * to , * repl ; to = g . inf ; if ( g . decode && ( g . headis & 1 ) != 0 && g . hname != NULL ) {  to = g . hname ; len = strlen ( g . hname ) ; <EndBug> } <StartBug> repl = g . decode && strcmp ( to + len , "".tgz"" ) ? """" : "".tar"" ; g . outf = MALLOC ( len + ( g . decode ? strlen ( repl ) : strlen ( g . sufx ) ) + 1 ) ; <EndBug> if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; <StartBug> memcpy ( g . outf , to , len ) ; strcpy ( g . outf + len , g . decode ? repl : g . sufx ) ; <EndBug> g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY | ( g . force ? 0 : O_EXCL ) , 0600 ) ; if ( g . outd < 0 && errno == EEXIST && isatty ( 0 ) && g . verbosity ) { int ch , reply ; fprintf ( stderr , ""%s exists -- overwrite (y/n)? "" , g . outf ) ; fflush ( stderr ) ; reply = - 1 ; do { ch = getchar ( ) ; if ( reply < 0 && ch != ' ' && ch != '\\t' ) reply = ch == 'y' || ch == 'Y' ? 1 : 0 ; } while ( ch != EOF && ch != '\\n' && ch != '\\r' ) ; if ( reply == 1 ) g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY , 0600 ) ; } if ( g . outd < 0 && errno == EEXIST ) { complain ( ""%s exists -- skipping"" , g . outf ) ; RELEASE ( g . outf ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( g . outd < 0 ) bail ( ""write error on "" , g . outf ) ; } SET_BINARY_MODE ( g . outd ) ; RELEASE ( g . hname ) ; if ( g . verbosity > 1 ) fprintf ( stderr , ""%s to %s "" , g . inf , g . outf ) ; if ( g . decode ) { if ( method == 8 ) infchk ( ) ; else if ( method == 257 ) unlzw ( ) ; else cat ( ) ; } # ifndef NOTHREAD else if ( g . procs > 1 ) parallel_compress ( ) ; # endif else single_compress ( 0 ) ; if ( g . verbosity > 1 ) { putc ( '\\n' , stderr ) ; fflush ( stderr ) ; } if ( g . ind != 0 ) close ( g . ind ) ; if ( g . outd != 1 ) { if ( close ( g . outd ) ) bail ( ""write error on "" , g . outf ) ; g . outd = - 1 ; if ( g . ind != 0 ) { copymeta ( g . inf , g . outf ) ; if ( ! g . keep ) unlink ( g . inf ) ; } if ( g . decode && ( g . headis & 2 ) != 0 && g . stamp ) touch ( g . outf , g . stamp ) ; } RELEASE ( g . outf ) ; }
Fixed code:"," local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; char* absolutePath = realpath(g.inf, NULL); if ( lstat ( absolutePath , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( absolutePath ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force && g . pipeout && g . decode != 2 && !",1450,-12.43870648162013,-0.008578418263186297
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force && g . pipeout && g . decode != 2 && ! g . list ) ) { RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; if ( method != - 1 ) complain ( method < 0 ? ""%s is not compressed -- skipping"" : ""%s has unknown compression method -- skipping"" , g . inf ) ; return ; } if ( g . decode == 2 ) { if ( method == 8 ) infchk ( ) ; else { unlzw ( ) ; if ( g . list ) { g . in_tot -= 3 ; show_info ( method , 0 , g . out_tot , 0 ) ; } } RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } } if ( g . list ) { list_info ( ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( path == NULL || g . pipeout ) { g . outf = MALLOC ( strlen ( ""<stdout>"" ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; strcpy ( g . outf , ""<stdout>"" ) ; g . outd = 1 ; if ( ! g . decode && ! g . force && isatty ( g . outd ) ) bail ( ""trying to write compressed data to a terminal"" , "" (use -f to force)"" ) ; } else { <StartBug> char * to , * repl ; to = g . inf ; if ( g . decode && ( g . headis & 1 ) != 0 && g . hname != NULL ) {  to = g . hname ; len = strlen ( g . hname ) ; <EndBug> } <StartBug> repl = g . decode && strcmp ( to + len , "".tgz"" ) ? """" : "".tar"" ; g . outf = MALLOC ( len + ( g . decode ? strlen ( repl ) : strlen ( g . sufx ) ) + 1 ) ; <EndBug> if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; <StartBug> memcpy ( g . outf , to , len ) ; strcpy ( g . outf + len , g . decode ? repl : g . sufx ) ; <EndBug> g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY | ( g . force ? 0 : O_EXCL ) , 0600 ) ; if ( g . outd < 0 && errno == EEXIST && isatty ( 0 ) && g . verbosity ) { int ch , reply ; fprintf ( stderr , ""%s exists -- overwrite (y/n)? "" , g . outf ) ; fflush ( stderr ) ; reply = - 1 ; do { ch = getchar ( ) ; if ( reply < 0 && ch != ' ' && ch != '\\t' ) reply = ch == 'y' || ch == 'Y' ? 1 : 0 ; } while ( ch != EOF && ch != '\\n' && ch != '\\r' ) ; if ( reply == 1 ) g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY , 0600 ) ; } if ( g . outd < 0 && errno == EEXIST ) { complain ( ""%s exists -- skipping"" , g . outf ) ; RELEASE ( g . outf ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( g . outd < 0 ) bail ( ""write error on "" , g . outf ) ; } SET_BINARY_MODE ( g . outd ) ; RELEASE ( g . hname ) ; if ( g . verbosity > 1 ) fprintf ( stderr , ""%s to %s "" , g . inf , g . outf ) ; if ( g . decode ) { if ( method == 8 ) infchk ( ) ; else if ( method == 257 ) unlzw ( ) ; else cat ( ) ; } # ifndef NOTHREAD else if ( g . procs > 1 ) parallel_compress ( ) ; # endif else single_compress ( 0 ) ; if ( g . verbosity > 1 ) { putc ( '\\n' , stderr ) ; fflush ( stderr ) ; } if ( g . ind != 0 ) close ( g . ind ) ; if ( g . outd != 1 ) { if ( close ( g . outd ) ) bail ( ""write error on "" , g . outf ) ; g . outd = - 1 ; if ( g . ind != 0 ) { copymeta ( g . inf , g . outf ) ; if ( ! g . keep ) unlink ( g . inf ) ; } if ( g . decode && ( g . headis & 2 ) != 0 && g . stamp ) touch ( g . outf , g . stamp ) ; } RELEASE ( g . outf ) ; }
Fixed code:","

local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; <StartBug> char resolved_path[PATH_MAX + 1]; realpath(g.inf, resolved_path); if ( lstat ( resolved_path , & st ) ) { <EndBug> if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; <StartBug> realpath(g.inf, resolved_path); if ( lstat ( resolved_path , & st ) && errno == ENOENT ) { <EndBug> } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } <StartBug> realpath(g.inf, resolved_path); process ( resolved_path ) ; <EndBug> item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname =",1450,-16.5354410321355,-0.011403752435955516
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force && g . pipeout && g . decode != 2 && ! g . list ) ) { RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; if ( method != - 1 ) complain ( method < 0 ? ""%s is not compressed -- skipping"" : ""%s has unknown compression method -- skipping"" , g . inf ) ; return ; } if ( g . decode == 2 ) { if ( method == 8 ) infchk ( ) ; else { unlzw ( ) ; if ( g . list ) { g . in_tot -= 3 ; show_info ( method , 0 , g . out_tot , 0 ) ; } } RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } } if ( g . list ) { list_info ( ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( path == NULL || g . pipeout ) { g . outf = MALLOC ( strlen ( ""<stdout>"" ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; strcpy ( g . outf , ""<stdout>"" ) ; g . outd = 1 ; if ( ! g . decode && ! g . force && isatty ( g . outd ) ) bail ( ""trying to write compressed data to a terminal"" , "" (use -f to force)"" ) ; } else { <StartBug> char * to , * repl ; to = g . inf ; if ( g . decode && ( g . headis & 1 ) != 0 && g . hname != NULL ) {  to = g . hname ; len = strlen ( g . hname ) ; <EndBug> } <StartBug> repl = g . decode && strcmp ( to + len , "".tgz"" ) ? """" : "".tar"" ; g . outf = MALLOC ( len + ( g . decode ? strlen ( repl ) : strlen ( g . sufx ) ) + 1 ) ; <EndBug> if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; <StartBug> memcpy ( g . outf , to , len ) ; strcpy ( g . outf + len , g . decode ? repl : g . sufx ) ; <EndBug> g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY | ( g . force ? 0 : O_EXCL ) , 0600 ) ; if ( g . outd < 0 && errno == EEXIST && isatty ( 0 ) && g . verbosity ) { int ch , reply ; fprintf ( stderr , ""%s exists -- overwrite (y/n)? "" , g . outf ) ; fflush ( stderr ) ; reply = - 1 ; do { ch = getchar ( ) ; if ( reply < 0 && ch != ' ' && ch != '\\t' ) reply = ch == 'y' || ch == 'Y' ? 1 : 0 ; } while ( ch != EOF && ch != '\\n' && ch != '\\r' ) ; if ( reply == 1 ) g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY , 0600 ) ; } if ( g . outd < 0 && errno == EEXIST ) { complain ( ""%s exists -- skipping"" , g . outf ) ; RELEASE ( g . outf ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( g . outd < 0 ) bail ( ""write error on "" , g . outf ) ; } SET_BINARY_MODE ( g . outd ) ; RELEASE ( g . hname ) ; if ( g . verbosity > 1 ) fprintf ( stderr , ""%s to %s "" , g . inf , g . outf ) ; if ( g . decode ) { if ( method == 8 ) infchk ( ) ; else if ( method == 257 ) unlzw ( ) ; else cat ( ) ; } # ifndef NOTHREAD else if ( g . procs > 1 ) parallel_compress ( ) ; # endif else single_compress ( 0 ) ; if ( g . verbosity > 1 ) { putc ( '\\n' , stderr ) ; fflush ( stderr ) ; } if ( g . ind != 0 ) close ( g . ind ) ; if ( g . outd != 1 ) { if ( close ( g . outd ) ) bail ( ""write error on "" , g . outf ) ; g . outd = - 1 ; if ( g . ind != 0 ) { copymeta ( g . inf , g . outf ) ; if ( ! g . keep ) unlink ( g . inf ) ; } if ( g . decode && ( g . headis & 2 ) != 0 && g . stamp ) touch ( g . outf , g . stamp ) ; } RELEASE ( g . outf ) ; }
Fixed code:","

local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { <StartBug> char realpath[PATH_MAX]; realpath[0] = '\0'; strncpy(realpath, g.inf, PATH_MAX); strncat(realpath, item, PATH_MAX - strlen(realpath) - 1); <EndBug> process ( realpath ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force && g . pipeout && g . decode != 2 && ! g . list ) ) { RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind",1450,-20.2196800716186,-0.013944606945943863
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force && g . pipeout && g . decode != 2 && ! g . list ) ) { RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; if ( method != - 1 ) complain ( method < 0 ? ""%s is not compressed -- skipping"" : ""%s has unknown compression method -- skipping"" , g . inf ) ; return ; } if ( g . decode == 2 ) { if ( method == 8 ) infchk ( ) ; else { unlzw ( ) ; if ( g . list ) { g . in_tot -= 3 ; show_info ( method , 0 , g . out_tot , 0 ) ; } } RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } } if ( g . list ) { list_info ( ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( path == NULL || g . pipeout ) { g . outf = MALLOC ( strlen ( ""<stdout>"" ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; strcpy ( g . outf , ""<stdout>"" ) ; g . outd = 1 ; if ( ! g . decode && ! g . force && isatty ( g . outd ) ) bail ( ""trying to write compressed data to a terminal"" , "" (use -f to force)"" ) ; } else { <StartBug> char * to , * repl ; to = g . inf ; if ( g . decode && ( g . headis & 1 ) != 0 && g . hname != NULL ) {  to = g . hname ; len = strlen ( g . hname ) ; <EndBug> } <StartBug> repl = g . decode && strcmp ( to + len , "".tgz"" ) ? """" : "".tar"" ; g . outf = MALLOC ( len + ( g . decode ? strlen ( repl ) : strlen ( g . sufx ) ) + 1 ) ; <EndBug> if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; <StartBug> memcpy ( g . outf , to , len ) ; strcpy ( g . outf + len , g . decode ? repl : g . sufx ) ; <EndBug> g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY | ( g . force ? 0 : O_EXCL ) , 0600 ) ; if ( g . outd < 0 && errno == EEXIST && isatty ( 0 ) && g . verbosity ) { int ch , reply ; fprintf ( stderr , ""%s exists -- overwrite (y/n)? "" , g . outf ) ; fflush ( stderr ) ; reply = - 1 ; do { ch = getchar ( ) ; if ( reply < 0 && ch != ' ' && ch != '\\t' ) reply = ch == 'y' || ch == 'Y' ? 1 : 0 ; } while ( ch != EOF && ch != '\\n' && ch != '\\r' ) ; if ( reply == 1 ) g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY , 0600 ) ; } if ( g . outd < 0 && errno == EEXIST ) { complain ( ""%s exists -- skipping"" , g . outf ) ; RELEASE ( g . outf ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( g . outd < 0 ) bail ( ""write error on "" , g . outf ) ; } SET_BINARY_MODE ( g . outd ) ; RELEASE ( g . hname ) ; if ( g . verbosity > 1 ) fprintf ( stderr , ""%s to %s "" , g . inf , g . outf ) ; if ( g . decode ) { if ( method == 8 ) infchk ( ) ; else if ( method == 257 ) unlzw ( ) ; else cat ( ) ; } # ifndef NOTHREAD else if ( g . procs > 1 ) parallel_compress ( ) ; # endif else single_compress ( 0 ) ; if ( g . verbosity > 1 ) { putc ( '\\n' , stderr ) ; fflush ( stderr ) ; } if ( g . ind != 0 ) close ( g . ind ) ; if ( g . outd != 1 ) { if ( close ( g . outd ) ) bail ( ""write error on "" , g . outf ) ; g . outd = - 1 ; if ( g . ind != 0 ) { copymeta ( g . inf , g . outf ) ; if ( ! g . keep ) unlink ( g . inf ) ; } if ( g . decode && ( g . headis & 2 ) != 0 && g . stamp ) touch ( g . outf , g . stamp ) ; } RELEASE ( g . outf ) ; }
Fixed code:","
local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { <StartBug> char full_path[512]; snprintf(full_path, sizeof(full_path), ""%s%s"", g.inf, item); process(full_path); <EndBug> item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force && g . pipeout && g . decode != 2 && ! g . list ) ) { RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; if ( method != - 1 ) complain ( method < 0 ? ""%s is not compressed -- skipping"" : ""%",1450,-16.174198424800792,-0.011154619603310892
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force && g . pipeout && g . decode != 2 && ! g . list ) ) { RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; if ( method != - 1 ) complain ( method < 0 ? ""%s is not compressed -- skipping"" : ""%s has unknown compression method -- skipping"" , g . inf ) ; return ; } if ( g . decode == 2 ) { if ( method == 8 ) infchk ( ) ; else { unlzw ( ) ; if ( g . list ) { g . in_tot -= 3 ; show_info ( method , 0 , g . out_tot , 0 ) ; } } RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } } if ( g . list ) { list_info ( ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( path == NULL || g . pipeout ) { g . outf = MALLOC ( strlen ( ""<stdout>"" ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; strcpy ( g . outf , ""<stdout>"" ) ; g . outd = 1 ; if ( ! g . decode && ! g . force && isatty ( g . outd ) ) bail ( ""trying to write compressed data to a terminal"" , "" (use -f to force)"" ) ; } else { <StartBug> char * to , * repl ; to = g . inf ; if ( g . decode && ( g . headis & 1 ) != 0 && g . hname != NULL ) {  to = g . hname ; len = strlen ( g . hname ) ; <EndBug> } <StartBug> repl = g . decode && strcmp ( to + len , "".tgz"" ) ? """" : "".tar"" ; g . outf = MALLOC ( len + ( g . decode ? strlen ( repl ) : strlen ( g . sufx ) ) + 1 ) ; <EndBug> if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; <StartBug> memcpy ( g . outf , to , len ) ; strcpy ( g . outf + len , g . decode ? repl : g . sufx ) ; <EndBug> g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY | ( g . force ? 0 : O_EXCL ) , 0600 ) ; if ( g . outd < 0 && errno == EEXIST && isatty ( 0 ) && g . verbosity ) { int ch , reply ; fprintf ( stderr , ""%s exists -- overwrite (y/n)? "" , g . outf ) ; fflush ( stderr ) ; reply = - 1 ; do { ch = getchar ( ) ; if ( reply < 0 && ch != ' ' && ch != '\\t' ) reply = ch == 'y' || ch == 'Y' ? 1 : 0 ; } while ( ch != EOF && ch != '\\n' && ch != '\\r' ) ; if ( reply == 1 ) g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY , 0600 ) ; } if ( g . outd < 0 && errno == EEXIST ) { complain ( ""%s exists -- skipping"" , g . outf ) ; RELEASE ( g . outf ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( g . outd < 0 ) bail ( ""write error on "" , g . outf ) ; } SET_BINARY_MODE ( g . outd ) ; RELEASE ( g . hname ) ; if ( g . verbosity > 1 ) fprintf ( stderr , ""%s to %s "" , g . inf , g . outf ) ; if ( g . decode ) { if ( method == 8 ) infchk ( ) ; else if ( method == 257 ) unlzw ( ) ; else cat ( ) ; } # ifndef NOTHREAD else if ( g . procs > 1 ) parallel_compress ( ) ; # endif else single_compress ( 0 ) ; if ( g . verbosity > 1 ) { putc ( '\\n' , stderr ) ; fflush ( stderr ) ; } if ( g . ind != 0 ) close ( g . ind ) ; if ( g . outd != 1 ) { if ( close ( g . outd ) ) bail ( ""write error on "" , g . outf ) ; g . outd = - 1 ; if ( g . ind != 0 ) { copymeta ( g . inf , g . outf ) ; if ( ! g . keep ) unlink ( g . inf ) ; } if ( g . decode && ( g . headis & 2 ) != 0 && g . stamp ) touch ( g . outf , g . stamp ) ; } RELEASE ( g . outf ) ; }
Fixed code:"," local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { <StartBug> char absolute_path [ FILENAME_MAX ] ; realpath ( path , absolute_path ) ; if ( lstat ( absolute_path , & st ) ) <EndBug> { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( <StartBug> lstat ( absolute_path , & st ) <EndBug> && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } <StartBug>  char absolute_path [ FILENAME_MAX ] ; realpath ( g . inf , absolute_path ) ; strncpy ( absolute_path + strlen ( absolute_path ) , next -> d_name , 256 ) ; strcpy ( item , absolute_path ) ; <EndBug> item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { <StartBug> strncpy ( g . inf , item , sizeof ( g . inf ) - 1 ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } <EndBug> process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method",1450,-53.72974660401675,-0.03705499765794259
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force && g . pipeout && g . decode != 2 && ! g . list ) ) { RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; if ( method != - 1 ) complain ( method < 0 ? ""%s is not compressed -- skipping"" : ""%s has unknown compression method -- skipping"" , g . inf ) ; return ; } if ( g . decode == 2 ) { if ( method == 8 ) infchk ( ) ; else { unlzw ( ) ; if ( g . list ) { g . in_tot -= 3 ; show_info ( method , 0 , g . out_tot , 0 ) ; } } RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } } if ( g . list ) { list_info ( ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( path == NULL || g . pipeout ) { g . outf = MALLOC ( strlen ( ""<stdout>"" ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; strcpy ( g . outf , ""<stdout>"" ) ; g . outd = 1 ; if ( ! g . decode && ! g . force && isatty ( g . outd ) ) bail ( ""trying to write compressed data to a terminal"" , "" (use -f to force)"" ) ; } else { <StartBug> char * to , * repl ; to = g . inf ; if ( g . decode && ( g . headis & 1 ) != 0 && g . hname != NULL ) {  to = g . hname ; len = strlen ( g . hname ) ; <EndBug> } <StartBug> repl = g . decode && strcmp ( to + len , "".tgz"" ) ? """" : "".tar"" ; g . outf = MALLOC ( len + ( g . decode ? strlen ( repl ) : strlen ( g . sufx ) ) + 1 ) ; <EndBug> if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; <StartBug> memcpy ( g . outf , to , len ) ; strcpy ( g . outf + len , g . decode ? repl : g . sufx ) ; <EndBug> g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY | ( g . force ? 0 : O_EXCL ) , 0600 ) ; if ( g . outd < 0 && errno == EEXIST && isatty ( 0 ) && g . verbosity ) { int ch , reply ; fprintf ( stderr , ""%s exists -- overwrite (y/n)? "" , g . outf ) ; fflush ( stderr ) ; reply = - 1 ; do { ch = getchar ( ) ; if ( reply < 0 && ch != ' ' && ch != '\\t' ) reply = ch == 'y' || ch == 'Y' ? 1 : 0 ; } while ( ch != EOF && ch != '\\n' && ch != '\\r' ) ; if ( reply == 1 ) g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY , 0600 ) ; } if ( g . outd < 0 && errno == EEXIST ) { complain ( ""%s exists -- skipping"" , g . outf ) ; RELEASE ( g . outf ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( g . outd < 0 ) bail ( ""write error on "" , g . outf ) ; } SET_BINARY_MODE ( g . outd ) ; RELEASE ( g . hname ) ; if ( g . verbosity > 1 ) fprintf ( stderr , ""%s to %s "" , g . inf , g . outf ) ; if ( g . decode ) { if ( method == 8 ) infchk ( ) ; else if ( method == 257 ) unlzw ( ) ; else cat ( ) ; } # ifndef NOTHREAD else if ( g . procs > 1 ) parallel_compress ( ) ; # endif else single_compress ( 0 ) ; if ( g . verbosity > 1 ) { putc ( '\\n' , stderr ) ; fflush ( stderr ) ; } if ( g . ind != 0 ) close ( g . ind ) ; if ( g . outd != 1 ) { if ( close ( g . outd ) ) bail ( ""write error on "" , g . outf ) ; g . outd = - 1 ; if ( g . ind != 0 ) { copymeta ( g . inf , g . outf ) ; if ( ! g . keep ) unlink ( g . inf ) ; } if ( g . decode && ( g . headis & 2 ) != 0 && g . stamp ) touch ( g . outf , g . stamp ) ; } RELEASE ( g . outf ) ; }
Fixed code:"," local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; char dirName [ 4096 ] ; realpath ( g . inf , dirName ) ; here = opendir ( dirName ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { <StartBug> strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } char dirName2 [ 4096 ] ; realpath ( g . inf , dirName2 ) ; process ( dirName2 ) ; <EndBug> item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ;",1450,-27.797282884525796,-0.019170539920362616
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force && g . pipeout && g . decode != 2 && ! g . list ) ) { RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; if ( method != - 1 ) complain ( method < 0 ? ""%s is not compressed -- skipping"" : ""%s has unknown compression method -- skipping"" , g . inf ) ; return ; } if ( g . decode == 2 ) { if ( method == 8 ) infchk ( ) ; else { unlzw ( ) ; if ( g . list ) { g . in_tot -= 3 ; show_info ( method , 0 , g . out_tot , 0 ) ; } } RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } } if ( g . list ) { list_info ( ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( path == NULL || g . pipeout ) { g . outf = MALLOC ( strlen ( ""<stdout>"" ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; strcpy ( g . outf , ""<stdout>"" ) ; g . outd = 1 ; if ( ! g . decode && ! g . force && isatty ( g . outd ) ) bail ( ""trying to write compressed data to a terminal"" , "" (use -f to force)"" ) ; } else { <StartBug> char * to , * repl ; to = g . inf ; if ( g . decode && ( g . headis & 1 ) != 0 && g . hname != NULL ) {  to = g . hname ; len = strlen ( g . hname ) ; <EndBug> } <StartBug> repl = g . decode && strcmp ( to + len , "".tgz"" ) ? """" : "".tar"" ; g . outf = MALLOC ( len + ( g . decode ? strlen ( repl ) : strlen ( g . sufx ) ) + 1 ) ; <EndBug> if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; <StartBug> memcpy ( g . outf , to , len ) ; strcpy ( g . outf + len , g . decode ? repl : g . sufx ) ; <EndBug> g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY | ( g . force ? 0 : O_EXCL ) , 0600 ) ; if ( g . outd < 0 && errno == EEXIST && isatty ( 0 ) && g . verbosity ) { int ch , reply ; fprintf ( stderr , ""%s exists -- overwrite (y/n)? "" , g . outf ) ; fflush ( stderr ) ; reply = - 1 ; do { ch = getchar ( ) ; if ( reply < 0 && ch != ' ' && ch != '\\t' ) reply = ch == 'y' || ch == 'Y' ? 1 : 0 ; } while ( ch != EOF && ch != '\\n' && ch != '\\r' ) ; if ( reply == 1 ) g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY , 0600 ) ; } if ( g . outd < 0 && errno == EEXIST ) { complain ( ""%s exists -- skipping"" , g . outf ) ; RELEASE ( g . outf ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( g . outd < 0 ) bail ( ""write error on "" , g . outf ) ; } SET_BINARY_MODE ( g . outd ) ; RELEASE ( g . hname ) ; if ( g . verbosity > 1 ) fprintf ( stderr , ""%s to %s "" , g . inf , g . outf ) ; if ( g . decode ) { if ( method == 8 ) infchk ( ) ; else if ( method == 257 ) unlzw ( ) ; else cat ( ) ; } # ifndef NOTHREAD else if ( g . procs > 1 ) parallel_compress ( ) ; # endif else single_compress ( 0 ) ; if ( g . verbosity > 1 ) { putc ( '\\n' , stderr ) ; fflush ( stderr ) ; } if ( g . ind != 0 ) close ( g . ind ) ; if ( g . outd != 1 ) { if ( close ( g . outd ) ) bail ( ""write error on "" , g . outf ) ; g . outd = - 1 ; if ( g . ind != 0 ) { copymeta ( g . inf , g . outf ) ; if ( ! g . keep ) unlink ( g . inf ) ; } if ( g . decode && ( g . headis & 2 ) != 0 && g . stamp ) touch ( g . outf , g . stamp ) ; } RELEASE ( g . outf ) ; }
Fixed code:","

local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { 
if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } 

<StartBug> //Added to fix vulnerability
char canonical_path[PATH_MAX + 1];
realpath(g.inf, canonical_path);
if (strncmp(canonical_path, g.basedir, strlen(g.basedir)) != 0) {
  complain(""Path traversal attempt detected: %s -- skipping"", g.inf);
  return;
}
<EndBug>

if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; 

<StartBug> //Added to fix vulnerability
char canonical_path[PATH_MAX + 1];
realpath(g.inf, canonical_path);
if (strncmp(canonical_path, g.basedir, strlen(g.basedir)) != 0) {
  complain(""Path traversal attempt detected: %s -- skipping"", g.inf);
  continue;
}
<EndBug>

if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 )",1450,-62.87104002092168,-0.043359337945463226
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force && g . pipeout && g . decode != 2 && ! g . list ) ) { RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; if ( method != - 1 ) complain ( method < 0 ? ""%s is not compressed -- skipping"" : ""%s has unknown compression method -- skipping"" , g . inf ) ; return ; } if ( g . decode == 2 ) { if ( method == 8 ) infchk ( ) ; else { unlzw ( ) ; if ( g . list ) { g . in_tot -= 3 ; show_info ( method , 0 , g . out_tot , 0 ) ; } } RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } } if ( g . list ) { list_info ( ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( path == NULL || g . pipeout ) { g . outf = MALLOC ( strlen ( ""<stdout>"" ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; strcpy ( g . outf , ""<stdout>"" ) ; g . outd = 1 ; if ( ! g . decode && ! g . force && isatty ( g . outd ) ) bail ( ""trying to write compressed data to a terminal"" , "" (use -f to force)"" ) ; } else { <StartBug> char * to , * repl ; to = g . inf ; if ( g . decode && ( g . headis & 1 ) != 0 && g . hname != NULL ) {  to = g . hname ; len = strlen ( g . hname ) ; <EndBug> } <StartBug> repl = g . decode && strcmp ( to + len , "".tgz"" ) ? """" : "".tar"" ; g . outf = MALLOC ( len + ( g . decode ? strlen ( repl ) : strlen ( g . sufx ) ) + 1 ) ; <EndBug> if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; <StartBug> memcpy ( g . outf , to , len ) ; strcpy ( g . outf + len , g . decode ? repl : g . sufx ) ; <EndBug> g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY | ( g . force ? 0 : O_EXCL ) , 0600 ) ; if ( g . outd < 0 && errno == EEXIST && isatty ( 0 ) && g . verbosity ) { int ch , reply ; fprintf ( stderr , ""%s exists -- overwrite (y/n)? "" , g . outf ) ; fflush ( stderr ) ; reply = - 1 ; do { ch = getchar ( ) ; if ( reply < 0 && ch != ' ' && ch != '\\t' ) reply = ch == 'y' || ch == 'Y' ? 1 : 0 ; } while ( ch != EOF && ch != '\\n' && ch != '\\r' ) ; if ( reply == 1 ) g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY , 0600 ) ; } if ( g . outd < 0 && errno == EEXIST ) { complain ( ""%s exists -- skipping"" , g . outf ) ; RELEASE ( g . outf ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( g . outd < 0 ) bail ( ""write error on "" , g . outf ) ; } SET_BINARY_MODE ( g . outd ) ; RELEASE ( g . hname ) ; if ( g . verbosity > 1 ) fprintf ( stderr , ""%s to %s "" , g . inf , g . outf ) ; if ( g . decode ) { if ( method == 8 ) infchk ( ) ; else if ( method == 257 ) unlzw ( ) ; else cat ( ) ; } # ifndef NOTHREAD else if ( g . procs > 1 ) parallel_compress ( ) ; # endif else single_compress ( 0 ) ; if ( g . verbosity > 1 ) { putc ( '\\n' , stderr ) ; fflush ( stderr ) ; } if ( g . ind != 0 ) close ( g . ind ) ; if ( g . outd != 1 ) { if ( close ( g . outd ) ) bail ( ""write error on "" , g . outf ) ; g . outd = - 1 ; if ( g . ind != 0 ) { copymeta ( g . inf , g . outf ) ; if ( ! g . keep ) unlink ( g . inf ) ; } if ( g . decode && ( g . headis & 2 ) != 0 && g . stamp ) touch ( g . outf , g . stamp ) ; } RELEASE ( g . outf ) ; }
Fixed code:"," local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { <StartBug> char tmpPath[sizeof(g.inf)] = {0}; strncpy (tmpPath, g.inf, sizeof(g.inf));//prevent path traversal <EndBug> <StartBug> strncpy ( tmpPath + ( base - g . inf ) , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( tmpPath [ sizeof ( g . inf ) - 1 ] ) { strcpy ( tmpPath + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , tmpPath ) ; } <EndBug> process ( tmpPath ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in",1450,-40.298946305015306,-0.02779237676207952
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force && g . pipeout && g . decode != 2 && ! g . list ) ) { RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; if ( method != - 1 ) complain ( method < 0 ? ""%s is not compressed -- skipping"" : ""%s has unknown compression method -- skipping"" , g . inf ) ; return ; } if ( g . decode == 2 ) { if ( method == 8 ) infchk ( ) ; else { unlzw ( ) ; if ( g . list ) { g . in_tot -= 3 ; show_info ( method , 0 , g . out_tot , 0 ) ; } } RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } } if ( g . list ) { list_info ( ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( path == NULL || g . pipeout ) { g . outf = MALLOC ( strlen ( ""<stdout>"" ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; strcpy ( g . outf , ""<stdout>"" ) ; g . outd = 1 ; if ( ! g . decode && ! g . force && isatty ( g . outd ) ) bail ( ""trying to write compressed data to a terminal"" , "" (use -f to force)"" ) ; } else { <StartBug> char * to , * repl ; to = g . inf ; if ( g . decode && ( g . headis & 1 ) != 0 && g . hname != NULL ) {  to = g . hname ; len = strlen ( g . hname ) ; <EndBug> } <StartBug> repl = g . decode && strcmp ( to + len , "".tgz"" ) ? """" : "".tar"" ; g . outf = MALLOC ( len + ( g . decode ? strlen ( repl ) : strlen ( g . sufx ) ) + 1 ) ; <EndBug> if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; <StartBug> memcpy ( g . outf , to , len ) ; strcpy ( g . outf + len , g . decode ? repl : g . sufx ) ; <EndBug> g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY | ( g . force ? 0 : O_EXCL ) , 0600 ) ; if ( g . outd < 0 && errno == EEXIST && isatty ( 0 ) && g . verbosity ) { int ch , reply ; fprintf ( stderr , ""%s exists -- overwrite (y/n)? "" , g . outf ) ; fflush ( stderr ) ; reply = - 1 ; do { ch = getchar ( ) ; if ( reply < 0 && ch != ' ' && ch != '\\t' ) reply = ch == 'y' || ch == 'Y' ? 1 : 0 ; } while ( ch != EOF && ch != '\\n' && ch != '\\r' ) ; if ( reply == 1 ) g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY , 0600 ) ; } if ( g . outd < 0 && errno == EEXIST ) { complain ( ""%s exists -- skipping"" , g . outf ) ; RELEASE ( g . outf ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( g . outd < 0 ) bail ( ""write error on "" , g . outf ) ; } SET_BINARY_MODE ( g . outd ) ; RELEASE ( g . hname ) ; if ( g . verbosity > 1 ) fprintf ( stderr , ""%s to %s "" , g . inf , g . outf ) ; if ( g . decode ) { if ( method == 8 ) infchk ( ) ; else if ( method == 257 ) unlzw ( ) ; else cat ( ) ; } # ifndef NOTHREAD else if ( g . procs > 1 ) parallel_compress ( ) ; # endif else single_compress ( 0 ) ; if ( g . verbosity > 1 ) { putc ( '\\n' , stderr ) ; fflush ( stderr ) ; } if ( g . ind != 0 ) close ( g . ind ) ; if ( g . outd != 1 ) { if ( close ( g . outd ) ) bail ( ""write error on "" , g . outf ) ; g . outd = - 1 ; if ( g . ind != 0 ) { copymeta ( g . inf , g . outf ) ; if ( ! g . keep ) unlink ( g . inf ) ; } if ( g . decode && ( g . headis & 2 ) != 0 && g . stamp ) touch ( g . outf , g . stamp ) ; } RELEASE ( g . outf ) ; }
Fixed code:","
local void process ( char * path ) {
 int method = - 1 ;
 size_t len ;
 struct stat st ;
 static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ;
 if ( path == NULL ) {
  strcpy ( g . inf , ""<stdin>"" ) ;
  g . ind = 0 ;
  g . name = NULL ;
  g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ;
  len = 0 ;
 } else {
  if ( path != g . inf ) {
   strncpy ( g . inf , path , sizeof ( g . inf ) ) ;
   if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ;
  }
  len = strlen ( g . inf ) ;
  if ( lstat ( g . inf , & st ) ) {
   if ( errno == ENOENT && ( g . list || g . decode ) ) {
    char * * try = sufs ;
    do {
     if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ;
     strcpy ( g . inf + len , * try ++ ) ;
     errno = 0 ;
    } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ;
   }
# ifdef EOVERFLOW
   if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ;
# endif
   if ( errno ) {
    g . inf [ len ] = 0 ;
    complain ( ""%s does not exist -- skipping"" , g . inf ) ;
    return ;
   }
   len = strlen ( g . inf ) ;
  }
  if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) {
   complain ( ""%s is a special file or device -- skipping"" , g . inf ) ;
   return ;
  }
  if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) {
   complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ;
   return ;
  }
  if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) {
   complain ( ""%s is a directory -- skipping"" , g . inf ) ;
   return ;
  }
  if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) {
   char * roll , * item , * cut , * base , * bigger ;
   size_t len , hold ;
   DIR * here ;
   struct dirent * next ;
   here = opendir ( g . inf ) ;
   if ( here == NULL ) return ;
   hold = 512 ;
   roll = MALLOC ( hold ) ;
   if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ;
   * roll = 0 ;
   item = roll ;
   while ( ( next = readdir ( here ) ) != NULL ) {
    if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ;
    len = strlen ( next -> d_name ) + 1 ;
    if ( item + len + 1 > roll + hold ) {
     do {
      hold <<= 1 ;
     } while ( item + len + 1 > roll + hold ) ;
     bigger = REALLOC ( roll , hold ) ;
     if ( bigger == NULL ) {
      FREE ( roll ) ;
      bail ( ""not enough memory"" , """" ) ;
     }
     item = bigger + ( item - roll ) ;
     roll = bigger ;
    }
    strcpy ( item , next -> d_name ) ;
    item += len ;
    * item = 0 ;
   }
   closedir ( here ) ;
   cut = base = g . inf + strlen ( g . inf ) ;
   if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) {
    if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ;
    * base ++ = '/' ;
   }
   item = roll ;
   while ( * item ) {
    strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ;
    if ( g . inf [ sizeof ( g . inf ) - 1 ] ) {
     strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ;
     bail ( ""path too long: "" , g . inf ) ;
    }
    char dir[2048];
    realpath(g.inf, dir);
    process ( dir ) ;
    item += strlen ( item ) + 1 ;
   }
   * cut = 0 ;
   FREE ( roll ) ;
   return ;
  }
  if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) {
   complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ;
   return ;
  }
  if ( g . decode == 1 && ! g . pipeout && ! g . list ) {
   int",1450,-23.931806593261413,-0.01650469420224925
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force && g . pipeout && g . decode != 2 && ! g . list ) ) { RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; if ( method != - 1 ) complain ( method < 0 ? ""%s is not compressed -- skipping"" : ""%s has unknown compression method -- skipping"" , g . inf ) ; return ; } if ( g . decode == 2 ) { if ( method == 8 ) infchk ( ) ; else { unlzw ( ) ; if ( g . list ) { g . in_tot -= 3 ; show_info ( method , 0 , g . out_tot , 0 ) ; } } RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } } if ( g . list ) { list_info ( ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( path == NULL || g . pipeout ) { g . outf = MALLOC ( strlen ( ""<stdout>"" ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; strcpy ( g . outf , ""<stdout>"" ) ; g . outd = 1 ; if ( ! g . decode && ! g . force && isatty ( g . outd ) ) bail ( ""trying to write compressed data to a terminal"" , "" (use -f to force)"" ) ; } else { <StartBug> char * to , * repl ; to = g . inf ; if ( g . decode && ( g . headis & 1 ) != 0 && g . hname != NULL ) {  to = g . hname ; len = strlen ( g . hname ) ; <EndBug> } <StartBug> repl = g . decode && strcmp ( to + len , "".tgz"" ) ? """" : "".tar"" ; g . outf = MALLOC ( len + ( g . decode ? strlen ( repl ) : strlen ( g . sufx ) ) + 1 ) ; <EndBug> if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; <StartBug> memcpy ( g . outf , to , len ) ; strcpy ( g . outf + len , g . decode ? repl : g . sufx ) ; <EndBug> g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY | ( g . force ? 0 : O_EXCL ) , 0600 ) ; if ( g . outd < 0 && errno == EEXIST && isatty ( 0 ) && g . verbosity ) { int ch , reply ; fprintf ( stderr , ""%s exists -- overwrite (y/n)? "" , g . outf ) ; fflush ( stderr ) ; reply = - 1 ; do { ch = getchar ( ) ; if ( reply < 0 && ch != ' ' && ch != '\\t' ) reply = ch == 'y' || ch == 'Y' ? 1 : 0 ; } while ( ch != EOF && ch != '\\n' && ch != '\\r' ) ; if ( reply == 1 ) g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY , 0600 ) ; } if ( g . outd < 0 && errno == EEXIST ) { complain ( ""%s exists -- skipping"" , g . outf ) ; RELEASE ( g . outf ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( g . outd < 0 ) bail ( ""write error on "" , g . outf ) ; } SET_BINARY_MODE ( g . outd ) ; RELEASE ( g . hname ) ; if ( g . verbosity > 1 ) fprintf ( stderr , ""%s to %s "" , g . inf , g . outf ) ; if ( g . decode ) { if ( method == 8 ) infchk ( ) ; else if ( method == 257 ) unlzw ( ) ; else cat ( ) ; } # ifndef NOTHREAD else if ( g . procs > 1 ) parallel_compress ( ) ; # endif else single_compress ( 0 ) ; if ( g . verbosity > 1 ) { putc ( '\\n' , stderr ) ; fflush ( stderr ) ; } if ( g . ind != 0 ) close ( g . ind ) ; if ( g . outd != 1 ) { if ( close ( g . outd ) ) bail ( ""write error on "" , g . outf ) ; g . outd = - 1 ; if ( g . ind != 0 ) { copymeta ( g . inf , g . outf ) ; if ( ! g . keep ) unlink ( g . inf ) ; } if ( g . decode && ( g . headis & 2 ) != 0 && g . stamp ) touch ( g . outf , g . stamp ) ; } RELEASE ( g . outf ) ; }
Fixed code:"," 
local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { <StartBug> char filepath [1024]; <EndBug> <StartBug> if (snprintf(filepath, sizeof(filepath), ""%s%s"", g.inf, item) >= sizeof(filepath)) <EndBug> { <StartBug> strncpy ( g . inf , filepath , sizeof ( g . inf ) ) <EndBug> if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } <StartBug> else { <EndBug> process ( g . inf ) ; <StartBug> } <EndBug> item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind",1450,-43.651260392366936,-0.0301043175119772
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force && g . pipeout && g . decode != 2 && ! g . list ) ) { RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; if ( method != - 1 ) complain ( method < 0 ? ""%s is not compressed -- skipping"" : ""%s has unknown compression method -- skipping"" , g . inf ) ; return ; } if ( g . decode == 2 ) { if ( method == 8 ) infchk ( ) ; else { unlzw ( ) ; if ( g . list ) { g . in_tot -= 3 ; show_info ( method , 0 , g . out_tot , 0 ) ; } } RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } } if ( g . list ) { list_info ( ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( path == NULL || g . pipeout ) { g . outf = MALLOC ( strlen ( ""<stdout>"" ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; strcpy ( g . outf , ""<stdout>"" ) ; g . outd = 1 ; if ( ! g . decode && ! g . force && isatty ( g . outd ) ) bail ( ""trying to write compressed data to a terminal"" , "" (use -f to force)"" ) ; } else { <StartBug> char * to , * repl ; to = g . inf ; if ( g . decode && ( g . headis & 1 ) != 0 && g . hname != NULL ) {  to = g . hname ; len = strlen ( g . hname ) ; <EndBug> } <StartBug> repl = g . decode && strcmp ( to + len , "".tgz"" ) ? """" : "".tar"" ; g . outf = MALLOC ( len + ( g . decode ? strlen ( repl ) : strlen ( g . sufx ) ) + 1 ) ; <EndBug> if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; <StartBug> memcpy ( g . outf , to , len ) ; strcpy ( g . outf + len , g . decode ? repl : g . sufx ) ; <EndBug> g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY | ( g . force ? 0 : O_EXCL ) , 0600 ) ; if ( g . outd < 0 && errno == EEXIST && isatty ( 0 ) && g . verbosity ) { int ch , reply ; fprintf ( stderr , ""%s exists -- overwrite (y/n)? "" , g . outf ) ; fflush ( stderr ) ; reply = - 1 ; do { ch = getchar ( ) ; if ( reply < 0 && ch != ' ' && ch != '\\t' ) reply = ch == 'y' || ch == 'Y' ? 1 : 0 ; } while ( ch != EOF && ch != '\\n' && ch != '\\r' ) ; if ( reply == 1 ) g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY , 0600 ) ; } if ( g . outd < 0 && errno == EEXIST ) { complain ( ""%s exists -- skipping"" , g . outf ) ; RELEASE ( g . outf ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( g . outd < 0 ) bail ( ""write error on "" , g . outf ) ; } SET_BINARY_MODE ( g . outd ) ; RELEASE ( g . hname ) ; if ( g . verbosity > 1 ) fprintf ( stderr , ""%s to %s "" , g . inf , g . outf ) ; if ( g . decode ) { if ( method == 8 ) infchk ( ) ; else if ( method == 257 ) unlzw ( ) ; else cat ( ) ; } # ifndef NOTHREAD else if ( g . procs > 1 ) parallel_compress ( ) ; # endif else single_compress ( 0 ) ; if ( g . verbosity > 1 ) { putc ( '\\n' , stderr ) ; fflush ( stderr ) ; } if ( g . ind != 0 ) close ( g . ind ) ; if ( g . outd != 1 ) { if ( close ( g . outd ) ) bail ( ""write error on "" , g . outf ) ; g . outd = - 1 ; if ( g . ind != 0 ) { copymeta ( g . inf , g . outf ) ; if ( ! g . keep ) unlink ( g . inf ) ; } if ( g . decode && ( g . headis & 2 ) != 0 && g . stamp ) touch ( g . outf , g . stamp ) ; } RELEASE ( g . outf ) ; }
Fixed code:","

local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { <StartBug> char absPath[PATH_MAX] = {0}; char* resolvedPath = realpath(g.inf, absPath); strncpy ( base , item , sizeof ( resolvedPath ) - ( base - g.inf) ) ; <EndBug> if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257",1450,-32.68696923455935,-0.02254273740314438
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force && g . pipeout && g . decode != 2 && ! g . list ) ) { RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; if ( method != - 1 ) complain ( method < 0 ? ""%s is not compressed -- skipping"" : ""%s has unknown compression method -- skipping"" , g . inf ) ; return ; } if ( g . decode == 2 ) { if ( method == 8 ) infchk ( ) ; else { unlzw ( ) ; if ( g . list ) { g . in_tot -= 3 ; show_info ( method , 0 , g . out_tot , 0 ) ; } } RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } } if ( g . list ) { list_info ( ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( path == NULL || g . pipeout ) { g . outf = MALLOC ( strlen ( ""<stdout>"" ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; strcpy ( g . outf , ""<stdout>"" ) ; g . outd = 1 ; if ( ! g . decode && ! g . force && isatty ( g . outd ) ) bail ( ""trying to write compressed data to a terminal"" , "" (use -f to force)"" ) ; } else { <StartBug> char * to , * repl ; to = g . inf ; if ( g . decode && ( g . headis & 1 ) != 0 && g . hname != NULL ) {  to = g . hname ; len = strlen ( g . hname ) ; <EndBug> } <StartBug> repl = g . decode && strcmp ( to + len , "".tgz"" ) ? """" : "".tar"" ; g . outf = MALLOC ( len + ( g . decode ? strlen ( repl ) : strlen ( g . sufx ) ) + 1 ) ; <EndBug> if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; <StartBug> memcpy ( g . outf , to , len ) ; strcpy ( g . outf + len , g . decode ? repl : g . sufx ) ; <EndBug> g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY | ( g . force ? 0 : O_EXCL ) , 0600 ) ; if ( g . outd < 0 && errno == EEXIST && isatty ( 0 ) && g . verbosity ) { int ch , reply ; fprintf ( stderr , ""%s exists -- overwrite (y/n)? "" , g . outf ) ; fflush ( stderr ) ; reply = - 1 ; do { ch = getchar ( ) ; if ( reply < 0 && ch != ' ' && ch != '\\t' ) reply = ch == 'y' || ch == 'Y' ? 1 : 0 ; } while ( ch != EOF && ch != '\\n' && ch != '\\r' ) ; if ( reply == 1 ) g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY , 0600 ) ; } if ( g . outd < 0 && errno == EEXIST ) { complain ( ""%s exists -- skipping"" , g . outf ) ; RELEASE ( g . outf ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( g . outd < 0 ) bail ( ""write error on "" , g . outf ) ; } SET_BINARY_MODE ( g . outd ) ; RELEASE ( g . hname ) ; if ( g . verbosity > 1 ) fprintf ( stderr , ""%s to %s "" , g . inf , g . outf ) ; if ( g . decode ) { if ( method == 8 ) infchk ( ) ; else if ( method == 257 ) unlzw ( ) ; else cat ( ) ; } # ifndef NOTHREAD else if ( g . procs > 1 ) parallel_compress ( ) ; # endif else single_compress ( 0 ) ; if ( g . verbosity > 1 ) { putc ( '\\n' , stderr ) ; fflush ( stderr ) ; } if ( g . ind != 0 ) close ( g . ind ) ; if ( g . outd != 1 ) { if ( close ( g . outd ) ) bail ( ""write error on "" , g . outf ) ; g . outd = - 1 ; if ( g . ind != 0 ) { copymeta ( g . inf , g . outf ) ; if ( ! g . keep ) unlink ( g . inf ) ; } if ( g . decode && ( g . headis & 2 ) != 0 && g . stamp ) touch ( g . outf , g . stamp ) ; } RELEASE ( g . outf ) ; }
Fixed code:"," 

local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } <StartBug> if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { /* Do not allow traversal of directories */ complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } <EndBug> if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force && g . pipeout && g . decode != 2 && ! g . list ) ) { RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; if ( method != - 1 ) complain ( method < 0 ? ""%s is not compressed -- skipping"" : ""%s has unknown compression method -- skipping"" , g . inf ) ; return ; } if ( g . decode == 2 ) { if ( method == 8 ) infchk ( ) ; else { unlzw ( ) ; if ( g . list ) { g . in_tot -= 3 ; show_info ( method , 0 , g . out_tot , 0 ) ; } } RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } } if ( g . list ) { list_info ( ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( path == NULL || g . pipeout ) { g . outf = MALLOC ( strlen ( ""<stdout>"" ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; strcpy ( g . outf , ""<stdout>"" ) ; g . outd = 1 ; if ( ! g . decode && ! g . force && isatty ( g . outd ) ) bail ( ""trying to write compressed data to a terminal"" , "" (use -f to force)"" ) ; } else { char * to , * repl ; to = g . inf ; if ( g . decode && ( g . headis & 1 ) != 0 && g . hname != NULL ) {  to = g . hname ; len = strlen ( g . hname ) ; } <StartBug> repl = g . decode && strcmp ( to + len , "".tgz"" ) ? """" : "".tar"" ; g . outf = MALLOC ( len + ( g . decode ? strlen ( repl ) : strlen ( g . sufx ) ) + 1 ) ; <EndBug> if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; <StartBug> memcpy ( g . outf , to , len ) ; strcpy ( g . outf + len , g . decode ? repl : g . sufx ) ; <EndBug> g . outd = open",1450,-26.930428798164847,-0.018572709515975755
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force && g . pipeout && g . decode != 2 && ! g . list ) ) { RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; if ( method != - 1 ) complain ( method < 0 ? ""%s is not compressed -- skipping"" : ""%s has unknown compression method -- skipping"" , g . inf ) ; return ; } if ( g . decode == 2 ) { if ( method == 8 ) infchk ( ) ; else { unlzw ( ) ; if ( g . list ) { g . in_tot -= 3 ; show_info ( method , 0 , g . out_tot , 0 ) ; } } RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } } if ( g . list ) { list_info ( ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( path == NULL || g . pipeout ) { g . outf = MALLOC ( strlen ( ""<stdout>"" ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; strcpy ( g . outf , ""<stdout>"" ) ; g . outd = 1 ; if ( ! g . decode && ! g . force && isatty ( g . outd ) ) bail ( ""trying to write compressed data to a terminal"" , "" (use -f to force)"" ) ; } else { <StartBug> char * to , * repl ; to = g . inf ; if ( g . decode && ( g . headis & 1 ) != 0 && g . hname != NULL ) {  to = g . hname ; len = strlen ( g . hname ) ; <EndBug> } <StartBug> repl = g . decode && strcmp ( to + len , "".tgz"" ) ? """" : "".tar"" ; g . outf = MALLOC ( len + ( g . decode ? strlen ( repl ) : strlen ( g . sufx ) ) + 1 ) ; <EndBug> if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; <StartBug> memcpy ( g . outf , to , len ) ; strcpy ( g . outf + len , g . decode ? repl : g . sufx ) ; <EndBug> g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY | ( g . force ? 0 : O_EXCL ) , 0600 ) ; if ( g . outd < 0 && errno == EEXIST && isatty ( 0 ) && g . verbosity ) { int ch , reply ; fprintf ( stderr , ""%s exists -- overwrite (y/n)? "" , g . outf ) ; fflush ( stderr ) ; reply = - 1 ; do { ch = getchar ( ) ; if ( reply < 0 && ch != ' ' && ch != '\\t' ) reply = ch == 'y' || ch == 'Y' ? 1 : 0 ; } while ( ch != EOF && ch != '\\n' && ch != '\\r' ) ; if ( reply == 1 ) g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY , 0600 ) ; } if ( g . outd < 0 && errno == EEXIST ) { complain ( ""%s exists -- skipping"" , g . outf ) ; RELEASE ( g . outf ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( g . outd < 0 ) bail ( ""write error on "" , g . outf ) ; } SET_BINARY_MODE ( g . outd ) ; RELEASE ( g . hname ) ; if ( g . verbosity > 1 ) fprintf ( stderr , ""%s to %s "" , g . inf , g . outf ) ; if ( g . decode ) { if ( method == 8 ) infchk ( ) ; else if ( method == 257 ) unlzw ( ) ; else cat ( ) ; } # ifndef NOTHREAD else if ( g . procs > 1 ) parallel_compress ( ) ; # endif else single_compress ( 0 ) ; if ( g . verbosity > 1 ) { putc ( '\\n' , stderr ) ; fflush ( stderr ) ; } if ( g . ind != 0 ) close ( g . ind ) ; if ( g . outd != 1 ) { if ( close ( g . outd ) ) bail ( ""write error on "" , g . outf ) ; g . outd = - 1 ; if ( g . ind != 0 ) { copymeta ( g . inf , g . outf ) ; if ( ! g . keep ) unlink ( g . inf ) ; } if ( g . decode && ( g . headis & 2 ) != 0 && g . stamp ) touch ( g . outf , g . stamp ) ; } RELEASE ( g . outf ) ; }
Fixed code:","

local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { <StartBug> char buf [ PATH_MAX ] ; if ( realpath ( path , buf ) != NULL ) { strncpy ( g . inf , buf , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } <EndBug> len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE",1450,-22.27045041469527,-0.015358931320479496
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force && g . pipeout && g . decode != 2 && ! g . list ) ) { RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; if ( method != - 1 ) complain ( method < 0 ? ""%s is not compressed -- skipping"" : ""%s has unknown compression method -- skipping"" , g . inf ) ; return ; } if ( g . decode == 2 ) { if ( method == 8 ) infchk ( ) ; else { unlzw ( ) ; if ( g . list ) { g . in_tot -= 3 ; show_info ( method , 0 , g . out_tot , 0 ) ; } } RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } } if ( g . list ) { list_info ( ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( path == NULL || g . pipeout ) { g . outf = MALLOC ( strlen ( ""<stdout>"" ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; strcpy ( g . outf , ""<stdout>"" ) ; g . outd = 1 ; if ( ! g . decode && ! g . force && isatty ( g . outd ) ) bail ( ""trying to write compressed data to a terminal"" , "" (use -f to force)"" ) ; } else { <StartBug> char * to , * repl ; to = g . inf ; if ( g . decode && ( g . headis & 1 ) != 0 && g . hname != NULL ) {  to = g . hname ; len = strlen ( g . hname ) ; <EndBug> } <StartBug> repl = g . decode && strcmp ( to + len , "".tgz"" ) ? """" : "".tar"" ; g . outf = MALLOC ( len + ( g . decode ? strlen ( repl ) : strlen ( g . sufx ) ) + 1 ) ; <EndBug> if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; <StartBug> memcpy ( g . outf , to , len ) ; strcpy ( g . outf + len , g . decode ? repl : g . sufx ) ; <EndBug> g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY | ( g . force ? 0 : O_EXCL ) , 0600 ) ; if ( g . outd < 0 && errno == EEXIST && isatty ( 0 ) && g . verbosity ) { int ch , reply ; fprintf ( stderr , ""%s exists -- overwrite (y/n)? "" , g . outf ) ; fflush ( stderr ) ; reply = - 1 ; do { ch = getchar ( ) ; if ( reply < 0 && ch != ' ' && ch != '\\t' ) reply = ch == 'y' || ch == 'Y' ? 1 : 0 ; } while ( ch != EOF && ch != '\\n' && ch != '\\r' ) ; if ( reply == 1 ) g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY , 0600 ) ; } if ( g . outd < 0 && errno == EEXIST ) { complain ( ""%s exists -- skipping"" , g . outf ) ; RELEASE ( g . outf ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( g . outd < 0 ) bail ( ""write error on "" , g . outf ) ; } SET_BINARY_MODE ( g . outd ) ; RELEASE ( g . hname ) ; if ( g . verbosity > 1 ) fprintf ( stderr , ""%s to %s "" , g . inf , g . outf ) ; if ( g . decode ) { if ( method == 8 ) infchk ( ) ; else if ( method == 257 ) unlzw ( ) ; else cat ( ) ; } # ifndef NOTHREAD else if ( g . procs > 1 ) parallel_compress ( ) ; # endif else single_compress ( 0 ) ; if ( g . verbosity > 1 ) { putc ( '\\n' , stderr ) ; fflush ( stderr ) ; } if ( g . ind != 0 ) close ( g . ind ) ; if ( g . outd != 1 ) { if ( close ( g . outd ) ) bail ( ""write error on "" , g . outf ) ; g . outd = - 1 ; if ( g . ind != 0 ) { copymeta ( g . inf , g . outf ) ; if ( ! g . keep ) unlink ( g . inf ) ; } if ( g . decode && ( g . headis & 2 ) != 0 && g . stamp ) touch ( g . outf , g . stamp ) ; } RELEASE ( g . outf ) ; }
Fixed code:"," local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; char* absolute_path; absolute_path = realpath(g.inf, NULL); if ( lstat ( absolute_path , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( absolute_path ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force && g . pipeout &&",1450,-14.997698346692507,-0.010343240239098281
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force && g . pipeout && g . decode != 2 && ! g . list ) ) { RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; if ( method != - 1 ) complain ( method < 0 ? ""%s is not compressed -- skipping"" : ""%s has unknown compression method -- skipping"" , g . inf ) ; return ; } if ( g . decode == 2 ) { if ( method == 8 ) infchk ( ) ; else { unlzw ( ) ; if ( g . list ) { g . in_tot -= 3 ; show_info ( method , 0 , g . out_tot , 0 ) ; } } RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } } if ( g . list ) { list_info ( ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( path == NULL || g . pipeout ) { g . outf = MALLOC ( strlen ( ""<stdout>"" ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; strcpy ( g . outf , ""<stdout>"" ) ; g . outd = 1 ; if ( ! g . decode && ! g . force && isatty ( g . outd ) ) bail ( ""trying to write compressed data to a terminal"" , "" (use -f to force)"" ) ; } else { <StartBug> char * to , * repl ; to = g . inf ; if ( g . decode && ( g . headis & 1 ) != 0 && g . hname != NULL ) {  to = g . hname ; len = strlen ( g . hname ) ; <EndBug> } <StartBug> repl = g . decode && strcmp ( to + len , "".tgz"" ) ? """" : "".tar"" ; g . outf = MALLOC ( len + ( g . decode ? strlen ( repl ) : strlen ( g . sufx ) ) + 1 ) ; <EndBug> if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; <StartBug> memcpy ( g . outf , to , len ) ; strcpy ( g . outf + len , g . decode ? repl : g . sufx ) ; <EndBug> g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY | ( g . force ? 0 : O_EXCL ) , 0600 ) ; if ( g . outd < 0 && errno == EEXIST && isatty ( 0 ) && g . verbosity ) { int ch , reply ; fprintf ( stderr , ""%s exists -- overwrite (y/n)? "" , g . outf ) ; fflush ( stderr ) ; reply = - 1 ; do { ch = getchar ( ) ; if ( reply < 0 && ch != ' ' && ch != '\\t' ) reply = ch == 'y' || ch == 'Y' ? 1 : 0 ; } while ( ch != EOF && ch != '\\n' && ch != '\\r' ) ; if ( reply == 1 ) g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY , 0600 ) ; } if ( g . outd < 0 && errno == EEXIST ) { complain ( ""%s exists -- skipping"" , g . outf ) ; RELEASE ( g . outf ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( g . outd < 0 ) bail ( ""write error on "" , g . outf ) ; } SET_BINARY_MODE ( g . outd ) ; RELEASE ( g . hname ) ; if ( g . verbosity > 1 ) fprintf ( stderr , ""%s to %s "" , g . inf , g . outf ) ; if ( g . decode ) { if ( method == 8 ) infchk ( ) ; else if ( method == 257 ) unlzw ( ) ; else cat ( ) ; } # ifndef NOTHREAD else if ( g . procs > 1 ) parallel_compress ( ) ; # endif else single_compress ( 0 ) ; if ( g . verbosity > 1 ) { putc ( '\\n' , stderr ) ; fflush ( stderr ) ; } if ( g . ind != 0 ) close ( g . ind ) ; if ( g . outd != 1 ) { if ( close ( g . outd ) ) bail ( ""write error on "" , g . outf ) ; g . outd = - 1 ; if ( g . ind != 0 ) { copymeta ( g . inf , g . outf ) ; if ( ! g . keep ) unlink ( g . inf ) ; } if ( g . decode && ( g . headis & 2 ) != 0 && g . stamp ) touch ( g . outf , g . stamp ) ; } RELEASE ( g . outf ) ; }
Fixed code:"," local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; }  if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { <StartBug> char path_copy [ sizeof ( g . inf ) ] ; strncpy ( path_copy , g . inf , sizeof ( g . inf ) ) ; strncpy ( path_copy + strlen ( g . inf ) , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( path_copy [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , path_copy ) ; } <EndBug> process ( path_copy ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method =",1450,-30.19060365191478,-0.02082110596683778
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force && g . pipeout && g . decode != 2 && ! g . list ) ) { RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; if ( method != - 1 ) complain ( method < 0 ? ""%s is not compressed -- skipping"" : ""%s has unknown compression method -- skipping"" , g . inf ) ; return ; } if ( g . decode == 2 ) { if ( method == 8 ) infchk ( ) ; else { unlzw ( ) ; if ( g . list ) { g . in_tot -= 3 ; show_info ( method , 0 , g . out_tot , 0 ) ; } } RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } } if ( g . list ) { list_info ( ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( path == NULL || g . pipeout ) { g . outf = MALLOC ( strlen ( ""<stdout>"" ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; strcpy ( g . outf , ""<stdout>"" ) ; g . outd = 1 ; if ( ! g . decode && ! g . force && isatty ( g . outd ) ) bail ( ""trying to write compressed data to a terminal"" , "" (use -f to force)"" ) ; } else { <StartBug> char * to , * repl ; to = g . inf ; if ( g . decode && ( g . headis & 1 ) != 0 && g . hname != NULL ) {  to = g . hname ; len = strlen ( g . hname ) ; <EndBug> } <StartBug> repl = g . decode && strcmp ( to + len , "".tgz"" ) ? """" : "".tar"" ; g . outf = MALLOC ( len + ( g . decode ? strlen ( repl ) : strlen ( g . sufx ) ) + 1 ) ; <EndBug> if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; <StartBug> memcpy ( g . outf , to , len ) ; strcpy ( g . outf + len , g . decode ? repl : g . sufx ) ; <EndBug> g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY | ( g . force ? 0 : O_EXCL ) , 0600 ) ; if ( g . outd < 0 && errno == EEXIST && isatty ( 0 ) && g . verbosity ) { int ch , reply ; fprintf ( stderr , ""%s exists -- overwrite (y/n)? "" , g . outf ) ; fflush ( stderr ) ; reply = - 1 ; do { ch = getchar ( ) ; if ( reply < 0 && ch != ' ' && ch != '\\t' ) reply = ch == 'y' || ch == 'Y' ? 1 : 0 ; } while ( ch != EOF && ch != '\\n' && ch != '\\r' ) ; if ( reply == 1 ) g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY , 0600 ) ; } if ( g . outd < 0 && errno == EEXIST ) { complain ( ""%s exists -- skipping"" , g . outf ) ; RELEASE ( g . outf ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( g . outd < 0 ) bail ( ""write error on "" , g . outf ) ; } SET_BINARY_MODE ( g . outd ) ; RELEASE ( g . hname ) ; if ( g . verbosity > 1 ) fprintf ( stderr , ""%s to %s "" , g . inf , g . outf ) ; if ( g . decode ) { if ( method == 8 ) infchk ( ) ; else if ( method == 257 ) unlzw ( ) ; else cat ( ) ; } # ifndef NOTHREAD else if ( g . procs > 1 ) parallel_compress ( ) ; # endif else single_compress ( 0 ) ; if ( g . verbosity > 1 ) { putc ( '\\n' , stderr ) ; fflush ( stderr ) ; } if ( g . ind != 0 ) close ( g . ind ) ; if ( g . outd != 1 ) { if ( close ( g . outd ) ) bail ( ""write error on "" , g . outf ) ; g . outd = - 1 ; if ( g . ind != 0 ) { copymeta ( g . inf , g . outf ) ; if ( ! g . keep ) unlink ( g . inf ) ; } if ( g . decode && ( g . headis & 2 ) != 0 && g . stamp ) touch ( g . outf , g . stamp ) ; } RELEASE ( g . outf ) ; }
Fixed code:","

local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) {  <StartBug> char absolute_path[PATH_MAX]; realpath(g.inf, absolute_path); strncpy(g.inf, absolute_path, sizeof(g.inf)); <EndBug> strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header",1450,-16.053363086253,-0.011071284887071035
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force && g . pipeout && g . decode != 2 && ! g . list ) ) { RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; if ( method != - 1 ) complain ( method < 0 ? ""%s is not compressed -- skipping"" : ""%s has unknown compression method -- skipping"" , g . inf ) ; return ; } if ( g . decode == 2 ) { if ( method == 8 ) infchk ( ) ; else { unlzw ( ) ; if ( g . list ) { g . in_tot -= 3 ; show_info ( method , 0 , g . out_tot , 0 ) ; } } RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } } if ( g . list ) { list_info ( ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( path == NULL || g . pipeout ) { g . outf = MALLOC ( strlen ( ""<stdout>"" ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; strcpy ( g . outf , ""<stdout>"" ) ; g . outd = 1 ; if ( ! g . decode && ! g . force && isatty ( g . outd ) ) bail ( ""trying to write compressed data to a terminal"" , "" (use -f to force)"" ) ; } else { <StartBug> char * to , * repl ; to = g . inf ; if ( g . decode && ( g . headis & 1 ) != 0 && g . hname != NULL ) {  to = g . hname ; len = strlen ( g . hname ) ; <EndBug> } <StartBug> repl = g . decode && strcmp ( to + len , "".tgz"" ) ? """" : "".tar"" ; g . outf = MALLOC ( len + ( g . decode ? strlen ( repl ) : strlen ( g . sufx ) ) + 1 ) ; <EndBug> if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; <StartBug> memcpy ( g . outf , to , len ) ; strcpy ( g . outf + len , g . decode ? repl : g . sufx ) ; <EndBug> g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY | ( g . force ? 0 : O_EXCL ) , 0600 ) ; if ( g . outd < 0 && errno == EEXIST && isatty ( 0 ) && g . verbosity ) { int ch , reply ; fprintf ( stderr , ""%s exists -- overwrite (y/n)? "" , g . outf ) ; fflush ( stderr ) ; reply = - 1 ; do { ch = getchar ( ) ; if ( reply < 0 && ch != ' ' && ch != '\\t' ) reply = ch == 'y' || ch == 'Y' ? 1 : 0 ; } while ( ch != EOF && ch != '\\n' && ch != '\\r' ) ; if ( reply == 1 ) g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY , 0600 ) ; } if ( g . outd < 0 && errno == EEXIST ) { complain ( ""%s exists -- skipping"" , g . outf ) ; RELEASE ( g . outf ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( g . outd < 0 ) bail ( ""write error on "" , g . outf ) ; } SET_BINARY_MODE ( g . outd ) ; RELEASE ( g . hname ) ; if ( g . verbosity > 1 ) fprintf ( stderr , ""%s to %s "" , g . inf , g . outf ) ; if ( g . decode ) { if ( method == 8 ) infchk ( ) ; else if ( method == 257 ) unlzw ( ) ; else cat ( ) ; } # ifndef NOTHREAD else if ( g . procs > 1 ) parallel_compress ( ) ; # endif else single_compress ( 0 ) ; if ( g . verbosity > 1 ) { putc ( '\\n' , stderr ) ; fflush ( stderr ) ; } if ( g . ind != 0 ) close ( g . ind ) ; if ( g . outd != 1 ) { if ( close ( g . outd ) ) bail ( ""write error on "" , g . outf ) ; g . outd = - 1 ; if ( g . ind != 0 ) { copymeta ( g . inf , g . outf ) ; if ( ! g . keep ) unlink ( g . inf ) ; } if ( g . decode && ( g . headis & 2 ) != 0 && g . stamp ) touch ( g . outf , g . stamp ) ; } RELEASE ( g . outf ) ; }
Fixed code:"," local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; <StartBug> //perform path canonicalization using realpath() char * temp; temp = realpath(g.inf, NULL); if(temp != NULL) { strncpy(g.inf, temp, sizeof(g.inf)); FREE(temp); } <EndBug> if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { <StartBug> //perform path canonicalization using realpath() char * temp; char buff[S_STRMAX]; strcpy(buff, g.inf); strcat(buff, item); temp = realpath(buff, NULL); if(temp != NULL) { strncpy(g.inf, temp, sizeof(g.inf)); FREE(temp); } <EndBug> strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind <",1450,-68.62419512763152,-0.0473270311225045
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force && g . pipeout && g . decode != 2 && ! g . list ) ) { RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; if ( method != - 1 ) complain ( method < 0 ? ""%s is not compressed -- skipping"" : ""%s has unknown compression method -- skipping"" , g . inf ) ; return ; } if ( g . decode == 2 ) { if ( method == 8 ) infchk ( ) ; else { unlzw ( ) ; if ( g . list ) { g . in_tot -= 3 ; show_info ( method , 0 , g . out_tot , 0 ) ; } } RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } } if ( g . list ) { list_info ( ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( path == NULL || g . pipeout ) { g . outf = MALLOC ( strlen ( ""<stdout>"" ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; strcpy ( g . outf , ""<stdout>"" ) ; g . outd = 1 ; if ( ! g . decode && ! g . force && isatty ( g . outd ) ) bail ( ""trying to write compressed data to a terminal"" , "" (use -f to force)"" ) ; } else { <StartBug> char * to , * repl ; to = g . inf ; if ( g . decode && ( g . headis & 1 ) != 0 && g . hname != NULL ) {  to = g . hname ; len = strlen ( g . hname ) ; <EndBug> } <StartBug> repl = g . decode && strcmp ( to + len , "".tgz"" ) ? """" : "".tar"" ; g . outf = MALLOC ( len + ( g . decode ? strlen ( repl ) : strlen ( g . sufx ) ) + 1 ) ; <EndBug> if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; <StartBug> memcpy ( g . outf , to , len ) ; strcpy ( g . outf + len , g . decode ? repl : g . sufx ) ; <EndBug> g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY | ( g . force ? 0 : O_EXCL ) , 0600 ) ; if ( g . outd < 0 && errno == EEXIST && isatty ( 0 ) && g . verbosity ) { int ch , reply ; fprintf ( stderr , ""%s exists -- overwrite (y/n)? "" , g . outf ) ; fflush ( stderr ) ; reply = - 1 ; do { ch = getchar ( ) ; if ( reply < 0 && ch != ' ' && ch != '\\t' ) reply = ch == 'y' || ch == 'Y' ? 1 : 0 ; } while ( ch != EOF && ch != '\\n' && ch != '\\r' ) ; if ( reply == 1 ) g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY , 0600 ) ; } if ( g . outd < 0 && errno == EEXIST ) { complain ( ""%s exists -- skipping"" , g . outf ) ; RELEASE ( g . outf ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( g . outd < 0 ) bail ( ""write error on "" , g . outf ) ; } SET_BINARY_MODE ( g . outd ) ; RELEASE ( g . hname ) ; if ( g . verbosity > 1 ) fprintf ( stderr , ""%s to %s "" , g . inf , g . outf ) ; if ( g . decode ) { if ( method == 8 ) infchk ( ) ; else if ( method == 257 ) unlzw ( ) ; else cat ( ) ; } # ifndef NOTHREAD else if ( g . procs > 1 ) parallel_compress ( ) ; # endif else single_compress ( 0 ) ; if ( g . verbosity > 1 ) { putc ( '\\n' , stderr ) ; fflush ( stderr ) ; } if ( g . ind != 0 ) close ( g . ind ) ; if ( g . outd != 1 ) { if ( close ( g . outd ) ) bail ( ""write error on "" , g . outf ) ; g . outd = - 1 ; if ( g . ind != 0 ) { copymeta ( g . inf , g . outf ) ; if ( ! g . keep ) unlink ( g . inf ) ; } if ( g . decode && ( g . headis & 2 ) != 0 && g . stamp ) touch ( g . outf , g . stamp ) ; } RELEASE ( g . outf ) ; }
Fixed code:"," local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; <StartBug> char * abs_path = realpath ( g . inf , NULL ) ; if ( lstat ( abs_path , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; <EndBug> <StartBug> char * abs_path = realpath ( g . inf , NULL ) ; if ( lstat ( abs_path , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; <EndBug> # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; <StartBug> here = opendir ( abs_path ) ; if ( here == NULL ) return ; <EndBug> hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } <StartBug> char * abs_path = realpath ( g . inf , NULL ) ; process ( abs_path ) ; <EndBug> item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind",1450,-25.023066498139418,-0.01725728724009615
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force && g . pipeout && g . decode != 2 && ! g . list ) ) { RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; if ( method != - 1 ) complain ( method < 0 ? ""%s is not compressed -- skipping"" : ""%s has unknown compression method -- skipping"" , g . inf ) ; return ; } if ( g . decode == 2 ) { if ( method == 8 ) infchk ( ) ; else { unlzw ( ) ; if ( g . list ) { g . in_tot -= 3 ; show_info ( method , 0 , g . out_tot , 0 ) ; } } RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } } if ( g . list ) { list_info ( ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( path == NULL || g . pipeout ) { g . outf = MALLOC ( strlen ( ""<stdout>"" ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; strcpy ( g . outf , ""<stdout>"" ) ; g . outd = 1 ; if ( ! g . decode && ! g . force && isatty ( g . outd ) ) bail ( ""trying to write compressed data to a terminal"" , "" (use -f to force)"" ) ; } else { <StartBug> char * to , * repl ; to = g . inf ; if ( g . decode && ( g . headis & 1 ) != 0 && g . hname != NULL ) {  to = g . hname ; len = strlen ( g . hname ) ; <EndBug> } <StartBug> repl = g . decode && strcmp ( to + len , "".tgz"" ) ? """" : "".tar"" ; g . outf = MALLOC ( len + ( g . decode ? strlen ( repl ) : strlen ( g . sufx ) ) + 1 ) ; <EndBug> if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; <StartBug> memcpy ( g . outf , to , len ) ; strcpy ( g . outf + len , g . decode ? repl : g . sufx ) ; <EndBug> g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY | ( g . force ? 0 : O_EXCL ) , 0600 ) ; if ( g . outd < 0 && errno == EEXIST && isatty ( 0 ) && g . verbosity ) { int ch , reply ; fprintf ( stderr , ""%s exists -- overwrite (y/n)? "" , g . outf ) ; fflush ( stderr ) ; reply = - 1 ; do { ch = getchar ( ) ; if ( reply < 0 && ch != ' ' && ch != '\\t' ) reply = ch == 'y' || ch == 'Y' ? 1 : 0 ; } while ( ch != EOF && ch != '\\n' && ch != '\\r' ) ; if ( reply == 1 ) g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY , 0600 ) ; } if ( g . outd < 0 && errno == EEXIST ) { complain ( ""%s exists -- skipping"" , g . outf ) ; RELEASE ( g . outf ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( g . outd < 0 ) bail ( ""write error on "" , g . outf ) ; } SET_BINARY_MODE ( g . outd ) ; RELEASE ( g . hname ) ; if ( g . verbosity > 1 ) fprintf ( stderr , ""%s to %s "" , g . inf , g . outf ) ; if ( g . decode ) { if ( method == 8 ) infchk ( ) ; else if ( method == 257 ) unlzw ( ) ; else cat ( ) ; } # ifndef NOTHREAD else if ( g . procs > 1 ) parallel_compress ( ) ; # endif else single_compress ( 0 ) ; if ( g . verbosity > 1 ) { putc ( '\\n' , stderr ) ; fflush ( stderr ) ; } if ( g . ind != 0 ) close ( g . ind ) ; if ( g . outd != 1 ) { if ( close ( g . outd ) ) bail ( ""write error on "" , g . outf ) ; g . outd = - 1 ; if ( g . ind != 0 ) { copymeta ( g . inf , g . outf ) ; if ( ! g . keep ) unlink ( g . inf ) ; } if ( g . decode && ( g . headis & 2 ) != 0 && g . stamp ) touch ( g . outf , g . stamp ) ; } RELEASE ( g . outf ) ; }
Fixed code:"," local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } <StartBug> if ( strstr ( next -> d_name , "".."" ) != NULL ) continue ; <EndBug> strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 &&",1450,-12.098988090704584,-0.0083441297177273
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force && g . pipeout && g . decode != 2 && ! g . list ) ) { RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; if ( method != - 1 ) complain ( method < 0 ? ""%s is not compressed -- skipping"" : ""%s has unknown compression method -- skipping"" , g . inf ) ; return ; } if ( g . decode == 2 ) { if ( method == 8 ) infchk ( ) ; else { unlzw ( ) ; if ( g . list ) { g . in_tot -= 3 ; show_info ( method , 0 , g . out_tot , 0 ) ; } } RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } } if ( g . list ) { list_info ( ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( path == NULL || g . pipeout ) { g . outf = MALLOC ( strlen ( ""<stdout>"" ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; strcpy ( g . outf , ""<stdout>"" ) ; g . outd = 1 ; if ( ! g . decode && ! g . force && isatty ( g . outd ) ) bail ( ""trying to write compressed data to a terminal"" , "" (use -f to force)"" ) ; } else { <StartBug> char * to , * repl ; to = g . inf ; if ( g . decode && ( g . headis & 1 ) != 0 && g . hname != NULL ) {  to = g . hname ; len = strlen ( g . hname ) ; <EndBug> } <StartBug> repl = g . decode && strcmp ( to + len , "".tgz"" ) ? """" : "".tar"" ; g . outf = MALLOC ( len + ( g . decode ? strlen ( repl ) : strlen ( g . sufx ) ) + 1 ) ; <EndBug> if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; <StartBug> memcpy ( g . outf , to , len ) ; strcpy ( g . outf + len , g . decode ? repl : g . sufx ) ; <EndBug> g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY | ( g . force ? 0 : O_EXCL ) , 0600 ) ; if ( g . outd < 0 && errno == EEXIST && isatty ( 0 ) && g . verbosity ) { int ch , reply ; fprintf ( stderr , ""%s exists -- overwrite (y/n)? "" , g . outf ) ; fflush ( stderr ) ; reply = - 1 ; do { ch = getchar ( ) ; if ( reply < 0 && ch != ' ' && ch != '\\t' ) reply = ch == 'y' || ch == 'Y' ? 1 : 0 ; } while ( ch != EOF && ch != '\\n' && ch != '\\r' ) ; if ( reply == 1 ) g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY , 0600 ) ; } if ( g . outd < 0 && errno == EEXIST ) { complain ( ""%s exists -- skipping"" , g . outf ) ; RELEASE ( g . outf ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( g . outd < 0 ) bail ( ""write error on "" , g . outf ) ; } SET_BINARY_MODE ( g . outd ) ; RELEASE ( g . hname ) ; if ( g . verbosity > 1 ) fprintf ( stderr , ""%s to %s "" , g . inf , g . outf ) ; if ( g . decode ) { if ( method == 8 ) infchk ( ) ; else if ( method == 257 ) unlzw ( ) ; else cat ( ) ; } # ifndef NOTHREAD else if ( g . procs > 1 ) parallel_compress ( ) ; # endif else single_compress ( 0 ) ; if ( g . verbosity > 1 ) { putc ( '\\n' , stderr ) ; fflush ( stderr ) ; } if ( g . ind != 0 ) close ( g . ind ) ; if ( g . outd != 1 ) { if ( close ( g . outd ) ) bail ( ""write error on "" , g . outf ) ; g . outd = - 1 ; if ( g . ind != 0 ) { copymeta ( g . inf , g . outf ) ; if ( ! g . keep ) unlink ( g . inf ) ; } if ( g . decode && ( g . headis & 2 ) != 0 && g . stamp ) touch ( g . outf , g . stamp ) ; } RELEASE ( g . outf ) ; }
Fixed code:"," local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; #ifndef NOTHREAD if ( realpath ( g . inf , g . inf ) == NULL ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } #else if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } #ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; #endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } #endif if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { #ifndef NOTHREAD if ( realpath ( g . inf , g . inf ) == NULL ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } #else strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } #endif process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf )",1450,-23.940696617794096,-0.0165108252536511
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force && g . pipeout && g . decode != 2 && ! g . list ) ) { RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; if ( method != - 1 ) complain ( method < 0 ? ""%s is not compressed -- skipping"" : ""%s has unknown compression method -- skipping"" , g . inf ) ; return ; } if ( g . decode == 2 ) { if ( method == 8 ) infchk ( ) ; else { unlzw ( ) ; if ( g . list ) { g . in_tot -= 3 ; show_info ( method , 0 , g . out_tot , 0 ) ; } } RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } } if ( g . list ) { list_info ( ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( path == NULL || g . pipeout ) { g . outf = MALLOC ( strlen ( ""<stdout>"" ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; strcpy ( g . outf , ""<stdout>"" ) ; g . outd = 1 ; if ( ! g . decode && ! g . force && isatty ( g . outd ) ) bail ( ""trying to write compressed data to a terminal"" , "" (use -f to force)"" ) ; } else { <StartBug> char * to , * repl ; to = g . inf ; if ( g . decode && ( g . headis & 1 ) != 0 && g . hname != NULL ) {  to = g . hname ; len = strlen ( g . hname ) ; <EndBug> } <StartBug> repl = g . decode && strcmp ( to + len , "".tgz"" ) ? """" : "".tar"" ; g . outf = MALLOC ( len + ( g . decode ? strlen ( repl ) : strlen ( g . sufx ) ) + 1 ) ; <EndBug> if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; <StartBug> memcpy ( g . outf , to , len ) ; strcpy ( g . outf + len , g . decode ? repl : g . sufx ) ; <EndBug> g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY | ( g . force ? 0 : O_EXCL ) , 0600 ) ; if ( g . outd < 0 && errno == EEXIST && isatty ( 0 ) && g . verbosity ) { int ch , reply ; fprintf ( stderr , ""%s exists -- overwrite (y/n)? "" , g . outf ) ; fflush ( stderr ) ; reply = - 1 ; do { ch = getchar ( ) ; if ( reply < 0 && ch != ' ' && ch != '\\t' ) reply = ch == 'y' || ch == 'Y' ? 1 : 0 ; } while ( ch != EOF && ch != '\\n' && ch != '\\r' ) ; if ( reply == 1 ) g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY , 0600 ) ; } if ( g . outd < 0 && errno == EEXIST ) { complain ( ""%s exists -- skipping"" , g . outf ) ; RELEASE ( g . outf ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( g . outd < 0 ) bail ( ""write error on "" , g . outf ) ; } SET_BINARY_MODE ( g . outd ) ; RELEASE ( g . hname ) ; if ( g . verbosity > 1 ) fprintf ( stderr , ""%s to %s "" , g . inf , g . outf ) ; if ( g . decode ) { if ( method == 8 ) infchk ( ) ; else if ( method == 257 ) unlzw ( ) ; else cat ( ) ; } # ifndef NOTHREAD else if ( g . procs > 1 ) parallel_compress ( ) ; # endif else single_compress ( 0 ) ; if ( g . verbosity > 1 ) { putc ( '\\n' , stderr ) ; fflush ( stderr ) ; } if ( g . ind != 0 ) close ( g . ind ) ; if ( g . outd != 1 ) { if ( close ( g . outd ) ) bail ( ""write error on "" , g . outf ) ; g . outd = - 1 ; if ( g . ind != 0 ) { copymeta ( g . inf , g . outf ) ; if ( ! g . keep ) unlink ( g . inf ) ; } if ( g . decode && ( g . headis & 2 ) != 0 && g . stamp ) touch ( g . outf , g . stamp ) ; } RELEASE ( g . outf ) ; }
Fixed code:","

local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; <StartBug> char abs_path[PATH_MAX]; realpath(g.inf, abs_path); if ( lstat ( abs_path , & st ) ) { <EndBug> if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == -",1450,-12.224918249814012,-0.008430978103320007
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force && g . pipeout && g . decode != 2 && ! g . list ) ) { RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; if ( method != - 1 ) complain ( method < 0 ? ""%s is not compressed -- skipping"" : ""%s has unknown compression method -- skipping"" , g . inf ) ; return ; } if ( g . decode == 2 ) { if ( method == 8 ) infchk ( ) ; else { unlzw ( ) ; if ( g . list ) { g . in_tot -= 3 ; show_info ( method , 0 , g . out_tot , 0 ) ; } } RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } } if ( g . list ) { list_info ( ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( path == NULL || g . pipeout ) { g . outf = MALLOC ( strlen ( ""<stdout>"" ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; strcpy ( g . outf , ""<stdout>"" ) ; g . outd = 1 ; if ( ! g . decode && ! g . force && isatty ( g . outd ) ) bail ( ""trying to write compressed data to a terminal"" , "" (use -f to force)"" ) ; } else { <StartBug> char * to , * repl ; to = g . inf ; if ( g . decode && ( g . headis & 1 ) != 0 && g . hname != NULL ) {  to = g . hname ; len = strlen ( g . hname ) ; <EndBug> } <StartBug> repl = g . decode && strcmp ( to + len , "".tgz"" ) ? """" : "".tar"" ; g . outf = MALLOC ( len + ( g . decode ? strlen ( repl ) : strlen ( g . sufx ) ) + 1 ) ; <EndBug> if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; <StartBug> memcpy ( g . outf , to , len ) ; strcpy ( g . outf + len , g . decode ? repl : g . sufx ) ; <EndBug> g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY | ( g . force ? 0 : O_EXCL ) , 0600 ) ; if ( g . outd < 0 && errno == EEXIST && isatty ( 0 ) && g . verbosity ) { int ch , reply ; fprintf ( stderr , ""%s exists -- overwrite (y/n)? "" , g . outf ) ; fflush ( stderr ) ; reply = - 1 ; do { ch = getchar ( ) ; if ( reply < 0 && ch != ' ' && ch != '\\t' ) reply = ch == 'y' || ch == 'Y' ? 1 : 0 ; } while ( ch != EOF && ch != '\\n' && ch != '\\r' ) ; if ( reply == 1 ) g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY , 0600 ) ; } if ( g . outd < 0 && errno == EEXIST ) { complain ( ""%s exists -- skipping"" , g . outf ) ; RELEASE ( g . outf ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( g . outd < 0 ) bail ( ""write error on "" , g . outf ) ; } SET_BINARY_MODE ( g . outd ) ; RELEASE ( g . hname ) ; if ( g . verbosity > 1 ) fprintf ( stderr , ""%s to %s "" , g . inf , g . outf ) ; if ( g . decode ) { if ( method == 8 ) infchk ( ) ; else if ( method == 257 ) unlzw ( ) ; else cat ( ) ; } # ifndef NOTHREAD else if ( g . procs > 1 ) parallel_compress ( ) ; # endif else single_compress ( 0 ) ; if ( g . verbosity > 1 ) { putc ( '\\n' , stderr ) ; fflush ( stderr ) ; } if ( g . ind != 0 ) close ( g . ind ) ; if ( g . outd != 1 ) { if ( close ( g . outd ) ) bail ( ""write error on "" , g . outf ) ; g . outd = - 1 ; if ( g . ind != 0 ) { copymeta ( g . inf , g . outf ) ; if ( ! g . keep ) unlink ( g . inf ) ; } if ( g . decode && ( g . headis & 2 ) != 0 && g . stamp ) touch ( g . outf , g . stamp ) ; } RELEASE ( g . outf ) ; }
Fixed code:"," local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { <StartBug> if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) || strstr ( next -> d_name , ""../"" ) != NULL ) continue ; <EndBug> len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force &&",1450,-10.666339698251806,-0.007356096343621935
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force && g . pipeout && g . decode != 2 && ! g . list ) ) { RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; if ( method != - 1 ) complain ( method < 0 ? ""%s is not compressed -- skipping"" : ""%s has unknown compression method -- skipping"" , g . inf ) ; return ; } if ( g . decode == 2 ) { if ( method == 8 ) infchk ( ) ; else { unlzw ( ) ; if ( g . list ) { g . in_tot -= 3 ; show_info ( method , 0 , g . out_tot , 0 ) ; } } RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } } if ( g . list ) { list_info ( ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( path == NULL || g . pipeout ) { g . outf = MALLOC ( strlen ( ""<stdout>"" ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; strcpy ( g . outf , ""<stdout>"" ) ; g . outd = 1 ; if ( ! g . decode && ! g . force && isatty ( g . outd ) ) bail ( ""trying to write compressed data to a terminal"" , "" (use -f to force)"" ) ; } else { <StartBug> char * to , * repl ; to = g . inf ; if ( g . decode && ( g . headis & 1 ) != 0 && g . hname != NULL ) {  to = g . hname ; len = strlen ( g . hname ) ; <EndBug> } <StartBug> repl = g . decode && strcmp ( to + len , "".tgz"" ) ? """" : "".tar"" ; g . outf = MALLOC ( len + ( g . decode ? strlen ( repl ) : strlen ( g . sufx ) ) + 1 ) ; <EndBug> if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; <StartBug> memcpy ( g . outf , to , len ) ; strcpy ( g . outf + len , g . decode ? repl : g . sufx ) ; <EndBug> g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY | ( g . force ? 0 : O_EXCL ) , 0600 ) ; if ( g . outd < 0 && errno == EEXIST && isatty ( 0 ) && g . verbosity ) { int ch , reply ; fprintf ( stderr , ""%s exists -- overwrite (y/n)? "" , g . outf ) ; fflush ( stderr ) ; reply = - 1 ; do { ch = getchar ( ) ; if ( reply < 0 && ch != ' ' && ch != '\\t' ) reply = ch == 'y' || ch == 'Y' ? 1 : 0 ; } while ( ch != EOF && ch != '\\n' && ch != '\\r' ) ; if ( reply == 1 ) g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY , 0600 ) ; } if ( g . outd < 0 && errno == EEXIST ) { complain ( ""%s exists -- skipping"" , g . outf ) ; RELEASE ( g . outf ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( g . outd < 0 ) bail ( ""write error on "" , g . outf ) ; } SET_BINARY_MODE ( g . outd ) ; RELEASE ( g . hname ) ; if ( g . verbosity > 1 ) fprintf ( stderr , ""%s to %s "" , g . inf , g . outf ) ; if ( g . decode ) { if ( method == 8 ) infchk ( ) ; else if ( method == 257 ) unlzw ( ) ; else cat ( ) ; } # ifndef NOTHREAD else if ( g . procs > 1 ) parallel_compress ( ) ; # endif else single_compress ( 0 ) ; if ( g . verbosity > 1 ) { putc ( '\\n' , stderr ) ; fflush ( stderr ) ; } if ( g . ind != 0 ) close ( g . ind ) ; if ( g . outd != 1 ) { if ( close ( g . outd ) ) bail ( ""write error on "" , g . outf ) ; g . outd = - 1 ; if ( g . ind != 0 ) { copymeta ( g . inf , g . outf ) ; if ( ! g . keep ) unlink ( g . inf ) ; } if ( g . decode && ( g . headis & 2 ) != 0 && g . stamp ) touch ( g . outf , g . stamp ) ; } RELEASE ( g . outf ) ; }
Fixed code:"," local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { <StartBug> char fullPath[strlen(g.inf) + strlen(*item) + 1]; strcpy(fullPath, g.inf); strcat(fullPath, *item); process(fullPath); <EndBug> item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force && g . pipeout && g . decode != 2 && ! g . list ) ) { RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; if ( method != - 1 ) complain ( method < 0 ? ""%s is",1450,-15.599295683853574,-0.010758134954381776
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force && g . pipeout && g . decode != 2 && ! g . list ) ) { RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; if ( method != - 1 ) complain ( method < 0 ? ""%s is not compressed -- skipping"" : ""%s has unknown compression method -- skipping"" , g . inf ) ; return ; } if ( g . decode == 2 ) { if ( method == 8 ) infchk ( ) ; else { unlzw ( ) ; if ( g . list ) { g . in_tot -= 3 ; show_info ( method , 0 , g . out_tot , 0 ) ; } } RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } } if ( g . list ) { list_info ( ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( path == NULL || g . pipeout ) { g . outf = MALLOC ( strlen ( ""<stdout>"" ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; strcpy ( g . outf , ""<stdout>"" ) ; g . outd = 1 ; if ( ! g . decode && ! g . force && isatty ( g . outd ) ) bail ( ""trying to write compressed data to a terminal"" , "" (use -f to force)"" ) ; } else { <StartBug> char * to , * repl ; to = g . inf ; if ( g . decode && ( g . headis & 1 ) != 0 && g . hname != NULL ) {  to = g . hname ; len = strlen ( g . hname ) ; <EndBug> } <StartBug> repl = g . decode && strcmp ( to + len , "".tgz"" ) ? """" : "".tar"" ; g . outf = MALLOC ( len + ( g . decode ? strlen ( repl ) : strlen ( g . sufx ) ) + 1 ) ; <EndBug> if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; <StartBug> memcpy ( g . outf , to , len ) ; strcpy ( g . outf + len , g . decode ? repl : g . sufx ) ; <EndBug> g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY | ( g . force ? 0 : O_EXCL ) , 0600 ) ; if ( g . outd < 0 && errno == EEXIST && isatty ( 0 ) && g . verbosity ) { int ch , reply ; fprintf ( stderr , ""%s exists -- overwrite (y/n)? "" , g . outf ) ; fflush ( stderr ) ; reply = - 1 ; do { ch = getchar ( ) ; if ( reply < 0 && ch != ' ' && ch != '\\t' ) reply = ch == 'y' || ch == 'Y' ? 1 : 0 ; } while ( ch != EOF && ch != '\\n' && ch != '\\r' ) ; if ( reply == 1 ) g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY , 0600 ) ; } if ( g . outd < 0 && errno == EEXIST ) { complain ( ""%s exists -- skipping"" , g . outf ) ; RELEASE ( g . outf ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( g . outd < 0 ) bail ( ""write error on "" , g . outf ) ; } SET_BINARY_MODE ( g . outd ) ; RELEASE ( g . hname ) ; if ( g . verbosity > 1 ) fprintf ( stderr , ""%s to %s "" , g . inf , g . outf ) ; if ( g . decode ) { if ( method == 8 ) infchk ( ) ; else if ( method == 257 ) unlzw ( ) ; else cat ( ) ; } # ifndef NOTHREAD else if ( g . procs > 1 ) parallel_compress ( ) ; # endif else single_compress ( 0 ) ; if ( g . verbosity > 1 ) { putc ( '\\n' , stderr ) ; fflush ( stderr ) ; } if ( g . ind != 0 ) close ( g . ind ) ; if ( g . outd != 1 ) { if ( close ( g . outd ) ) bail ( ""write error on "" , g . outf ) ; g . outd = - 1 ; if ( g . ind != 0 ) { copymeta ( g . inf , g . outf ) ; if ( ! g . keep ) unlink ( g . inf ) ; } if ( g . decode && ( g . headis & 2 ) != 0 && g . stamp ) touch ( g . outf , g . stamp ) ; } RELEASE ( g . outf ) ; }
Fixed code:"," local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strncpy ( g . inf , realpath ( g . inf , NULL ) , sizeof ( g . inf ) ) ; strcat ( g . inf , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force && g",1450,-14.418970034560905,-0.009944117265214417
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force && g . pipeout && g . decode != 2 && ! g . list ) ) { RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; if ( method != - 1 ) complain ( method < 0 ? ""%s is not compressed -- skipping"" : ""%s has unknown compression method -- skipping"" , g . inf ) ; return ; } if ( g . decode == 2 ) { if ( method == 8 ) infchk ( ) ; else { unlzw ( ) ; if ( g . list ) { g . in_tot -= 3 ; show_info ( method , 0 , g . out_tot , 0 ) ; } } RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } } if ( g . list ) { list_info ( ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( path == NULL || g . pipeout ) { g . outf = MALLOC ( strlen ( ""<stdout>"" ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; strcpy ( g . outf , ""<stdout>"" ) ; g . outd = 1 ; if ( ! g . decode && ! g . force && isatty ( g . outd ) ) bail ( ""trying to write compressed data to a terminal"" , "" (use -f to force)"" ) ; } else { <StartBug> char * to , * repl ; to = g . inf ; if ( g . decode && ( g . headis & 1 ) != 0 && g . hname != NULL ) {  to = g . hname ; len = strlen ( g . hname ) ; <EndBug> } <StartBug> repl = g . decode && strcmp ( to + len , "".tgz"" ) ? """" : "".tar"" ; g . outf = MALLOC ( len + ( g . decode ? strlen ( repl ) : strlen ( g . sufx ) ) + 1 ) ; <EndBug> if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; <StartBug> memcpy ( g . outf , to , len ) ; strcpy ( g . outf + len , g . decode ? repl : g . sufx ) ; <EndBug> g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY | ( g . force ? 0 : O_EXCL ) , 0600 ) ; if ( g . outd < 0 && errno == EEXIST && isatty ( 0 ) && g . verbosity ) { int ch , reply ; fprintf ( stderr , ""%s exists -- overwrite (y/n)? "" , g . outf ) ; fflush ( stderr ) ; reply = - 1 ; do { ch = getchar ( ) ; if ( reply < 0 && ch != ' ' && ch != '\\t' ) reply = ch == 'y' || ch == 'Y' ? 1 : 0 ; } while ( ch != EOF && ch != '\\n' && ch != '\\r' ) ; if ( reply == 1 ) g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY , 0600 ) ; } if ( g . outd < 0 && errno == EEXIST ) { complain ( ""%s exists -- skipping"" , g . outf ) ; RELEASE ( g . outf ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( g . outd < 0 ) bail ( ""write error on "" , g . outf ) ; } SET_BINARY_MODE ( g . outd ) ; RELEASE ( g . hname ) ; if ( g . verbosity > 1 ) fprintf ( stderr , ""%s to %s "" , g . inf , g . outf ) ; if ( g . decode ) { if ( method == 8 ) infchk ( ) ; else if ( method == 257 ) unlzw ( ) ; else cat ( ) ; } # ifndef NOTHREAD else if ( g . procs > 1 ) parallel_compress ( ) ; # endif else single_compress ( 0 ) ; if ( g . verbosity > 1 ) { putc ( '\\n' , stderr ) ; fflush ( stderr ) ; } if ( g . ind != 0 ) close ( g . ind ) ; if ( g . outd != 1 ) { if ( close ( g . outd ) ) bail ( ""write error on "" , g . outf ) ; g . outd = - 1 ; if ( g . ind != 0 ) { copymeta ( g . inf , g . outf ) ; if ( ! g . keep ) unlink ( g . inf ) ; } if ( g . decode && ( g . headis & 2 ) != 0 && g . stamp ) touch ( g . outf , g . stamp ) ; } RELEASE ( g . outf ) ; }
Fixed code:"," 

local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; /* Added code to create absolute path and check if it is traversing outside its root directory */ <StartBug>  char absolute_path[PATH_MAX];  if (realpath(g.inf, absolute_path) == NULL) {  bail(""Path traversal error"","""");  }  if (strncmp(base_path, absolute_path, strlen(base_path))) {  bail(""Path traversal error"","""");  } <EndBug> if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) {  /* Added code to create absolute path and check if it is traversing outside its root directory */ <StartBug>  char absolute_path[PATH_MAX];  if (realpath(g.inf, absolute_path) == NULL) {  bail(""Path traversal error"","""");  }  if (strncmp(base_path, absolute_path, strlen(base_path))) {  bail(""Path traversal error"","""");  } <EndBug> strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if",1450,-80.45160608050288,-0.05548386626241578
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force && g . pipeout && g . decode != 2 && ! g . list ) ) { RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; if ( method != - 1 ) complain ( method < 0 ? ""%s is not compressed -- skipping"" : ""%s has unknown compression method -- skipping"" , g . inf ) ; return ; } if ( g . decode == 2 ) { if ( method == 8 ) infchk ( ) ; else { unlzw ( ) ; if ( g . list ) { g . in_tot -= 3 ; show_info ( method , 0 , g . out_tot , 0 ) ; } } RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } } if ( g . list ) { list_info ( ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( path == NULL || g . pipeout ) { g . outf = MALLOC ( strlen ( ""<stdout>"" ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; strcpy ( g . outf , ""<stdout>"" ) ; g . outd = 1 ; if ( ! g . decode && ! g . force && isatty ( g . outd ) ) bail ( ""trying to write compressed data to a terminal"" , "" (use -f to force)"" ) ; } else { <StartBug> char * to , * repl ; to = g . inf ; if ( g . decode && ( g . headis & 1 ) != 0 && g . hname != NULL ) {  to = g . hname ; len = strlen ( g . hname ) ; <EndBug> } <StartBug> repl = g . decode && strcmp ( to + len , "".tgz"" ) ? """" : "".tar"" ; g . outf = MALLOC ( len + ( g . decode ? strlen ( repl ) : strlen ( g . sufx ) ) + 1 ) ; <EndBug> if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; <StartBug> memcpy ( g . outf , to , len ) ; strcpy ( g . outf + len , g . decode ? repl : g . sufx ) ; <EndBug> g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY | ( g . force ? 0 : O_EXCL ) , 0600 ) ; if ( g . outd < 0 && errno == EEXIST && isatty ( 0 ) && g . verbosity ) { int ch , reply ; fprintf ( stderr , ""%s exists -- overwrite (y/n)? "" , g . outf ) ; fflush ( stderr ) ; reply = - 1 ; do { ch = getchar ( ) ; if ( reply < 0 && ch != ' ' && ch != '\\t' ) reply = ch == 'y' || ch == 'Y' ? 1 : 0 ; } while ( ch != EOF && ch != '\\n' && ch != '\\r' ) ; if ( reply == 1 ) g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY , 0600 ) ; } if ( g . outd < 0 && errno == EEXIST ) { complain ( ""%s exists -- skipping"" , g . outf ) ; RELEASE ( g . outf ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( g . outd < 0 ) bail ( ""write error on "" , g . outf ) ; } SET_BINARY_MODE ( g . outd ) ; RELEASE ( g . hname ) ; if ( g . verbosity > 1 ) fprintf ( stderr , ""%s to %s "" , g . inf , g . outf ) ; if ( g . decode ) { if ( method == 8 ) infchk ( ) ; else if ( method == 257 ) unlzw ( ) ; else cat ( ) ; } # ifndef NOTHREAD else if ( g . procs > 1 ) parallel_compress ( ) ; # endif else single_compress ( 0 ) ; if ( g . verbosity > 1 ) { putc ( '\\n' , stderr ) ; fflush ( stderr ) ; } if ( g . ind != 0 ) close ( g . ind ) ; if ( g . outd != 1 ) { if ( close ( g . outd ) ) bail ( ""write error on "" , g . outf ) ; g . outd = - 1 ; if ( g . ind != 0 ) { copymeta ( g . inf , g . outf ) ; if ( ! g . keep ) unlink ( g . inf ) ; } if ( g . decode && ( g . headis & 2 ) != 0 && g . stamp ) touch ( g . outf , g . stamp ) ; } RELEASE ( g . outf ) ; }
Fixed code:","

local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { <StartBug> char buffer[MAX_PATH]; realpath(g.inf, buffer); if(buffer == NULL){ complain( ""%s does not exist -- skipping"" , g.inf); return; } strncpy(g.inf, buffer, sizeof(g.inf)); <EndBug> process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force && g . pipeout && g . decode != 2 && ! g . list ) ) { RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g",1450,-30.338039438512254,-0.020922785819663624
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force && g . pipeout && g . decode != 2 && ! g . list ) ) { RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; if ( method != - 1 ) complain ( method < 0 ? ""%s is not compressed -- skipping"" : ""%s has unknown compression method -- skipping"" , g . inf ) ; return ; } if ( g . decode == 2 ) { if ( method == 8 ) infchk ( ) ; else { unlzw ( ) ; if ( g . list ) { g . in_tot -= 3 ; show_info ( method , 0 , g . out_tot , 0 ) ; } } RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } } if ( g . list ) { list_info ( ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( path == NULL || g . pipeout ) { g . outf = MALLOC ( strlen ( ""<stdout>"" ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; strcpy ( g . outf , ""<stdout>"" ) ; g . outd = 1 ; if ( ! g . decode && ! g . force && isatty ( g . outd ) ) bail ( ""trying to write compressed data to a terminal"" , "" (use -f to force)"" ) ; } else { <StartBug> char * to , * repl ; to = g . inf ; if ( g . decode && ( g . headis & 1 ) != 0 && g . hname != NULL ) {  to = g . hname ; len = strlen ( g . hname ) ; <EndBug> } <StartBug> repl = g . decode && strcmp ( to + len , "".tgz"" ) ? """" : "".tar"" ; g . outf = MALLOC ( len + ( g . decode ? strlen ( repl ) : strlen ( g . sufx ) ) + 1 ) ; <EndBug> if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; <StartBug> memcpy ( g . outf , to , len ) ; strcpy ( g . outf + len , g . decode ? repl : g . sufx ) ; <EndBug> g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY | ( g . force ? 0 : O_EXCL ) , 0600 ) ; if ( g . outd < 0 && errno == EEXIST && isatty ( 0 ) && g . verbosity ) { int ch , reply ; fprintf ( stderr , ""%s exists -- overwrite (y/n)? "" , g . outf ) ; fflush ( stderr ) ; reply = - 1 ; do { ch = getchar ( ) ; if ( reply < 0 && ch != ' ' && ch != '\\t' ) reply = ch == 'y' || ch == 'Y' ? 1 : 0 ; } while ( ch != EOF && ch != '\\n' && ch != '\\r' ) ; if ( reply == 1 ) g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY , 0600 ) ; } if ( g . outd < 0 && errno == EEXIST ) { complain ( ""%s exists -- skipping"" , g . outf ) ; RELEASE ( g . outf ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( g . outd < 0 ) bail ( ""write error on "" , g . outf ) ; } SET_BINARY_MODE ( g . outd ) ; RELEASE ( g . hname ) ; if ( g . verbosity > 1 ) fprintf ( stderr , ""%s to %s "" , g . inf , g . outf ) ; if ( g . decode ) { if ( method == 8 ) infchk ( ) ; else if ( method == 257 ) unlzw ( ) ; else cat ( ) ; } # ifndef NOTHREAD else if ( g . procs > 1 ) parallel_compress ( ) ; # endif else single_compress ( 0 ) ; if ( g . verbosity > 1 ) { putc ( '\\n' , stderr ) ; fflush ( stderr ) ; } if ( g . ind != 0 ) close ( g . ind ) ; if ( g . outd != 1 ) { if ( close ( g . outd ) ) bail ( ""write error on "" , g . outf ) ; g . outd = - 1 ; if ( g . ind != 0 ) { copymeta ( g . inf , g . outf ) ; if ( ! g . keep ) unlink ( g . inf ) ; } if ( g . decode && ( g . headis & 2 ) != 0 && g . stamp ) touch ( g . outf , g . stamp ) ; } RELEASE ( g . outf ) ; }
Fixed code:"," local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; char validPath [ PATH_MAX ] ; struct dirent * next ; realpath ( g . inf , validPath ) ; here = opendir ( validPath ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force && g . pipeout &&",1450,-19.182743039807665,-0.013229477958488044
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force && g . pipeout && g . decode != 2 && ! g . list ) ) { RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; if ( method != - 1 ) complain ( method < 0 ? ""%s is not compressed -- skipping"" : ""%s has unknown compression method -- skipping"" , g . inf ) ; return ; } if ( g . decode == 2 ) { if ( method == 8 ) infchk ( ) ; else { unlzw ( ) ; if ( g . list ) { g . in_tot -= 3 ; show_info ( method , 0 , g . out_tot , 0 ) ; } } RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } } if ( g . list ) { list_info ( ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( path == NULL || g . pipeout ) { g . outf = MALLOC ( strlen ( ""<stdout>"" ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; strcpy ( g . outf , ""<stdout>"" ) ; g . outd = 1 ; if ( ! g . decode && ! g . force && isatty ( g . outd ) ) bail ( ""trying to write compressed data to a terminal"" , "" (use -f to force)"" ) ; } else { <StartBug> char * to , * repl ; to = g . inf ; if ( g . decode && ( g . headis & 1 ) != 0 && g . hname != NULL ) {  to = g . hname ; len = strlen ( g . hname ) ; <EndBug> } <StartBug> repl = g . decode && strcmp ( to + len , "".tgz"" ) ? """" : "".tar"" ; g . outf = MALLOC ( len + ( g . decode ? strlen ( repl ) : strlen ( g . sufx ) ) + 1 ) ; <EndBug> if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; <StartBug> memcpy ( g . outf , to , len ) ; strcpy ( g . outf + len , g . decode ? repl : g . sufx ) ; <EndBug> g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY | ( g . force ? 0 : O_EXCL ) , 0600 ) ; if ( g . outd < 0 && errno == EEXIST && isatty ( 0 ) && g . verbosity ) { int ch , reply ; fprintf ( stderr , ""%s exists -- overwrite (y/n)? "" , g . outf ) ; fflush ( stderr ) ; reply = - 1 ; do { ch = getchar ( ) ; if ( reply < 0 && ch != ' ' && ch != '\\t' ) reply = ch == 'y' || ch == 'Y' ? 1 : 0 ; } while ( ch != EOF && ch != '\\n' && ch != '\\r' ) ; if ( reply == 1 ) g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY , 0600 ) ; } if ( g . outd < 0 && errno == EEXIST ) { complain ( ""%s exists -- skipping"" , g . outf ) ; RELEASE ( g . outf ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( g . outd < 0 ) bail ( ""write error on "" , g . outf ) ; } SET_BINARY_MODE ( g . outd ) ; RELEASE ( g . hname ) ; if ( g . verbosity > 1 ) fprintf ( stderr , ""%s to %s "" , g . inf , g . outf ) ; if ( g . decode ) { if ( method == 8 ) infchk ( ) ; else if ( method == 257 ) unlzw ( ) ; else cat ( ) ; } # ifndef NOTHREAD else if ( g . procs > 1 ) parallel_compress ( ) ; # endif else single_compress ( 0 ) ; if ( g . verbosity > 1 ) { putc ( '\\n' , stderr ) ; fflush ( stderr ) ; } if ( g . ind != 0 ) close ( g . ind ) ; if ( g . outd != 1 ) { if ( close ( g . outd ) ) bail ( ""write error on "" , g . outf ) ; g . outd = - 1 ; if ( g . ind != 0 ) { copymeta ( g . inf , g . outf ) ; if ( ! g . keep ) unlink ( g . inf ) ; } if ( g . decode && ( g . headis & 2 ) != 0 && g . stamp ) touch ( g . outf , g . stamp ) ; } RELEASE ( g . outf ) ; }
Fixed code:"," 
local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { <StartBug> if ( strstr(item, "".."") == NULL ) { <EndBug> strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } <StartBug> else { item += strlen ( item ) + 1; // skips over the directory } <EndBug> } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method =",1450,-32.18721915856593,-0.02219808217832133
