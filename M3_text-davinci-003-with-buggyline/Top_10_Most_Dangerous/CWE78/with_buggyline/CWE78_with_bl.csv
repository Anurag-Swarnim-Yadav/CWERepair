Unnamed: 0,cwe_id,source,target,project_and_commit_id,cve_id,original_address,time,raw_predictions,correctly_predicted
1012,CWE-78,"R_API char * r_socket_http_post ( const char * url , const char * data , int * code , int * rlen ) { RSocket * s ; bool ssl = r_str_startswith ( url , ""https://"" ) ; char * uri = strdup ( url ) ; if ( ! uri ) { return NULL ; } char * host = strstr ( uri , ""://"" ) ; if ( ! host ) { free ( uri ) ; printf ( ""Invalid URI"" ) ; return NULL ; } host += 3 ; char * port = strchr ( host , ':' ) ; if ( ! port ) { port = ( ssl ) ? ""443"" : ""80"" ; } else { * port ++ = 0 ; } char * path = strchr ( host , '/' ) ; if ( ! path ) { path = """" ; } else { * path ++ = 0 ; } s = r_socket_new ( ssl ) ; if ( ! s ) { printf ( ""Cannot create socket\\n"" ) ; free ( uri ) ; return NULL ; } if ( ! r_socket_connect_tcp ( s , host , port , 0 ) ) { eprintf ( ""Cannot connect to %s:%s\\n"" , host , port ) ; free ( uri ) ; return NULL ; } r_socket_printf ( s , ""POST /%s HTTP/1.0\\r\\n"" ""User-Agent: radare2 "" R2_VERSION ""\\r\\n"" ""Accept: */*\\r\\n"" ""Host: %s\\r\\n"" ""Content-Length: %i\\r\\n"" ""Content-Type: application/x-www-form-urlencoded\\r\\n"" ""\\r\\n"" , path , host , ( int ) strlen ( data ) ) ; free ( uri ) ; r_socket_write ( s , ( void * ) data , strlen ( data ) ) ; <StartBug> return r_socket_http_answer ( s , code , rlen ) ; <EndBug> }
","<S2SV_ModStart> ) ; return socket_http_answer <S2SV_ModEnd> ( s , <S2SV_ModStart> code , rlen , 0
",radareorg@radare2/04edfa82c1f3fa2bc3621ccdad2f93bdbf00e4f9,CVE-2020-15121,https://github.com/radareorg/radare2/commit/04edfa82c1f3fa2bc3621ccdad2f93bdbf00e4f9,2020-07-20T18:15Z,<S2SV_ModStart> ) ) ; char * resp = malloc ( strlen ( data ) + 1 ) ; if (! resp ) { free ( uri ) ; return NULL ; } <S2SV_ModStart> ) ) ; resp = malloc ( strlen ( data ) + 1 ) ; if (! resp ) { free ( uri ) ; return NULL ; },0
1149,CWE-78,"static int bin_symbols ( RCore * r , int mode , ut64 laddr , int va , ut64 at , const char * name , bool exponly , const char * args ) { RBinInfo * info = r_bin_get_info ( r -> bin ) ; RList * entries = r_bin_get_entries ( r -> bin ) ; RBinSymbol * symbol ; RBinAddr * entry ; RListIter * iter ; bool firstexp = true ; bool printHere = false ; int i = 0 , lastfs = 's' ; bool bin_demangle = r_config_get_i ( r -> config , ""bin.demangle"" ) ; if ( ! info ) { return 0 ; } if ( args && * args == '.' ) { printHere = true ; } bool is_arm = info && info -> arch && ! strncmp ( info -> arch , ""arm"" , 3 ) ; const char * lang = bin_demangle ? r_config_get ( r -> config , ""bin.lang"" ) : NULL ; RList * symbols = r_bin_get_symbols ( r -> bin ) ; r_spaces_push ( & r -> anal -> meta_spaces , ""bin"" ) ; if ( IS_MODE_JSON ( mode ) && ! printHere ) { r_cons_printf ( ""["" ) ; } else if ( IS_MODE_SET ( mode ) ) { r_flag_space_set ( r -> flags , R_FLAGS_FS_SYMBOLS ) ; } else if ( ! at && exponly ) { if ( IS_MODE_RAD ( mode ) ) { r_cons_printf ( ""fs exports\\n"" ) ; } else if ( IS_MODE_NORMAL ( mode ) ) { r_cons_printf ( printHere ? """" : ""[Exports]\\n"" ) ; } } else if ( ! at && ! exponly ) { if ( IS_MODE_RAD ( mode ) ) { r_cons_printf ( ""fs symbols\\n"" ) ; } else if ( IS_MODE_NORMAL ( mode ) ) { r_cons_printf ( printHere ? """" : ""[Symbols]\\n"" ) ; } } if ( IS_MODE_NORMAL ( mode ) ) { r_cons_printf ( ""Num Paddr      Vaddr      Bind     Type Size Name\\n"" ) ; } size_t count = 0 ; r_list_foreach ( symbols , iter , symbol ) { if ( ! symbol -> name ) { continue ; } char * r_symbol_name = r_str_escape_utf8 ( symbol -> name , false , true ) ; ut64 addr = compute_addr ( r -> bin , symbol -> paddr , symbol -> vaddr , va ) ; int len = symbol -> size ? symbol -> size : 32 ; SymName sn = { 0 } ; if ( exponly && ! isAnExport ( symbol ) ) { free ( r_symbol_name ) ; continue ; } if ( name && strcmp ( r_symbol_name , name ) ) { free ( r_symbol_name ) ; continue ; } if ( at && ( ! symbol -> size || ! is_in_range ( at , addr , symbol -> size ) ) ) { free ( r_symbol_name ) ; continue ; } if ( ( printHere && ! is_in_range ( r -> offset , symbol -> paddr , len ) ) && ( printHere && ! is_in_range ( r -> offset , addr , len ) ) ) { free ( r_symbol_name ) ; continue ; } count ++ ; snInit ( r , & sn , symbol , lang ) ; if ( IS_MODE_SET ( mode ) && ( is_section_symbol ( symbol ) || is_file_symbol ( symbol ) ) ) { } else if ( IS_MODE_SET ( mode ) && is_special_symbol ( symbol ) ) { if ( is_arm ) { handle_arm_special_symbol ( r , symbol , va ) ; } } else if ( IS_MODE_SET ( mode ) ) { if ( is_arm ) { handle_arm_symbol ( r , symbol , info , va ) ; } select_flag_space ( r , symbol ) ; if ( sn . classname ) { RFlagItem * fi = r_flag_get ( r -> flags , sn . methflag ) ; if ( r -> bin -> prefix ) { char * prname = r_str_newf ( ""%s.%s"" , r -> bin -> prefix , sn . methflag ) ; r_name_filter ( sn . methflag , - 1 ) ; free ( sn . methflag ) ; sn . methflag = prname ; } if ( fi ) { r_flag_item_set_realname ( fi , sn . methname ) ; if ( ( fi -> offset - r -> flags -> base ) == addr ) { r_flag_unset ( r -> flags , fi ) ; } } else { fi = r_flag_set ( r -> flags , sn . methflag , addr , symbol -> size ) ; char * comment = fi -> comment ? strdup ( fi -> comment ) : NULL ; if ( comment ) { r_flag_item_set_comment ( fi , comment ) ; R_FREE ( comment ) ; } } } else { const char * n = sn . demname ? sn . demname : sn . name ; const char * fn = sn . demflag ? sn . demflag : sn . nameflag ; char * fnp = ( r -> bin -> prefix ) ? r_str_newf ( ""%s.%s"" , r -> bin -> prefix , fn ) : strdup ( fn ) ; RFlagItem * fi = r_flag_set ( r -> flags , fnp , addr , symbol -> size ) ; if ( fi ) { r_flag_item_set_realname ( fi , n ) ; fi -> demangled = ( bool ) ( size_t ) sn . demname ; } else { if ( fn ) { eprintf ( ""[Warning] Can\'t find flag (%s)\\n"" , fn ) ; } } free ( fnp ) ; } if ( sn . demname ) { r_meta_add ( r -> anal , R_META_TYPE_COMMENT , addr , symbol -> size , sn . demname ) ; } r_flag_space_pop ( r -> flags ) ; } else if ( IS_MODE_JSON ( mode ) ) { char * str = r_str_escape_utf8_for_json ( r_symbol_name , - 1 ) ; r_cons_printf ( ""%s{\\""name\\"":\\""%s\\"","" ""\\""demname\\"":\\""%s\\"","" ""\\""flagname\\"":\\""%s\\"","" ""\\""ordinal\\"":%d,"" ""\\""bind\\"":\\""%s\\"","" ""\\""size\\"":%d,"" ""\\""type\\"":\\""%s\\"","" ""\\""vaddr\\"":%"" PFMT64d "","" ""\\""paddr\\"":%"" PFMT64d ""}"" , ( ( exponly && firstexp ) || printHere ) ? """" : ( iter -> p ? "","" : """" ) , str , sn . demname ? sn . demname : """" , sn . nameflag , symbol -> ordinal , symbol -> bind , ( int ) symbol -> size , symbol -> type , ( ut64 ) addr , ( ut64 ) symbol -> paddr ) ; free ( str ) ; } else if ( IS_MODE_SIMPLE ( mode ) ) { const char * name = sn . demname ? sn . demname : r_symbol_name ; r_cons_printf ( ""0x%08"" PFMT64x "" %d %s\\n"" , addr , ( int ) symbol -> size , name ) ; } else if ( IS_MODE_SIMPLEST ( mode ) ) { const char * name = sn . demname ? sn . demname : r_symbol_name ; r_cons_printf ( ""%s\\n"" , name ) ; } else if ( IS_MODE_RAD ( mode ) ) { if ( is_special_symbol ( symbol ) ) { goto next ; } RBinFile * binfile ; RBinPlugin * plugin ; const char * name = sn . demname ? sn . demname : r_symbol_name ; if ( ! name ) { goto next ; } if ( ! strncmp ( name , ""imp."" , 4 ) ) { if ( lastfs != 'i' ) { r_cons_printf ( ""fs imports\\n"" ) ; } lastfs = 'i' ; } else { if ( lastfs != 's' ) { const char * fs = exponly ? ""exports"" : ""symbols"" ; r_cons_printf ( ""fs %s\\n"" , fs ) ; } lastfs = 's' ; } if ( r -> bin -> prefix || * name ) { char * flagname = construct_symbol_flagname ( ""sym"" , name , MAXFLAG_LEN_DEFAULT ) ; if ( ! flagname ) { goto next ; } r_cons_printf ( ""\\""f %s%s%s %u 0x%08"" PFMT64x ""\\""\\n"" , r -> bin -> prefix ? r -> bin -> prefix : """" , r -> bin -> prefix ? ""."" : """" , flagname , symbol -> size , addr ) ; free ( flagname ) ; } binfile = r_bin_cur ( r -> bin ) ; plugin = r_bin_file_cur_plugin ( binfile ) ; if ( plugin && plugin -> name ) { if ( r_str_startswith ( plugin -> name , ""pe"" ) ) { char * module = strdup ( r_symbol_name ) ; char * p = strstr ( module , "".dll_"" ) ; if ( p && strstr ( module , ""imp."" ) ) { char * symname = __filterShell ( p + 5 ) ; char * m = __filterShell ( module ) ; * p = 0 ; if ( r -> bin -> prefix ) { <StartBug> r_cons_printf ( ""k bin/pe/%s/%d=%s.%s\\n"" , <EndBug> module , symbol -> ordinal , r -> bin -> prefix , symname ) ; } else { <StartBug> r_cons_printf ( ""k bin/pe/%s/%d=%s\\n"" , <EndBug> module , symbol -> ordinal , symname ) ; } free ( symname ) ; free ( m ) ; } free ( module ) ; } } } else { const char * bind = symbol -> bind ? symbol -> bind : ""NONE"" ; const char * type = symbol -> type ? symbol -> type : ""NONE"" ; const char * name = r_str_get ( sn . demname ? sn . demname : r_symbol_name ) ; r_cons_printf ( ""%03u"" , symbol -> ordinal ) ; if ( symbol -> paddr == UT64_MAX ) { r_cons_printf ( "" ----------"" ) ; } else { r_cons_printf ( "" 0x%08"" PFMT64x , symbol -> paddr ) ; } r_cons_printf ( "" 0x%08"" PFMT64x "" %6s %6s %4d%s%s\\n"" , addr , bind , type , symbol -> size , * name ? "" "" : """" , name ) ; } next : snFini ( & sn ) ; i ++ ; free ( r_symbol_name ) ; if ( exponly && firstexp ) { firstexp = false ; } if ( printHere ) { break ; } } if ( count == 0 && IS_MODE_JSON ( mode ) ) { r_cons_printf ( ""{}"" ) ; } if ( is_arm ) { r_list_foreach ( entries , iter , entry ) { if ( IS_MODE_SET ( mode ) ) { handle_arm_entry ( r , entry , info , va ) ; } } } if ( IS_MODE_JSON ( mode ) && ! printHere ) { r_cons_printf ( ""]"" ) ; } r_spaces_pop ( & r -> anal -> meta_spaces ) ; return true ; }
","<S2SV_ModStart> { r_cons_printf ( ""\\""k bin/pe/%s/%d=%s.%s\\""\\n"" <S2SV_ModEnd> , module , <S2SV_ModStart> { r_cons_printf ( ""\\""k bin/pe/%s/%d=%s\\""\\n"" <S2SV_ModEnd> , module ,
",radareorg@radare2/5411543a310a470b1257fb93273cdd6e8dfcb3af,CVE-2019-16718,https://github.com/radareorg/radare2/commit/5411543a310a470b1257fb93273cdd6e8dfcb3af,2019-09-23T14:15Z,"<S2SV_ModStart> { r_cons_printf ( ""\\n"" ) ; } else if ( IS_MODE_RAD ( mode ) ) { r_cons_printf ( ""fs exports\\n"" ) ; } else if ( IS_MODE_NORMAL ( mode ) ) { r_cons_printf ( ""fs symbols\\n"" ) ; } else if ( IS_MODE_SET ( mode ) ) { r_flag_space_set ( r -> flags, R_FLAGS_FS_SYMBOLS ) ; } else if ( IS_MODE_RAD ( mode ) ) { r_cons_printf ( ""fs symbols\\n"" ) ; } else if ( IS_MODE_NORMAL ( mode ) ) { r_cons_printf ( ""fs symbols\\n"" ) ; } } else if ( IS_MODE_SET ( mode ) ) { r_flag_space_set ( r -> flags, R_FLAGS_FS_SYMBOLS ) ; } else if (! exponly ) { if ( IS_MODE_RAD ( mode ) ) { r_cons_printf ( ""fs symbols\\n"" ) ; } else if ( IS_MODE_NORMAL ( mode ) ) { r_",0
1502,CWE-78,"static char * __filterShell ( const char * arg ) { r_return_val_if_fail ( arg , NULL ) ; char * a = malloc ( strlen ( arg ) + 1 ) ; if ( ! a ) { return NULL ; } char * b = a ; while ( * arg ) { <StartBug> switch ( * arg ) { <EndBug> case '@' : case '`' : case '|' : case ';' : <StartBug> case '\\n' : <EndBug> break ; default : <StartBug> * b ++ = * arg ; <EndBug> break ; } arg ++ ; } * b = 0 ; return a ; }
","<S2SV_ModStart> arg ) { char ch = * arg ; switch ( ch <S2SV_ModEnd> ) { case <S2SV_ModStart> ';' : case '=' : case <S2SV_ModStart> b ++ = ch <S2SV_ModEnd> ; break ;
",radareorg@radare2/5411543a310a470b1257fb93273cdd6e8dfcb3af,CVE-2019-16718,https://github.com/radareorg/radare2/commit/5411543a310a470b1257fb93273cdd6e8dfcb3af,2019-09-23T14:15Z,<S2SV_ModStart> arg ) { char ch = * arg ; switch ( ch <S2SV_ModEnd> ) { case <S2SV_ModStart> ';' : case '=' : case <S2SV_ModStart> b ++ = ch <S2SV_ModEnd> ; break ;,1
