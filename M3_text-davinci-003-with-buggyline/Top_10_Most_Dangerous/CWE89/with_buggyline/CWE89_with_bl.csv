Unnamed: 0,cwe_id,source,target,project_and_commit_id,cve_id,original_address,time,raw_predictions,correctly_predicted
57,CWE-89,"static CURLcode smtp_connect ( struct connectdata * conn , bool * done ) { CURLcode result ; struct smtp_conn * smtpc = & conn -> proto . smtpc ; struct SessionHandle * data = conn -> data ; struct pingpong * pp = & smtpc -> pp ; <StartBug> const char * path = conn -> data -> state . path ; <EndBug> int len ; char localhost [ HOSTNAME_MAX + 1 ] ; * done = FALSE ; Curl_reset_reqproto ( conn ) ; result = smtp_init ( conn ) ; if ( CURLE_OK != result ) return result ; conn -> bits . close = FALSE ; pp -> response_time = RESP_TIMEOUT ; pp -> statemach_act = smtp_statemach_act ; pp -> endofresp = smtp_endofresp ; pp -> conn = conn ; if ( conn -> bits . tunnel_proxy && conn -> bits . httpproxy ) { struct HTTP http_proxy ; struct FTP * smtp_save ; smtp_save = data -> state . proto . smtp ; memset ( & http_proxy , 0 , sizeof ( http_proxy ) ) ; data -> state . proto . http = & http_proxy ; result = Curl_proxyCONNECT ( conn , FIRSTSOCKET , conn -> host . name , conn -> remote_port ) ; data -> state . proto . smtp = smtp_save ; if ( CURLE_OK != result ) return result ; } if ( ( conn -> handler -> protocol & CURLPROTO_SMTPS ) && data -> state . used_interface != Curl_if_multi ) { result = Curl_ssl_connect ( conn , FIRSTSOCKET ) ; if ( result ) return result ; } Curl_pp_init ( pp ) ; pp -> response_time = RESP_TIMEOUT ; pp -> statemach_act = smtp_statemach_act ; pp -> endofresp = smtp_endofresp ; pp -> conn = conn ; if ( ! * path ) { if ( ! Curl_gethostname ( localhost , sizeof localhost ) ) path = localhost ; else path = ""localhost"" ; } <StartBug> smtpc -> domain = curl_easy_unescape ( conn -> data , path , 0 , & len ) ; <EndBug> if ( ! smtpc -> domain ) return CURLE_OUT_OF_MEMORY ; state ( conn , SMTP_SERVERGREET ) ; if ( data -> state . used_interface == Curl_if_multi ) result = smtp_multi_statemach ( conn , done ) ; else { result = smtp_easy_statemach ( conn ) ; if ( ! result ) * done = TRUE ; } return result ; }
","<S2SV_ModStart> state . path <S2SV_ModEnd> ; char localhost <S2SV_ModStart> ""localhost"" ; } result = Curl_urldecode ( conn -> data , path , 0 , & <S2SV_ModStart> smtpc -> domain , NULL , TRUE ) ; if ( result ) return result <S2SV_ModEnd> ; state (
",bagder@curl/75ca568fa1c19de4c5358fed246686de8467c238,CVE-2012-0036,https://github.com/bagder/curl/commit/75ca568fa1c19de4c5358fed246686de8467c238,2012-04-13T20:55Z,"<S2SV_ModStart> -> pp ; <S2SV_ModEnd> * done = <S2SV_ModStart> ""localhost"" ; } <S2SV_ModEnd> curl_easy_unescape ( conn <S2SV_ModStart> len ) ; <S2SV_ModEnd> state ( conn",0
1063,CWE-89,"static CURLcode pop3_parse_url_path ( struct connectdata * conn ) { struct pop3_conn * pop3c = & conn -> proto . pop3c ; struct SessionHandle * data = conn -> data ; const char * path = data -> state . path ; <StartBug> pop3c -> mailbox = curl_easy_unescape ( data , path , 0 , NULL ) ; <EndBug> <StartBug> if ( ! pop3c -> mailbox ) <EndBug> return CURLE_OUT_OF_MEMORY ; return CURLE_OK ; }
","<S2SV_ModStart> . path ; return Curl_urldecode <S2SV_ModEnd> ( data , <S2SV_ModStart> , 0 , & <S2SV_ModEnd> pop3c -> mailbox <S2SV_ModStart> pop3c -> mailbox , NULL , TRUE ) <S2SV_ModEnd> ; } <S2SV_null>
",bagder@curl/75ca568fa1c19de4c5358fed246686de8467c238,CVE-2012-0036,https://github.com/bagder/curl/commit/75ca568fa1c19de4c5358fed246686de8467c238,2012-04-13T20:55Z,<S2SV_ModStart>. path ; char * mailbox ; if ( strlen ( path ) >= MAX_PATH ) return CURLE_OUT_OF_MEMORY ; <S2SV_ModStart> mailbox ) ; if (! mailbox ) return CURLE_OUT_OF_MEMORY ;,0
1484,CWE-89,"char * curl_easy_escape ( CURL * handle , const char * string , int inlength ) { size_t alloc = ( inlength ? ( size_t ) inlength : strlen ( string ) ) + 1 ; char * ns ; char * testing_ptr = NULL ; unsigned char in ; size_t newlen = alloc ; <StartBug> int strindex = 0 ; <EndBug> size_t length ; CURLcode res ; ns = malloc ( alloc ) ; if ( ! ns ) return NULL ; length = alloc - 1 ; while ( length -- ) { in = * string ; if ( Curl_isunreserved ( in ) ) ns [ strindex ++ ] = in ; else { newlen += 2 ; if ( newlen > alloc ) { alloc *= 2 ; testing_ptr = realloc ( ns , alloc ) ; if ( ! testing_ptr ) { free ( ns ) ; return NULL ; } else { ns = testing_ptr ; } } res = Curl_convert_to_network ( handle , & in , 1 ) ; if ( res ) { free ( ns ) ; return NULL ; } snprintf ( & ns [ strindex ] , 4 , ""%%%02X"" , in ) ; strindex += 3 ; } string ++ ; } ns [ strindex ] = 0 ; return ns ; }
","<S2SV_ModStart> = alloc ; size_t <S2SV_ModEnd> strindex = 0
",bagder@curl/75ca568fa1c19de4c5358fed246686de8467c238,CVE-2012-0036,https://github.com/bagder/curl/commit/75ca568fa1c19de4c5358fed246686de8467c238,2012-04-13T20:55Z,<S2SV_ModStart> = alloc ; size_t <S2SV_ModEnd> strindex = 0,1
1671,CWE-89,"char * curl_easy_unescape ( CURL * handle , const char * string , int length , int * olen ) { <StartBug> int alloc = ( length ? length : ( int ) strlen ( string ) ) + 1 ; <EndBug> char * ns = malloc ( alloc ) ; unsigned char in ; int strindex = 0 ; unsigned long hex ; <StartBug> CURLcode res ; <EndBug> if ( ! ns ) return NULL ; while ( -- alloc > 0 ) { in = * string ; if ( ( '%' == in ) && ISXDIGIT ( string [ 1 ] ) && ISXDIGIT ( string [ 2 ] ) ) { char hexstr [ 3 ] ; char * ptr ; hexstr [ 0 ] = string [ 1 ] ; hexstr [ 1 ] = string [ 2 ] ; hexstr [ 2 ] = 0 ; hex = strtoul ( hexstr , & ptr , 16 ) ; in = curlx_ultouc ( hex ) ; <StartBug> res = Curl_convert_from_network ( handle , & in , 1 ) ; <EndBug> <StartBug> if ( res ) { <EndBug> free ( ns ) ; return NULL ; } string += 2 ; alloc -= 2 ; } ns [ strindex ++ ] = in ; string ++ ; } ns [ strindex ] = 0 ; if ( olen ) <StartBug> * olen = strindex ; <EndBug> return ns ; }
","<S2SV_ModStart> olen ) { char * str = NULL ; size_t inputlen = length ; size_t outputlen <S2SV_ModEnd> ; CURLcode res <S2SV_ModStart> ; CURLcode res = Curl_urldecode <S2SV_ModEnd> ( handle , <S2SV_ModStart> ( handle , string , inputlen , & str , & outputlen , FALSE <S2SV_ModEnd> ) ; if <S2SV_ModStart> ( res ) return NULL <S2SV_ModEnd> ; if ( <S2SV_ModStart> * olen = curlx_uztosi ( outputlen ) ; return str <S2SV_ModEnd> ; } <S2SV_null>
",bagder@curl/75ca568fa1c19de4c5358fed246686de8467c238,CVE-2012-0036,https://github.com/bagder/curl/commit/75ca568fa1c19de4c5358fed246686de8467c238,2012-04-13T20:55Z,"<S2SV_ModStart> len ) { size_t <S2SV_ModEnd> alloc = ( <S2SV_ModStart> ( length? ( size_t ) length : ( size_t ) strlen ( string ) ) + 1 ; char * ns = malloc ( alloc ) ; if (! ns ) return NULL ; int strindex = 0 ; CURLcode res ; if ( alloc < 2 ) return NULL ; alloc -= 2 ; in = curlx_ultouc ( hex ) ; res = Curl_convert_from_network ( handle, & in, 1 ) ; if ( res ) { free ( ns ) ; return NULL ; } ns [ strindex ++ ] = in ; string ++ ; alloc -= 2 ; } ns [ strindex ++ ] = 0 ; if ( olen ) * olen = strindex ; return ns ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>",0
1691,CWE-89,"char * curl_easy_unescape ( CURL * handle , const char * string , int length , int * olen ) { <StartBug> int alloc = ( length ? length : ( int ) strlen ( string ) ) + 1 ; <EndBug> char * ns = malloc ( alloc ) ; unsigned char in ; int strindex = 0 ; unsigned long hex ; <StartBug> CURLcode res ; <EndBug> if ( ! ns ) return NULL ; while ( -- alloc > 0 ) { in = * string ; if ( ( '%' == in ) && ISXDIGIT ( string [ 1 ] ) && ISXDIGIT ( string [ 2 ] ) ) { char hexstr [ 3 ] ; char * ptr ; hexstr [ 0 ] = string [ 1 ] ; hexstr [ 1 ] = string [ 2 ] ; hexstr [ 2 ] = 0 ; hex = strtoul ( hexstr , & ptr , 16 ) ; in = curlx_ultouc ( hex ) ; <StartBug> res = Curl_convert_from_network ( handle , & in , 1 ) ; <EndBug> <StartBug> if ( res ) { <EndBug> free ( ns ) ; return NULL ; } string += 2 ; alloc -= 2 ; } ns [ strindex ++ ] = in ; string ++ ; } ns [ strindex ] = 0 ; if ( olen ) <StartBug> * olen = strindex ; <EndBug> return ns ; }
","<S2SV_ModStart> olen ) { char * str = NULL ; size_t inputlen = length ; size_t outputlen <S2SV_ModEnd> ; CURLcode res <S2SV_ModStart> ; CURLcode res = Curl_urldecode <S2SV_ModEnd> ( handle , <S2SV_ModStart> ( handle , string , inputlen , & str , & outputlen , FALSE <S2SV_ModEnd> ) ; if <S2SV_ModStart> ( res ) return NULL <S2SV_ModEnd> ; if ( <S2SV_ModStart> * olen = curlx_uztosi ( outputlen ) ; return str <S2SV_ModEnd> ; } <S2SV_null>
",bagder@curl/75ca568fa1c19de4c5358fed246686de8467c238,CVE-2012-0036,https://github.com/bagder/curl/commit/75ca568fa1c19de4c5358fed246686de8467c238,2012-04-13T20:55Z,"<S2SV_ModStart> len ) { size_t <S2SV_ModEnd> alloc = ( <S2SV_ModStart> ( length? ( size_t ) length : ( size_t ) strlen ( string ) ) + 1 ; char * ns = malloc ( alloc ) ; if (! ns ) return NULL ; int strindex = 0 ; CURLcode res ; if ( alloc < 2 ) return NULL ; alloc -= 2 ; in = curlx_ultouc ( hex ) ; res = Curl_convert_from_network ( handle, & in, 1 ) ; if ( res ) { free ( ns ) ; return NULL ; } ns [ strindex ++ ] = in ; string ++ ; alloc -= 2 ; } ns [ strindex ++ ] = 0 ; if ( olen ) * olen = strindex ; return ns ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>",0
