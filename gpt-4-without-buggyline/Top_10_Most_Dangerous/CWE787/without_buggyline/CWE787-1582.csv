Original code,Plausible Program,Total Tokens,Sum Entropy,Mean Entropy
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
void jslTokenAsString ( int token , char * str , size_t len ) { if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; return ; case LEX_ID : strncpy ( str , ""ID"" , len ) ; return ; case LEX_INT : strncpy ( str , ""INT"" , len ) ; return ; case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; return ; case LEX_STR : strncpy ( str , ""STRING"" , len ) ; return ; case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len ) ; return ; case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; return ; case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; return ; case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; return ; case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len ) ; return ; case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; return ; } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; strncpy ( str , & tokenNames [ p ] , len ) ; return ; } assert ( len >= 10 ) ; espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }
Fixed code:","
void jslTokenAsString ( int token , char * str , size_t len ) { if ( token > 32 && token < 128 ) { if (len < 4) { return; } str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { case LEX_EOF : if (len < 3) { return; } strncpy ( str , ""EOF"" , len ) ; return ; case LEX_ID : if (len < 2) { return; } strncpy ( str , ""ID"" , len ) ; return ; case LEX_INT : if (len < 3) { return; } strncpy ( str , ""INT"" , len ) ; return ; case LEX_FLOAT : if (len < 5) { return; } strncpy ( str , ""FLOAT"" , len ) ; return ; case LEX_STR : if (len < 6) { return; } strncpy ( str , ""STRING"" , len ) ; return ; case LEX_UNFINISHED_STR : if (len < 15) { return; } strncpy ( str , ""UNFINISHED STRING"" , len ) ; return ; case LEX_TEMPLATE_LITERAL : if (len < 15) { return; } strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; return ; case LEX_UNFINISHED_TEMPLATE_LITERAL : if (len < 26) { return; } strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; return ; case LEX_REGEX : if (len < 5) { return; } strncpy ( str , ""REGEX"" , len ) ; return ; case LEX_UNFINISHED_REGEX : if (len < 16) { return; } strncpy ( str , ""UNFINISHED REGEX"" , len ) ; return ; case LEX_UNFINISHED_COMMENT : if (len < 18) { return; } strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; return ; } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) { p ++ ; } p ++ ; n -- ; } assert ( n == 0 ) ; if (len < (p + 1)) { return; } strncpy ( str , & tokenNames [ p ] , len ) ; return ; } if (len < 10) { return; } espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }",989,-25.242432547166143,-0.025523187610885886
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
void jslTokenAsString ( int token , char * str , size_t len ) { if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; return ; case LEX_ID : strncpy ( str , ""ID"" , len ) ; return ; case LEX_INT : strncpy ( str , ""INT"" , len ) ; return ; case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; return ; case LEX_STR : strncpy ( str , ""STRING"" , len ) ; return ; case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len ) ; return ; case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; return ; case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; return ; case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; return ; case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len ) ; return ; case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; return ; } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; strncpy ( str , & tokenNames [ p ] , len ) ; return ; } assert ( len >= 10 ) ; espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }
Fixed code:","
void jslTokenAsString ( int token , char * str , size_t len ) {
  if ( token > 32 && token < 128 ) {
    assert ( len >= 4 ) ;
    str [ 0 ] = '\\'' ;
    str [ 1 ] = ( char ) token ;
    str [ 2 ] = '\\'' ;
    str [ 3 ] = 0 ;
    return ;
  }
  switch ( token ) {
    case LEX_EOF :
      strncpy ( str , ""EOF"" , len - 1 ) ;
      return ;
    case LEX_ID :
      strncpy ( str , ""ID"" , len - 1 ) ;
      return ;
    case LEX_INT :
      strncpy ( str , ""INT"" , len - 1 ) ;
      return ;
    case LEX_FLOAT :
      strncpy ( str , ""FLOAT"" , len - 1 ) ;
      return ;
    case LEX_STR :
      strncpy ( str , ""STRING"" , len - 1 ) ;
      return ;
    case LEX_UNFINISHED_STR :
      strncpy ( str , ""UNFINISHED STRING"" , len - 1 ) ;
      return ;
    case LEX_TEMPLATE_LITERAL :
      strncpy ( str , ""TEMPLATE LITERAL"" , len - 1 ) ;
      return ;
    case LEX_UNFINISHED_TEMPLATE_LITERAL :
      strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len - 1 ) ;
      return ;
    case LEX_REGEX :
      strncpy ( str , ""REGEX"" , len - 1 ) ;
      return ;
    case LEX_UNFINISHED_REGEX :
      strncpy ( str , ""UNFINISHED REGEX"" , len - 1 ) ;
      return ;
    case LEX_UNFINISHED_COMMENT :
      strncpy ( str , ""UNFINISHED COMMENT"" , len - 1 ) ;
      return ;
  }
  if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) {
    const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ;
    unsigned int p = 0 ;
    int n = token - _LEX_OPERATOR_START ;
    while ( n > 0 && p < sizeof ( tokenNames ) ) {
      while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ;
      p ++ ;
      n -- ;
    }
    assert ( n == 0 ) ;
    strncpy ( str , & tokenNames [ p ] , len - 1 ) ;
    return ;
  }
  assert ( len >= 10 ) ;
  espruino_snprintf ( str , len - 1 , ""?[%d]"" , token ) ;
",1000,-9.924640599253152,-0.009924640599253153
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
void jslTokenAsString ( int token , char * str , size_t len ) { if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; return ; case LEX_ID : strncpy ( str , ""ID"" , len ) ; return ; case LEX_INT : strncpy ( str , ""INT"" , len ) ; return ; case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; return ; case LEX_STR : strncpy ( str , ""STRING"" , len ) ; return ; case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len ) ; return ; case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; return ; case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; return ; case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; return ; case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len ) ; return ; case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; return ; } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; strncpy ( str , & tokenNames [ p ] , len ) ; return ; } assert ( len >= 10 ) ; espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }
Fixed code:","
void jslTokenAsString ( int token , char * str , size_t len ) { if ( token > 32 && token < 128 ) { len = (len > 4) ? 4 : len ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; return ; case LEX_ID : strncpy ( str , ""ID"" , len ) ; return ; case LEX_INT : strncpy ( str , ""INT"" , len ) ; return ; case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; return ; case LEX_STR : strncpy ( str , ""STRING"" , len ) ; return ; case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len ) ; return ; case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; return ; case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; return ; case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; return ; case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len ) ; return ; case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; return ; } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; memcpy ( str, & tokenNames [ p ] , len ) ; return ; } len = (len > 10) ? 10 : len ; espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }",868,-28.465930385149946,-0.03279485067413588
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
void jslTokenAsString ( int token , char * str , size_t len ) { if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; return ; case LEX_ID : strncpy ( str , ""ID"" , len ) ; return ; case LEX_INT : strncpy ( str , ""INT"" , len ) ; return ; case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; return ; case LEX_STR : strncpy ( str , ""STRING"" , len ) ; return ; case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len ) ; return ; case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; return ; case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; return ; case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; return ; case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len ) ; return ; case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; return ; } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; strncpy ( str , & tokenNames [ p ] , len ) ; return ; } assert ( len >= 10 ) ; espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }
Fixed code:","
void jslTokenAsString ( int token , char * str , size_t len ) { 
    if ( token > 32 && token < 128 ) { 
        assert ( len >= 4 ) ; 
        str [ 0 ] = '\\'' ; 
        str [ 1 ] = ( char ) token ; 
        str [ 2 ] = '\\'' ; 
        str [ 3 ] = 0 ; 
        return ; 
    } 
    switch ( token ) { 
        case LEX_EOF : 
            strncpy ( str , ""EOF"" , len-1 ) ; 
            return ; 
        case LEX_ID : 
            strncpy ( str , ""ID"" , len-1 ) ; 
            return ; 
        case LEX_INT : 
            strncpy ( str , ""INT"" , len-1 ) ; 
            return ; 
        case LEX_FLOAT : 
            strncpy ( str , ""FLOAT"" , len-1 ) ; 
            return ; 
        case LEX_STR : 
            strncpy ( str , ""STRING"" , len-1 ) ; 
            return ; 
        case LEX_UNFINISHED_STR : 
            strncpy ( str , ""UNFINISHED STRING"" , len-1 ) ; 
            return ; 
        case LEX_TEMPLATE_LITERAL : 
            strncpy ( str , ""TEMPLATE LITERAL"" , len-1 ) ; 
            return ; 
        case LEX_UNFINISHED_TEMPLATE_LITERAL : 
            strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len-1 ) ; 
            return ; 
        case LEX_REGEX : 
            strncpy ( str , ""REGEX"" , len-1 ) ; 
            return ; 
        case LEX_UNFINISHED_REGEX : 
            strncpy ( str , ""UNFINISHED REGEX"" , len-1 ) ; 
            return ; 
        case LEX_UNFINISHED_COMMENT : 
            strncpy ( str , ""UNFINISHED COMMENT"" , len-1 ) ; 
            return ; 
    } 
    if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { 
        const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; 
        unsigned int p = 0 ; 
        int n = token - _LEX_OPERATOR_START ; 
        while ( n > 0 && p < sizeof ( tokenNames ) ) { 
            while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; 
            p ++ ; 
            n -- ; 
        } 
        assert ( n == 0 ) ; 
        strncpy ( str ,",1000,-8.51201744423943,-0.00851201744423943
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
void jslTokenAsString ( int token , char * str , size_t len ) { if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; return ; case LEX_ID : strncpy ( str , ""ID"" , len ) ; return ; case LEX_INT : strncpy ( str , ""INT"" , len ) ; return ; case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; return ; case LEX_STR : strncpy ( str , ""STRING"" , len ) ; return ; case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len ) ; return ; case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; return ; case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; return ; case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; return ; case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len ) ; return ; case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; return ; } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; strncpy ( str , & tokenNames [ p ] , len ) ; return ; } assert ( len >= 10 ) ; espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }
Fixed code:","
void jslTokenAsString ( int token , char * str , size_t len ) { 
if ( token > 32 && token < 128 ) { 
if (len < 4){ 
return; 
} 
assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; 
} 
switch ( token ) { 
case LEX_EOF : 
if (len < 4){ 
return; 
} 
strncpy ( str , ""EOF"" , len ) ; return ; 
case LEX_ID : 
if (len < 3){ 
return; 
} 
strncpy ( str , ""ID"" , len ) ; return ; 
case LEX_INT : 
if (len < 4){ 
return; 
} 
strncpy ( str , ""INT"" , len ) ; return ; 
case LEX_FLOAT : 
if (len < 6){ 
return; 
} 
strncpy ( str , ""FLOAT"" , len ) ; return ; 
case LEX_STR : 
if (len < 7){ 
return; 
} 
strncpy ( str , ""STRING"" , len ) ; return ; 
case LEX_UNFINISHED_STR : 
if (len < 17){ 
return; 
} 
strncpy ( str , ""UNFINISHED STRING"" , len ) ; return ; 
case LEX_TEMPLATE_LITERAL : 
if (len < 17){ 
return; 
} 
strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; return ; 
case LEX_UNFINISHED_TEMPLATE_LITERAL : 
if (len < 25){ 
return; 
} 
strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; return ; 
case LEX_REGEX : 
if (len < 6){ 
return; 
} 
strncpy ( str , ""REGEX"" , len ) ; return ; 
case LEX_UNFINISHED_REGEX : 
if (len < 17){ 
return; 
} 
strncpy ( str , ""UNFINISHED REGEX"" , len ) ; return ; 
case LEX_UNFINISHED_COMMENT : 
if (len < 21){ 
return; 
} 
strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; return ; 
} 
if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { 
const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; 
unsigned int p = 0 ; 
int n = token - _LEX_OPERATOR",1000,-27.920789155885902,-0.027920789155885903
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
void jslTokenAsString ( int token , char * str , size_t len ) { if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; return ; case LEX_ID : strncpy ( str , ""ID"" , len ) ; return ; case LEX_INT : strncpy ( str , ""INT"" , len ) ; return ; case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; return ; case LEX_STR : strncpy ( str , ""STRING"" , len ) ; return ; case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len ) ; return ; case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; return ; case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; return ; case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; return ; case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len ) ; return ; case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; return ; } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; strncpy ( str , & tokenNames [ p ] , len ) ; return ; } assert ( len >= 10 ) ; espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }
Fixed code:","
void jslTokenAsString ( int token , char * str , size_t len ) { if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { case LEX_EOF : strncpy ( str , ""EOF"" , len - 1 ) ; return ; case LEX_ID : strncpy ( str , ""ID"" , len - 1 ) ; return ; case LEX_INT : strncpy ( str , ""INT"" , len - 1 ) ; return ; case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len - 1 ) ; return ; case LEX_STR : strncpy ( str , ""STRING"" , len - 1 ) ; return ; case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len - 1 ) ; return ; case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len - 1 ) ; return ; case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len - 1 ) ; return ; case LEX_REGEX : strncpy ( str , ""REGEX"" , len - 1 ) ; return ; case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len - 1 ) ; return ; case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len - 1 ) ; return ; } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; strncpy ( str , & tokenNames [ p ] , len - 1 ) ; return ; } assert ( len >= 10 ) ; espruino_snprintf ( str , len - 1 , ""?[%d]"" , token ) ; }",884,-4.1305103153735985,-0.004672522981191854
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
void jslTokenAsString ( int token , char * str , size_t len ) { if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; return ; case LEX_ID : strncpy ( str , ""ID"" , len ) ; return ; case LEX_INT : strncpy ( str , ""INT"" , len ) ; return ; case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; return ; case LEX_STR : strncpy ( str , ""STRING"" , len ) ; return ; case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len ) ; return ; case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; return ; case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; return ; case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; return ; case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len ) ; return ; case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; return ; } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; strncpy ( str , & tokenNames [ p ] , len ) ; return ; } assert ( len >= 10 ) ; espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }
Fixed code:","
void jslTokenAsString ( int token , char * str , size_t len ) { if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { case LEX_EOF : strncpy ( str , ""EOF"" , len-1 ) ; return ; case LEX_ID : strncpy ( str , ""ID"" , len-1 ) ; return ; case LEX_INT : strncpy ( str , ""INT"" , len-1 ) ; return ; case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len-1 ) ; return ; case LEX_STR : strncpy ( str , ""STRING"" , len-1 ) ; return ; case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len-1 ) ; return ; case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len-1 ) ; return ; case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len-1 ) ; return ; case LEX_REGEX : strncpy ( str , ""REGEX"" , len-1 ) ; return ; case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len-1 ) ; return ; case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len-1 ) ; return ; } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; strncpy ( str , & tokenNames [ p ] , len-1 ) ; return ; } assert ( len >= 10 ) ; espruino_snprintf ( str , len-1 , ""?[%d]"" , token ) ; }",884,-4.802441831379361,-0.0054326265060852495
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
void jslTokenAsString ( int token , char * str , size_t len ) { if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; return ; case LEX_ID : strncpy ( str , ""ID"" , len ) ; return ; case LEX_INT : strncpy ( str , ""INT"" , len ) ; return ; case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; return ; case LEX_STR : strncpy ( str , ""STRING"" , len ) ; return ; case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len ) ; return ; case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; return ; case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; return ; case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; return ; case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len ) ; return ; case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; return ; } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; strncpy ( str , & tokenNames [ p ] , len ) ; return ; } assert ( len >= 10 ) ; espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }
Fixed code:","
void jslTokenAsString ( int token , char * str , size_t len ) { if ( token > 32 && token < 128 ) { //assert ( len >= 4 ) ; if (len < 4) return; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { case LEX_EOF : //strncpy ( str , ""EOF"" , len ) ; if (len < 3) return; strncpy ( str , ""EOF"" , len-1 ) ; return ; case LEX_ID : //strncpy ( str , ""ID"" , len ) ; if (len < 2) return; strncpy ( str , ""ID"" , len-1 ) ; return ; case LEX_INT : //strncpy ( str , ""INT"" , len ) ; if (len < 3) return; strncpy ( str , ""INT"" , len-1 ) ; return ; case LEX_FLOAT : //strncpy ( str , ""FLOAT"" , len ) ; if (len < 5) return; strncpy ( str , ""FLOAT"" , len-1 ) ; return ; case LEX_STR : //strncpy ( str , ""STRING"" , len ) ; if (len < 7) return; strncpy ( str , ""STRING"" , len-1 ) ; return ; case LEX_UNFINISHED_STR : //strncpy ( str , ""UNFINISHED STRING"" , len ) ; if (len < 17) return; strncpy ( str , ""UNFINISHED STRING"" , len-1 ) ; return ; case LEX_TEMPLATE_LITERAL : //strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; if (len < 17) return; strncpy ( str , ""TEMPLATE LITERAL"" , len-1 ) ; return ; case LEX_UNFINISHED_TEMPLATE_LITERAL : //strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; if (len < 27) return; strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len-1 ) ; return ; case LEX_REGEX : //strncpy ( str , ""REGEX"" , len ) ; if (len < 5) return; strncpy ( str , ""REGEX"" , len-1 ) ; return ; case LEX_UNFINISHED_REGEX : //strncpy ( str , ""UNFINISHED REGEX"" , len ) ; if (len < 17) return; strncpy ( str , ""UNFINISHED REGEX"" , len-1 ) ; return ; case LEX_UNFINISHED_COMMENT : //strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; if (len < 19) return; strncpy ( str , ""UNFINISHED COMMENT"" , len-1 ) ; return ; } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0",1000,-16.48257130296804,-0.01648257130296804
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
void jslTokenAsString ( int token , char * str , size_t len ) { if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; return ; case LEX_ID : strncpy ( str , ""ID"" , len ) ; return ; case LEX_INT : strncpy ( str , ""INT"" , len ) ; return ; case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; return ; case LEX_STR : strncpy ( str , ""STRING"" , len ) ; return ; case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len ) ; return ; case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; return ; case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; return ; case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; return ; case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len ) ; return ; case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; return ; } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; strncpy ( str , & tokenNames [ p ] , len ) ; return ; } assert ( len >= 10 ) ; espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }
Fixed code:","
void jslTokenAsString ( int token , char * str , size_t len ) { if ( token > 32 && token < 128 ) { if (len < 4) return; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { case LEX_EOF : if (len < 4) return; strncpy ( str , ""EOF"" , len ) ; return ; case LEX_ID : if (len < 4) return; strncpy ( str , ""ID"" , len ) ; return ; case LEX_INT : if (len < 5) return; strncpy ( str , ""INT"" , len ) ; return ; case LEX_FLOAT : if (len < 7) return; strncpy ( str , ""FLOAT"" , len ) ; return ; case LEX_STR : if (len < 8) return; strncpy ( str , ""STRING"" , len ) ; return ; case LEX_UNFINISHED_STR : if (len < 18) return; strncpy ( str , ""UNFINISHED STRING"" , len ) ; return ; case LEX_TEMPLATE_LITERAL : if (len < 17) return; strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; return ; case LEX_UNFINISHED_TEMPLATE_LITERAL : if (len < 28) return; strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; return ; case LEX_REGEX : if (len < 7) return; strncpy ( str , ""REGEX"" , len ) ; return ; case LEX_UNFINISHED_REGEX : if (len < 19) return; strncpy ( str , ""UNFINISHED REGEX"" , len ) ; return ; case LEX_UNFINISHED_COMMENT : if (len < 21) return; strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; return ; } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; if (len < strlen(&tokenNames[p])) return; strncpy ( str , & tokenNames [ p ] , len ) ; return ; } if (len < 10) return; espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }",963,-14.77222098907725,-0.015339793342759344
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
void jslTokenAsString ( int token , char * str , size_t len ) { if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; return ; case LEX_ID : strncpy ( str , ""ID"" , len ) ; return ; case LEX_INT : strncpy ( str , ""INT"" , len ) ; return ; case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; return ; case LEX_STR : strncpy ( str , ""STRING"" , len ) ; return ; case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len ) ; return ; case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; return ; case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; return ; case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; return ; case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len ) ; return ; case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; return ; } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; strncpy ( str , & tokenNames [ p ] , len ) ; return ; } assert ( len >= 10 ) ; espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }
Fixed code:","
void jslTokenAsString ( int token , char * str , size_t len ) { if ( token > 32 && token < 128 ) { snprintf ( str , len , ""\\'%c\\'"" , ( char ) token ) ; return ; } switch ( token ) { case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; return ; case LEX_ID : strncpy ( str , ""ID"" , len ) ; return ; case LEX_INT : strncpy ( str , ""INT"" , len ) ; return ; case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; return ; case LEX_STR : strncpy ( str , ""STRING"" , len ) ; return ; case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len ) ; return ; case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; return ; case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; return ; case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; return ; case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len ) ; return ; case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; return ; } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; strncpy ( str , & tokenNames [ p ] , len ) ; return ; } snprintf ( str , len , ""?[%d]"" , token ) ; }",826,-6.745546869113408,-0.00816652163330921
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
void jslTokenAsString ( int token , char * str , size_t len ) { if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; return ; case LEX_ID : strncpy ( str , ""ID"" , len ) ; return ; case LEX_INT : strncpy ( str , ""INT"" , len ) ; return ; case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; return ; case LEX_STR : strncpy ( str , ""STRING"" , len ) ; return ; case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len ) ; return ; case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; return ; case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; return ; case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; return ; case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len ) ; return ; case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; return ; } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; strncpy ( str , & tokenNames [ p ] , len ) ; return ; } assert ( len >= 10 ) ; espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }
Fixed code:","

void jslTokenAsString ( int token , char * str , size_t len ) { if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { case LEX_EOF : strncpy ( str , ""EOF"" , len - 1 ) ; return ; case LEX_ID : strncpy ( str , ""ID"" , len - 1 ) ; return ; case LEX_INT : strncpy ( str , ""INT"" , len - 1 ) ; return ; case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len - 1 ) ; return ; case LEX_STR : strncpy ( str , ""STRING"" , len - 1 ) ; return ; case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len - 1 ) ; return ; case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len - 1 ) ; return ; case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len - 1 ) ; return ; case LEX_REGEX : strncpy ( str , ""REGEX"" , len - 1 ) ; return ; case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len - 1 ) ; return ; case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len - 1 ) ; return ; } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; strncpy ( str , & tokenNames [ p ] , len - 1 ) ; return ; } assert ( len >= 10 ) ; espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }",883,-8.335536690509311,-0.00944001890204905
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
void jslTokenAsString ( int token , char * str , size_t len ) { if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; return ; case LEX_ID : strncpy ( str , ""ID"" , len ) ; return ; case LEX_INT : strncpy ( str , ""INT"" , len ) ; return ; case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; return ; case LEX_STR : strncpy ( str , ""STRING"" , len ) ; return ; case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len ) ; return ; case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; return ; case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; return ; case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; return ; case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len ) ; return ; case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; return ; } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; strncpy ( str , & tokenNames [ p ] , len ) ; return ; } assert ( len >= 10 ) ; espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }
Fixed code:","
void jslTokenAsString ( int token , char * str , size_t len ) { if ( token > 32 && token < 128 ) { strncpy ( str , ""\'"" , len ) ; strncat ( str, ( char ) token , len - 1 ) ; strncat ( str, ""\'"" , len - 1 ) ; return ; } switch ( token ) { case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; return ; case LEX_ID : strncpy ( str , ""ID"" , len ) ; return ; case LEX_INT : strncpy ( str , ""INT"" , len ) ; return ; case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; return ; case LEX_STR : strncpy ( str , ""STRING"" , len ) ; return ; case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len ) ; return ; case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; return ; case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; return ; case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; return ; case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len ) ; return ; case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; return ; } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; strncpy ( str , & tokenNames [ p ] , len ) ; return ; } assert ( len >= 10 ) ; snprintf ( str , len , ""?[%d]"" , token ) ; }",854,-22.553684843638834,-0.026409467030022053
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
void jslTokenAsString ( int token , char * str , size_t len ) { if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; return ; case LEX_ID : strncpy ( str , ""ID"" , len ) ; return ; case LEX_INT : strncpy ( str , ""INT"" , len ) ; return ; case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; return ; case LEX_STR : strncpy ( str , ""STRING"" , len ) ; return ; case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len ) ; return ; case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; return ; case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; return ; case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; return ; case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len ) ; return ; case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; return ; } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; strncpy ( str , & tokenNames [ p ] , len ) ; return ; } assert ( len >= 10 ) ; espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }
Fixed code:","
void jslTokenAsString ( int token , char * str , size_t len ) { if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { case LEX_EOF : strncpy ( str , ""EOF"" , len-1 ) ; return ; case LEX_ID : strncpy ( str , ""ID"" , len-1 ) ; return ; case LEX_INT : strncpy ( str , ""INT"" , len-1 ) ; return ; case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len-1 ) ; return ; case LEX_STR : strncpy ( str , ""STRING"" , len-1 ) ; return ; case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len-1 ) ; return ; case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len-1 ) ; return ; case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len-1 ) ; return ; case LEX_REGEX : strncpy ( str , ""REGEX"" , len-1 ) ; return ; case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len-1 ) ; return ; case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len-1 ) ; return ; } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; strncpy ( str , & tokenNames [ p ] , len-1 ) ; return ; } assert ( len >= 10 ) ; espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }",882,-4.7877197110963605,-0.005428253640698821
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
void jslTokenAsString ( int token , char * str , size_t len ) { if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; return ; case LEX_ID : strncpy ( str , ""ID"" , len ) ; return ; case LEX_INT : strncpy ( str , ""INT"" , len ) ; return ; case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; return ; case LEX_STR : strncpy ( str , ""STRING"" , len ) ; return ; case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len ) ; return ; case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; return ; case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; return ; case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; return ; case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len ) ; return ; case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; return ; } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; strncpy ( str , & tokenNames [ p ] , len ) ; return ; } assert ( len >= 10 ) ; espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }
Fixed code:","
void jslTokenAsString ( int token , char * str , size_t len ) { 
if ( token > 32 && token < 128 ) { 
assert ( len >= 4 ) ; 
str [ 0 ] = '\\'' ; 
str [ 1 ] = ( char ) token ; 
str [ 2 ] = '\\'' ; 
str [ 3 ] = 0 ; 
return ; 
} 
switch ( token ) { 
case LEX_EOF : 
if (len >= 3) {
strncpy ( str , ""EOF"" , len - 1 ) ; 
str[len - 1] = '\0';
}
return ; 
case LEX_ID : 
if (len >= 2) {
strncpy ( str , ""ID"" , len - 1 ) ; 
str[len - 1] = '\0';
}
return ; 
case LEX_INT : 
if (len >= 3) {
strncpy ( str , ""INT"" , len - 1 ) ; 
str[len - 1] = '\0';
}
return ; 
case LEX_FLOAT : 
if (len >= 5) {
strncpy ( str , ""FLOAT"" , len - 1 ) ; 
str[len - 1] = '\0';
}
return ; 
case LEX_STR : 
if (len >= 6) {
strncpy ( str , ""STRING"" , len - 1 ) ; 
str[len - 1] = '\0';
}
return ; 
case LEX_UNFINISHED_STR : 
if (len >= 16) {
strncpy ( str , ""UNFINISHED STRING"" , len - 1 ) ; 
str[len - 1] = '\0';
}
return ; 
case LEX_TEMPLATE_LITERAL : 
if (len >= 15) {
strncpy ( str , ""TEMPLATE LITERAL"" , len - 1 ) ;
str[len - 1] = '\0'; 
}
return ; 
case LEX_UNFINISHED_TEMPLATE_LITERAL : 
if (len >= 25) {
strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len - 1 ) ; 
str[len - 1] = '\0';
}
return ; 
case LEX_REGEX : 
if (len >= 5) {
strncpy ( str , ""REGEX"" , len - 1 ) ; 
str[len - 1] = '\0';
}
return ; 
case LEX_UNFINISHED_REGEX : 
if (len >= 15) {
strncpy ( str , ""UNFINISHED REGEX"" , len - 1 ) ; 
str[len - 1] = '\0';
}
return ; 
case LEX_UNFINISHED_COMMENT : 
if (len >= 18) {
strncpy ( str , ""UNFINISHED COMMENT"" , len - 1 ) ; 
str[len - 1] = '\0';
}
return ; 
} 
if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { 
const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" """,1000,-26.378217118561814,-0.026378217118561816
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
void jslTokenAsString ( int token , char * str , size_t len ) { if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; return ; case LEX_ID : strncpy ( str , ""ID"" , len ) ; return ; case LEX_INT : strncpy ( str , ""INT"" , len ) ; return ; case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; return ; case LEX_STR : strncpy ( str , ""STRING"" , len ) ; return ; case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len ) ; return ; case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; return ; case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; return ; case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; return ; case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len ) ; return ; case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; return ; } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; strncpy ( str , & tokenNames [ p ] , len ) ; return ; } assert ( len >= 10 ) ; espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }
Fixed code:","
void jslTokenAsString ( int token , char * str , size_t len ) { if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; return ; case LEX_ID : strncpy ( str , ""ID"" , len ) ; return ; case LEX_INT : strncpy ( str , ""INT"" , len ) ; return ; case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; return ; case LEX_STR : strncpy ( str , ""STRING"" , len ) ; return ; case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len ) ; return ; case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; return ; case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; return ; case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; return ; case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len ) ; return ; case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; return ; } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) - 1 ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; strncpy ( str , & tokenNames [ p ] , len ) ; return ; } assert ( len >= 10 ) ; espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }",860,-6.889559708182768,-0.008011115939747404
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
void jslTokenAsString ( int token , char * str , size_t len ) { if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; return ; case LEX_ID : strncpy ( str , ""ID"" , len ) ; return ; case LEX_INT : strncpy ( str , ""INT"" , len ) ; return ; case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; return ; case LEX_STR : strncpy ( str , ""STRING"" , len ) ; return ; case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len ) ; return ; case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; return ; case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; return ; case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; return ; case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len ) ; return ; case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; return ; } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; strncpy ( str , & tokenNames [ p ] , len ) ; return ; } assert ( len >= 10 ) ; espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }
Fixed code:","

void jslTokenAsString ( int token , char * str , size_t len ) { 
if ( token > 32 && token < 128 ) { 
    assert ( len >= 4 ) ; 
    if(len < 4) return;
    str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; 
} 
switch ( token ) { 
    case LEX_EOF : 
        strncpy ( str , ""EOF"" , len ) ; 
        break; 
    case LEX_ID : 
        strncpy ( str , ""ID"" , len ) ; 
        break; 
    case LEX_INT : 
        strncpy ( str , ""INT"" , len ) ; 
        break; 
    case LEX_FLOAT : 
        strncpy ( str , ""FLOAT"" , len ) ; 
        break; 
    case LEX_STR : 
        strncpy ( str , ""STRING"" , len ) ; 
        break; 
    case LEX_UNFINISHED_STR : 
        strncpy ( str , ""UNFINISHED STRING"" , len ) ; 
        break; 
    case LEX_TEMPLATE_LITERAL : 
        strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; 
        break; 
    case LEX_UNFINISHED_TEMPLATE_LITERAL : 
        strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; 
        break; 
    case LEX_REGEX : 
        strncpy ( str , ""REGEX"" , len ) ; 
        break; 
    case LEX_UNFINISHED_REGEX : 
        strncpy ( str , ""UNFINISHED REGEX"" , len ) ; 
        break; 
    case LEX_UNFINISHED_COMMENT : 
        strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; 
        break; 
} 
if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { 
    const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; 
    unsigned int p = 0 ; 
    int n = token - _LEX_OPERATOR_START ; 
    
    while ( n > 0 && p < sizeof ( tokenNames ) ) { 
        while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) 
            p ++ ; 
        p ++ ; 
        n -- ; 
    } 
    assert ( n == 0 ) ;
    size_t tokenNameLen = strlen(&tokenNames[p]);
    if(len < tokenNameLen+1)
        return",1000,-45.177890394951866,-0.04517789039495187
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
void jslTokenAsString ( int token , char * str , size_t len ) { if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; return ; case LEX_ID : strncpy ( str , ""ID"" , len ) ; return ; case LEX_INT : strncpy ( str , ""INT"" , len ) ; return ; case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; return ; case LEX_STR : strncpy ( str , ""STRING"" , len ) ; return ; case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len ) ; return ; case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; return ; case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; return ; case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; return ; case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len ) ; return ; case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; return ; } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; strncpy ( str , & tokenNames [ p ] , len ) ; return ; } assert ( len >= 10 ) ; espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }
Fixed code:","
void jslTokenAsString ( int token , char * str , size_t len ) { if ( token > 32 && token < 128 ) { if ( len >= 4 ) { str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } else { return ; } } switch ( token ) { case LEX_EOF : if ( len >= 3 ) { strncpy ( str , ""EOF"" , len ) ; return ; } else { return ; } case LEX_ID : if ( len >= 2 ) { strncpy ( str , ""ID"" , len ) ; return ; } else { return ; } case LEX_INT : if ( len >= 3 ) { strncpy ( str , ""INT"" , len ) ; return ; } else { return ; } case LEX_FLOAT : if ( len >= 5 ) { strncpy ( str , ""FLOAT"" , len ) ; return ; } else { return ; } case LEX_STR : if ( len >= 6 ) { strncpy ( str , ""STRING"" , len ) ; return ; } else { return ; } case LEX_UNFINISHED_STR : if ( len >= 16 ) { strncpy ( str , ""UNFINISHED STRING"" , len ) ; return ; } else { return ; } case LEX_TEMPLATE_LITERAL : if ( len >= 15 ) { strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; return ; } else { return ; } case LEX_UNFINISHED_TEMPLATE_LITERAL : if ( len >= 25 ) { strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; return ; } else { return ; } case LEX_REGEX : if ( len >= 5 ) { strncpy ( str , ""REGEX"" , len ) ; return ; } else { return ; } case LEX_UNFINISHED_REGEX : if ( len >= 17 ) { strncpy ( str , ""UNFINISHED REGEX"" , len ) ; return ; } else { return ; } case LEX_UNFINISHED_COMMENT : if ( len >= 18 ) { strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; return ; } else { return ; } } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } if ( n == 0 ) { if ( len >= strlen ( & tokenNames [ p ] ) ) { strncpy ( str , & tokenNames [ p ] , len ) ; return ; } else { return ; } }",1000,-15.565199907941672,-0.015565199907941672
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
void jslTokenAsString ( int token , char * str , size_t len ) { if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; return ; case LEX_ID : strncpy ( str , ""ID"" , len ) ; return ; case LEX_INT : strncpy ( str , ""INT"" , len ) ; return ; case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; return ; case LEX_STR : strncpy ( str , ""STRING"" , len ) ; return ; case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len ) ; return ; case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; return ; case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; return ; case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; return ; case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len ) ; return ; case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; return ; } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; strncpy ( str , & tokenNames [ p ] , len ) ; return ; } assert ( len >= 10 ) ; espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }
Fixed code:","
void jslTokenAsString ( int token , char * str , size_t len ) { 
if ( token > 32 && token < 128 ) { 
assert ( len >= 4 ) ; 
str [ 0 ] = '\\'' ; 
str [ 1 ] = ( char ) token ; 
str [ 2 ] = '\\'' ; 
str [ 3 ] = 0 ; 
str [ 4 ] = '\0' ; 
return ; 
} 
switch ( token ) { 
case LEX_EOF : 
strncpy ( str , ""EOF"" , len ) ; 
str [ len - 1 ] = '\0' ; 
return ; 
case LEX_ID : 
strncpy ( str , ""ID"" , len ) ; 
str [ len - 1 ] = '\0' ; 
return ; 
case LEX_INT : 
strncpy ( str , ""INT"" , len ) ; 
str [ len - 1 ] = '\0' ; 
return ; 
case LEX_FLOAT : 
strncpy ( str , ""FLOAT"" , len ) ; 
str [ len - 1 ] = '\0' ; 
return ; 
case LEX_STR : 
strncpy ( str , ""STRING"" , len ) ; 
str [ len - 1 ] = '\0' ; 
return ; 
case LEX_UNFINISHED_STR : 
strncpy ( str , ""UNFINISHED STRING"" , len ) ; 
str [ len - 1 ] = '\0' ; 
return ; 
case LEX_TEMPLATE_LITERAL : 
strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; 
str [ len - 1 ] = '\0' ; 
return ; 
case LEX_UNFINISHED_TEMPLATE_LITERAL : 
strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; 
str [ len - 1 ] = '\0' ; 
return ; 
case LEX_REGEX : 
strncpy ( str , ""REGEX"" , len ) ; 
str [ len - 1 ] = '\0' ; 
return ; 
case LEX_UNFINISHED_REGEX : 
strncpy ( str , ""UNFINISHED REGEX"" , len ) ; 
str [ len - 1 ] = '\0' ; 
return ; 
case LEX_UNFINISHED_COMMENT : 
strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; 
str [ len - 1 ] = '\0' ; 
return ; 
} 
if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { 
const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; 
unsigned",1000,-12.428931870582733,-0.012428931870582733
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
void jslTokenAsString ( int token , char * str , size_t len ) { if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; return ; case LEX_ID : strncpy ( str , ""ID"" , len ) ; return ; case LEX_INT : strncpy ( str , ""INT"" , len ) ; return ; case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; return ; case LEX_STR : strncpy ( str , ""STRING"" , len ) ; return ; case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len ) ; return ; case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; return ; case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; return ; case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; return ; case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len ) ; return ; case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; return ; } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; strncpy ( str , & tokenNames [ p ] , len ) ; return ; } assert ( len >= 10 ) ; espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }
Fixed code:","
void jslTokenAsString(int token, char *str, size_t len) {
  if (token > 32 && token < 128) {
    assert(len >= 4);
    str[0] = '\\'';
    str[1] = (char)token;
    str[2] = '\\'';
    str[3] = 0;
    return;
  }
  switch (token) {
    case LEX_EOF:
      str[0] = 'E';
      str[1] = 'O';
      str[2] = 'F';
      str[3] = 0;
      return;
    case LEX_ID:
      str[0] = 'I';
      str[1] = 'D';
      str[2] = 0;
      return;
    case LEX_INT:
      str[0] = 'I';
      str[1] = 'N';
      str[2] = 'T';
      str[3] = 0;
      return;
    case LEX_FLOAT:
      str[0] = 'F';
      str[1] = 'L';
      str[2] = 'O';
      str[3] = 'A';
      str[4] = 'T';
      str[5] = 0;
      return;
    case LEX_STR:
      str[0] = 'S';
      str[1] = 'T';
      str[2] = 'R';
      str[3] = 'I';
      str[4] = 'N';
      str[5] = 'G';
      str[6] = 0;
      return;
    case LEX_UNFINISHED_STR:
      str[0] = 'U';
      str[1] = 'N';
      str[2] = 'F';
      str[3] = 'I';
      str[4] = 'N';
      str[5] = 'I';
      str[6] = 'S';
      str[7] = 'H';
      str[8] = 'E';
      str[9] = 'D';
      str[10] = ' ';
      str[11] = 'S';
      str[12] = 'T';
      str[13] = 'R';
      str[14] = 'I';
      str[15] = 'N';
      str[16] = 'G';
      str[17] = 0;
      return;
    case LEX_TEMPLATE_LITERAL:
      str[0] = 'T';
      str[1] = 'E';
      str[2] = 'M';
      str[3] = 'P';
      str[4] = 'L';
      str[5] = 'A';
      str[6] = 'T';
      str[7] = 'E';
      str[8] = ' ';
      str[9] = 'L';
      str[10] = 'I';
      str[11] = 'T';
      str[12] = 'E';
      str[13] = 'R';
      str[14] = 'A';
      str[15] = 'L';
      str[16] = 0;
      return;
    case LEX_UNFINISHED_TEMPLATE_LITERAL:
      str[0] = 'U';
      str[1] = 'N';
      str[2] = 'F';
      str[3] = 'I';
      str[4] = 'N';
      str[5] = 'I';
      str[6] = 'S';
      str[7] = 'H';
      str[8] = 'E';
      str[9] = 'D';
      str[10] = ' ';
      str[11] = 'T';
      str[12] = 'E';
      str[13] = 'M';
      str[14] = 'P';
      str[15] = 'L';
      str[16] = 'A';
      str[17] = 'T';
      str[18] = 'E';
      str[19] = ' ';
",1000,-15.708126501244912,-0.015708126501244913
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
void jslTokenAsString ( int token , char * str , size_t len ) { if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; return ; case LEX_ID : strncpy ( str , ""ID"" , len ) ; return ; case LEX_INT : strncpy ( str , ""INT"" , len ) ; return ; case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; return ; case LEX_STR : strncpy ( str , ""STRING"" , len ) ; return ; case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len ) ; return ; case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; return ; case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; return ; case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; return ; case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len ) ; return ; case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; return ; } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; strncpy ( str , & tokenNames [ p ] , len ) ; return ; } assert ( len >= 10 ) ; espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }
Fixed code:","
void jslTokenAsString ( int token , char * str , size_t len ) { if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { case LEX_EOF : strncpy ( str , ""EOF"" , len - 1 ) ; return ; case LEX_ID : strncpy ( str , ""ID"" , len - 1 ) ; return ; case LEX_INT : strncpy ( str , ""INT"" , len - 1 ) ; return ; case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len - 1 ) ; return ; case LEX_STR : strncpy ( str , ""STRING"" , len - 1 ) ; return ; case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len - 1 ) ; return ; case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len - 1 ) ; return ; case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len - 1 ) ; return ; case LEX_REGEX : strncpy ( str , ""REGEX"" , len - 1 ) ; return ; case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len - 1 ) ; return ; case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len - 1 ) ; return ; } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; strncpy ( str , & tokenNames [ p ] , len - 1 ) ; return ; } assert ( len >= 10 ) ; espruino_snprintf ( str , len - 1 , ""?[%d]"" , token ) ; }",884,-4.188989258282932,-0.004738675631541778
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
void jslTokenAsString ( int token , char * str , size_t len ) { if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; return ; case LEX_ID : strncpy ( str , ""ID"" , len ) ; return ; case LEX_INT : strncpy ( str , ""INT"" , len ) ; return ; case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; return ; case LEX_STR : strncpy ( str , ""STRING"" , len ) ; return ; case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len ) ; return ; case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; return ; case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; return ; case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; return ; case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len ) ; return ; case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; return ; } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; strncpy ( str , & tokenNames [ p ] , len ) ; return ; } assert ( len >= 10 ) ; espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }
Fixed code:","
void jslTokenAsString ( int token , char * str , size_t len ) { if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; return ; case LEX_ID : strncpy ( str , ""ID"" , len ) ; return ; case LEX_INT : strncpy ( str , ""INT"" , len ) ; return ; case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; return ; case LEX_STR : strncpy ( str , ""STRING"" , len ) ; return ; case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len ) ; return ; case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; return ; case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; return ; case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; return ; case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len ) ; return ; case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; return ; } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) { if ( p > len - 1 ) { break ; } p ++ ; } p ++ ; n -- ; } assert ( n == 0 ) ; strncpy ( str , & tokenNames [ p ] , len ) ; return ; } assert ( len >= 10 ) ; espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }",872,-16.35878665376954,-0.018760076437809102
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
void jslTokenAsString ( int token , char * str , size_t len ) { if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; return ; case LEX_ID : strncpy ( str , ""ID"" , len ) ; return ; case LEX_INT : strncpy ( str , ""INT"" , len ) ; return ; case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; return ; case LEX_STR : strncpy ( str , ""STRING"" , len ) ; return ; case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len ) ; return ; case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; return ; case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; return ; case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; return ; case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len ) ; return ; case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; return ; } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; strncpy ( str , & tokenNames [ p ] , len ) ; return ; } assert ( len >= 10 ) ; espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }
Fixed code:","
void jslTokenAsString ( int token , char * str , size_t len ) { if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; return ; case LEX_ID : strncpy ( str , ""ID"" , len ) ; return ; case LEX_INT : strncpy ( str , ""INT"" , len ) ; return ; case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; return ; case LEX_STR : strncpy ( str , ""STRING"" , len ) ; return ; case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len ) ; return ; case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; return ; case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; return ; case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; return ; case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len ) ; return ; case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; return ; } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } if ( n == 0 ) { size_t tokenNameLen = strlen ( & tokenNames [ p ] ) ; size_t strLen = ( len < tokenNameLen ) ? len : tokenNameLen ; strncpy ( str , & tokenNames [ p ] , strLen ) ; return ; } } assert ( len >= 10 ) ; espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }",898,-18.93058346787251,-0.02108082791522551
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
void jslTokenAsString ( int token , char * str , size_t len ) { if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; return ; case LEX_ID : strncpy ( str , ""ID"" , len ) ; return ; case LEX_INT : strncpy ( str , ""INT"" , len ) ; return ; case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; return ; case LEX_STR : strncpy ( str , ""STRING"" , len ) ; return ; case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len ) ; return ; case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; return ; case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; return ; case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; return ; case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len ) ; return ; case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; return ; } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; strncpy ( str , & tokenNames [ p ] , len ) ; return ; } assert ( len >= 10 ) ; espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }
Fixed code:","
void jslTokenAsString ( int token , char * str , size_t len ) { if ( token > 32 && token < 128 ) { snprintf ( str , len , ""'%c'"" , ( char ) token ) ; return ; } switch ( token ) { case LEX_EOF : snprintf ( str , len , ""EOF"" ) ; return ; case LEX_ID : snprintf ( str , len , ""ID"" ) ; return ; case LEX_INT : snprintf ( str , len , ""INT"" ) ; return ; case LEX_FLOAT : snprintf ( str , len , ""FLOAT"" ) ; return ; case LEX_STR : snprintf ( str , len , ""STRING"" ) ; return ; case LEX_UNFINISHED_STR : snprintf ( str , len , ""UNFINISHED STRING"" ) ; return ; case LEX_TEMPLATE_LITERAL : snprintf ( str , len , ""TEMPLATE LITERAL"" ) ; return ; case LEX_UNFINISHED_TEMPLATE_LITERAL : snprintf ( str , len , ""UNFINISHED TEMPLATE LITERAL"" ) ; return ; case LEX_REGEX : snprintf ( str , len , ""REGEX"" ) ; return ; case LEX_UNFINISHED_REGEX : snprintf ( str , len , ""UNFINISHED REGEX"" ) ; return ; case LEX_UNFINISHED_COMMENT : snprintf ( str , len , ""UNFINISHED COMMENT"" ) ; return ; } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; snprintf ( str , len , ""%s"" , & tokenNames [ p ] ) ; return ; } snprintf ( str , len , ""?[%d]"" , token ) ; }",815,-6.562277594635254,-0.008051874349245711
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
void jslTokenAsString ( int token , char * str , size_t len ) { if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; return ; case LEX_ID : strncpy ( str , ""ID"" , len ) ; return ; case LEX_INT : strncpy ( str , ""INT"" , len ) ; return ; case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; return ; case LEX_STR : strncpy ( str , ""STRING"" , len ) ; return ; case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len ) ; return ; case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; return ; case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; return ; case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; return ; case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len ) ; return ; case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; return ; } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; strncpy ( str , & tokenNames [ p ] , len ) ; return ; } assert ( len >= 10 ) ; espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }
Fixed code:","

void jslTokenAsString ( int token , char * str , size_t len ) { 
    if ( token > 32 && token < 128 ) { 
        assert ( len >= 4 ) ; 
        str [ 0 ] = '\\'' ; 
        str [ 1 ] = ( char ) token ; 
        str [ 2 ] = '\\'' ; 
        str [ 3 ] = 0 ; 
        return ; 
    } 
    switch ( token ) { 
        case LEX_EOF :
            strncpy ( str , ""EOF"" , len-1 ) ; 
            return ; 
        case LEX_ID : 
            strncpy ( str , ""ID"" , len-1 ) ; 
            return ; 
        case LEX_INT : 
            strncpy ( str , ""INT"" , len-1 ) ; 
            return ; 
        case LEX_FLOAT : 
            strncpy ( str , ""FLOAT"" , len-1 ) ; 
            return ; 
        case LEX_STR : 
            strncpy ( str , ""STRING"" , len-1 ) ; 
            return ; 
        case LEX_UNFINISHED_STR : 
            strncpy ( str , ""UNFINISHED STRING"" , len-1 ) ; 
            return ; 
        case LEX_TEMPLATE_LITERAL : 
            strncpy ( str , ""TEMPLATE LITERAL"" , len-1 ) ; 
            return ; 
        case LEX_UNFINISHED_TEMPLATE_LITERAL : 
            strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len-1 ) ; 
            return ; 
        case LEX_REGEX : 
            strncpy ( str , ""REGEX"" , len-1 ) ; 
            return ; 
        case LEX_UNFINISHED_REGEX : 
            strncpy ( str , ""UNFINISHED REGEX"" , len-1 ) ; 
            return ; 
        case LEX_UNFINISHED_COMMENT : 
            strncpy ( str , ""UNFINISHED COMMENT"" , len-1 ) ; 
            return ; 
    } 

    if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { 
        const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; 
        unsigned int p = 0 ; 
        int n = token - _LEX_OPERATOR_START ; 
        while ( n > 0 && p < sizeof ( tokenNames ) ) { 
            while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; 
            p ++ ; 
            n -- ; 
        } 
        assert ( n == 0 ) ; 
        strncpy ( str ,",1000,-19.806087081553958,-0.019806087081553958
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
void jslTokenAsString ( int token , char * str , size_t len ) { if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; return ; case LEX_ID : strncpy ( str , ""ID"" , len ) ; return ; case LEX_INT : strncpy ( str , ""INT"" , len ) ; return ; case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; return ; case LEX_STR : strncpy ( str , ""STRING"" , len ) ; return ; case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len ) ; return ; case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; return ; case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; return ; case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; return ; case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len ) ; return ; case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; return ; } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; strncpy ( str , & tokenNames [ p ] , len ) ; return ; } assert ( len >= 10 ) ; espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }
Fixed code:","
void jslTokenAsString ( int token , char * str , size_t len ) { if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { case LEX_EOF : strncpy_s ( str , len , ""EOF"" , _TRUNCATE ) ; return ; case LEX_ID : strncpy_s ( str , len , ""ID"" , _TRUNCATE ) ; return ; case LEX_INT : strncpy_s ( str , len , ""INT"" , _TRUNCATE ) ; return ; case LEX_FLOAT : strncpy_s ( str , len , ""FLOAT"" , _TRUNCATE ) ; return ; case LEX_STR : strncpy_s ( str , len , ""STRING"" , _TRUNCATE ) ; return ; case LEX_UNFINISHED_STR : strncpy_s ( str , len , ""UNFINISHED STRING"" , _TRUNCATE ) ; return ; case LEX_TEMPLATE_LITERAL : strncpy_s ( str , len , ""TEMPLATE LITERAL"" , _TRUNCATE ) ; return ; case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy_s ( str , len , ""UNFINISHED TEMPLATE LITERAL"" , _TRUNCATE ) ; return ; case LEX_REGEX : strncpy_s ( str , len , ""REGEX"" , _TRUNCATE ) ; return ; case LEX_UNFINISHED_REGEX : strncpy_s ( str , len , ""UNFINISHED REGEX"" , _TRUNCATE ) ; return ; case LEX_UNFINISHED_COMMENT : strncpy_s ( str , len , ""UNFINISHED COMMENT"" , _TRUNCATE ) ; return ; } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; strncpy_s ( str , len , & tokenNames [ p ] , _TRUNCATE ) ; return ; } assert ( len >= 10 ) ; espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }",954,-5.573401338429153,-0.005842139767745443
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
void jslTokenAsString ( int token , char * str , size_t len ) { if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; return ; case LEX_ID : strncpy ( str , ""ID"" , len ) ; return ; case LEX_INT : strncpy ( str , ""INT"" , len ) ; return ; case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; return ; case LEX_STR : strncpy ( str , ""STRING"" , len ) ; return ; case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len ) ; return ; case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; return ; case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; return ; case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; return ; case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len ) ; return ; case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; return ; } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; strncpy ( str , & tokenNames [ p ] , len ) ; return ; } assert ( len >= 10 ) ; espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }
Fixed code:","
void jslTokenAsString ( int token , char * str , size_t len ) { if ( token > 32 && token < 128 ) { 
assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { case LEX_EOF : strncpy ( str , ""EOF"" , len -1 ) ; return ; case LEX_ID : strncpy ( str , ""ID"" , len -1 ) ; return ; case LEX_INT : strncpy ( str , ""INT"" , len -1 ) ; return ; case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len -1 ) ; return ; case LEX_STR : strncpy ( str , ""STRING"" , len -1 ) ; return ; case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len -1 ) ; return ; case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len -1 ) ; return ; case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len -1 ) ; return ; case LEX_REGEX : strncpy ( str , ""REGEX"" , len -1 ) ; return ; case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len -1 ) ; return ; case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len -1 ) ; return ; } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; strncpy ( str , & tokenNames [ p ] , len -1 ) ; return ; } assert ( len >= 10 ) ; espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }",884,-15.360922699469807,-0.017376609388540507
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
void jslTokenAsString ( int token , char * str , size_t len ) { if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; return ; case LEX_ID : strncpy ( str , ""ID"" , len ) ; return ; case LEX_INT : strncpy ( str , ""INT"" , len ) ; return ; case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; return ; case LEX_STR : strncpy ( str , ""STRING"" , len ) ; return ; case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len ) ; return ; case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; return ; case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; return ; case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; return ; case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len ) ; return ; case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; return ; } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; strncpy ( str , & tokenNames [ p ] , len ) ; return ; } assert ( len >= 10 ) ; espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }
Fixed code:","
void jslTokenAsString ( int token , char * str , size_t len ) { if ( token > 32 && token < 128 ) { if (len < 4 ) {return;} str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { case LEX_EOF : if (len < 4 ) {return;} strncpy ( str , ""EOF"" , len ) ; return ; case LEX_ID : if (len < 3 ) {return;} strncpy ( str , ""ID"" , len ) ; return ; case LEX_INT : if (len < 5 ) {return;} strncpy ( str , ""INT"" , len ) ; return ; case LEX_FLOAT : if (len < 7 ) {return;} strncpy ( str , ""FLOAT"" , len ) ; return ; case LEX_STR : if (len < 8 ) {return;} strncpy ( str , ""STRING"" , len ) ; return ; case LEX_UNFINISHED_STR : if (len < 19 ) {return;} strncpy ( str , ""UNFINISHED STRING"" , len ) ; return ; case LEX_TEMPLATE_LITERAL : if (len < 17 ) {return;} strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; return ; case LEX_UNFINISHED_TEMPLATE_LITERAL : if (len < 30 ) {return;} strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; return ; case LEX_REGEX : if (len < 7 ) {return;} strncpy ( str , ""REGEX"" , len ) ; return ; case LEX_UNFINISHED_REGEX : if (len < 19 ) {return;} strncpy ( str , ""UNFINISHED REGEX"" , len ) ; return ; case LEX_UNFINISHED_COMMENT : if (len < 20 ) {return;} strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; return ; } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; int tokenNameLength; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } tokenNameLength = strlen(&tokenNames[p]); if (tokenNameLength >= len) {return;} assert ( n == 0 ) ; strncpy ( str , & tokenNames [ p ] , len ) ; return ; } if (len < 10 ) {return;} espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }",989,-39.81949700036417,-0.04026238321573728
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
void jslTokenAsString ( int token , char * str , size_t len ) { if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; return ; case LEX_ID : strncpy ( str , ""ID"" , len ) ; return ; case LEX_INT : strncpy ( str , ""INT"" , len ) ; return ; case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; return ; case LEX_STR : strncpy ( str , ""STRING"" , len ) ; return ; case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len ) ; return ; case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; return ; case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; return ; case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; return ; case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len ) ; return ; case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; return ; } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; strncpy ( str , & tokenNames [ p ] , len ) ; return ; } assert ( len >= 10 ) ; espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }
Fixed code:","
void jslTokenAsString ( int token , char * str , size_t len ) { if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; return ; case LEX_ID : strncpy ( str , ""ID"" , len ) ; return ; case LEX_INT : strncpy ( str , ""INT"" , len ) ; return ; case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; return ; case LEX_STR : strncpy ( str , ""STRING"" , len ) ; return ; case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len ) ; return ; case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; return ; case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; return ; case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; return ; case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len ) ; return ; case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; return ; } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; size_t tokenNameLen = strlen ( & tokenNames [ p ] ) ; size_t toCopyLen = ( tokenNameLen < len ) ? tokenNameLen : ( len - 1 ) ; strncpy ( str , & tokenNames [ p ] , toCopyLen ) ; str [ toCopyLen ] = 0 ; return ; } assert ( len >= 10 ) ; espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }",912,-20.766696235203273,-0.022770500257898327
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
void jslTokenAsString ( int token , char * str , size_t len ) { if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; return ; case LEX_ID : strncpy ( str , ""ID"" , len ) ; return ; case LEX_INT : strncpy ( str , ""INT"" , len ) ; return ; case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; return ; case LEX_STR : strncpy ( str , ""STRING"" , len ) ; return ; case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len ) ; return ; case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; return ; case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; return ; case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; return ; case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len ) ; return ; case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; return ; } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; strncpy ( str , & tokenNames [ p ] , len ) ; return ; } assert ( len >= 10 ) ; espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }
Fixed code:","
void jslTokenAsString ( int token , char * str , size_t len ) { if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; return ; case LEX_ID : strncpy ( str , ""ID"" , len ) ; return ; case LEX_INT : strncpy ( str , ""INT"" , len ) ; return ; case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; return ; case LEX_STR : strncpy ( str , ""STRING"" , len ) ; return ; case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len ) ; return ; case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; return ; case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; return ; case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; return ; case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len ) ; return ; case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; return ; } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; size_t nameLen = strlen (& tokenNames [ p ]); if (nameLen <= len) { strncpy ( str , & tokenNames [ p ] , len ) ; return ; } else { assert ( len >= 10 ) ; espruino_snprintf ( str , len , ""?[%d]"" , token ) ; return ; } } assert ( len >= 10 ) ; espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }",915,-24.021105069674054,-0.02625257384663831
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
void jslTokenAsString ( int token , char * str , size_t len ) { if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; return ; case LEX_ID : strncpy ( str , ""ID"" , len ) ; return ; case LEX_INT : strncpy ( str , ""INT"" , len ) ; return ; case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; return ; case LEX_STR : strncpy ( str , ""STRING"" , len ) ; return ; case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len ) ; return ; case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; return ; case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; return ; case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; return ; case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len ) ; return ; case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; return ; } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; strncpy ( str , & tokenNames [ p ] , len ) ; return ; } assert ( len >= 10 ) ; espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }
Fixed code:","
void jslTokenAsString ( int token , char * str , size_t len ) { 
if ( token > 32 && token < 128 ) { 
if (len < 4) {
return;
}
assert ( len >= 4 ); 
str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; 
str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; 
return ; 
} 
switch ( token ) { 
case LEX_EOF : 
if (len < 3) {
return;
}
strncpy ( str , ""EOF"" , len ) ;
return ; 
case LEX_ID : 
if (len < 2) {
return;
}
strncpy ( str , ""ID"" , len ) ; 
return ; 
case LEX_INT : 
if (len < 3) {
return;
}
strncpy ( str , ""INT"" , len ) ; 
return ; 
case LEX_FLOAT : 
if (len < 5) {
return;
}
strncpy ( str , ""FLOAT"" , len ) ; 
return ; 
case LEX_STR : 
if (len < 6) {
return;
}
strncpy ( str , ""STRING"" , len ) ; 
return ; 
case LEX_UNFINISHED_STR : 
if (len < 16) {
return;
}
strncpy ( str , ""UNFINISHED STRING"" , len ) ; 
return ; 
case LEX_TEMPLATE_LITERAL : 
if (len < 16) {
return;
}
strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; 
return ; 
case LEX_UNFINISHED_TEMPLATE_LITERAL : 
if (len < 26) {
return;
}
strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; 
return ;
case LEX_REGEX : 
if (len < 5) {
return;
}
strncpy ( str , ""REGEX"" , len ) ; 
return ; 
case LEX_UNFINISHED_REGEX : 
if (len < 16) {
return;
}
strncpy ( str , ""UNFINISHED REGEX"" , len ) ; 
return ; 
case LEX_UNFINISHED_COMMENT : 
if (len < 18) {
return;
}
strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; 
return ; 
} 
if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { 
const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; 
unsigned int p = 0 ; int n = token - _LEX_OPERATOR_",1000,-40.57139046844413,-0.04057139046844413
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
void jslTokenAsString ( int token , char * str , size_t len ) { if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; return ; case LEX_ID : strncpy ( str , ""ID"" , len ) ; return ; case LEX_INT : strncpy ( str , ""INT"" , len ) ; return ; case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; return ; case LEX_STR : strncpy ( str , ""STRING"" , len ) ; return ; case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len ) ; return ; case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; return ; case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; return ; case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; return ; case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len ) ; return ; case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; return ; } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; strncpy ( str , & tokenNames [ p ] , len ) ; return ; } assert ( len >= 10 ) ; espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }
Fixed code:","
void jslTokenAsString ( int token , char * str , size_t len ) { 
  if ( token > 32 && token < 128 ) { 
    if(len < 4) return;
    str [ 0 ] = '\\'' ; 
    str [ 1 ] = ( char ) token ; 
    str [ 2 ] = '\\'' ; 
    str [ 3 ] = 0 ; 
    return ; 
  } 
  switch ( token ) { 
    case LEX_EOF : 
      if(len < 3) return;
      strncpy ( str , ""EOF"" , len ) ; 
      return ; 
    case LEX_ID : 
      if(len < 2) return;
      strncpy ( str , ""ID"" , len ) ; 
      return ; 
    case LEX_INT : 
      if(len < 3) return;
      strncpy ( str , ""INT"" , len ) ; 
      return ; 
    case LEX_FLOAT : 
      if(len < 5) return;
      strncpy ( str , ""FLOAT"" , len ) ; 
      return ; 
    case LEX_STR : 
      if(len < 6) return;
      strncpy ( str , ""STRING"" , len ) ; 
      return ; 
    case LEX_UNFINISHED_STR : 
      if(len < 17) return;
      strncpy ( str , ""UNFINISHED STRING"" , len ) ; 
      return ; 
    case LEX_TEMPLATE_LITERAL : 
      if(len < 16) return;
      strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; 
      return ; 
    case LEX_UNFINISHED_TEMPLATE_LITERAL : 
      if(len < 27) return;
      strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; 
      return ; 
    case LEX_REGEX : 
      if(len < 5) return;
      strncpy ( str , ""REGEX"" , len ) ; 
      return ; 
    case LEX_UNFINISHED_REGEX : 
      if(len < 17) return;
      strncpy ( str , ""UNFINISHED REGEX"" , len ) ; 
      return ; 
    case LEX_UNFINISHED_COMMENT : 
      if(len < 19) return;
      strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; 
      return ; 
  } 
  if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { 
    const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; 
    unsigned int p = 0 ; 
    int n",1000,-16.722535022649033,-0.016722535022649032
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
void jslTokenAsString ( int token , char * str , size_t len ) { if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; return ; case LEX_ID : strncpy ( str , ""ID"" , len ) ; return ; case LEX_INT : strncpy ( str , ""INT"" , len ) ; return ; case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; return ; case LEX_STR : strncpy ( str , ""STRING"" , len ) ; return ; case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len ) ; return ; case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; return ; case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; return ; case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; return ; case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len ) ; return ; case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; return ; } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; strncpy ( str , & tokenNames [ p ] , len ) ; return ; } assert ( len >= 10 ) ; espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }
Fixed code:","
void jslTokenAsString ( int token , char * str , size_t len ) { if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { case LEX_EOF : strncpy ( str , ""EOF"" , len - 1 ) ; str [ len - 1 ] = '\0' ; return ; case LEX_ID : strncpy ( str , ""ID"" , len - 1 ) ; str [ len - 1 ] = '\0' ; return ; case LEX_INT : strncpy ( str , ""INT"" , len - 1 ) ; str [ len - 1 ] = '\0' ; return ; case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len - 1 ) ; str [ len - 1 ] = '\0' ; return ; case LEX_STR : strncpy ( str , ""STRING"" , len - 1 ) ; str [ len - 1 ] = '\0' ; return ; case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len - 1 ) ; str [ len - 1 ] = '\0' ; return ; case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len - 1 ) ; str [ len - 1 ] = '\0' ; return ; case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len - 1 ) ; str [ len - 1 ] = '\0' ; return ; case LEX_REGEX : strncpy ( str , ""REGEX"" , len - 1 ) ; str [ len - 1 ] = '\0' ; return ; case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len - 1 ) ; str [ len - 1 ] = '\0' ; return ; case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len - 1 ) ; str [ len - 1 ] = '\0' ; return ; } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; strncpy ( str , & tokenNames [ p ] , len - 1 ) ; str [ len - 1 ] = '\0' ; return ; } assert ( len",1000,-6.318035848968922,-0.006318035848968922
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
void jslTokenAsString ( int token , char * str , size_t len ) { if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; return ; case LEX_ID : strncpy ( str , ""ID"" , len ) ; return ; case LEX_INT : strncpy ( str , ""INT"" , len ) ; return ; case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; return ; case LEX_STR : strncpy ( str , ""STRING"" , len ) ; return ; case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len ) ; return ; case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; return ; case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; return ; case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; return ; case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len ) ; return ; case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; return ; } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; strncpy ( str , & tokenNames [ p ] , len ) ; return ; } assert ( len >= 10 ) ; espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }
Fixed code:","
void jslTokenAsString ( int token , char * str , size_t len ) {
  if ( token > 32 && token < 128 ) {
    assert ( len >= 4 ) ;
    str [ 0 ] = '\\'' ;
    str [ 1 ] = ( char ) token ;
    str [ 2 ] = '\\'' ;
    str [ 3 ] = 0 ;
    return ;
  }
  switch ( token ) {
    case LEX_EOF : strncpy ( str , ""EOF"" , len - 1 ) ; return ;
    case LEX_ID : strncpy ( str , ""ID"" , len - 1 ) ; return ;
    case LEX_INT : strncpy ( str , ""INT"" , len - 1 ) ; return ;
    case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len - 1 ) ; return ;
    case LEX_STR : strncpy ( str , ""STRING"" , len - 1 ) ; return ;
    case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len - 1 ) ; return ;
    case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len - 1 ) ; return ;
    case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len - 1 ) ; return ;
    case LEX_REGEX : strncpy ( str , ""REGEX"" , len - 1 ) ; return ;
    case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len - 1 ) ; return ;
    case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len - 1 ) ; return ;
  }
  if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) {
    const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ;
    unsigned int p = 0 ;
    int n = token - _LEX_OPERATOR_START ;
    while ( n > 0 && p < sizeof ( tokenNames ) ) {
      while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ;
      p ++ ;
      n -- ;
    }
    assert ( n == 0 ) ;
    strncpy ( str , & tokenNames [ p ] , len - 1 ) ;
    return ;
  }
  assert ( len >= 10 ) ;
  espruino_snprintf ( str , len - 1 , ""?[%d]"" , token ) ; 
}",958,-13.199268910720862,-0.01377794249553326
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
void jslTokenAsString ( int token , char * str , size_t len ) { if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; return ; case LEX_ID : strncpy ( str , ""ID"" , len ) ; return ; case LEX_INT : strncpy ( str , ""INT"" , len ) ; return ; case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; return ; case LEX_STR : strncpy ( str , ""STRING"" , len ) ; return ; case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len ) ; return ; case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; return ; case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; return ; case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; return ; case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len ) ; return ; case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; return ; } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; strncpy ( str , & tokenNames [ p ] , len ) ; return ; } assert ( len >= 10 ) ; espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }
Fixed code:","
void jslTokenAsString ( int token , char * str , size_t len ) { 
 if ( token > 32 && token < 128 ) { 
  assert ( len >= 4 ) ; 
  str [ 0 ] = '\\'' ; 
  str [ 1 ] = ( char ) token ; 
  str [ 2 ] = '\\'' ; 
  str [ 3 ] = 0 ; 
  return ; 
 } 
 switch ( token ) { 
  case LEX_EOF : strncpy ( str , ""EOF"" , len-1 ) ; return ; 
  case LEX_ID : strncpy ( str , ""ID"" , len-1 ) ; return ; 
  case LEX_INT : strncpy ( str , ""INT"" , len-1 ) ; return ; 
  case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len-1 ) ; return ; 
  case LEX_STR : strncpy ( str , ""STRING"" , len-1 ) ; return ; 
  case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len-1 ) ; return ; 
  case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len-1 ) ; return ; 
  case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len-1 ) ; return ; 
  case LEX_REGEX : strncpy ( str , ""REGEX"" , len-1 ) ; return ; 
  case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len-1 ) ; return ; 
  case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len-1 ) ; return ; 
 } 
 if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { 
  const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; 
  unsigned int p = 0 ; 
  int n = token - _LEX_OPERATOR_START ; 
  while ( n > 0 && p < sizeof ( tokenNames ) ) { 
   while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; 
   p ++ ; 
   n -- ; 
  } 
  assert ( n == 0 ) ; 
  strncpy ( str , & tokenNames [ p ] , len-1 ) ; 
  return ; 
 } 
 assert ( len >= 10 ) ; 
 espruino_snprintf ( str , len-1 , ""?[%d]"" , token ) ; 
}",986,-12.118647123124283,-0.012290717163412053
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
void jslTokenAsString ( int token , char * str , size_t len ) { if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; return ; case LEX_ID : strncpy ( str , ""ID"" , len ) ; return ; case LEX_INT : strncpy ( str , ""INT"" , len ) ; return ; case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; return ; case LEX_STR : strncpy ( str , ""STRING"" , len ) ; return ; case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len ) ; return ; case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; return ; case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; return ; case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; return ; case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len ) ; return ; case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; return ; } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; strncpy ( str , & tokenNames [ p ] , len ) ; return ; } assert ( len >= 10 ) ; espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }
Fixed code:","
void jslTokenAsString ( int token , char * str , size_t len ) { if ( token > 32 && token < 128 ) { if ( len >= 4 ) { str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } else { str [ 0 ] = '\0' ; } } switch ( token ) { case LEX_EOF : if ( len >= 3 ) { strncpy ( str , ""EOF"" , len ) ; return ; } else { str [ 0 ] = '\0' ; } case LEX_ID : if ( len >= 2 ) { strncpy ( str , ""ID"" , len ) ; return ; } else { str [ 0 ] = '\0' ; } case LEX_INT : if ( len >= 3 ) { strncpy ( str , ""INT"" , len ) ; return ; } else { str [ 0 ] = '\0' ; } case LEX_FLOAT : if ( len >= 5 ) { strncpy ( str , ""FLOAT"" , len ) ; return ; } else { str [ 0 ] = '\0' ; } case LEX_STR : if ( len >= 6 ) { strncpy ( str , ""STRING"" , len ) ; return ; } else { str [ 0 ] = '\0' ; } case LEX_UNFINISHED_STR : if ( len >= 17 ) { strncpy ( str , ""UNFINISHED STRING"" , len ) ; return ; } else { str [ 0 ] = '\0' ; } case LEX_TEMPLATE_LITERAL : if ( len >= 15 ) { strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; return ; } else { str [ 0 ] = '\0' ; } case LEX_UNFINISHED_TEMPLATE_LITERAL : if ( len >= 26 ) { strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; return ; } else { str [ 0 ] = '\0' ; } case LEX_REGEX : if ( len >= 5 ) { strncpy ( str , ""REGEX"" , len ) ; return ; } else { str [ 0 ] = '\0' ; } case LEX_UNFINISHED_REGEX : if ( len >= 17 ) { strncpy ( str , ""UNFINISHED REGEX"" , len ) ; return ; } else { str [ 0 ] = '\0' ; } case LEX_UNFINISHED_COMMENT : if ( len >= 19 ) { strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; return ; } else { str [ 0 ] = '\0' ; } } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX",1000,-16.0561875504841,-0.0160561875504841
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
void jslTokenAsString ( int token , char * str , size_t len ) { if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; return ; case LEX_ID : strncpy ( str , ""ID"" , len ) ; return ; case LEX_INT : strncpy ( str , ""INT"" , len ) ; return ; case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; return ; case LEX_STR : strncpy ( str , ""STRING"" , len ) ; return ; case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len ) ; return ; case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; return ; case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; return ; case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; return ; case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len ) ; return ; case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; return ; } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; strncpy ( str , & tokenNames [ p ] , len ) ; return ; } assert ( len >= 10 ) ; espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }
Fixed code:","
void jslTokenAsString ( int token , char * str , size_t len ) { if ( token > 32 && token < 128 ) { snprintf ( str , len , ""\\'%c\\'"" , ( char ) token ) ; return ; } switch ( token ) { case LEX_EOF : snprintf ( str , len , ""EOF"" ) ; return ; case LEX_ID : snprintf ( str , len , ""ID"" ) ; return ; case LEX_INT : snprintf ( str , len , ""INT"" ) ; return ; case LEX_FLOAT : snprintf ( str , len , ""FLOAT"" ) ; return ; case LEX_STR : snprintf ( str , len , ""STRING"" ) ; return ; case LEX_UNFINISHED_STR : snprintf ( str , len , ""UNFINISHED STRING"" ) ; return ; case LEX_TEMPLATE_LITERAL : snprintf ( str , len , ""TEMPLATE LITERAL"" ) ; return ; case LEX_UNFINISHED_TEMPLATE_LITERAL : snprintf ( str , len , ""UNFINISHED TEMPLATE LITERAL"" ) ; return ; case LEX_REGEX : snprintf ( str , len , ""REGEX"" ) ; return ; case LEX_UNFINISHED_REGEX : snprintf ( str , len , ""UNFINISHED REGEX"" ) ; return ; case LEX_UNFINISHED_COMMENT : snprintf ( str , len , ""UNFINISHED COMMENT"" ) ; return ; } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; snprintf ( str , len , ""%s"" , & tokenNames [ p ] ) ; return ; } snprintf ( str , len , ""?[%d]"" , token ) ; }",818,-5.684313788311311,-0.006949038861016272
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
void jslTokenAsString ( int token , char * str , size_t len ) { if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; return ; case LEX_ID : strncpy ( str , ""ID"" , len ) ; return ; case LEX_INT : strncpy ( str , ""INT"" , len ) ; return ; case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; return ; case LEX_STR : strncpy ( str , ""STRING"" , len ) ; return ; case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len ) ; return ; case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; return ; case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; return ; case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; return ; case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len ) ; return ; case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; return ; } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; strncpy ( str , & tokenNames [ p ] , len ) ; return ; } assert ( len >= 10 ) ; espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }
Fixed code:","
void jslTokenAsString ( int token , char * str , size_t len ) { if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { case LEX_EOF : strncpy_s ( str , len , ""EOF"" , len ) ; return ; case LEX_ID : strncpy_s ( str , len , ""ID"" , len ) ; return ; case LEX_INT : strncpy_s ( str , len , ""INT"" , len ) ; return ; case LEX_FLOAT : strncpy_s ( str , len , ""FLOAT"" , len ) ; return ; case LEX_STR : strncpy_s ( str , len , ""STRING"" , len ) ; return ; case LEX_UNFINISHED_STR : strncpy_s ( str , len , ""UNFINISHED STRING"" , len ) ; return ; case LEX_TEMPLATE_LITERAL : strncpy_s ( str , len , ""TEMPLATE LITERAL"" , len ) ; return ; case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy_s ( str , len , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; return ; case LEX_REGEX : strncpy_s ( str , len , ""REGEX"" , len ) ; return ; case LEX_UNFINISHED_REGEX : strncpy_s ( str , len , ""UNFINISHED REGEX"" , len ) ; return ; case LEX_UNFINISHED_COMMENT : strncpy_s ( str , len , ""UNFINISHED COMMENT"" , len ) ; return ; } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; strncpy_s ( str , len , & tokenNames [ p ] , len ) ; return ; } assert ( len >= 10 ) ; espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }",906,-6.2069712849742995,-0.006850961683194591
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
void jslTokenAsString ( int token , char * str , size_t len ) { if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; return ; case LEX_ID : strncpy ( str , ""ID"" , len ) ; return ; case LEX_INT : strncpy ( str , ""INT"" , len ) ; return ; case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; return ; case LEX_STR : strncpy ( str , ""STRING"" , len ) ; return ; case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len ) ; return ; case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; return ; case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; return ; case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; return ; case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len ) ; return ; case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; return ; } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; strncpy ( str , & tokenNames [ p ] , len ) ; return ; } assert ( len >= 10 ) ; espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }
Fixed code:","
void jslTokenAsString ( int token , char * str , size_t len ) { if ( token > 32 && token < 128 ) { if ( len < 4) return; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { case LEX_EOF : if ( len < 3 ) return; strncpy ( str , ""EOF"" , len ) ; return ; case LEX_ID : if ( len < 2 ) return; strncpy ( str , ""ID"" , len ) ; return ; case LEX_INT : if ( len < 3 ) return; strncpy ( str , ""INT"" , len ) ; return ; case LEX_FLOAT : if ( len < 5 ) return; strncpy ( str , ""FLOAT"" , len ) ; return ; case LEX_STR : if ( len < 6 ) return; strncpy ( str , ""STRING"" , len ) ; return ; case LEX_UNFINISHED_STR : if ( len < 16 ) return; strncpy ( str , ""UNFINISHED STRING"" , len ) ; return ; case LEX_TEMPLATE_LITERAL : if ( len < 15 ) return; strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; return ; case LEX_UNFINISHED_TEMPLATE_LITERAL : if ( len < 24 ) return; strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; return ; case LEX_REGEX : if ( len < 5 ) return; strncpy ( str , ""REGEX"" , len ) ; return ; case LEX_UNFINISHED_REGEX : if ( len < 16 ) return; strncpy ( str , ""UNFINISHED REGEX"" , len ) ; return ; case LEX_UNFINISHED_COMMENT : if ( len < 18 ) return; strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; return ; } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } if ( n == 0 ) { size_t copy_len = strlen(&tokenNames[p]); if ( len < copy_len ) return; strncpy ( str , & tokenNames [ p ] , len ) ; return ; } } if ( len < 10 ) return; espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }",974,-33.50022883635666,-0.03439448545827173
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
void jslTokenAsString ( int token , char * str , size_t len ) { if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; return ; case LEX_ID : strncpy ( str , ""ID"" , len ) ; return ; case LEX_INT : strncpy ( str , ""INT"" , len ) ; return ; case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; return ; case LEX_STR : strncpy ( str , ""STRING"" , len ) ; return ; case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len ) ; return ; case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; return ; case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; return ; case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; return ; case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len ) ; return ; case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; return ; } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; strncpy ( str , & tokenNames [ p ] , len ) ; return ; } assert ( len >= 10 ) ; espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }
Fixed code:","
void jslTokenAsString ( int token , char * str , size_t len ) { if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; return ; case LEX_ID : strncpy ( str , ""ID"" , len ) ; return ; case LEX_INT : strncpy ( str , ""INT"" , len ) ; return ; case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; return ; case LEX_STR : strncpy ( str , ""STRING"" , len ) ; return ; case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len ) ; return ; case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; return ; case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; return ; case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; return ; case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len ) ; return ; case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; return ; } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) - 1 ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) - 1 ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; strncpy ( str , & tokenNames [ p ] , len ) ; return ; } assert ( len >= 10 ) ; espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }",862,-6.361750539859689,-0.0073802210439207535
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
void jslTokenAsString ( int token , char * str , size_t len ) { if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; return ; case LEX_ID : strncpy ( str , ""ID"" , len ) ; return ; case LEX_INT : strncpy ( str , ""INT"" , len ) ; return ; case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; return ; case LEX_STR : strncpy ( str , ""STRING"" , len ) ; return ; case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len ) ; return ; case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; return ; case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; return ; case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; return ; case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len ) ; return ; case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; return ; } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; strncpy ( str , & tokenNames [ p ] , len ) ; return ; } assert ( len >= 10 ) ; espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }
Fixed code:","
void jslTokenAsString ( int token , char * str , size_t len ) { 
if ( token > 32 && token < 128 ) { 
if (len < 4)
return;
assert ( len >= 4 ) ; 
str [ 0 ] = '\\'' ; 
str [ 1 ] = ( char ) token ; 
str [ 2 ] = '\\'' ; 
str [ 3 ] = 0 ; 
return ; 
} 
switch ( token ) { 
case LEX_EOF : 
if (len < 4)
return;
strncpy ( str , ""EOF"" , len ) ; 
return ; 
case LEX_ID : 
if (len < 3)
return;
strncpy ( str , ""ID"" , len ) ; 
return ; 
case LEX_INT : 
if (len < 5)
return;
strncpy ( str , ""INT"" , len ) ; 
return ; 
case LEX_FLOAT : 
if (len < 7)
return;
strncpy ( str , ""FLOAT"" , len ) ; 
return ; 
case LEX_STR : 
if (len < 8)
return;
strncpy ( str , ""STRING"" , len ) ; 
return ; 
case LEX_UNFINISHED_STR : 
if (len < 19)
return;
strncpy ( str , ""UNFINISHED STRING"" , len ) ; 
return ; 
case LEX_TEMPLATE_LITERAL : 
if (len < 18)
return;
strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; 
return ; 
case LEX_UNFINISHED_TEMPLATE_LITERAL : 
if (len < 29)
return;
strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; 
return ; 
case LEX_REGEX : 
if (len < 6)
return;
strncpy ( str , ""REGEX"" , len ) ; 
return ; 
case LEX_UNFINISHED_REGEX : 
if (len < 19)
return;
strncpy ( str , ""UNFINISHED REGEX"" , len ) ; 
return ; 
case LEX_UNFINISHED_COMMENT : 
if (len < 20)
return;
strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; 
return ; 
} 
if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { 
const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; 
unsigned int p = 0 ; 
int n = token - _LEX_OPERATOR_START ; 
while ( n > 0 && p < sizeof ( tokenNames ) ) { 
while ( tokenNames [",1000,-21.42132874468395,-0.02142132874468395
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
void jslTokenAsString ( int token , char * str , size_t len ) { if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; return ; case LEX_ID : strncpy ( str , ""ID"" , len ) ; return ; case LEX_INT : strncpy ( str , ""INT"" , len ) ; return ; case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; return ; case LEX_STR : strncpy ( str , ""STRING"" , len ) ; return ; case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len ) ; return ; case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; return ; case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; return ; case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; return ; case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len ) ; return ; case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; return ; } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; strncpy ( str , & tokenNames [ p ] , len ) ; return ; } assert ( len >= 10 ) ; espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }
Fixed code:","
void jslTokenAsString(int token, char* str, size_t len)
{
    if (token > 32 && token < 128)
    {
        strncpy(str, ""\\'"", len);
        strncat(str, (char)token, len);
        strncat(str, ""\\'"", len);
        return;
    }
    switch (token)
    {
        case LEX_EOF:
            strncpy(str, ""EOF"", len);
            return;
        case LEX_ID:
            strncpy(str, ""ID"", len);
            return;
        case LEX_INT:
            strncpy(str, ""INT"", len);
            return;
        case LEX_FLOAT:
            strncpy(str, ""FLOAT"", len);
            return;
        case LEX_STR:
            strncpy(str, ""STRING"", len);
            return;
        case LEX_UNFINISHED_STR:
            strncpy(str, ""UNFINISHED STRING"", len);
            return;
        case LEX_TEMPLATE_LITERAL:
            strncpy(str, ""TEMPLATE LITERAL"", len);
            return;
        case LEX_UNFINISHED_TEMPLATE_LITERAL:
            strncpy(str, ""UNFINISHED TEMPLATE LITERAL"", len);
            return;
        case LEX_REGEX:
            strncpy(str, ""REGEX"", len);
            return;
        case LEX_UNFINISHED_REGEX:
            strncpy(str, ""UNFINISHED REGEX"", len);
            return;
        case LEX_UNFINISHED_COMMENT:
            strncpy(str, ""UNFINISHED COMMENT"", len);
            return;
    }
    if (token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END)
    {
        const char tokenNames[] =
            ""==\\0""
            ""===\\0""
            ""!=\\0""
            ""!==\\0""
            ""<=\\0""
            ""<<\\0""
            ""<<=\\0""
            "">=\\0""
            "">>\\0""
            "">>>\\0""
            "">>=\\0""
            "">>>=\\0""
            ""+=\\0""
            ""-=\\0""
            ""++\\0""
            ""--\\0""
            ""*=\\0""
            ""/=\\0""
            ""%=\\0""
            ""&=\\0""
            ""&&\\0""
            ""|=\\0""
            ""||\\0""
            ""^=\\0""
            ""=>\\0""
            ""if\\0""
            ""else\\0""
            ""do\\0""
            ""while\\0""
            ""for\\0""
            ""return\\0""
            ""continue\\0""
            ""function\\0""
            ""return\\0""
            ""var\\0""
            ""let\\0""
            ""const\\0""
            ""this\\0""
            ""throw\\0""
            ""try\\0""
            ""catch\\0""
            ""finally\\0""
            ""true\\0""
            ""false\\0""
            ""null\\0""
            ""undefined\\0""
            ""new\\0""
            ""in\\0""
            ""instanceof\\0""
            ""switch\\0""
            ""case\\0""
            ""default\\0""
            ""delete\\0""
            ""typeof\\0""
            ""void\\0""
            ""debugger\\0""
            ""class\\0""
            ""extends\\0""
            ""super\\0""
            ""static\\0"";
        unsigned int p = 0;
        int n = token - _LEX_OPERATOR_START;
        while (n > 0 && p < sizeof(tokenNames))
        {
            while (tokenNames[p] && p < sizeof(tokenNames))
                p++;
            p++;
            n--;
       ",1000,-21.429427028538946,-0.021429427028538946
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
void jslTokenAsString ( int token , char * str , size_t len ) { if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; return ; case LEX_ID : strncpy ( str , ""ID"" , len ) ; return ; case LEX_INT : strncpy ( str , ""INT"" , len ) ; return ; case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; return ; case LEX_STR : strncpy ( str , ""STRING"" , len ) ; return ; case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len ) ; return ; case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; return ; case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; return ; case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; return ; case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len ) ; return ; case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; return ; } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; strncpy ( str , & tokenNames [ p ] , len ) ; return ; } assert ( len >= 10 ) ; espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }
Fixed code:","
void jslTokenAsString ( int token , char * str , size_t len ) { if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { case LEX_EOF : strncpy ( str , ""EOF"" , len - 1 ) ; str[len - 1] = '\0'; return ; case LEX_ID : strncpy ( str , ""ID"" , len - 1 ) ; str[len - 1] = '\0'; return ; case LEX_INT : strncpy ( str , ""INT"" , len - 1 ) ; str[len - 1] = '\0'; return ; case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len - 1 ) ; str[len - 1] = '\0'; return ; case LEX_STR : strncpy ( str , ""STRING"" , len - 1 ) ; str[len - 1] = '\0'; return ; case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len - 1 ) ; str[len - 1] = '\0'; return ; case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len - 1 ) ; str[len - 1] = '\0'; return ; case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len - 1 ) ; str[len - 1] = '\0'; return ; case LEX_REGEX : strncpy ( str , ""REGEX"" , len - 1 ) ; str[len - 1] = '\0'; return ; case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len - 1 ) ; str[len - 1] = '\0'; return ; case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len - 1 ) ; str[len - 1] = '\0'; return ; } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; strncpy ( str , & tokenNames [ p ] , len - 1 ) ; str[len - 1] = '\0'; return ; } assert ( len >= 10 ) ; espruino_snprintf ( str",1000,-6.61380585693688,-0.0066138058569368795
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
void jslTokenAsString ( int token , char * str , size_t len ) { if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; return ; case LEX_ID : strncpy ( str , ""ID"" , len ) ; return ; case LEX_INT : strncpy ( str , ""INT"" , len ) ; return ; case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; return ; case LEX_STR : strncpy ( str , ""STRING"" , len ) ; return ; case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len ) ; return ; case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; return ; case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; return ; case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; return ; case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len ) ; return ; case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; return ; } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; strncpy ( str , & tokenNames [ p ] , len ) ; return ; } assert ( len >= 10 ) ; espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }
Fixed code:","
void jslTokenAsString ( int token , char * str , size_t len ) { if ( token > 32 && token < 128 ) { snprintf ( str , len , ""\\'%c\\'"" , ( char ) token ) ; return ; } switch ( token ) { case LEX_EOF : snprintf ( str , len , ""EOF"" ) ; return ; case LEX_ID : snprintf ( str , len , ""ID"" ) ; return ; case LEX_INT : snprintf ( str , len , ""INT"" ) ; return ; case LEX_FLOAT : snprintf ( str , len , ""FLOAT"" ) ; return ; case LEX_STR : snprintf ( str , len , ""STRING"" ) ; return ; case LEX_UNFINISHED_STR : snprintf ( str , len , ""UNFINISHED STRING"" ) ; return ; case LEX_TEMPLATE_LITERAL : snprintf ( str , len , ""TEMPLATE LITERAL"" ) ; return ; case LEX_UNFINISHED_TEMPLATE_LITERAL : snprintf ( str , len , ""UNFINISHED TEMPLATE LITERAL"" ) ; return ; case LEX_REGEX : snprintf ( str , len , ""REGEX"" ) ; return ; case LEX_UNFINISHED_REGEX : snprintf ( str , len , ""UNFINISHED REGEX"" ) ; return ; case LEX_UNFINISHED_COMMENT : snprintf ( str , len , ""UNFINISHED COMMENT"" ) ; return ; } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; snprintf ( str , len , ""%s"" , & tokenNames [ p ] ) ; return ; } snprintf ( str , len , ""?[%d]"" , token ) ; }",818,-5.735676716848807,-0.00701182972719903
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
void jslTokenAsString ( int token , char * str , size_t len ) { if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; return ; case LEX_ID : strncpy ( str , ""ID"" , len ) ; return ; case LEX_INT : strncpy ( str , ""INT"" , len ) ; return ; case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; return ; case LEX_STR : strncpy ( str , ""STRING"" , len ) ; return ; case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len ) ; return ; case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; return ; case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; return ; case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; return ; case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len ) ; return ; case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; return ; } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; strncpy ( str , & tokenNames [ p ] , len ) ; return ; } assert ( len >= 10 ) ; espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }
Fixed code:","
void jslTokenAsString ( int token , char * str , size_t len ) { 
   if ( token > 32 && token < 128 ) { 
      assert ( len >= 4 ) ; 
      str [ 0 ] = '\\'' ; 
      str [ 1 ] = ( char ) token ; 
      str [ 2 ] = '\\'' ; 
      str [ 3 ] = 0 ; 
      return ; 
   } 
   switch ( token ) { 
      case LEX_EOF : 
         strncpy ( str , ""EOF"" , len-1 ) ; 
         return ; 
      case LEX_ID : 
         strncpy ( str , ""ID"" , len-1 ) ; 
         return ; 
      case LEX_INT : 
         strncpy ( str , ""INT"" , len-1 ) ; 
         return ; 
      case LEX_FLOAT : 
         strncpy ( str , ""FLOAT"" , len-1 ) ; 
         return ; 
      case LEX_STR : 
         strncpy ( str , ""STRING"" , len-1 ) ; 
         return ; 
      case LEX_UNFINISHED_STR : 
         strncpy ( str , ""UNFINISHED STRING"" , len-1 ) ; 
         return ; 
      case LEX_TEMPLATE_LITERAL : 
         strncpy ( str , ""TEMPLATE LITERAL"" , len-1 ) ; 
         return ; 
      case LEX_UNFINISHED_TEMPLATE_LITERAL : 
         strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len-1 ) ; 
         return ; 
      case LEX_REGEX : 
         strncpy ( str , ""REGEX"" , len-1 ) ; 
         return ; 
      case LEX_UNFINISHED_REGEX : 
         strncpy ( str , ""UNFINISHED REGEX"" , len-1 ) ; 
         return ; 
      case LEX_UNFINISHED_COMMENT : 
         strncpy ( str , ""UNFINISHED COMMENT"" , len-1 ) ; 
         return ; 
   } 
   if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { 
      const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; 
      unsigned int p = 0 ; 
      int n = token - _LEX_OPERATOR_START ; 
      while ( n > 0 && p < sizeof ( tokenNames ) ) { 
         while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; 
         p ++ ; 
         n -- ; 
      } 
      assert ( n == 0 ) ; 
      strncpy ( str ,",1000,-11.911657611032838,-0.011911657611032838
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
void jslTokenAsString ( int token , char * str , size_t len ) { if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; return ; case LEX_ID : strncpy ( str , ""ID"" , len ) ; return ; case LEX_INT : strncpy ( str , ""INT"" , len ) ; return ; case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; return ; case LEX_STR : strncpy ( str , ""STRING"" , len ) ; return ; case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len ) ; return ; case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; return ; case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; return ; case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; return ; case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len ) ; return ; case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; return ; } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; strncpy ( str , & tokenNames [ p ] , len ) ; return ; } assert ( len >= 10 ) ; espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }
Fixed code:","
void jslTokenAsString ( int token , char * str , size_t len ) { if ( token > 32 && token < 128 ) { if ( len >= 4 ) { str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } else { espruino_snprintf ( str , len , ""?[%d]"" , token ) ; return ; } } switch ( token ) { case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; return ; case LEX_ID : strncpy ( str , ""ID"" , len ) ; return ; case LEX_INT : strncpy ( str , ""INT"" , len ) ; return ; case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; return ; case LEX_STR : strncpy ( str , ""STRING"" , len ) ; return ; case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len ) ; return ; case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; return ; case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; return ; case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; return ; case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len ) ; return ; case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; return ; } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; char buf [ 256 ] ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; strncpy ( buf , & tokenNames [ p ] , sizeof ( buf ) ) ; if ( len < strlen ( buf ) ) { espruino_snprintf ( str , len , ""?[%d]"" , token ) ; } else { strncpy ( str , buf , len ) ; } return ; } if ( len >= 10 ) { espruino_snprintf ( str , len , ""?[%d]"" , token ) ; } }",942,-28.672926166584567,-0.030438350495312703
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
void jslTokenAsString ( int token , char * str , size_t len ) { if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; return ; case LEX_ID : strncpy ( str , ""ID"" , len ) ; return ; case LEX_INT : strncpy ( str , ""INT"" , len ) ; return ; case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; return ; case LEX_STR : strncpy ( str , ""STRING"" , len ) ; return ; case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len ) ; return ; case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; return ; case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; return ; case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; return ; case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len ) ; return ; case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; return ; } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; strncpy ( str , & tokenNames [ p ] , len ) ; return ; } assert ( len >= 10 ) ; espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }
Fixed code:","
void jslTokenAsString ( int token , char * str , size_t len ) { if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; return ; case LEX_ID : strncpy ( str , ""ID"" , len ) ; return ; case LEX_INT : strncpy ( str , ""INT"" , len ) ; return ; case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; return ; case LEX_STR : strncpy ( str , ""STRING"" , len ) ; return ; case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len ) ; return ; case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; return ; case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; return ; case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; return ; case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len ) ; return ; case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; return ; } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; strncpy ( str , & tokenNames [ p ] , sizeof ( tokenNames ) - 1 ) ; return ; } assert ( len >= 10 ) ; espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }",864,-12.971531254902777,-0.015013346359841176
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
void jslTokenAsString ( int token , char * str , size_t len ) { if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; return ; case LEX_ID : strncpy ( str , ""ID"" , len ) ; return ; case LEX_INT : strncpy ( str , ""INT"" , len ) ; return ; case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; return ; case LEX_STR : strncpy ( str , ""STRING"" , len ) ; return ; case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len ) ; return ; case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; return ; case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; return ; case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; return ; case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len ) ; return ; case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; return ; } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; strncpy ( str , & tokenNames [ p ] , len ) ; return ; } assert ( len >= 10 ) ; espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }
Fixed code:","
void jslTokenAsString ( int token , char * str , size_t len ) { if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { case LEX_EOF : strncpy ( str , ""EOF"" , len - 1 ) ; return ; case LEX_ID : strncpy ( str , ""ID"" , len - 1 ) ; return ; case LEX_INT : strncpy ( str , ""INT"" , len - 1 ) ; return ; case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len - 1 ) ; return ; case LEX_STR : strncpy ( str , ""STRING"" , len - 1 ) ; return ; case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len - 1 ) ; return ; case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len - 1 ) ; return ; case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len - 1 ) ; return ; case LEX_REGEX : strncpy ( str , ""REGEX"" , len - 1 ) ; return ; case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len - 1 ) ; return ; case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len - 1 ) ; return ; } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; strncpy ( str , & tokenNames [ p ] , len - 1 ) ; return ; } assert ( len >= 10 ) ; espruino_snprintf ( str , len - 1 , ""?[%d]"" , token ) ; }",884,-4.151178844664811,-0.004695903670435307
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
void jslTokenAsString ( int token , char * str , size_t len ) { if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; return ; case LEX_ID : strncpy ( str , ""ID"" , len ) ; return ; case LEX_INT : strncpy ( str , ""INT"" , len ) ; return ; case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; return ; case LEX_STR : strncpy ( str , ""STRING"" , len ) ; return ; case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len ) ; return ; case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; return ; case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; return ; case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; return ; case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len ) ; return ; case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; return ; } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; strncpy ( str , & tokenNames [ p ] , len ) ; return ; } assert ( len >= 10 ) ; espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }
Fixed code:","
void jslTokenAsString ( int token , char * str , size_t len ) { if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { case LEX_EOF : strncpy ( str , ""EOF"" , len < 4 ? len : 4 ) ; return ; case LEX_ID : strncpy ( str , ""ID"" , len < 3 ? len : 3 ) ; return ; case LEX_INT : strncpy ( str , ""INT"" , len < 4 ? len : 4 ) ; return ; case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len < 6 ? len : 6 ) ; return ; case LEX_STR : strncpy ( str , ""STRING"" , len < 7 ? len : 7 ) ; return ; case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len < 18 ? len : 18 ) ; return ; case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len < 17 ? len : 17 ) ; return ; case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len < 27 ? len : 27 ) ; return ; case LEX_REGEX : strncpy ( str , ""REGEX"" , len < 6 ? len : 6 ) ; return ; case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len < 17 ? len : 17 ) ; return ; case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len < 19 ? len : 19 ) ; return ; } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; size_t max_len = strlen(&tokenNames[p]); strncpy ( str , & tokenNames [ p ] , len < max_len ? len : max_len ) ; return ; } assert ( len >= 10 ) ; espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }",949,-19.155445104202535,-0.02018487366090889
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
void jslTokenAsString ( int token , char * str , size_t len ) { if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; return ; case LEX_ID : strncpy ( str , ""ID"" , len ) ; return ; case LEX_INT : strncpy ( str , ""INT"" , len ) ; return ; case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; return ; case LEX_STR : strncpy ( str , ""STRING"" , len ) ; return ; case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len ) ; return ; case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; return ; case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; return ; case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; return ; case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len ) ; return ; case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; return ; } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; strncpy ( str , & tokenNames [ p ] , len ) ; return ; } assert ( len >= 10 ) ; espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }
Fixed code:","
void jslTokenAsString ( int token , char * str , size_t len ) { if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { case LEX_EOF : strncpy ( str , ""EOF"" , ( len < 3 ) ? len : 3 ) ; return ; case LEX_ID : strncpy ( str , ""ID"" , ( len < 2 ) ? len : 2 ) ; return ; case LEX_INT : strncpy ( str , ""INT"" , ( len < 3 ) ? len : 3 ) ; return ; case LEX_FLOAT : strncpy ( str , ""FLOAT"" , ( len < 5 ) ? len : 5 ) ; return ; case LEX_STR : strncpy ( str , ""STRING"" , ( len < 7 ) ? len : 7 ) ; return ; case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , ( len < 18 ) ? len : 18 ) ; return ; case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , ( len < 17 ) ? len : 17 ) ; return ; case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , ( len < 27 ) ? len : 27 ) ; return ; case LEX_REGEX : strncpy ( str , ""REGEX"" , ( len < 5 ) ? len : 5 ) ; return ; case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , ( len < 16 ) ? len : 16 ) ; return ; case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , ( len < 19 ) ? len : 19 ) ; return ; } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; unsigned int token_len = 0 ; while ( tokenNames [ p + token_len ] != '\\0' && ( p + token_len ) < sizeof ( tokenNames ) ) { token_len ++ ; } strncpy ( str , & tokenNames [ p ] , ( len < token_len ) ? len : token_len ) ; return ; } assert ( len >= 10 ) ; espruino_snprintf ( str , len , ""?[%d]"" ,",1000,-25.66362321985454,-0.02566362321985454
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
void jslTokenAsString ( int token , char * str , size_t len ) { if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; return ; case LEX_ID : strncpy ( str , ""ID"" , len ) ; return ; case LEX_INT : strncpy ( str , ""INT"" , len ) ; return ; case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; return ; case LEX_STR : strncpy ( str , ""STRING"" , len ) ; return ; case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED STRING"" , len ) ; return ; case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; return ; case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; return ; case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; return ; case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED REGEX"" , len ) ; return ; case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; return ; } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; strncpy ( str , & tokenNames [ p ] , len ) ; return ; } assert ( len >= 10 ) ; espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }
Fixed code:"," 
void jslTokenAsString ( int token , char * str , size_t len ) { 
 if ( token > 32 && token < 128 ) { 
     if(len >=4){
       str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; 
     }
     return ; 
} 
 switch ( token ) { 
     case LEX_EOF : 
     if(len >=3){
       strncpy ( str , ""EOF"" , len ) ; 
     }
     return ; 
     case LEX_ID : 
     if(len >=2){
       strncpy ( str , ""ID"" , len ) ; 
     }
     return ; 
     case LEX_INT : 
     if(len >=3){
       strncpy ( str , ""INT"" , len ) ; 
     }
     return ; 
     case LEX_FLOAT : 
     if(len >=5){
       strncpy ( str , ""FLOAT"" , len ) ; 
     }
     return ; 
     case LEX_STR : 
     if(len >=7){
       strncpy ( str , ""STRING"" , len ) ; 
     }
     return ; 
     case LEX_UNFINISHED_STR : 
     if(len >=17){
       strncpy ( str , ""UNFINISHED STRING"" , len ) ; 
     }
     return ; 
     case LEX_TEMPLATE_LITERAL : 
     if(len >=16){
       strncpy ( str , ""TEMPLATE LITERAL"" , len ) ; 
     }
     return ; 
     case LEX_UNFINISHED_TEMPLATE_LITERAL : 
     if(len >=29){
       strncpy ( str , ""UNFINISHED TEMPLATE LITERAL"" , len ) ; 
     }
     return ; 
     case LEX_REGEX : 
     if(len >=5){
       strncpy ( str , ""REGEX"" , len ) ; 
     }
     return ; 
     case LEX_UNFINISHED_REGEX : 
     if(len >=18){
       strncpy ( str , ""UNFINISHED REGEX"" , len ) ; 
     }
     return ; 
     case LEX_UNFINISHED_COMMENT : 
     if(len >=20){
       strncpy ( str , ""UNFINISHED COMMENT"" , len ) ; 
     }
     return ; 
 } 
 if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { 
    const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; 
    unsigned int p = 0 ; 
    int n =",1000,-51.314132197848295,-0.05131413219784829
