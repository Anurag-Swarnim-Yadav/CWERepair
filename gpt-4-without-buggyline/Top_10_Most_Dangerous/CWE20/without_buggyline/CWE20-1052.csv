Original code,Plausible Program,Total Tokens,Sum Entropy,Mean Entropy
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int try_read_command ( conn * c ) { assert ( c != NULL ) ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; assert ( c -> rbytes > 0 ) ; if ( c -> protocol == negotiating_prot || c -> transport == udp_transport ) { if ( ( unsigned char ) c -> rbuf [ 0 ] == ( unsigned char ) PROTOCOL_BINARY_REQ ) { c -> protocol = binary_prot ; } else { c -> protocol = ascii_prot ; } if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Client using the %s protocol\\n"" , c -> sfd , prot_text ( c -> protocol ) ) ; } } if ( c -> protocol == binary_prot ) { if ( c -> rbytes < sizeof ( c -> binary_header ) ) { return 0 ; } else { # ifdef NEED_ALIGN if ( ( ( long ) ( c -> rcurr ) ) % 8 != 0 ) { memmove ( c -> rbuf , c -> rcurr , c -> rbytes ) ; c -> rcurr = c -> rbuf ; if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Realign input buffer\\n"" , c -> sfd ) ; } } # endif protocol_binary_request_header * req ; req = ( protocol_binary_request_header * ) c -> rcurr ; if ( settings . verbose > 1 ) { int ii ; fprintf ( stderr , ""<%d Read binary protocol data:"" , c -> sfd ) ; for ( ii = 0 ; ii < sizeof ( req -> bytes ) ; ++ ii ) { if ( ii % 4 == 0 ) { fprintf ( stderr , ""\\n<%d   "" , c -> sfd ) ; } fprintf ( stderr , "" 0x%02x"" , req -> bytes [ ii ] ) ; } fprintf ( stderr , ""\\n"" ) ; } c -> binary_header = * req ; c -> binary_header . request . keylen = ntohs ( req -> request . keylen ) ; c -> binary_header . request . bodylen = ntohl ( req -> request . bodylen ) ; c -> binary_header . request . cas = ntohll ( req -> request . cas ) ; if ( c -> binary_header . request . magic != PROTOCOL_BINARY_REQ ) { if ( settings . verbose ) { fprintf ( stderr , ""Invalid magic:  %x\\n"" , c -> binary_header . request . magic ) ; } conn_set_state ( c , conn_closing ) ; return - 1 ; } c -> msgcurr = 0 ; c -> msgused = 0 ; c -> iovused = 0 ; if ( add_msghdr ( c ) != 0 ) { out_string ( c , ""SERVER_ERROR out of memory"" ) ; return 0 ; } c -> cmd = c -> binary_header . request . opcode ; c -> keylen = c -> binary_header . request . keylen ; c -> opaque = c -> binary_header . request . opaque ; c -> cas = 0 ; dispatch_bin_command ( c ) ; c -> rbytes -= sizeof ( c -> binary_header ) ; c -> rcurr += sizeof ( c -> binary_header ) ; } } else { char * el , * cont ; if ( c -> rbytes == 0 ) return 0 ; el = memchr ( c -> rcurr , '\\n' , c -> rbytes ) ; if ( ! el ) return 0 ; cont = el + 1 ; if ( ( el - c -> rcurr ) > 1 && * ( el - 1 ) == '\\r' ) { el -- ; } * el = '\\0' ; assert ( cont <= ( c -> rcurr + c -> rbytes ) ) ; process_command ( c , c -> rcurr ) ; c -> rbytes -= ( cont - c -> rcurr ) ; c -> rcurr = cont ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; } return 1 ; }
Fixed code:","
static int try_read_command ( conn * c ) { assert ( c != NULL ) ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; assert ( c -> rbytes > 0 ) ; if ( c -> protocol == negotiating_prot || c -> transport == udp_transport ) { if ( ( unsigned char ) c -> rbuf [ 0 ] == ( unsigned char ) PROTOCOL_BINARY_REQ ) { c -> protocol = binary_prot ; } else { c -> protocol = ascii_prot ; } if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Client using the %s protocol\\n"" , c -> sfd , prot_text ( c -> protocol ) ) ; } } if ( c -> protocol == binary_prot ) { if ( c -> rbytes < sizeof ( c -> binary_header ) ) { return 0 ; } else { # ifdef NEED_ALIGN if ( ( ( long ) ( c -> rcurr ) ) % 8 != 0 ) { memmove ( c -> rbuf , c -> rcurr , c -> rbytes ) ; c -> rcurr = c -> rbuf ; if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Realign input buffer\\n"" , c -> sfd ) ; } } # endif protocol_binary_request_header * req ; req = ( protocol_binary_request_header * ) c -> rcurr ; if ( settings . verbose > 1 ) { int ii ; fprintf ( stderr , ""<%d Read binary protocol data:"" , c -> sfd ) ; for ( ii = 0 ; ii < sizeof ( req -> bytes ) ; ++ ii ) { if ( ii % 4 == 0 ) { fprintf ( stderr , ""\\n<%d   "" , c -> sfd ) ; } fprintf ( stderr , "" 0x%02x"" , req -> bytes [ ii ] ) ; } fprintf ( stderr , ""\\n"" ) ; } c -> binary_header = * req ; c -> binary_header . request . keylen = ntohs ( req -> request . keylen ) ; c -> binary_header . request . bodylen = ntohl ( req -> request . bodylen ) ; c -> binary_header . request . cas = ntohll ( req -> request . cas ) ; if ( c -> binary_header . request . magic != PROTOCOL_BINARY_REQ ) { if ( settings . verbose ) { fprintf ( stderr , ""Invalid magic:  %x\\n"" , c -> binary_header . request . magic ) ; } if ( c -> binary_header . request . opcode >= PROTOCOL_BINARY_CMD_SASL_LIST_MECHS && c -> binary_header . request . opcode <= PROTOCOL_BINARY_CMD_SASL_AUTH ) { out_string ( c , ""UNKNOWN_COMMAND"" ) ; return 0 ; } else { conn_set_state ( c , conn_closing ) ; return - 1 ; } } c -> msgcurr = 0 ; c -> msgused = 0 ; c -> iovused = 0 ; if ( add_msghdr ( c ) != 0 ) { out_string ( c , ""SERVER_ERROR out of memory"" ) ; return 0 ; } c -> cmd = c -> binary_header . request . opcode ; c -> keylen = c -> binary_header . request . keylen ; c -> opaque = c -> binary_header . request . opaque ; c -> cas = 0 ; dispatch_bin_command ( c ) ; c -> rbytes -= sizeof ( c -> binary_header ) ; c -> rcurr += sizeof ( c -> binary_header ) ; } } else { char * el , * cont ; if ( c -> rbytes == 0 ) return 0 ; el = memchr ( c -> rcurr , '\\n' , c -> rbytes ) ; if ( ! el ) return 0 ; cont = el + 1 ; if ( ( el - c -> rcurr ) > 1 && * ( el - 1 ) == '\\r' ) { el -- ; } * el = '\\0' ; assert ( cont <= ( c -> rcurr + c -> rbytes ) ) ; process_command ( c , c -> rcurr ) ; c -> rbytes -= ( cont - c -> rcurr ) ; c -> rcurr = cont ;",1000,-20.678264377207892,-0.02067826437720789
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int try_read_command ( conn * c ) { assert ( c != NULL ) ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; assert ( c -> rbytes > 0 ) ; if ( c -> protocol == negotiating_prot || c -> transport == udp_transport ) { if ( ( unsigned char ) c -> rbuf [ 0 ] == ( unsigned char ) PROTOCOL_BINARY_REQ ) { c -> protocol = binary_prot ; } else { c -> protocol = ascii_prot ; } if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Client using the %s protocol\\n"" , c -> sfd , prot_text ( c -> protocol ) ) ; } } if ( c -> protocol == binary_prot ) { if ( c -> rbytes < sizeof ( c -> binary_header ) ) { return 0 ; } else { # ifdef NEED_ALIGN if ( ( ( long ) ( c -> rcurr ) ) % 8 != 0 ) { memmove ( c -> rbuf , c -> rcurr , c -> rbytes ) ; c -> rcurr = c -> rbuf ; if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Realign input buffer\\n"" , c -> sfd ) ; } } # endif protocol_binary_request_header * req ; req = ( protocol_binary_request_header * ) c -> rcurr ; if ( settings . verbose > 1 ) { int ii ; fprintf ( stderr , ""<%d Read binary protocol data:"" , c -> sfd ) ; for ( ii = 0 ; ii < sizeof ( req -> bytes ) ; ++ ii ) { if ( ii % 4 == 0 ) { fprintf ( stderr , ""\\n<%d   "" , c -> sfd ) ; } fprintf ( stderr , "" 0x%02x"" , req -> bytes [ ii ] ) ; } fprintf ( stderr , ""\\n"" ) ; } c -> binary_header = * req ; c -> binary_header . request . keylen = ntohs ( req -> request . keylen ) ; c -> binary_header . request . bodylen = ntohl ( req -> request . bodylen ) ; c -> binary_header . request . cas = ntohll ( req -> request . cas ) ; if ( c -> binary_header . request . magic != PROTOCOL_BINARY_REQ ) { if ( settings . verbose ) { fprintf ( stderr , ""Invalid magic:  %x\\n"" , c -> binary_header . request . magic ) ; } conn_set_state ( c , conn_closing ) ; return - 1 ; } c -> msgcurr = 0 ; c -> msgused = 0 ; c -> iovused = 0 ; if ( add_msghdr ( c ) != 0 ) { out_string ( c , ""SERVER_ERROR out of memory"" ) ; return 0 ; } c -> cmd = c -> binary_header . request . opcode ; c -> keylen = c -> binary_header . request . keylen ; c -> opaque = c -> binary_header . request . opaque ; c -> cas = 0 ; dispatch_bin_command ( c ) ; c -> rbytes -= sizeof ( c -> binary_header ) ; c -> rcurr += sizeof ( c -> binary_header ) ; } } else { char * el , * cont ; if ( c -> rbytes == 0 ) return 0 ; el = memchr ( c -> rcurr , '\\n' , c -> rbytes ) ; if ( ! el ) return 0 ; cont = el + 1 ; if ( ( el - c -> rcurr ) > 1 && * ( el - 1 ) == '\\r' ) { el -- ; } * el = '\\0' ; assert ( cont <= ( c -> rcurr + c -> rbytes ) ) ; process_command ( c , c -> rcurr ) ; c -> rbytes -= ( cont - c -> rcurr ) ; c -> rcurr = cont ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; } return 1 ; }
Fixed code:","
static int try_read_command ( conn * c ) { assert ( c != NULL ) ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; assert ( c -> rbytes > 0 ) ; if ( c -> protocol == negotiating_prot || c -> transport == udp_transport ) { if ( ( unsigned char ) c -> rbuf [ 0 ] == ( unsigned char ) PROTOCOL_BINARY_REQ ) { c -> protocol = binary_prot ; } else { c -> protocol = ascii_prot ; } if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Client using the %s protocol\\n"" , c -> sfd , prot_text ( c -> protocol ) ) ; } } if ( c -> protocol == binary_prot ) { if ( c -> rbytes < sizeof ( c -> binary_header ) ) { return 0 ; } else { # ifdef NEED_ALIGN if ( ( ( long ) ( c -> rcurr ) ) % 8 != 0 ) { memmove ( c -> rbuf , c -> rcurr , c -> rbytes ) ; c -> rcurr = c -> rbuf ; if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Realign input buffer\\n"" , c -> sfd ) ; } } # endif protocol_binary_request_header * req ; req = ( protocol_binary_request_header * ) c -> rcurr ; if ( settings . verbose > 1 ) { int ii ; fprintf ( stderr , ""<%d Read binary protocol data:"" , c -> sfd ) ; for ( ii = 0 ; ii < sizeof ( req -> bytes ) ; ++ ii ) { if ( ii % 4 == 0 ) { fprintf ( stderr , ""\\n<%d   "" , c -> sfd ) ; } fprintf ( stderr , "" 0x%02x"" , req -> bytes [ ii ] ) ; } fprintf ( stderr , ""\\n"" ) ; } if ( req -> request . magic != PROTOCOL_BINARY_REQ ) { if ( settings . verbose ) { fprintf ( stderr , ""Invalid magic:  %x\\n"" , c -> binary_header . request . magic ) ; } conn_set_state ( c , conn_closing ) ; return - 1 ; } c -> binary_header = * req ; c -> binary_header . request . keylen = ntohs ( req -> request . keylen ) ; c -> binary_header . request . bodylen = ntohl ( req -> request . bodylen ) ; c -> binary_header . request . cas = ntohll ( req -> request . cas ) ; c -> msgcurr = 0 ; c -> msgused = 0 ; c -> iovused = 0 ; if ( add_msghdr ( c ) != 0 ) { out_string ( c , ""SERVER_ERROR out of memory"" ) ; return 0 ; } c -> cmd = c -> binary_header . request . opcode ; c -> keylen = c -> binary_header . request . keylen ; c -> opaque = c -> binary_header . request . opaque ; c -> cas = 0 ; dispatch_bin_command ( c ) ; c -> rbytes -= sizeof ( c -> binary_header ) ; c -> rcurr += sizeof ( c -> binary_header ) ; } } else { char * el , * cont ; if ( c -> rbytes == 0 ) return 0 ; el = memchr ( c -> rcurr , '\\n' , c -> rbytes ) ; if ( ! el ) return 0 ; cont = el + 1 ; if ( ( el - c -> rcurr ) > 1 && * ( el - 1 ) == '\\r' ) { el -- ; } * el = '\\0' ; assert ( cont <= ( c -> rcurr + c -> rbytes ) ) ; process_command ( c , c -> rcurr ) ; c -> rbytes -= ( cont - c -> rcurr ) ; c -> rcurr = cont ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; } return 1 ; }",935,-8.837808734711722,-0.009452201855306654
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int try_read_command ( conn * c ) { assert ( c != NULL ) ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; assert ( c -> rbytes > 0 ) ; if ( c -> protocol == negotiating_prot || c -> transport == udp_transport ) { if ( ( unsigned char ) c -> rbuf [ 0 ] == ( unsigned char ) PROTOCOL_BINARY_REQ ) { c -> protocol = binary_prot ; } else { c -> protocol = ascii_prot ; } if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Client using the %s protocol\\n"" , c -> sfd , prot_text ( c -> protocol ) ) ; } } if ( c -> protocol == binary_prot ) { if ( c -> rbytes < sizeof ( c -> binary_header ) ) { return 0 ; } else { # ifdef NEED_ALIGN if ( ( ( long ) ( c -> rcurr ) ) % 8 != 0 ) { memmove ( c -> rbuf , c -> rcurr , c -> rbytes ) ; c -> rcurr = c -> rbuf ; if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Realign input buffer\\n"" , c -> sfd ) ; } } # endif protocol_binary_request_header * req ; req = ( protocol_binary_request_header * ) c -> rcurr ; if ( settings . verbose > 1 ) { int ii ; fprintf ( stderr , ""<%d Read binary protocol data:"" , c -> sfd ) ; for ( ii = 0 ; ii < sizeof ( req -> bytes ) ; ++ ii ) { if ( ii % 4 == 0 ) { fprintf ( stderr , ""\\n<%d   "" , c -> sfd ) ; } fprintf ( stderr , "" 0x%02x"" , req -> bytes [ ii ] ) ; } fprintf ( stderr , ""\\n"" ) ; } c -> binary_header = * req ; c -> binary_header . request . keylen = ntohs ( req -> request . keylen ) ; c -> binary_header . request . bodylen = ntohl ( req -> request . bodylen ) ; c -> binary_header . request . cas = ntohll ( req -> request . cas ) ; if ( c -> binary_header . request . magic != PROTOCOL_BINARY_REQ ) { if ( settings . verbose ) { fprintf ( stderr , ""Invalid magic:  %x\\n"" , c -> binary_header . request . magic ) ; } conn_set_state ( c , conn_closing ) ; return - 1 ; } c -> msgcurr = 0 ; c -> msgused = 0 ; c -> iovused = 0 ; if ( add_msghdr ( c ) != 0 ) { out_string ( c , ""SERVER_ERROR out of memory"" ) ; return 0 ; } c -> cmd = c -> binary_header . request . opcode ; c -> keylen = c -> binary_header . request . keylen ; c -> opaque = c -> binary_header . request . opaque ; c -> cas = 0 ; dispatch_bin_command ( c ) ; c -> rbytes -= sizeof ( c -> binary_header ) ; c -> rcurr += sizeof ( c -> binary_header ) ; } } else { char * el , * cont ; if ( c -> rbytes == 0 ) return 0 ; el = memchr ( c -> rcurr , '\\n' , c -> rbytes ) ; if ( ! el ) return 0 ; cont = el + 1 ; if ( ( el - c -> rcurr ) > 1 && * ( el - 1 ) == '\\r' ) { el -- ; } * el = '\\0' ; assert ( cont <= ( c -> rcurr + c -> rbytes ) ) ; process_command ( c , c -> rcurr ) ; c -> rbytes -= ( cont - c -> rcurr ) ; c -> rcurr = cont ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; } return 1 ; }
Fixed code:","
static int try_read_command ( conn * c ) { assert ( c != NULL ) ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; assert ( c -> rbytes > 0 ) ; if ( c -> protocol == negotiating_prot || c -> transport == udp_transport ) { if ( ( unsigned char ) c -> rbuf [ 0 ] == ( unsigned char ) PROTOCOL_BINARY_REQ ) { c -> protocol = binary_prot ; } else if ( is_valid_ascii_protocol(c->rbuf) ) { c -> protocol = ascii_prot ; } else { conn_set_state ( c , conn_closing ) ; return - 1 ; } if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Client using the %s protocol\\n"" , c -> sfd , prot_text ( c -> protocol ) ) ; } } if ( c -> protocol == binary_prot ) { if ( c -> rbytes < sizeof ( c -> binary_header ) ) { return 0 ; } else { # ifdef NEED_ALIGN if ( ( ( long ) ( c -> rcurr ) ) % 8 != 0 ) { memmove ( c -> rbuf , c -> rcurr , c -> rbytes ) ; c -> rcurr = c -> rbuf ; if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Realign input buffer\\n"" , c -> sfd ) ; } } # endif protocol_binary_request_header * req ; req = ( protocol_binary_request_header * ) c -> rcurr ; if ( settings . verbose > 1 ) { int ii ; fprintf ( stderr , ""<%d Read binary protocol data:"" , c -> sfd ) ; for ( ii = 0 ; ii < sizeof ( req -> bytes ) ; ++ ii ) { if ( ii % 4 == 0 ) { fprintf ( stderr , ""\\n<%d   "" , c -> sfd ) ; } fprintf ( stderr , "" 0x%02x"" , req -> bytes [ ii ] ) ; } fprintf ( stderr , ""\\n"" ) ; } c -> binary_header = * req ; c -> binary_header . request . keylen = ntohs ( req -> request . keylen ) ; c -> binary_header . request . bodylen = ntohl ( req -> request . bodylen ) ; c -> binary_header . request . cas = ntohll ( req -> request . cas ) ; if ( c -> binary_header . request . magic != PROTOCOL_BINARY_REQ ) { if ( settings . verbose ) { fprintf ( stderr , ""Invalid magic:  %x\\n"" , c -> binary_header . request . magic ) ; } conn_set_state ( c , conn_closing ) ; return - 1 ; } c -> msgcurr = 0 ; c -> msgused = 0 ; c -> iovused = 0 ; if ( add_msghdr ( c ) != 0 ) { out_string ( c , ""SERVER_ERROR out of memory"" ) ; return 0 ; } c -> cmd = c -> binary_header . request . opcode ; c -> keylen = c -> binary_header . request . keylen ; c -> opaque = c -> binary_header . request . opaque ; c -> cas = 0 ; dispatch_bin_command ( c ) ; c -> rbytes -= sizeof ( c -> binary_header ) ; c -> rcurr += sizeof ( c -> binary_header ) ; } } else { char * el , * cont ; if ( c -> rbytes == 0 ) return 0 ; el = memchr ( c -> rcurr , '\\n' , c -> rbytes ) ; if ( ! el ) return 0 ; cont = el + 1 ; if ( ( el - c -> rcurr ) > 1 && * ( el - 1 ) == '\\r' ) { el -- ; } * el = '\\0' ; assert ( cont <= ( c -> rcurr + c -> rbytes ) ) ; if ( is_valid_ascii_protocol(c->rcurr) ) { process_command ( c , c -> rcurr ) ; c -> rbytes -= ( cont - c -> rcurr ) ; c -> rcurr = cont ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; } else { conn_",1000,-18.390153463490307,-0.018390153463490308
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int try_read_command ( conn * c ) { assert ( c != NULL ) ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; assert ( c -> rbytes > 0 ) ; if ( c -> protocol == negotiating_prot || c -> transport == udp_transport ) { if ( ( unsigned char ) c -> rbuf [ 0 ] == ( unsigned char ) PROTOCOL_BINARY_REQ ) { c -> protocol = binary_prot ; } else { c -> protocol = ascii_prot ; } if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Client using the %s protocol\\n"" , c -> sfd , prot_text ( c -> protocol ) ) ; } } if ( c -> protocol == binary_prot ) { if ( c -> rbytes < sizeof ( c -> binary_header ) ) { return 0 ; } else { # ifdef NEED_ALIGN if ( ( ( long ) ( c -> rcurr ) ) % 8 != 0 ) { memmove ( c -> rbuf , c -> rcurr , c -> rbytes ) ; c -> rcurr = c -> rbuf ; if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Realign input buffer\\n"" , c -> sfd ) ; } } # endif protocol_binary_request_header * req ; req = ( protocol_binary_request_header * ) c -> rcurr ; if ( settings . verbose > 1 ) { int ii ; fprintf ( stderr , ""<%d Read binary protocol data:"" , c -> sfd ) ; for ( ii = 0 ; ii < sizeof ( req -> bytes ) ; ++ ii ) { if ( ii % 4 == 0 ) { fprintf ( stderr , ""\\n<%d   "" , c -> sfd ) ; } fprintf ( stderr , "" 0x%02x"" , req -> bytes [ ii ] ) ; } fprintf ( stderr , ""\\n"" ) ; } c -> binary_header = * req ; c -> binary_header . request . keylen = ntohs ( req -> request . keylen ) ; c -> binary_header . request . bodylen = ntohl ( req -> request . bodylen ) ; c -> binary_header . request . cas = ntohll ( req -> request . cas ) ; if ( c -> binary_header . request . magic != PROTOCOL_BINARY_REQ ) { if ( settings . verbose ) { fprintf ( stderr , ""Invalid magic:  %x\\n"" , c -> binary_header . request . magic ) ; } conn_set_state ( c , conn_closing ) ; return - 1 ; } c -> msgcurr = 0 ; c -> msgused = 0 ; c -> iovused = 0 ; if ( add_msghdr ( c ) != 0 ) { out_string ( c , ""SERVER_ERROR out of memory"" ) ; return 0 ; } c -> cmd = c -> binary_header . request . opcode ; c -> keylen = c -> binary_header . request . keylen ; c -> opaque = c -> binary_header . request . opaque ; c -> cas = 0 ; dispatch_bin_command ( c ) ; c -> rbytes -= sizeof ( c -> binary_header ) ; c -> rcurr += sizeof ( c -> binary_header ) ; } } else { char * el , * cont ; if ( c -> rbytes == 0 ) return 0 ; el = memchr ( c -> rcurr , '\\n' , c -> rbytes ) ; if ( ! el ) return 0 ; cont = el + 1 ; if ( ( el - c -> rcurr ) > 1 && * ( el - 1 ) == '\\r' ) { el -- ; } * el = '\\0' ; assert ( cont <= ( c -> rcurr + c -> rbytes ) ) ; process_command ( c , c -> rcurr ) ; c -> rbytes -= ( cont - c -> rcurr ) ; c -> rcurr = cont ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; } return 1 ; }
Fixed code:","
static int try_read_command ( conn * c ) { assert ( c != NULL ) ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; assert ( c -> rbytes > 0 ) ; if ( c -> protocol == negotiating_prot || c -> transport == udp_transport ) { if ( ( unsigned char ) c -> rbuf [ 0 ] == ( unsigned char ) PROTOCOL_BINARY_REQ ) { c -> protocol = binary_prot ; } else { c -> protocol = ascii_prot ; } if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Client using the %s protocol\\n"" , c -> sfd , prot_text ( c -> protocol ) ) ; } } if ( c -> protocol == binary_prot ) { if ( c -> rbytes < sizeof ( c -> binary_header ) ) { return 0 ; } else { //Validate the input if (!validate_input(c->rcurr)) { //Set state to closing if failed to validate input conn_set_state ( c , conn_closing ) ; return - 1 ; } # ifdef NEED_ALIGN if ( ( ( long ) ( c -> rcurr ) ) % 8 != 0 ) { memmove ( c -> rbuf , c -> rcurr , c -> rbytes ) ; c -> rcurr = c -> rbuf ; if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Realign input buffer\\n"" , c -> sfd ) ; } } # endif protocol_binary_request_header * req ; req = ( protocol_binary_request_header * ) c -> rcurr ; if ( settings . verbose > 1 ) { int ii ; fprintf ( stderr , ""<%d Read binary protocol data:"" , c -> sfd ) ; for ( ii = 0 ; ii < sizeof ( req -> bytes ) ; ++ ii ) { if ( ii % 4 == 0 ) { fprintf ( stderr , ""\\n<%d   "" , c -> sfd ) ; } fprintf ( stderr , "" 0x%02x"" , req -> bytes [ ii ] ) ; } fprintf ( stderr , ""\\n"" ) ; } c -> binary_header = * req ; c -> binary_header . request . keylen = ntohs ( req -> request . keylen ) ; c -> binary_header . request . bodylen = ntohl ( req -> request . bodylen ) ; c -> binary_header . request . cas = ntohll ( req -> request . cas ) ; if ( c -> binary_header . request . magic != PROTOCOL_BINARY_REQ ) { if ( settings . verbose ) { fprintf ( stderr , ""Invalid magic:  %x\\n"" , c -> binary_header . request . magic ) ; } conn_set_state ( c , conn_closing ) ; return - 1 ; } c -> msgcurr = 0 ; c -> msgused = 0 ; c -> iovused = 0 ; if ( add_msghdr ( c ) != 0 ) { out_string ( c , ""SERVER_ERROR out of memory"" ) ; return 0 ; } c -> cmd = c -> binary_header . request . opcode ; c -> keylen = c -> binary_header . request . keylen ; c -> opaque = c -> binary_header . request . opaque ; c -> cas = 0 ; dispatch_bin_command ( c ) ; c -> rbytes -= sizeof ( c -> binary_header ) ; c -> rcurr += sizeof ( c -> binary_header ) ; } } else { char * el , * cont ; if ( c -> rbytes == 0 ) return 0 ; el = memchr ( c -> rcurr , '\\n' , c -> rbytes ) ; if ( ! el ) return 0 ; cont = el + 1 ; if ( ( el - c -> rcurr ) > 1 && * ( el - 1 ) == '\\r' ) { el -- ; } * el = '\\0' ; assert ( cont <= ( c -> rcurr + c -> rbytes ) ) ; //Validate the input if (!validate_input(c->rcurr)) { //Set state to closing if failed to validate input conn_set_state ( c , conn_closing ) ; return - 1 ; } process_command ( c , c -> rcurr ) ; c -> rbytes -= ( cont - c -> rcurr )",1000,-34.93791042238667,-0.03493791042238667
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int try_read_command ( conn * c ) { assert ( c != NULL ) ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; assert ( c -> rbytes > 0 ) ; if ( c -> protocol == negotiating_prot || c -> transport == udp_transport ) { if ( ( unsigned char ) c -> rbuf [ 0 ] == ( unsigned char ) PROTOCOL_BINARY_REQ ) { c -> protocol = binary_prot ; } else { c -> protocol = ascii_prot ; } if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Client using the %s protocol\\n"" , c -> sfd , prot_text ( c -> protocol ) ) ; } } if ( c -> protocol == binary_prot ) { if ( c -> rbytes < sizeof ( c -> binary_header ) ) { return 0 ; } else { # ifdef NEED_ALIGN if ( ( ( long ) ( c -> rcurr ) ) % 8 != 0 ) { memmove ( c -> rbuf , c -> rcurr , c -> rbytes ) ; c -> rcurr = c -> rbuf ; if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Realign input buffer\\n"" , c -> sfd ) ; } } # endif protocol_binary_request_header * req ; req = ( protocol_binary_request_header * ) c -> rcurr ; if ( settings . verbose > 1 ) { int ii ; fprintf ( stderr , ""<%d Read binary protocol data:"" , c -> sfd ) ; for ( ii = 0 ; ii < sizeof ( req -> bytes ) ; ++ ii ) { if ( ii % 4 == 0 ) { fprintf ( stderr , ""\\n<%d   "" , c -> sfd ) ; } fprintf ( stderr , "" 0x%02x"" , req -> bytes [ ii ] ) ; } fprintf ( stderr , ""\\n"" ) ; } c -> binary_header = * req ; c -> binary_header . request . keylen = ntohs ( req -> request . keylen ) ; c -> binary_header . request . bodylen = ntohl ( req -> request . bodylen ) ; c -> binary_header . request . cas = ntohll ( req -> request . cas ) ; if ( c -> binary_header . request . magic != PROTOCOL_BINARY_REQ ) { if ( settings . verbose ) { fprintf ( stderr , ""Invalid magic:  %x\\n"" , c -> binary_header . request . magic ) ; } conn_set_state ( c , conn_closing ) ; return - 1 ; } c -> msgcurr = 0 ; c -> msgused = 0 ; c -> iovused = 0 ; if ( add_msghdr ( c ) != 0 ) { out_string ( c , ""SERVER_ERROR out of memory"" ) ; return 0 ; } c -> cmd = c -> binary_header . request . opcode ; c -> keylen = c -> binary_header . request . keylen ; c -> opaque = c -> binary_header . request . opaque ; c -> cas = 0 ; dispatch_bin_command ( c ) ; c -> rbytes -= sizeof ( c -> binary_header ) ; c -> rcurr += sizeof ( c -> binary_header ) ; } } else { char * el , * cont ; if ( c -> rbytes == 0 ) return 0 ; el = memchr ( c -> rcurr , '\\n' , c -> rbytes ) ; if ( ! el ) return 0 ; cont = el + 1 ; if ( ( el - c -> rcurr ) > 1 && * ( el - 1 ) == '\\r' ) { el -- ; } * el = '\\0' ; assert ( cont <= ( c -> rcurr + c -> rbytes ) ) ; process_command ( c , c -> rcurr ) ; c -> rbytes -= ( cont - c -> rcurr ) ; c -> rcurr = cont ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; } return 1 ; }
Fixed code:","
static int try_read_command ( conn * c ) { assert ( c != NULL ) ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; assert ( c -> rbytes > 0 ) ; 
// Validate the input data  
if(validateInput(c->rbuf, c->rbytes) == -1) { 
    conn_set_state ( c , conn_closing ) ; 
    return -1; 
} 

if ( c -> protocol == negotiating_prot || c -> transport == udp_transport ) { if ( ( unsigned char ) c -> rbuf [ 0 ] == ( unsigned char ) PROTOCOL_BINARY_REQ ) { c -> protocol = binary_prot ; } else { c -> protocol = ascii_prot ; } if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Client using the %s protocol\\n"" , c -> sfd , prot_text ( c -> protocol ) ) ; } } if ( c -> protocol == binary_prot ) { if ( c -> rbytes < sizeof ( c -> binary_header ) ) { return 0 ; } else { # ifdef NEED_ALIGN if ( ( ( long ) ( c -> rcurr ) ) % 8 != 0 ) { memmove ( c -> rbuf , c -> rcurr , c -> rbytes ) ; c -> rcurr = c -> rbuf ; if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Realign input buffer\\n"" , c -> sfd ) ; } } # endif protocol_binary_request_header * req ; req = ( protocol_binary_request_header * ) c -> rcurr ; if ( settings . verbose > 1 ) { int ii ; fprintf ( stderr , ""<%d Read binary protocol data:"" , c -> sfd ) ; for ( ii = 0 ; ii < sizeof ( req -> bytes ) ; ++ ii ) { if ( ii % 4 == 0 ) { fprintf ( stderr , ""\\n<%d   "" , c -> sfd ) ; } fprintf ( stderr , "" 0x%02x"" , req -> bytes [ ii ] ) ; } fprintf ( stderr , ""\\n"" ) ; } c -> binary_header = * req ; c -> binary_header . request . keylen = ntohs ( req -> request . keylen ) ; c -> binary_header . request . bodylen = ntohl ( req -> request . bodylen ) ; c -> binary_header . request . cas = ntohll ( req -> request . cas ) ; if ( c -> binary_header . request . magic != PROTOCOL_BINARY_REQ ) { if ( settings . verbose ) { fprintf ( stderr , ""Invalid magic:  %x\\n"" , c -> binary_header . request . magic ) ; } conn_set_state ( c , conn_closing ) ; return - 1 ; } c -> msgcurr = 0 ; c -> msgused = 0 ; c -> iovused = 0 ; if ( add_msghdr ( c ) != 0 ) { out_string ( c , ""SERVER_ERROR out of memory"" ) ; return 0 ; } c -> cmd = c -> binary_header . request . opcode ; c -> keylen = c -> binary_header . request . keylen ; c -> opaque = c -> binary_header . request . opaque ; c -> cas = 0 ; dispatch_bin_command ( c ) ; c -> rbytes -= sizeof ( c -> binary_header ) ; c -> rcurr += sizeof ( c -> binary_header ) ; } } else { char * el , * cont ; if ( c -> rbytes == 0 ) return 0 ; el = memchr ( c -> rcurr , '\\n' , c -> rbytes ) ; if ( ! el ) return 0 ; cont = el + 1 ; if ( ( el - c -> rcurr ) > 1 && * ( el - 1 ) == '\\r' ) { el -- ; } * el = '\\0' ; assert ( cont <= ( c -> rcurr + c -> rbytes ) ) ; process_command ( c , c -> rcurr ) ; c -> rbytes -= ( cont - c -> rcurr ) ; c -> rcurr = cont ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; } return 1 ; }",1000,-28.97445041208707,-0.028974450412087068
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int try_read_command ( conn * c ) { assert ( c != NULL ) ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; assert ( c -> rbytes > 0 ) ; if ( c -> protocol == negotiating_prot || c -> transport == udp_transport ) { if ( ( unsigned char ) c -> rbuf [ 0 ] == ( unsigned char ) PROTOCOL_BINARY_REQ ) { c -> protocol = binary_prot ; } else { c -> protocol = ascii_prot ; } if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Client using the %s protocol\\n"" , c -> sfd , prot_text ( c -> protocol ) ) ; } } if ( c -> protocol == binary_prot ) { if ( c -> rbytes < sizeof ( c -> binary_header ) ) { return 0 ; } else { # ifdef NEED_ALIGN if ( ( ( long ) ( c -> rcurr ) ) % 8 != 0 ) { memmove ( c -> rbuf , c -> rcurr , c -> rbytes ) ; c -> rcurr = c -> rbuf ; if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Realign input buffer\\n"" , c -> sfd ) ; } } # endif protocol_binary_request_header * req ; req = ( protocol_binary_request_header * ) c -> rcurr ; if ( settings . verbose > 1 ) { int ii ; fprintf ( stderr , ""<%d Read binary protocol data:"" , c -> sfd ) ; for ( ii = 0 ; ii < sizeof ( req -> bytes ) ; ++ ii ) { if ( ii % 4 == 0 ) { fprintf ( stderr , ""\\n<%d   "" , c -> sfd ) ; } fprintf ( stderr , "" 0x%02x"" , req -> bytes [ ii ] ) ; } fprintf ( stderr , ""\\n"" ) ; } c -> binary_header = * req ; c -> binary_header . request . keylen = ntohs ( req -> request . keylen ) ; c -> binary_header . request . bodylen = ntohl ( req -> request . bodylen ) ; c -> binary_header . request . cas = ntohll ( req -> request . cas ) ; if ( c -> binary_header . request . magic != PROTOCOL_BINARY_REQ ) { if ( settings . verbose ) { fprintf ( stderr , ""Invalid magic:  %x\\n"" , c -> binary_header . request . magic ) ; } conn_set_state ( c , conn_closing ) ; return - 1 ; } c -> msgcurr = 0 ; c -> msgused = 0 ; c -> iovused = 0 ; if ( add_msghdr ( c ) != 0 ) { out_string ( c , ""SERVER_ERROR out of memory"" ) ; return 0 ; } c -> cmd = c -> binary_header . request . opcode ; c -> keylen = c -> binary_header . request . keylen ; c -> opaque = c -> binary_header . request . opaque ; c -> cas = 0 ; dispatch_bin_command ( c ) ; c -> rbytes -= sizeof ( c -> binary_header ) ; c -> rcurr += sizeof ( c -> binary_header ) ; } } else { char * el , * cont ; if ( c -> rbytes == 0 ) return 0 ; el = memchr ( c -> rcurr , '\\n' , c -> rbytes ) ; if ( ! el ) return 0 ; cont = el + 1 ; if ( ( el - c -> rcurr ) > 1 && * ( el - 1 ) == '\\r' ) { el -- ; } * el = '\\0' ; assert ( cont <= ( c -> rcurr + c -> rbytes ) ) ; process_command ( c , c -> rcurr ) ; c -> rbytes -= ( cont - c -> rcurr ) ; c -> rcurr = cont ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; } return 1 ; }
Fixed code:","
static int try_read_command ( conn * c ) { assert ( c != NULL ) ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; assert ( c -> rbytes > 0 ) ; 

//Validate input 
if (c->rbytes > MAX_COMMAND_SIZE) {
    if (settings.verbose > 1) {
        fprintf(stderr, ""Invalid command size, closing connection\n"");
    }
    conn_set_state(c, conn_closing);
    return -1;
}

if ( c -> protocol == negotiating_prot || c -> transport == udp_transport ) { if ( ( unsigned char ) c -> rbuf [ 0 ] == ( unsigned char ) PROTOCOL_BINARY_REQ ) { c -> protocol = binary_prot ; } else { c -> protocol = ascii_prot ; } if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Client using the %s protocol\\n"" , c -> sfd , prot_text ( c -> protocol ) ) ; } } if ( c -> protocol == binary_prot ) { if ( c -> rbytes < sizeof ( c -> binary_header ) ) { return 0 ; } else { # ifdef NEED_ALIGN if ( ( ( long ) ( c -> rcurr ) ) % 8 != 0 ) { memmove ( c -> rbuf , c -> rcurr , c -> rbytes ) ; c -> rcurr = c -> rbuf ; if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Realign input buffer\\n"" , c -> sfd ) ; } } # endif protocol_binary_request_header * req ; req = ( protocol_binary_request_header * ) c -> rcurr ; if ( settings . verbose > 1 ) { int ii ; fprintf ( stderr , ""<%d Read binary protocol data:"" , c -> sfd ) ; for ( ii = 0 ; ii < sizeof ( req -> bytes ) ; ++ ii ) { if ( ii % 4 == 0 ) { fprintf ( stderr , ""\\n<%d   "" , c -> sfd ) ; } fprintf ( stderr , "" 0x%02x"" , req -> bytes [ ii ] ) ; } fprintf ( stderr , ""\\n"" ) ; } c -> binary_header = * req ; c -> binary_header . request . keylen = ntohs ( req -> request . keylen ) ; c -> binary_header . request . bodylen = ntohl ( req -> request . bodylen ) ; c -> binary_header . request . cas = ntohll ( req -> request . cas ) ; if ( c -> binary_header . request . magic != PROTOCOL_BINARY_REQ ) { if ( settings . verbose ) { fprintf ( stderr , ""Invalid magic:  %x\\n"" , c -> binary_header . request . magic ) ; } conn_set_state ( c , conn_closing ) ; return - 1 ; } c -> msgcurr = 0 ; c -> msgused = 0 ; c -> iovused = 0 ; if ( add_msghdr ( c ) != 0 ) { out_string ( c , ""SERVER_ERROR out of memory"" ) ; return 0 ; } c -> cmd = c -> binary_header . request . opcode ; c -> keylen = c -> binary_header . request . keylen ; c -> opaque = c -> binary_header . request . opaque ; c -> cas = 0 ; dispatch_bin_command ( c ) ; c -> rbytes -= sizeof ( c -> binary_header ) ; c -> rcurr += sizeof ( c -> binary_header ) ; } } else { char * el , * cont ; if ( c -> rbytes == 0 ) return 0 ; el = memchr ( c -> rcurr , '\\n' , c -> rbytes ) ; if ( ! el ) return 0 ; cont = el + 1 ; if ( ( el - c -> rcurr ) > 1 && * ( el - 1 ) == '\\r' ) { el -- ; } * el = '\\0' ; assert ( cont <= ( c -> rcurr + c -> rbytes ) ) ; process_command ( c , c -> rcurr ) ; c -> rbytes -= ( cont - c -> rcurr ) ; c -> rcurr = cont ; assert ( c",1000,-29.348352675791038,-0.02934835267579104
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int try_read_command ( conn * c ) { assert ( c != NULL ) ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; assert ( c -> rbytes > 0 ) ; if ( c -> protocol == negotiating_prot || c -> transport == udp_transport ) { if ( ( unsigned char ) c -> rbuf [ 0 ] == ( unsigned char ) PROTOCOL_BINARY_REQ ) { c -> protocol = binary_prot ; } else { c -> protocol = ascii_prot ; } if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Client using the %s protocol\\n"" , c -> sfd , prot_text ( c -> protocol ) ) ; } } if ( c -> protocol == binary_prot ) { if ( c -> rbytes < sizeof ( c -> binary_header ) ) { return 0 ; } else { # ifdef NEED_ALIGN if ( ( ( long ) ( c -> rcurr ) ) % 8 != 0 ) { memmove ( c -> rbuf , c -> rcurr , c -> rbytes ) ; c -> rcurr = c -> rbuf ; if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Realign input buffer\\n"" , c -> sfd ) ; } } # endif protocol_binary_request_header * req ; req = ( protocol_binary_request_header * ) c -> rcurr ; if ( settings . verbose > 1 ) { int ii ; fprintf ( stderr , ""<%d Read binary protocol data:"" , c -> sfd ) ; for ( ii = 0 ; ii < sizeof ( req -> bytes ) ; ++ ii ) { if ( ii % 4 == 0 ) { fprintf ( stderr , ""\\n<%d   "" , c -> sfd ) ; } fprintf ( stderr , "" 0x%02x"" , req -> bytes [ ii ] ) ; } fprintf ( stderr , ""\\n"" ) ; } c -> binary_header = * req ; c -> binary_header . request . keylen = ntohs ( req -> request . keylen ) ; c -> binary_header . request . bodylen = ntohl ( req -> request . bodylen ) ; c -> binary_header . request . cas = ntohll ( req -> request . cas ) ; if ( c -> binary_header . request . magic != PROTOCOL_BINARY_REQ ) { if ( settings . verbose ) { fprintf ( stderr , ""Invalid magic:  %x\\n"" , c -> binary_header . request . magic ) ; } conn_set_state ( c , conn_closing ) ; return - 1 ; } c -> msgcurr = 0 ; c -> msgused = 0 ; c -> iovused = 0 ; if ( add_msghdr ( c ) != 0 ) { out_string ( c , ""SERVER_ERROR out of memory"" ) ; return 0 ; } c -> cmd = c -> binary_header . request . opcode ; c -> keylen = c -> binary_header . request . keylen ; c -> opaque = c -> binary_header . request . opaque ; c -> cas = 0 ; dispatch_bin_command ( c ) ; c -> rbytes -= sizeof ( c -> binary_header ) ; c -> rcurr += sizeof ( c -> binary_header ) ; } } else { char * el , * cont ; if ( c -> rbytes == 0 ) return 0 ; el = memchr ( c -> rcurr , '\\n' , c -> rbytes ) ; if ( ! el ) return 0 ; cont = el + 1 ; if ( ( el - c -> rcurr ) > 1 && * ( el - 1 ) == '\\r' ) { el -- ; } * el = '\\0' ; assert ( cont <= ( c -> rcurr + c -> rbytes ) ) ; process_command ( c , c -> rcurr ) ; c -> rbytes -= ( cont - c -> rcurr ) ; c -> rcurr = cont ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; } return 1 ; }
Fixed code:","
static int try_read_command ( conn * c ) { assert ( c != NULL ) ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; assert ( c -> rbytes > 0 ) ; if ( c -> protocol == negotiating_prot || c -> transport == udp_transport ) { if ( ( unsigned char ) c -> rbuf [ 0 ] == ( unsigned char ) PROTOCOL_BINARY_REQ ) { c -> protocol = binary_prot ; } else { c -> protocol = ascii_prot ; } if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Client using the %s protocol\\n"" , c -> sfd , prot_text ( c -> protocol ) ) ; } } if ( c -> protocol == binary_prot ) { if ( c -> rbytes < sizeof ( c -> binary_header ) ) { return 0 ; } else { # ifdef NEED_ALIGN if ( ( ( long ) ( c -> rcurr ) ) % 8 != 0 ) { memmove ( c -> rbuf , c -> rcurr , c -> rbytes ) ; c -> rcurr = c -> rbuf ; if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Realign input buffer\\n"" , c -> sfd ) ; } } # endif protocol_binary_request_header * req ; req = ( protocol_binary_request_header * ) c -> rcurr ; // Add input validation before processing the request if (req->request.magic != PROTOCOL_BINARY_REQ) { if ( settings . verbose ) { fprintf ( stderr , ""Invalid magic:  %x\\n"" , c -> binary_header . request . magic ) ; } conn_set_state ( c , conn_closing ) ; return - 1 ; } if ( settings . verbose > 1 ) { int ii ; fprintf ( stderr , ""<%d Read binary protocol data:"" , c -> sfd ) ; for ( ii = 0 ; ii < sizeof ( req -> bytes ) ; ++ ii ) { if ( ii % 4 == 0 ) { fprintf ( stderr , ""\\n<%d   "" , c -> sfd ) ; } fprintf ( stderr , "" 0x%02x"" , req -> bytes [ ii ] ) ; } fprintf ( stderr , ""\\n"" ) ; } c -> binary_header = * req ; c -> binary_header . request . keylen = ntohs ( req -> request . keylen ) ; c -> binary_header . request . bodylen = ntohl ( req -> request . bodylen ) ; c -> binary_header . request . cas = ntohll ( req -> request . cas ) ; c -> msgcurr = 0 ; c -> msgused = 0 ; c -> iovused = 0 ; if ( add_msghdr ( c ) != 0 ) { out_string ( c , ""SERVER_ERROR out of memory"" ) ; return 0 ; } c -> cmd = c -> binary_header . request . opcode ; c -> keylen = c -> binary_header . request . keylen ; c -> opaque = c -> binary_header . request . opaque ; c -> cas = 0 ; dispatch_bin_command ( c ) ; c -> rbytes -= sizeof ( c -> binary_header ) ; c -> rcurr += sizeof ( c -> binary_header ) ; } } else { char * el , * cont ; if ( c -> rbytes == 0 ) return 0 ; el = memchr ( c -> rcurr , '\\n' , c -> rbytes ) ; if ( ! el ) return 0 ; cont = el + 1 ; if ( ( el - c -> rcurr ) > 1 && * ( el - 1 ) == '\\r' ) { el -- ; } * el = '\\0' ; assert ( cont <= ( c -> rcurr + c -> rbytes ) ) ; process_command ( c , c -> rcurr ) ; c -> rbytes -= ( cont - c -> rcurr ) ; c -> rcurr = cont ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; } return 1 ; }",943,-19.161631587870954,-0.02031986382595011
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int try_read_command ( conn * c ) { assert ( c != NULL ) ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; assert ( c -> rbytes > 0 ) ; if ( c -> protocol == negotiating_prot || c -> transport == udp_transport ) { if ( ( unsigned char ) c -> rbuf [ 0 ] == ( unsigned char ) PROTOCOL_BINARY_REQ ) { c -> protocol = binary_prot ; } else { c -> protocol = ascii_prot ; } if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Client using the %s protocol\\n"" , c -> sfd , prot_text ( c -> protocol ) ) ; } } if ( c -> protocol == binary_prot ) { if ( c -> rbytes < sizeof ( c -> binary_header ) ) { return 0 ; } else { # ifdef NEED_ALIGN if ( ( ( long ) ( c -> rcurr ) ) % 8 != 0 ) { memmove ( c -> rbuf , c -> rcurr , c -> rbytes ) ; c -> rcurr = c -> rbuf ; if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Realign input buffer\\n"" , c -> sfd ) ; } } # endif protocol_binary_request_header * req ; req = ( protocol_binary_request_header * ) c -> rcurr ; if ( settings . verbose > 1 ) { int ii ; fprintf ( stderr , ""<%d Read binary protocol data:"" , c -> sfd ) ; for ( ii = 0 ; ii < sizeof ( req -> bytes ) ; ++ ii ) { if ( ii % 4 == 0 ) { fprintf ( stderr , ""\\n<%d   "" , c -> sfd ) ; } fprintf ( stderr , "" 0x%02x"" , req -> bytes [ ii ] ) ; } fprintf ( stderr , ""\\n"" ) ; } c -> binary_header = * req ; c -> binary_header . request . keylen = ntohs ( req -> request . keylen ) ; c -> binary_header . request . bodylen = ntohl ( req -> request . bodylen ) ; c -> binary_header . request . cas = ntohll ( req -> request . cas ) ; if ( c -> binary_header . request . magic != PROTOCOL_BINARY_REQ ) { if ( settings . verbose ) { fprintf ( stderr , ""Invalid magic:  %x\\n"" , c -> binary_header . request . magic ) ; } conn_set_state ( c , conn_closing ) ; return - 1 ; } c -> msgcurr = 0 ; c -> msgused = 0 ; c -> iovused = 0 ; if ( add_msghdr ( c ) != 0 ) { out_string ( c , ""SERVER_ERROR out of memory"" ) ; return 0 ; } c -> cmd = c -> binary_header . request . opcode ; c -> keylen = c -> binary_header . request . keylen ; c -> opaque = c -> binary_header . request . opaque ; c -> cas = 0 ; dispatch_bin_command ( c ) ; c -> rbytes -= sizeof ( c -> binary_header ) ; c -> rcurr += sizeof ( c -> binary_header ) ; } } else { char * el , * cont ; if ( c -> rbytes == 0 ) return 0 ; el = memchr ( c -> rcurr , '\\n' , c -> rbytes ) ; if ( ! el ) return 0 ; cont = el + 1 ; if ( ( el - c -> rcurr ) > 1 && * ( el - 1 ) == '\\r' ) { el -- ; } * el = '\\0' ; assert ( cont <= ( c -> rcurr + c -> rbytes ) ) ; process_command ( c , c -> rcurr ) ; c -> rbytes -= ( cont - c -> rcurr ) ; c -> rcurr = cont ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; } return 1 ; }
Fixed code:","
static int try_read_command ( conn * c ) { assert ( c != NULL ) ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; assert ( c -> rbytes > 0 ) ; if ( c -> protocol == negotiating_prot || c -> transport == udp_transport ) { if ( ( unsigned char ) c -> rbuf [ 0 ] == ( unsigned char ) PROTOCOL_BINARY_REQ ) { c -> protocol = binary_prot ; } else { c -> protocol = ascii_prot ; } if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Client using the %s protocol\\n"" , c -> sfd , prot_text ( c -> protocol ) ) ; } } if ( c -> protocol == binary_prot ) { if ( c -> rbytes < sizeof ( c -> binary_header ) ) { return 0 ; } else { # ifdef NEED_ALIGN if ( ( ( long ) ( c -> rcurr ) ) % 8 != 0 ) { memmove ( c -> rbuf , c -> rcurr , c -> rbytes ) ; c -> rcurr = c -> rbuf ; if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Realign input buffer\\n"" , c -> sfd ) ; } } # endif protocol_binary_request_header * req ; req = ( protocol_binary_request_header * ) c -> rcurr ; if ( settings . verbose > 1 ) { int ii ; fprintf ( stderr , ""<%d Read binary protocol data:"" , c -> sfd ) ; for ( ii = 0 ; ii < sizeof ( req -> bytes ) ; ++ ii ) { if ( ii % 4 == 0 ) { fprintf ( stderr , ""\\n<%d   "" , c -> sfd ) ; } fprintf ( stderr , "" 0x%02x"" , req -> bytes [ ii ] ) ; } fprintf ( stderr , ""\\n"" ) ; } if (req->request.magic != PROTOCOL_BINARY_REQ) { if ( settings . verbose ) { fprintf ( stderr , ""Invalid magic:  %x\\n"" , c -> binary_header . request . magic ) ; } conn_set_state ( c , conn_closing ) ; return - 1 ; } c -> binary_header = * req ; c -> binary_header . request . keylen = ntohs ( req -> request . keylen ) ; c -> binary_header . request . bodylen = ntohl ( req -> request . bodylen ) ; c -> binary_header . request . cas = ntohll ( req -> request . cas ) ; c -> msgcurr = 0 ; c -> msgused = 0 ; c -> iovused = 0 ; if ( add_msghdr ( c ) != 0 ) { out_string ( c , ""SERVER_ERROR out of memory"" ) ; return 0 ; } c -> cmd = c -> binary_header . request . opcode ; c -> keylen = c -> binary_header . request . keylen ; c -> opaque = c -> binary_header . request . opaque ; c -> cas = 0 ; dispatch_bin_command ( c ) ; c -> rbytes -= sizeof ( c -> binary_header ) ; c -> rcurr += sizeof ( c -> binary_header ) ; } } else { char * el , * cont ; if ( c -> rbytes == 0 ) return 0 ; el = memchr ( c -> rcurr , '\\n' , c -> rbytes ) ; if ( ! el ) return 0 ; cont = el + 1 ; if ( ( el - c -> rcurr ) > 1 && * ( el - 1 ) == '\\r' ) { el -- ; } * el = '\\0' ; assert ( cont <= ( c -> rcurr + c -> rbytes ) ) ; process_command ( c , c -> rcurr ) ; c -> rbytes -= ( cont - c -> rcurr ) ; c -> rcurr = cont ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; } return 1 ; }",935,-7.33915395010203,-0.007849362513478108
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int try_read_command ( conn * c ) { assert ( c != NULL ) ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; assert ( c -> rbytes > 0 ) ; if ( c -> protocol == negotiating_prot || c -> transport == udp_transport ) { if ( ( unsigned char ) c -> rbuf [ 0 ] == ( unsigned char ) PROTOCOL_BINARY_REQ ) { c -> protocol = binary_prot ; } else { c -> protocol = ascii_prot ; } if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Client using the %s protocol\\n"" , c -> sfd , prot_text ( c -> protocol ) ) ; } } if ( c -> protocol == binary_prot ) { if ( c -> rbytes < sizeof ( c -> binary_header ) ) { return 0 ; } else { # ifdef NEED_ALIGN if ( ( ( long ) ( c -> rcurr ) ) % 8 != 0 ) { memmove ( c -> rbuf , c -> rcurr , c -> rbytes ) ; c -> rcurr = c -> rbuf ; if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Realign input buffer\\n"" , c -> sfd ) ; } } # endif protocol_binary_request_header * req ; req = ( protocol_binary_request_header * ) c -> rcurr ; if ( settings . verbose > 1 ) { int ii ; fprintf ( stderr , ""<%d Read binary protocol data:"" , c -> sfd ) ; for ( ii = 0 ; ii < sizeof ( req -> bytes ) ; ++ ii ) { if ( ii % 4 == 0 ) { fprintf ( stderr , ""\\n<%d   "" , c -> sfd ) ; } fprintf ( stderr , "" 0x%02x"" , req -> bytes [ ii ] ) ; } fprintf ( stderr , ""\\n"" ) ; } c -> binary_header = * req ; c -> binary_header . request . keylen = ntohs ( req -> request . keylen ) ; c -> binary_header . request . bodylen = ntohl ( req -> request . bodylen ) ; c -> binary_header . request . cas = ntohll ( req -> request . cas ) ; if ( c -> binary_header . request . magic != PROTOCOL_BINARY_REQ ) { if ( settings . verbose ) { fprintf ( stderr , ""Invalid magic:  %x\\n"" , c -> binary_header . request . magic ) ; } conn_set_state ( c , conn_closing ) ; return - 1 ; } c -> msgcurr = 0 ; c -> msgused = 0 ; c -> iovused = 0 ; if ( add_msghdr ( c ) != 0 ) { out_string ( c , ""SERVER_ERROR out of memory"" ) ; return 0 ; } c -> cmd = c -> binary_header . request . opcode ; c -> keylen = c -> binary_header . request . keylen ; c -> opaque = c -> binary_header . request . opaque ; c -> cas = 0 ; dispatch_bin_command ( c ) ; c -> rbytes -= sizeof ( c -> binary_header ) ; c -> rcurr += sizeof ( c -> binary_header ) ; } } else { char * el , * cont ; if ( c -> rbytes == 0 ) return 0 ; el = memchr ( c -> rcurr , '\\n' , c -> rbytes ) ; if ( ! el ) return 0 ; cont = el + 1 ; if ( ( el - c -> rcurr ) > 1 && * ( el - 1 ) == '\\r' ) { el -- ; } * el = '\\0' ; assert ( cont <= ( c -> rcurr + c -> rbytes ) ) ; process_command ( c , c -> rcurr ) ; c -> rbytes -= ( cont - c -> rcurr ) ; c -> rcurr = cont ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; } return 1 ; }
Fixed code:","

static int try_read_command ( conn * c ) { 
  assert ( c != NULL ) ; 
  assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; 
  assert ( c -> rbytes > 0 ) ; 
  
  if ( c -> protocol == negotiating_prot || c -> transport == udp_transport ) { 
    if ( ( unsigned char ) c -> rbuf [ 0 ] == ( unsigned char ) PROTOCOL_BINARY_REQ ) { 
      c -> protocol = binary_prot ; 
    } else { 
      c -> protocol = ascii_prot ; 
    } 
    
    if ( settings . verbose > 1 ) { 
      fprintf ( stderr , ""%d: Client using the %s protocol\\n"" , c -> sfd , prot_text ( c -> protocol ) ) ; 
    } 
  } 
  
  if ( c -> protocol == binary_prot ) { 
    if ( c -> rbytes < sizeof ( c -> binary_header ) ) { 
      return 0 ; 
    } else { 
      # ifdef NEED_ALIGN 
      if ( ( ( long ) ( c -> rcurr ) ) % 8 != 0 ) { 
        memmove ( c -> rbuf , c -> rcurr , c -> rbytes ) ; 
        c -> rcurr = c -> rbuf ; 
        if ( settings . verbose > 1 ) { 
          fprintf ( stderr , ""%d: Realign input buffer\\n"" , c -> sfd ) ; 
        } 
      } 
      # endif 
      
      protocol_binary_request_header * req ; 
      req = ( protocol_binary_request_header * ) c -> rcurr ; 
      if ( settings . verbose > 1 ) { 
        int ii ; 
        fprintf ( stderr , ""<%d Read binary protocol data:"" , c -> sfd ) ; 
        for ( ii = 0 ; ii < sizeof ( req -> bytes ) ; ++ ii ) { 
          if ( ii % 4 == 0 ) { 
            fprintf ( stderr , ""\\n<%d   "" , c -> sfd ) ; 
          } 
          
          fprintf ( stderr , "" 0x%02x"" , req -> bytes [ ii ] ) ; 
        } 
        
        fprintf ( stderr , ""\\n"" ) ; 
      } 
      
      c -> binary_header = * req ; 
      c -> binary_header . request . keylen = ntohs ( req -> request . keylen ) ; 
      c -> binary_header . request . bodylen = ntohl ( req -> request . bodylen ) ; 
      c -> binary_header . request . cas = ntohll ( req -> request . cas ) ; 
      
      //Added to fix CWE-20
      if ( c -> binary_header . request . keylen > MAX_KEY_LENGTH ) {
        out_string(c, ""SERVER_ERROR key length too long"");
        return -1;
      }
      
      if ( c -> binary_header . request . magic != PROTOCOL_BINARY_REQ ) { 
        if ( settings . verbose ) { 
          fprintf ( stderr , ""Invalid magic:  %x\\n"" , c -> binary_header . request . magic ) ; 
        } 
        
        conn_set_state ( c , conn_closing ) ; 
        return - 1 ; 
      } 
      
      c -> msgcurr = 0 ; 
      c -> msgused = 0 ; 
      c -> iovused = 0 ; 
      if ( add_msghdr ( c ) != 0 ) { 
        out_string ( c , ""SERVER_ERROR out of memory"" ) ; 
        return 0 ; 
      } 
      
      c -> cmd = c -> binary_header . request . opcode ; 
      c -> keylen = c -> binary_header . request . keylen ; 
      c -> opaque = c -> binary_header . request . opaque ; 
      c -> cas = 0 ; 
      dispatch_bin_command ( c",1000,-44.85990034267065,-0.04485990034267065
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int try_read_command ( conn * c ) { assert ( c != NULL ) ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; assert ( c -> rbytes > 0 ) ; if ( c -> protocol == negotiating_prot || c -> transport == udp_transport ) { if ( ( unsigned char ) c -> rbuf [ 0 ] == ( unsigned char ) PROTOCOL_BINARY_REQ ) { c -> protocol = binary_prot ; } else { c -> protocol = ascii_prot ; } if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Client using the %s protocol\\n"" , c -> sfd , prot_text ( c -> protocol ) ) ; } } if ( c -> protocol == binary_prot ) { if ( c -> rbytes < sizeof ( c -> binary_header ) ) { return 0 ; } else { # ifdef NEED_ALIGN if ( ( ( long ) ( c -> rcurr ) ) % 8 != 0 ) { memmove ( c -> rbuf , c -> rcurr , c -> rbytes ) ; c -> rcurr = c -> rbuf ; if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Realign input buffer\\n"" , c -> sfd ) ; } } # endif protocol_binary_request_header * req ; req = ( protocol_binary_request_header * ) c -> rcurr ; if ( settings . verbose > 1 ) { int ii ; fprintf ( stderr , ""<%d Read binary protocol data:"" , c -> sfd ) ; for ( ii = 0 ; ii < sizeof ( req -> bytes ) ; ++ ii ) { if ( ii % 4 == 0 ) { fprintf ( stderr , ""\\n<%d   "" , c -> sfd ) ; } fprintf ( stderr , "" 0x%02x"" , req -> bytes [ ii ] ) ; } fprintf ( stderr , ""\\n"" ) ; } c -> binary_header = * req ; c -> binary_header . request . keylen = ntohs ( req -> request . keylen ) ; c -> binary_header . request . bodylen = ntohl ( req -> request . bodylen ) ; c -> binary_header . request . cas = ntohll ( req -> request . cas ) ; if ( c -> binary_header . request . magic != PROTOCOL_BINARY_REQ ) { if ( settings . verbose ) { fprintf ( stderr , ""Invalid magic:  %x\\n"" , c -> binary_header . request . magic ) ; } conn_set_state ( c , conn_closing ) ; return - 1 ; } c -> msgcurr = 0 ; c -> msgused = 0 ; c -> iovused = 0 ; if ( add_msghdr ( c ) != 0 ) { out_string ( c , ""SERVER_ERROR out of memory"" ) ; return 0 ; } c -> cmd = c -> binary_header . request . opcode ; c -> keylen = c -> binary_header . request . keylen ; c -> opaque = c -> binary_header . request . opaque ; c -> cas = 0 ; dispatch_bin_command ( c ) ; c -> rbytes -= sizeof ( c -> binary_header ) ; c -> rcurr += sizeof ( c -> binary_header ) ; } } else { char * el , * cont ; if ( c -> rbytes == 0 ) return 0 ; el = memchr ( c -> rcurr , '\\n' , c -> rbytes ) ; if ( ! el ) return 0 ; cont = el + 1 ; if ( ( el - c -> rcurr ) > 1 && * ( el - 1 ) == '\\r' ) { el -- ; } * el = '\\0' ; assert ( cont <= ( c -> rcurr + c -> rbytes ) ) ; process_command ( c , c -> rcurr ) ; c -> rbytes -= ( cont - c -> rcurr ) ; c -> rcurr = cont ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; } return 1 ; }
Fixed code:","
static int try_read_command ( conn * c ) { assert ( c != NULL ) ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; assert ( c -> rbytes > 0 ) ; 

// Add condition checks to ensure input is valid
if(c->rbuf[0] == NULL || c->rbuf[0] > 127) {
   return 0; 
}

if ( c -> protocol == negotiating_prot || c -> transport == udp_transport ) { 
if ( ( unsigned char ) c -> rbuf [ 0 ] == ( unsigned char ) PROTOCOL_BINARY_REQ ) { c -> protocol = binary_prot ; } else { c -> protocol = ascii_prot ; } if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Client using the %s protocol\\n"" , c -> sfd , prot_text ( c -> protocol ) ) ; } } 

if ( c -> protocol == binary_prot ) { if ( c -> rbytes < sizeof ( c -> binary_header ) ) { return 0 ; } else { # ifdef NEED_ALIGN if ( ( ( long ) ( c -> rcurr ) ) % 8 != 0 ) { memmove ( c -> rbuf , c -> rcurr , c -> rbytes ) ; c -> rcurr = c -> rbuf ; if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Realign input buffer\\n"" , c -> sfd ) ; } } # endif protocol_binary_request_header * req ; req = ( protocol_binary_request_header * ) c -> rcurr ; if ( settings . verbose > 1 ) { int ii ; fprintf ( stderr , ""<%d Read binary protocol data:"" , c -> sfd ) ; for ( ii = 0 ; ii < sizeof ( req -> bytes ) ; ++ ii ) { if ( ii % 4 == 0 ) { fprintf ( stderr , ""\\n<%d   "" , c -> sfd ) ; } fprintf ( stderr , "" 0x%02x"" , req -> bytes [ ii ] ) ; } fprintf ( stderr , ""\\n"" ) ; } c -> binary_header = * req ; c -> binary_header . request . keylen = ntohs ( req -> request . keylen ) ; c -> binary_header . request . bodylen = ntohl ( req -> request . bodylen ) ; c -> binary_header . request . cas = ntohll ( req -> request . cas ) ; 

// Add checks to ensure valid binary protocol
if ( c -> binary_header . request . magic != PROTOCOL_BINARY_REQ || c -> binary_header . request . magic == NULL || c -> binary_header . request.keylen < 0 || c -> binary_header . request . bodylen < 0 || c -> binary_header . request . cas < 0) { 
if ( settings . verbose ) { fprintf ( stderr , ""Invalid magic:  %x\\n"" , c -> binary_header . request . magic ) ; } conn_set_state ( c , conn_closing ) ; return - 1 ; } 

c -> msgcurr = 0 ; c -> msgused = 0 ; c -> iovused = 0 ; if ( add_msghdr ( c ) != 0 ) { out_string ( c , ""SERVER_ERROR out of memory"" ) ; return 0 ; } c -> cmd = c -> binary_header . request . opcode ; c -> keylen = c -> binary_header . request . keylen ; c -> opaque = c -> binary_header . request . opaque ; c -> cas = 0 ; dispatch_bin_command ( c ) ; c -> rbytes -= sizeof ( c -> binary_header ) ; c -> rcurr += sizeof ( c -> binary_header ) ; } } else { char * el , * cont ; if ( c -> rbytes == 0 ) return 0 ; el = memchr ( c -> rcurr , '\\n' , c -> rbytes ) ; if ( ! el ) return 0 ; cont = el + 1 ; if ( ( el - c -> rcurr ) > 1 && * ( el - 1 ) == '\\r' ) { el -- ; } * el = '\\0' ; assert ( cont <= ( c -> rcurr + c -> rbytes ) ) ; 

// Add",1000,-79.99943155853063,-0.07999943155853063
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int try_read_command ( conn * c ) { assert ( c != NULL ) ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; assert ( c -> rbytes > 0 ) ; if ( c -> protocol == negotiating_prot || c -> transport == udp_transport ) { if ( ( unsigned char ) c -> rbuf [ 0 ] == ( unsigned char ) PROTOCOL_BINARY_REQ ) { c -> protocol = binary_prot ; } else { c -> protocol = ascii_prot ; } if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Client using the %s protocol\\n"" , c -> sfd , prot_text ( c -> protocol ) ) ; } } if ( c -> protocol == binary_prot ) { if ( c -> rbytes < sizeof ( c -> binary_header ) ) { return 0 ; } else { # ifdef NEED_ALIGN if ( ( ( long ) ( c -> rcurr ) ) % 8 != 0 ) { memmove ( c -> rbuf , c -> rcurr , c -> rbytes ) ; c -> rcurr = c -> rbuf ; if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Realign input buffer\\n"" , c -> sfd ) ; } } # endif protocol_binary_request_header * req ; req = ( protocol_binary_request_header * ) c -> rcurr ; if ( settings . verbose > 1 ) { int ii ; fprintf ( stderr , ""<%d Read binary protocol data:"" , c -> sfd ) ; for ( ii = 0 ; ii < sizeof ( req -> bytes ) ; ++ ii ) { if ( ii % 4 == 0 ) { fprintf ( stderr , ""\\n<%d   "" , c -> sfd ) ; } fprintf ( stderr , "" 0x%02x"" , req -> bytes [ ii ] ) ; } fprintf ( stderr , ""\\n"" ) ; } c -> binary_header = * req ; c -> binary_header . request . keylen = ntohs ( req -> request . keylen ) ; c -> binary_header . request . bodylen = ntohl ( req -> request . bodylen ) ; c -> binary_header . request . cas = ntohll ( req -> request . cas ) ; if ( c -> binary_header . request . magic != PROTOCOL_BINARY_REQ ) { if ( settings . verbose ) { fprintf ( stderr , ""Invalid magic:  %x\\n"" , c -> binary_header . request . magic ) ; } conn_set_state ( c , conn_closing ) ; return - 1 ; } c -> msgcurr = 0 ; c -> msgused = 0 ; c -> iovused = 0 ; if ( add_msghdr ( c ) != 0 ) { out_string ( c , ""SERVER_ERROR out of memory"" ) ; return 0 ; } c -> cmd = c -> binary_header . request . opcode ; c -> keylen = c -> binary_header . request . keylen ; c -> opaque = c -> binary_header . request . opaque ; c -> cas = 0 ; dispatch_bin_command ( c ) ; c -> rbytes -= sizeof ( c -> binary_header ) ; c -> rcurr += sizeof ( c -> binary_header ) ; } } else { char * el , * cont ; if ( c -> rbytes == 0 ) return 0 ; el = memchr ( c -> rcurr , '\\n' , c -> rbytes ) ; if ( ! el ) return 0 ; cont = el + 1 ; if ( ( el - c -> rcurr ) > 1 && * ( el - 1 ) == '\\r' ) { el -- ; } * el = '\\0' ; assert ( cont <= ( c -> rcurr + c -> rbytes ) ) ; process_command ( c , c -> rcurr ) ; c -> rbytes -= ( cont - c -> rcurr ) ; c -> rcurr = cont ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; } return 1 ; }
Fixed code:"," 
static int try_read_command ( conn * c ) { assert ( c != NULL ) ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; assert ( c -> rbytes > 0 ) ; if ( c -> protocol == negotiating_prot || c -> transport == udp_transport ) { if ( ( unsigned char ) c -> rbuf [ 0 ] == ( unsigned char ) PROTOCOL_BINARY_REQ ) { c -> protocol = binary_prot ; } else { c -> protocol = ascii_prot ; } if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Client using the %s protocol\\n"" , c -> sfd , prot_text ( c -> protocol ) ) ; } } if ( c -> protocol == binary_prot ) { if ( c -> rbytes < sizeof ( c -> binary_header ) ) { return 0 ; } else { # ifdef NEED_ALIGN if ( ( ( long ) ( c -> rcurr ) ) % 8 != 0 ) { memmove ( c -> rbuf , c -> rcurr , c -> rbytes ) ; c -> rcurr = c -> rbuf ; if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Realign input buffer\\n"" , c -> sfd ) ; } } # endif protocol_binary_request_header * req ; req = ( protocol_binary_request_header * ) c -> rcurr ; if ( settings . verbose > 1 ) { int ii ; fprintf ( stderr , ""<%d Read binary protocol data:"" , c -> sfd ) ; for ( ii = 0 ; ii < sizeof ( req -> bytes ) ; ++ ii ) { if ( ii % 4 == 0 ) { fprintf ( stderr , ""\\n<%d   "" , c -> sfd ) ; } fprintf ( stderr , "" 0x%02x"" , req -> bytes [ ii ] ) ; } fprintf ( stderr , ""\\n"" ) ; } // Added input validation if ( ! is_valid_binary_request ( req ) ) { conn_set_state ( c , conn_closing ) ; return - 1 ; } c -> binary_header = * req ; c -> binary_header . request . keylen = ntohs ( req -> request . keylen ) ; c -> binary_header . request . bodylen = ntohl ( req -> request . bodylen ) ; c -> binary_header . request . cas = ntohll ( req -> request . cas ) ; c -> msgcurr = 0 ; c -> msgused = 0 ; c -> iovused = 0 ; if ( add_msghdr ( c ) != 0 ) { out_string ( c , ""SERVER_ERROR out of memory"" ) ; return 0 ; } c -> cmd = c -> binary_header . request . opcode ; c -> keylen = c -> binary_header . request . keylen ; c -> opaque = c -> binary_header . request . opaque ; c -> cas = 0 ; dispatch_bin_command ( c ) ; c -> rbytes -= sizeof ( c -> binary_header ) ; c -> rcurr += sizeof ( c -> binary_header ) ; } } else { char * el , * cont ; if ( c -> rbytes == 0 ) return 0 ; el = memchr ( c -> rcurr , '\\n' , c -> rbytes ) ; if ( ! el ) return 0 ; cont = el + 1 ; if ( ( el - c -> rcurr ) > 1 && * ( el - 1 ) == '\\r' ) { el -- ; } * el = '\\0' ; assert ( cont <= ( c -> rcurr + c -> rbytes ) ) ; process_command ( c , c -> rcurr ) ; c -> rbytes -= ( cont - c -> rcurr ) ; c -> rcurr = cont ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; } return 1 ; }

// Added function
int is_valid_binary_request ( protocol_binary_request_header * req ) { if ( req -> request . magic != PROTOCOL_BINARY_REQ ) { if ( settings . verbose ) { fprintf ( stderr , ""Invalid magic:  %x\\n"" , req -> request . magic ) ; } return 0 ; } return 1 ; }",985,-24.33182432377676,-0.024702359719570317
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int try_read_command ( conn * c ) { assert ( c != NULL ) ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; assert ( c -> rbytes > 0 ) ; if ( c -> protocol == negotiating_prot || c -> transport == udp_transport ) { if ( ( unsigned char ) c -> rbuf [ 0 ] == ( unsigned char ) PROTOCOL_BINARY_REQ ) { c -> protocol = binary_prot ; } else { c -> protocol = ascii_prot ; } if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Client using the %s protocol\\n"" , c -> sfd , prot_text ( c -> protocol ) ) ; } } if ( c -> protocol == binary_prot ) { if ( c -> rbytes < sizeof ( c -> binary_header ) ) { return 0 ; } else { # ifdef NEED_ALIGN if ( ( ( long ) ( c -> rcurr ) ) % 8 != 0 ) { memmove ( c -> rbuf , c -> rcurr , c -> rbytes ) ; c -> rcurr = c -> rbuf ; if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Realign input buffer\\n"" , c -> sfd ) ; } } # endif protocol_binary_request_header * req ; req = ( protocol_binary_request_header * ) c -> rcurr ; if ( settings . verbose > 1 ) { int ii ; fprintf ( stderr , ""<%d Read binary protocol data:"" , c -> sfd ) ; for ( ii = 0 ; ii < sizeof ( req -> bytes ) ; ++ ii ) { if ( ii % 4 == 0 ) { fprintf ( stderr , ""\\n<%d   "" , c -> sfd ) ; } fprintf ( stderr , "" 0x%02x"" , req -> bytes [ ii ] ) ; } fprintf ( stderr , ""\\n"" ) ; } c -> binary_header = * req ; c -> binary_header . request . keylen = ntohs ( req -> request . keylen ) ; c -> binary_header . request . bodylen = ntohl ( req -> request . bodylen ) ; c -> binary_header . request . cas = ntohll ( req -> request . cas ) ; if ( c -> binary_header . request . magic != PROTOCOL_BINARY_REQ ) { if ( settings . verbose ) { fprintf ( stderr , ""Invalid magic:  %x\\n"" , c -> binary_header . request . magic ) ; } conn_set_state ( c , conn_closing ) ; return - 1 ; } c -> msgcurr = 0 ; c -> msgused = 0 ; c -> iovused = 0 ; if ( add_msghdr ( c ) != 0 ) { out_string ( c , ""SERVER_ERROR out of memory"" ) ; return 0 ; } c -> cmd = c -> binary_header . request . opcode ; c -> keylen = c -> binary_header . request . keylen ; c -> opaque = c -> binary_header . request . opaque ; c -> cas = 0 ; dispatch_bin_command ( c ) ; c -> rbytes -= sizeof ( c -> binary_header ) ; c -> rcurr += sizeof ( c -> binary_header ) ; } } else { char * el , * cont ; if ( c -> rbytes == 0 ) return 0 ; el = memchr ( c -> rcurr , '\\n' , c -> rbytes ) ; if ( ! el ) return 0 ; cont = el + 1 ; if ( ( el - c -> rcurr ) > 1 && * ( el - 1 ) == '\\r' ) { el -- ; } * el = '\\0' ; assert ( cont <= ( c -> rcurr + c -> rbytes ) ) ; process_command ( c , c -> rcurr ) ; c -> rbytes -= ( cont - c -> rcurr ) ; c -> rcurr = cont ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; } return 1 ; }
Fixed code:","
static int try_read_command ( conn * c ) { assert ( c != NULL ) ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; assert ( c -> rbytes > 0 ) ; if ( c -> protocol == negotiating_prot || c -> transport == udp_transport ) { if ( ( unsigned char ) c -> rbuf [ 0 ] == ( unsigned char ) PROTOCOL_BINARY_REQ ) { c -> protocol = binary_prot ; } else { c -> protocol = ascii_prot ; if ( !is_valid_characters(c->rbuf) ) { /*Validate the characters in the buffer*/
conn_set_state ( c , conn_closing ) ; return - 1 ; } } if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Client using the %s protocol\\n"" , c -> sfd , prot_text ( c -> protocol ) ) ; } } if ( c -> protocol == binary_prot ) { if ( c -> rbytes < sizeof ( c -> binary_header ) ) { return 0 ; } else { # ifdef NEED_ALIGN if ( ( ( long ) ( c -> rcurr ) ) % 8 != 0 ) { memmove ( c -> rbuf , c -> rcurr , c -> rbytes ) ; c -> rcurr = c -> rbuf ; if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Realign input buffer\\n"" , c -> sfd ) ; } } # endif protocol_binary_request_header * req ; req = ( protocol_binary_request_header * ) c -> rcurr ; if ( settings . verbose > 1 ) { int ii ; fprintf ( stderr , ""<%d Read binary protocol data:"" , c -> sfd ) ; for ( ii = 0 ; ii < sizeof ( req -> bytes ) ; ++ ii ) { if ( ii % 4 == 0 ) { fprintf ( stderr , ""\\n<%d   "" , c -> sfd ) ; } fprintf ( stderr , "" 0x%02x"" , req -> bytes [ ii ] ) ; } fprintf ( stderr , ""\\n"" ) ; } c -> binary_header = * req ; c -> binary_header . request . keylen = ntohs ( req -> request . keylen ) ; c -> binary_header . request . bodylen = ntohl ( req -> request . bodylen ) ; c -> binary_header . request . cas = ntohll ( req -> request . cas ) ; if ( c -> binary_header . request . magic != PROTOCOL_BINARY_REQ ) { if ( settings . verbose ) { fprintf ( stderr , ""Invalid magic:  %x\\n"" , c -> binary_header . request . magic ) ; } conn_set_state ( c , conn_closing ) ; return - 1 ; } c -> msgcurr = 0 ; c -> msgused = 0 ; c -> iovused = 0 ; if ( add_msghdr ( c ) != 0 ) { out_string ( c , ""SERVER_ERROR out of memory"" ) ; return 0 ; } c -> cmd = c -> binary_header . request . opcode ; c -> keylen = c -> binary_header . request . keylen ; c -> opaque = c -> binary_header . request . opaque ; c -> cas = 0 ; dispatch_bin_command ( c ) ; c -> rbytes -= sizeof ( c -> binary_header ) ; c -> rcurr += sizeof ( c -> binary_header ) ; } } else { char * el , * cont ; if ( c -> rbytes == 0 ) return 0 ; el = memchr ( c -> rcurr , '\\n' , c -> rbytes ) ; if ( ! el ) return 0 ; cont = el + 1 ; if ( ( el - c -> rcurr ) > 1 && * ( el - 1 ) == '\\r' ) { el -- ; } * el = '\\0' ; if ( !is_valid_characters(c->rbuf) ) { /*Validate the characters in the buffer*/
conn_set_state ( c , conn_closing ) ; return - 1 ; }
assert ( cont <= ( c -> rcurr + c -> rbytes ) ) ; process_command ( c , c -> rcurr ) ; c -> rbytes -= ( cont - c -> rcurr ) ; c ->",1000,-44.87664768873502,-0.04487664768873502
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int try_read_command ( conn * c ) { assert ( c != NULL ) ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; assert ( c -> rbytes > 0 ) ; if ( c -> protocol == negotiating_prot || c -> transport == udp_transport ) { if ( ( unsigned char ) c -> rbuf [ 0 ] == ( unsigned char ) PROTOCOL_BINARY_REQ ) { c -> protocol = binary_prot ; } else { c -> protocol = ascii_prot ; } if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Client using the %s protocol\\n"" , c -> sfd , prot_text ( c -> protocol ) ) ; } } if ( c -> protocol == binary_prot ) { if ( c -> rbytes < sizeof ( c -> binary_header ) ) { return 0 ; } else { # ifdef NEED_ALIGN if ( ( ( long ) ( c -> rcurr ) ) % 8 != 0 ) { memmove ( c -> rbuf , c -> rcurr , c -> rbytes ) ; c -> rcurr = c -> rbuf ; if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Realign input buffer\\n"" , c -> sfd ) ; } } # endif protocol_binary_request_header * req ; req = ( protocol_binary_request_header * ) c -> rcurr ; if ( settings . verbose > 1 ) { int ii ; fprintf ( stderr , ""<%d Read binary protocol data:"" , c -> sfd ) ; for ( ii = 0 ; ii < sizeof ( req -> bytes ) ; ++ ii ) { if ( ii % 4 == 0 ) { fprintf ( stderr , ""\\n<%d   "" , c -> sfd ) ; } fprintf ( stderr , "" 0x%02x"" , req -> bytes [ ii ] ) ; } fprintf ( stderr , ""\\n"" ) ; } c -> binary_header = * req ; c -> binary_header . request . keylen = ntohs ( req -> request . keylen ) ; c -> binary_header . request . bodylen = ntohl ( req -> request . bodylen ) ; c -> binary_header . request . cas = ntohll ( req -> request . cas ) ; if ( c -> binary_header . request . magic != PROTOCOL_BINARY_REQ ) { if ( settings . verbose ) { fprintf ( stderr , ""Invalid magic:  %x\\n"" , c -> binary_header . request . magic ) ; } conn_set_state ( c , conn_closing ) ; return - 1 ; } c -> msgcurr = 0 ; c -> msgused = 0 ; c -> iovused = 0 ; if ( add_msghdr ( c ) != 0 ) { out_string ( c , ""SERVER_ERROR out of memory"" ) ; return 0 ; } c -> cmd = c -> binary_header . request . opcode ; c -> keylen = c -> binary_header . request . keylen ; c -> opaque = c -> binary_header . request . opaque ; c -> cas = 0 ; dispatch_bin_command ( c ) ; c -> rbytes -= sizeof ( c -> binary_header ) ; c -> rcurr += sizeof ( c -> binary_header ) ; } } else { char * el , * cont ; if ( c -> rbytes == 0 ) return 0 ; el = memchr ( c -> rcurr , '\\n' , c -> rbytes ) ; if ( ! el ) return 0 ; cont = el + 1 ; if ( ( el - c -> rcurr ) > 1 && * ( el - 1 ) == '\\r' ) { el -- ; } * el = '\\0' ; assert ( cont <= ( c -> rcurr + c -> rbytes ) ) ; process_command ( c , c -> rcurr ) ; c -> rbytes -= ( cont - c -> rcurr ) ; c -> rcurr = cont ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; } return 1 ; }
Fixed code:","
static int try_read_command ( conn * c ) { assert ( c != NULL ) ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; assert ( c -> rbytes > 0 ) ; if ( c -> protocol == negotiating_prot || c -> transport == udp_transport ) { if ( ( unsigned char ) c -> rbuf [ 0 ] == ( unsigned char ) PROTOCOL_BINARY_REQ ) { c -> protocol = binary_prot ; } else { c -> protocol = ascii_prot ; } if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Client using the %s protocol\\n"" , c -> sfd , prot_text ( c -> protocol ) ) ; } } if ( c -> protocol == binary_prot ) { if ( c -> rbytes < sizeof ( c -> binary_header ) ) { return 0 ; } else { # ifdef NEED_ALIGN if ( ( ( long ) ( c -> rcurr ) ) % 8 != 0 ) { memmove ( c -> rbuf , c -> rcurr , c -> rbytes ) ; c -> rcurr = c -> rbuf ; if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Realign input buffer\\n"" , c -> sfd ) ; } } # endif protocol_binary_request_header * req ; req = ( protocol_binary_request_header * ) c -> rcurr ; if ( settings . verbose > 1 ) { int ii ; fprintf ( stderr , ""<%d Read binary protocol data:"" , c -> sfd ) ; for ( ii = 0 ; ii < sizeof ( req -> bytes ) ; ++ ii ) { if ( ii % 4 == 0 ) { fprintf ( stderr , ""\\n<%d   "" , c -> sfd ) ; } fprintf ( stderr , "" 0x%02x"" , req -> bytes [ ii ] ) ; } fprintf ( stderr , ""\\n"" ) ; } c -> binary_header = * req ; // Validate input values before assigning to avoid improper input validation if (req->request.keylen > 0 && req->request.keylen <= KEY_MAX_LENGTH) { c -> binary_header . request . keylen = ntohs ( req -> request . keylen ) ; } else { fprintf ( stderr , ""Invalid key length: %d\\n"" , req -> request . keylen ) ; conn_set_state ( c , conn_closing ) ; return - 1 ; } if (req->request.bodylen > 0 && req->request.bodylen <= BODY_MAX_LENGTH) { c -> binary_header . request . bodylen = ntohl ( req -> request . bodylen ) ; } else { fprintf ( stderr , ""Invalid body length: %d\\n"" , req -> request . bodylen ) ; conn_set_state ( c , conn_closing ) ; return - 1 ; } c -> binary_header . request . cas = ntohll ( req -> request . cas ) ; if ( c -> binary_header . request . magic != PROTOCOL_BINARY_REQ ) { if ( settings . verbose ) { fprintf ( stderr , ""Invalid magic:  %x\\n"" , c -> binary_header . request . magic ) ; } conn_set_state ( c , conn_closing ) ; return - 1 ; } c -> msgcurr = 0 ; c -> msgused = 0 ; c -> iovused = 0 ; if ( add_msghdr ( c ) != 0 ) { out_string ( c , ""SERVER_ERROR out of memory"" ) ; return 0 ; } c -> cmd = c -> binary_header . request . opcode ; c -> keylen = c -> binary_header . request . keylen ; c -> opaque = c -> binary_header . request . opaque ; c -> cas = 0 ; dispatch_bin_command ( c ) ; c -> rbytes -= sizeof ( c -> binary_header ) ; c -> rcurr += sizeof ( c -> binary_header ) ; } } else { char * el , * cont ; if ( c -> rbytes == 0 ) return 0 ; el = memchr ( c -> rcurr , '\\n' , c -> rbytes ) ; if ( ! el ) return 0 ; cont = el + 1 ; if ( ( el - c -> rcurr ) > 1 && * ( el - 1",1000,-37.29149343356528,-0.037291493433565276
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int try_read_command ( conn * c ) { assert ( c != NULL ) ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; assert ( c -> rbytes > 0 ) ; if ( c -> protocol == negotiating_prot || c -> transport == udp_transport ) { if ( ( unsigned char ) c -> rbuf [ 0 ] == ( unsigned char ) PROTOCOL_BINARY_REQ ) { c -> protocol = binary_prot ; } else { c -> protocol = ascii_prot ; } if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Client using the %s protocol\\n"" , c -> sfd , prot_text ( c -> protocol ) ) ; } } if ( c -> protocol == binary_prot ) { if ( c -> rbytes < sizeof ( c -> binary_header ) ) { return 0 ; } else { # ifdef NEED_ALIGN if ( ( ( long ) ( c -> rcurr ) ) % 8 != 0 ) { memmove ( c -> rbuf , c -> rcurr , c -> rbytes ) ; c -> rcurr = c -> rbuf ; if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Realign input buffer\\n"" , c -> sfd ) ; } } # endif protocol_binary_request_header * req ; req = ( protocol_binary_request_header * ) c -> rcurr ; if ( settings . verbose > 1 ) { int ii ; fprintf ( stderr , ""<%d Read binary protocol data:"" , c -> sfd ) ; for ( ii = 0 ; ii < sizeof ( req -> bytes ) ; ++ ii ) { if ( ii % 4 == 0 ) { fprintf ( stderr , ""\\n<%d   "" , c -> sfd ) ; } fprintf ( stderr , "" 0x%02x"" , req -> bytes [ ii ] ) ; } fprintf ( stderr , ""\\n"" ) ; } c -> binary_header = * req ; c -> binary_header . request . keylen = ntohs ( req -> request . keylen ) ; c -> binary_header . request . bodylen = ntohl ( req -> request . bodylen ) ; c -> binary_header . request . cas = ntohll ( req -> request . cas ) ; if ( c -> binary_header . request . magic != PROTOCOL_BINARY_REQ ) { if ( settings . verbose ) { fprintf ( stderr , ""Invalid magic:  %x\\n"" , c -> binary_header . request . magic ) ; } conn_set_state ( c , conn_closing ) ; return - 1 ; } c -> msgcurr = 0 ; c -> msgused = 0 ; c -> iovused = 0 ; if ( add_msghdr ( c ) != 0 ) { out_string ( c , ""SERVER_ERROR out of memory"" ) ; return 0 ; } c -> cmd = c -> binary_header . request . opcode ; c -> keylen = c -> binary_header . request . keylen ; c -> opaque = c -> binary_header . request . opaque ; c -> cas = 0 ; dispatch_bin_command ( c ) ; c -> rbytes -= sizeof ( c -> binary_header ) ; c -> rcurr += sizeof ( c -> binary_header ) ; } } else { char * el , * cont ; if ( c -> rbytes == 0 ) return 0 ; el = memchr ( c -> rcurr , '\\n' , c -> rbytes ) ; if ( ! el ) return 0 ; cont = el + 1 ; if ( ( el - c -> rcurr ) > 1 && * ( el - 1 ) == '\\r' ) { el -- ; } * el = '\\0' ; assert ( cont <= ( c -> rcurr + c -> rbytes ) ) ; process_command ( c , c -> rcurr ) ; c -> rbytes -= ( cont - c -> rcurr ) ; c -> rcurr = cont ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; } return 1 ; }
Fixed code:","
static int try_read_command ( conn * c ) { assert ( c != NULL ) ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; assert ( c -> rbytes > 0 ) ; if ( c -> protocol == negotiating_prot || c -> transport == udp_transport ) { if ( ( unsigned char ) c -> rbuf [ 0 ] == ( unsigned char ) PROTOCOL_BINARY_REQ ) { c -> protocol = binary_prot ; } else { c -> protocol = ascii_prot ; } if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Client using the %s protocol\\n"" , c -> sfd , prot_text ( c -> protocol ) ) ; } } if ( c -> protocol == binary_prot ) { if ( c -> rbytes < sizeof ( c -> binary_header ) ) { return 0 ; } else { # ifdef NEED_ALIGN if ( ( ( long ) ( c -> rcurr ) ) % 8 != 0 ) { memmove ( c -> rbuf , c -> rcurr , c -> rbytes ) ; c -> rcurr = c -> rbuf ; if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Realign input buffer\\n"" , c -> sfd ) ; } } # endif protocol_binary_request_header * req ; req = ( protocol_binary_request_header * ) c -> rcurr ; if ( settings . verbose > 1 ) { int ii ; fprintf ( stderr , ""<%d Read binary protocol data:"" , c -> sfd ) ; for ( ii = 0 ; ii < sizeof ( req -> bytes ) ; ++ ii ) { if ( ii % 4 == 0 ) { fprintf ( stderr , ""\\n<%d   "" , c -> sfd ) ; } fprintf ( stderr , "" 0x%02x"" , req -> bytes [ ii ] ) ; } fprintf ( stderr , ""\\n"" ) ; } c -> binary_header = * req ; c -> binary_header . request . keylen = ntohs ( req -> request . keylen ) ; c -> binary_header . request . bodylen = ntohl ( req -> request . bodylen ) ; c -> binary_header . request . cas = ntohll ( req -> request . cas ) ; // ADDED INPUT VALIDATION IF STATEMENT IF (req->request.magic < PROTOCOL_BINARY_REQ || req->request.magic > PROTOCOL_BINARY_RES) { if ( settings . verbose ) { fprintf ( stderr , ""Invalid magic:  %x\\n"" , c -> binary_header . request . magic ) ; } conn_set_state ( c , conn_closing ) ; return - 1 ; } c -> msgcurr = 0 ; c -> msgused = 0 ; c -> iovused = 0 ; if ( add_msghdr ( c ) != 0 ) { out_string ( c , ""SERVER_ERROR out of memory"" ) ; return 0 ; } c -> cmd = c -> binary_header . request . opcode ; c -> keylen = c -> binary_header . request . keylen ; c -> opaque = c -> binary_header . request . opaque ; c -> cas = 0 ; dispatch_bin_command ( c ) ; c -> rbytes -= sizeof ( c -> binary_header ) ; c -> rcurr += sizeof ( c -> binary_header ) ; } } else { char * el , * cont ; if ( c -> rbytes == 0 ) return 0 ; el = memchr ( c -> rcurr , '\\n' , c -> rbytes ) ; if ( ! el ) return 0 ; cont = el + 1 ; if ( ( el - c -> rcurr ) > 1 && * ( el - 1 ) == '\\r' ) { el -- ; } * el = '\\0' ; assert ( cont <= ( c -> rcurr + c -> rbytes ) ) ; process_command ( c , c -> rcurr ) ; c -> rbytes -= ( cont - c -> rcurr ) ; c -> rcurr = cont ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; } return 1 ; }",962,-23.5197238902614,-0.02444877743270416
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int try_read_command ( conn * c ) { assert ( c != NULL ) ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; assert ( c -> rbytes > 0 ) ; if ( c -> protocol == negotiating_prot || c -> transport == udp_transport ) { if ( ( unsigned char ) c -> rbuf [ 0 ] == ( unsigned char ) PROTOCOL_BINARY_REQ ) { c -> protocol = binary_prot ; } else { c -> protocol = ascii_prot ; } if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Client using the %s protocol\\n"" , c -> sfd , prot_text ( c -> protocol ) ) ; } } if ( c -> protocol == binary_prot ) { if ( c -> rbytes < sizeof ( c -> binary_header ) ) { return 0 ; } else { # ifdef NEED_ALIGN if ( ( ( long ) ( c -> rcurr ) ) % 8 != 0 ) { memmove ( c -> rbuf , c -> rcurr , c -> rbytes ) ; c -> rcurr = c -> rbuf ; if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Realign input buffer\\n"" , c -> sfd ) ; } } # endif protocol_binary_request_header * req ; req = ( protocol_binary_request_header * ) c -> rcurr ; if ( settings . verbose > 1 ) { int ii ; fprintf ( stderr , ""<%d Read binary protocol data:"" , c -> sfd ) ; for ( ii = 0 ; ii < sizeof ( req -> bytes ) ; ++ ii ) { if ( ii % 4 == 0 ) { fprintf ( stderr , ""\\n<%d   "" , c -> sfd ) ; } fprintf ( stderr , "" 0x%02x"" , req -> bytes [ ii ] ) ; } fprintf ( stderr , ""\\n"" ) ; } c -> binary_header = * req ; c -> binary_header . request . keylen = ntohs ( req -> request . keylen ) ; c -> binary_header . request . bodylen = ntohl ( req -> request . bodylen ) ; c -> binary_header . request . cas = ntohll ( req -> request . cas ) ; if ( c -> binary_header . request . magic != PROTOCOL_BINARY_REQ ) { if ( settings . verbose ) { fprintf ( stderr , ""Invalid magic:  %x\\n"" , c -> binary_header . request . magic ) ; } conn_set_state ( c , conn_closing ) ; return - 1 ; } c -> msgcurr = 0 ; c -> msgused = 0 ; c -> iovused = 0 ; if ( add_msghdr ( c ) != 0 ) { out_string ( c , ""SERVER_ERROR out of memory"" ) ; return 0 ; } c -> cmd = c -> binary_header . request . opcode ; c -> keylen = c -> binary_header . request . keylen ; c -> opaque = c -> binary_header . request . opaque ; c -> cas = 0 ; dispatch_bin_command ( c ) ; c -> rbytes -= sizeof ( c -> binary_header ) ; c -> rcurr += sizeof ( c -> binary_header ) ; } } else { char * el , * cont ; if ( c -> rbytes == 0 ) return 0 ; el = memchr ( c -> rcurr , '\\n' , c -> rbytes ) ; if ( ! el ) return 0 ; cont = el + 1 ; if ( ( el - c -> rcurr ) > 1 && * ( el - 1 ) == '\\r' ) { el -- ; } * el = '\\0' ; assert ( cont <= ( c -> rcurr + c -> rbytes ) ) ; process_command ( c , c -> rcurr ) ; c -> rbytes -= ( cont - c -> rcurr ) ; c -> rcurr = cont ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; } return 1 ; }
Fixed code:","
static int try_read_command ( conn * c ) { assert ( c != NULL ) ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; assert ( c -> rbytes > 0 ) ; // Add input validation to check for malicious input if (c->rbytes > MAX_COMMAND_SIZE || c->rbytes < MIN_COMMAND_SIZE) { return 0; } if ( c -> protocol == negotiating_prot || c -> transport == udp_transport ) { if ( ( unsigned char ) c -> rbuf [ 0 ] == ( unsigned char ) PROTOCOL_BINARY_REQ ) { c -> protocol = binary_prot ; } else { c -> protocol = ascii_prot ; } if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Client using the %s protocol\\n"" , c -> sfd , prot_text ( c -> protocol ) ) ; } } if ( c -> protocol == binary_prot ) { if ( c -> rbytes < sizeof ( c -> binary_header ) ) { return 0 ; } else { # ifdef NEED_ALIGN if ( ( ( long ) ( c -> rcurr ) ) % 8 != 0 ) { memmove ( c -> rbuf , c -> rcurr , c -> rbytes ) ; c -> rcurr = c -> rbuf ; if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Realign input buffer\\n"" , c -> sfd ) ; } } # endif protocol_binary_request_header * req ; req = ( protocol_binary_request_header * ) c -> rcurr ; if ( settings . verbose > 1 ) { int ii ; fprintf ( stderr , ""<%d Read binary protocol data:"" , c -> sfd ) ; for ( ii = 0 ; ii < sizeof ( req -> bytes ) ; ++ ii ) { if ( ii % 4 == 0 ) { fprintf ( stderr , ""\\n<%d   "" , c -> sfd ) ; } fprintf ( stderr , "" 0x%02x"" , req -> bytes [ ii ] ) ; } fprintf ( stderr , ""\\n"" ) ; } c -> binary_header = * req ; c -> binary_header . request . keylen = ntohs ( req -> request . keylen ) ; c -> binary_header . request . bodylen = ntohl ( req -> request . bodylen ) ; c -> binary_header . request . cas = ntohll ( req -> request . cas ) ; if ( c -> binary_header . request . magic != PROTOCOL_BINARY_REQ ) { if ( settings . verbose ) { fprintf ( stderr , ""Invalid magic:  %x\\n"" , c -> binary_header . request . magic ) ; } conn_set_state ( c , conn_closing ) ; return - 1 ; } c -> msgcurr = 0 ; c -> msgused = 0 ; c -> iovused = 0 ; if ( add_msghdr ( c ) != 0 ) { out_string ( c , ""SERVER_ERROR out of memory"" ) ; return 0 ; } c -> cmd = c -> binary_header . request . opcode ; c -> keylen = c -> binary_header . request . keylen ; c -> opaque = c -> binary_header . request . opaque ; c -> cas = 0 ; dispatch_bin_command ( c ) ; c -> rbytes -= sizeof ( c -> binary_header ) ; c -> rcurr += sizeof ( c -> binary_header ) ; } } else { char * el , * cont ; if ( c -> rbytes == 0 ) return 0 ; el = memchr ( c -> rcurr , '\\n' , c -> rbytes ) ; if ( ! el ) return 0 ; cont = el + 1 ; if ( ( el - c -> rcurr ) > 1 && * ( el - 1 ) == '\\r' ) { el -- ; } * el = '\\0' ; assert ( cont <= ( c -> rcurr + c -> rbytes ) ) ; // Add input validation to check for malicious input if (el - c->rcurr > MAX_COMMAND_SIZE || el - c->rcurr < MIN_COMMAND_SIZE) { return 0; } process_command ( c , c -> rcurr ) ; c -> rbytes -= ( cont - c -> rcurr ) ; c -> rcurr",1000,-25.173604030324988,-0.025173604030324988
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int try_read_command ( conn * c ) { assert ( c != NULL ) ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; assert ( c -> rbytes > 0 ) ; if ( c -> protocol == negotiating_prot || c -> transport == udp_transport ) { if ( ( unsigned char ) c -> rbuf [ 0 ] == ( unsigned char ) PROTOCOL_BINARY_REQ ) { c -> protocol = binary_prot ; } else { c -> protocol = ascii_prot ; } if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Client using the %s protocol\\n"" , c -> sfd , prot_text ( c -> protocol ) ) ; } } if ( c -> protocol == binary_prot ) { if ( c -> rbytes < sizeof ( c -> binary_header ) ) { return 0 ; } else { # ifdef NEED_ALIGN if ( ( ( long ) ( c -> rcurr ) ) % 8 != 0 ) { memmove ( c -> rbuf , c -> rcurr , c -> rbytes ) ; c -> rcurr = c -> rbuf ; if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Realign input buffer\\n"" , c -> sfd ) ; } } # endif protocol_binary_request_header * req ; req = ( protocol_binary_request_header * ) c -> rcurr ; if ( settings . verbose > 1 ) { int ii ; fprintf ( stderr , ""<%d Read binary protocol data:"" , c -> sfd ) ; for ( ii = 0 ; ii < sizeof ( req -> bytes ) ; ++ ii ) { if ( ii % 4 == 0 ) { fprintf ( stderr , ""\\n<%d   "" , c -> sfd ) ; } fprintf ( stderr , "" 0x%02x"" , req -> bytes [ ii ] ) ; } fprintf ( stderr , ""\\n"" ) ; } c -> binary_header = * req ; c -> binary_header . request . keylen = ntohs ( req -> request . keylen ) ; c -> binary_header . request . bodylen = ntohl ( req -> request . bodylen ) ; c -> binary_header . request . cas = ntohll ( req -> request . cas ) ; if ( c -> binary_header . request . magic != PROTOCOL_BINARY_REQ ) { if ( settings . verbose ) { fprintf ( stderr , ""Invalid magic:  %x\\n"" , c -> binary_header . request . magic ) ; } conn_set_state ( c , conn_closing ) ; return - 1 ; } c -> msgcurr = 0 ; c -> msgused = 0 ; c -> iovused = 0 ; if ( add_msghdr ( c ) != 0 ) { out_string ( c , ""SERVER_ERROR out of memory"" ) ; return 0 ; } c -> cmd = c -> binary_header . request . opcode ; c -> keylen = c -> binary_header . request . keylen ; c -> opaque = c -> binary_header . request . opaque ; c -> cas = 0 ; dispatch_bin_command ( c ) ; c -> rbytes -= sizeof ( c -> binary_header ) ; c -> rcurr += sizeof ( c -> binary_header ) ; } } else { char * el , * cont ; if ( c -> rbytes == 0 ) return 0 ; el = memchr ( c -> rcurr , '\\n' , c -> rbytes ) ; if ( ! el ) return 0 ; cont = el + 1 ; if ( ( el - c -> rcurr ) > 1 && * ( el - 1 ) == '\\r' ) { el -- ; } * el = '\\0' ; assert ( cont <= ( c -> rcurr + c -> rbytes ) ) ; process_command ( c , c -> rcurr ) ; c -> rbytes -= ( cont - c -> rcurr ) ; c -> rcurr = cont ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; } return 1 ; }
Fixed code:","
static int try_read_command ( conn * c ) { assert ( c != NULL ) ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; assert ( c -> rbytes > 0 ) ; 
//input validation added 
if (c->rbuf < 0 || c->rbuf > 255 || c->rsize < 0 || c->rsize > 255) {
	return -1;
}
if ( c -> protocol == negotiating_prot || c -> transport == udp_transport ) { if ( ( unsigned char ) c -> rbuf [ 0 ] == ( unsigned char ) PROTOCOL_BINARY_REQ ) { c -> protocol = binary_prot ; } else { c -> protocol = ascii_prot ; } if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Client using the %s protocol\\n"" , c -> sfd , prot_text ( c -> protocol ) ) ; } } if ( c -> protocol == binary_prot ) { if ( c -> rbytes < sizeof ( c -> binary_header ) ) { return 0 ; } else { # ifdef NEED_ALIGN if ( ( ( long ) ( c -> rcurr ) ) % 8 != 0 ) { memmove ( c -> rbuf , c -> rcurr , c -> rbytes ) ; c -> rcurr = c -> rbuf ; if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Realign input buffer\\n"" , c -> sfd ) ; } } # endif protocol_binary_request_header * req ; req = ( protocol_binary_request_header * ) c -> rcurr ; if ( settings . verbose > 1 ) { int ii ; fprintf ( stderr , ""<%d Read binary protocol data:"" , c -> sfd ) ; for ( ii = 0 ; ii < sizeof ( req -> bytes ) ; ++ ii ) { if ( ii % 4 == 0 ) { fprintf ( stderr , ""\\n<%d   "" , c -> sfd ) ; } fprintf ( stderr , "" 0x%02x"" , req -> bytes [ ii ] ) ; } fprintf ( stderr , ""\\n"" ) ; } c -> binary_header = * req ; c -> binary_header . request . keylen = ntohs ( req -> request . keylen ) ; c -> binary_header . request . bodylen = ntohl ( req -> request . bodylen ) ; c -> binary_header . request . cas = ntohll ( req -> request . cas ) ; 
//input validation added 
if (c->binary_header.request.keylen < 0 || c->binary_header.request.keylen > 255 || c->binary_header.request.bodylen < 0 || c->binary_header.request.bodylen > 255) {
	return -1;
}
if ( c -> binary_header . request . magic != PROTOCOL_BINARY_REQ ) { if ( settings . verbose ) { fprintf ( stderr , ""Invalid magic:  %x\\n"" , c -> binary_header . request . magic ) ; } conn_set_state ( c , conn_closing ) ; return - 1 ; } c -> msgcurr = 0 ; c -> msgused = 0 ; c -> iovused = 0 ; if ( add_msghdr ( c ) != 0 ) { out_string ( c , ""SERVER_ERROR out of memory"" ) ; return 0 ; } c -> cmd = c -> binary_header . request . opcode ; c -> keylen = c -> binary_header . request . keylen ; c -> opaque = c -> binary_header . request . opaque ; c -> cas = 0 ; dispatch_bin_command ( c ) ; c -> rbytes -= sizeof ( c -> binary_header ) ; c -> rcurr += sizeof ( c -> binary_header ) ; } } else { char * el , * cont ; if ( c -> rbytes == 0 ) return 0 ; el = memchr ( c -> rcurr , '\\n' , c -> rbytes ) ; if ( ! el ) return 0 ; cont = el + 1 ; if ( ( el - c -> rcurr ) > 1 && * ( el - 1 ) == '\\r' ) { el -- ; } * el = '\\0' ; assert ( cont <= ( c -> rcurr + c -> rbytes ) ) ; 
//",1000,-36.60551234884524,-0.03660551234884524
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int try_read_command ( conn * c ) { assert ( c != NULL ) ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; assert ( c -> rbytes > 0 ) ; if ( c -> protocol == negotiating_prot || c -> transport == udp_transport ) { if ( ( unsigned char ) c -> rbuf [ 0 ] == ( unsigned char ) PROTOCOL_BINARY_REQ ) { c -> protocol = binary_prot ; } else { c -> protocol = ascii_prot ; } if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Client using the %s protocol\\n"" , c -> sfd , prot_text ( c -> protocol ) ) ; } } if ( c -> protocol == binary_prot ) { if ( c -> rbytes < sizeof ( c -> binary_header ) ) { return 0 ; } else { # ifdef NEED_ALIGN if ( ( ( long ) ( c -> rcurr ) ) % 8 != 0 ) { memmove ( c -> rbuf , c -> rcurr , c -> rbytes ) ; c -> rcurr = c -> rbuf ; if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Realign input buffer\\n"" , c -> sfd ) ; } } # endif protocol_binary_request_header * req ; req = ( protocol_binary_request_header * ) c -> rcurr ; if ( settings . verbose > 1 ) { int ii ; fprintf ( stderr , ""<%d Read binary protocol data:"" , c -> sfd ) ; for ( ii = 0 ; ii < sizeof ( req -> bytes ) ; ++ ii ) { if ( ii % 4 == 0 ) { fprintf ( stderr , ""\\n<%d   "" , c -> sfd ) ; } fprintf ( stderr , "" 0x%02x"" , req -> bytes [ ii ] ) ; } fprintf ( stderr , ""\\n"" ) ; } c -> binary_header = * req ; c -> binary_header . request . keylen = ntohs ( req -> request . keylen ) ; c -> binary_header . request . bodylen = ntohl ( req -> request . bodylen ) ; c -> binary_header . request . cas = ntohll ( req -> request . cas ) ; if ( c -> binary_header . request . magic != PROTOCOL_BINARY_REQ ) { if ( settings . verbose ) { fprintf ( stderr , ""Invalid magic:  %x\\n"" , c -> binary_header . request . magic ) ; } conn_set_state ( c , conn_closing ) ; return - 1 ; } c -> msgcurr = 0 ; c -> msgused = 0 ; c -> iovused = 0 ; if ( add_msghdr ( c ) != 0 ) { out_string ( c , ""SERVER_ERROR out of memory"" ) ; return 0 ; } c -> cmd = c -> binary_header . request . opcode ; c -> keylen = c -> binary_header . request . keylen ; c -> opaque = c -> binary_header . request . opaque ; c -> cas = 0 ; dispatch_bin_command ( c ) ; c -> rbytes -= sizeof ( c -> binary_header ) ; c -> rcurr += sizeof ( c -> binary_header ) ; } } else { char * el , * cont ; if ( c -> rbytes == 0 ) return 0 ; el = memchr ( c -> rcurr , '\\n' , c -> rbytes ) ; if ( ! el ) return 0 ; cont = el + 1 ; if ( ( el - c -> rcurr ) > 1 && * ( el - 1 ) == '\\r' ) { el -- ; } * el = '\\0' ; assert ( cont <= ( c -> rcurr + c -> rbytes ) ) ; process_command ( c , c -> rcurr ) ; c -> rbytes -= ( cont - c -> rcurr ) ; c -> rcurr = cont ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; } return 1 ; }
Fixed code:","

static int try_read_command ( conn * c ) { assert ( c != NULL ) ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; assert ( c -> rbytes > 0 ) ; 
// Validate input to ensure it is valid binary and not malicious code
if ( c -> protocol == negotiating_prot || c -> transport == udp_transport ) {
    if ( ( unsigned char ) c -> rbuf [ 0 ] == ( unsigned char ) PROTOCOL_BINARY_REQ && c -> rbytes == sizeof ( c -> binary_header ) && c -> rcurr % 8 == 0 ) {
        c -> protocol = binary_prot ;
    } else {
        c -> protocol = ascii_prot ;
    }
	if ( settings . verbose > 1 ) {
		fprintf ( stderr , ""%d: Client using the %s protocol\\n"" , c -> sfd , prot_text ( c -> protocol ) ) ;
	}
}
if ( c -> protocol == binary_prot ) {
	protocol_binary_request_header * req ;
	req = ( protocol_binary_request_header * ) c -> rcurr ;
	if ( settings . verbose > 1 ) {
		int ii ;
		fprintf ( stderr , ""<%d Read binary protocol data:"" , c -> sfd ) ;
		for ( ii = 0 ; ii < sizeof ( req -> bytes ) ; ++ ii ) {
			if ( ii % 4 == 0 ) {
				fprintf ( stderr , ""\\n<%d   "" , c -> sfd ) ;
			}
			fprintf ( stderr , "" 0x%02x"" , req -> bytes [ ii ] ) ;
		}
		fprintf ( stderr , ""\\n"" ) ;
	}
	c -> binary_header = * req ;
	c -> binary_header . request . keylen = ntohs ( req -> request . keylen ) ;
	c -> binary_header . request . bodylen = ntohl ( req -> request . bodylen ) ;
	c -> binary_header . request . cas = ntohll ( req -> request . cas ) ;
	if ( c -> binary_header . request . magic != PROTOCOL_BINARY_REQ ) {
		if ( settings . verbose ) {
			fprintf ( stderr , ""Invalid magic:  %x\\n"" , c -> binary_header . request . magic ) ;
		}
		conn_set_state ( c , conn_closing ) ;
		return - 1 ;
	}
	c -> msgcurr = 0 ;
	c -> msgused = 0 ;
	c -> iovused = 0 ;
	if ( add_msghdr ( c ) != 0 ) {
		out_string ( c , ""SERVER_ERROR out of memory"" ) ;
		return 0 ;
	}
	c -> cmd = c -> binary_header . request . opcode ;
	c -> keylen = c -> binary_header . request . keylen ;
	c -> opaque = c -> binary_header . request . opaque ;
	c -> cas = 0 ;
	dispatch_bin_command ( c ) ;
	c -> rbytes -= sizeof ( c -> binary_header ) ;
	c -> rcurr += sizeof ( c -> binary_header ) ;
} else {
	char * el , * cont ;
	if ( c -> rbytes == 0 ) return 0 ;
	el = memchr ( c -> rcurr , '\\n' , c -> rbytes ) ;
	if ( ! el ) return 0 ;
	cont = el + 1 ;
	if ( ( el - c -> rcurr ) > 1 && * ( el - 1 ) == '\\r' ) {
		el -- ;
	}
	* el = '\\0' ;
	assert ( cont <= ( c -> rcurr + c -> rbytes ) ) ;
	process_command ( c , c -> rcurr ) ;
	c -> rbytes -= ( cont - c -> rcurr ) ;
	c -> rcurr = cont ;
	assert ( c -> rcurr <= ( c -> rbuf + c ->",1000,-51.20367703241151,-0.051203677032411514
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int try_read_command ( conn * c ) { assert ( c != NULL ) ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; assert ( c -> rbytes > 0 ) ; if ( c -> protocol == negotiating_prot || c -> transport == udp_transport ) { if ( ( unsigned char ) c -> rbuf [ 0 ] == ( unsigned char ) PROTOCOL_BINARY_REQ ) { c -> protocol = binary_prot ; } else { c -> protocol = ascii_prot ; } if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Client using the %s protocol\\n"" , c -> sfd , prot_text ( c -> protocol ) ) ; } } if ( c -> protocol == binary_prot ) { if ( c -> rbytes < sizeof ( c -> binary_header ) ) { return 0 ; } else { # ifdef NEED_ALIGN if ( ( ( long ) ( c -> rcurr ) ) % 8 != 0 ) { memmove ( c -> rbuf , c -> rcurr , c -> rbytes ) ; c -> rcurr = c -> rbuf ; if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Realign input buffer\\n"" , c -> sfd ) ; } } # endif protocol_binary_request_header * req ; req = ( protocol_binary_request_header * ) c -> rcurr ; if ( settings . verbose > 1 ) { int ii ; fprintf ( stderr , ""<%d Read binary protocol data:"" , c -> sfd ) ; for ( ii = 0 ; ii < sizeof ( req -> bytes ) ; ++ ii ) { if ( ii % 4 == 0 ) { fprintf ( stderr , ""\\n<%d   "" , c -> sfd ) ; } fprintf ( stderr , "" 0x%02x"" , req -> bytes [ ii ] ) ; } fprintf ( stderr , ""\\n"" ) ; } c -> binary_header = * req ; c -> binary_header . request . keylen = ntohs ( req -> request . keylen ) ; c -> binary_header . request . bodylen = ntohl ( req -> request . bodylen ) ; c -> binary_header . request . cas = ntohll ( req -> request . cas ) ; if ( c -> binary_header . request . magic != PROTOCOL_BINARY_REQ ) { if ( settings . verbose ) { fprintf ( stderr , ""Invalid magic:  %x\\n"" , c -> binary_header . request . magic ) ; } conn_set_state ( c , conn_closing ) ; return - 1 ; } c -> msgcurr = 0 ; c -> msgused = 0 ; c -> iovused = 0 ; if ( add_msghdr ( c ) != 0 ) { out_string ( c , ""SERVER_ERROR out of memory"" ) ; return 0 ; } c -> cmd = c -> binary_header . request . opcode ; c -> keylen = c -> binary_header . request . keylen ; c -> opaque = c -> binary_header . request . opaque ; c -> cas = 0 ; dispatch_bin_command ( c ) ; c -> rbytes -= sizeof ( c -> binary_header ) ; c -> rcurr += sizeof ( c -> binary_header ) ; } } else { char * el , * cont ; if ( c -> rbytes == 0 ) return 0 ; el = memchr ( c -> rcurr , '\\n' , c -> rbytes ) ; if ( ! el ) return 0 ; cont = el + 1 ; if ( ( el - c -> rcurr ) > 1 && * ( el - 1 ) == '\\r' ) { el -- ; } * el = '\\0' ; assert ( cont <= ( c -> rcurr + c -> rbytes ) ) ; process_command ( c , c -> rcurr ) ; c -> rbytes -= ( cont - c -> rcurr ) ; c -> rcurr = cont ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; } return 1 ; }
Fixed code:","
static int try_read_command ( conn * c ) { assert ( c != NULL ) ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; assert ( c -> rbytes > 0 ) ; if ( c -> protocol == negotiating_prot || c -> transport == udp_transport ) { if ( ( unsigned char ) c -> rbuf [ 0 ] == ( unsigned char ) PROTOCOL_BINARY_REQ ) { c -> protocol = binary_prot ; } else { c -> protocol = ascii_prot ; } if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Client using the %s protocol\\n"" , c -> sfd , prot_text ( c -> protocol ) ) ; } } if ( c -> protocol == binary_prot ) { if ( c -> rbytes < sizeof ( c -> binary_header ) ) { return 0 ; } else { # ifdef NEED_ALIGN if ( ( ( long ) ( c -> rcurr ) ) % 8 != 0 ) { memmove ( c -> rbuf , c -> rcurr , c -> rbytes ) ; c -> rcurr = c -> rbuf ; if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Realign input buffer\\n"" , c -> sfd ) ; } } # endif protocol_binary_request_header * req ; req = ( protocol_binary_request_header * ) c -> rcurr ; if ( settings . verbose > 1 ) { int ii ; fprintf ( stderr , ""<%d Read binary protocol data:"" , c -> sfd ) ; for ( ii = 0 ; ii < sizeof ( req -> bytes ) ; ++ ii ) { if ( ii % 4 == 0 ) { fprintf ( stderr , ""\\n<%d   "" , c -> sfd ) ; } fprintf ( stderr , "" 0x%02x"" , req -> bytes [ ii ] ) ; } fprintf ( stderr , ""\\n"" ) ; } c -> binary_header = * req ; c -> binary_header . request . keylen = ntohs ( req -> request . keylen ) ; c -> binary_header . request . bodylen = ntohl ( req -> request . bodylen ) ; c -> binary_header . request . cas = ntohll ( req -> request . cas ) ; // ADDED: Validate the binary_header magic value before proceeding if ( c -> binary_header . request . magic != PROTOCOL_BINARY_REQ ) { if ( settings . verbose ) { fprintf ( stderr , ""Invalid magic:  %x\\n"" , c -> binary_header . request . magic ) ; } conn_set_state ( c , conn_closing ) ; return - 1 ; } c -> msgcurr = 0 ; c -> msgused = 0 ; c -> iovused = 0 ; if ( add_msghdr ( c ) != 0 ) { out_string ( c , ""SERVER_ERROR out of memory"" ) ; return 0 ; } c -> cmd = c -> binary_header . request . opcode ; c -> keylen = c -> binary_header . request . keylen ; c -> opaque = c -> binary_header . request . opaque ; c -> cas = 0 ; dispatch_bin_command ( c ) ; c -> rbytes -= sizeof ( c -> binary_header ) ; c -> rcurr += sizeof ( c -> binary_header ) ; } } else { char * el , * cont ; if ( c -> rbytes == 0 ) return 0 ; // ADDED: Validate the input before proceeding if (!validate_input(c->rcurr)) { conn_set_state ( c , conn_closing ) ; return - 1 ; } el = memchr ( c -> rcurr , '\\n' , c -> rbytes ) ; if ( ! el ) return 0 ; cont = el + 1 ; if ( ( el - c -> rcurr ) > 1 && * ( el - 1 ) == '\\r' ) { el -- ; } * el = '\\0' ; assert ( cont <= ( c -> rcurr + c -> rbytes ) ) ; process_command ( c , c -> rcurr ) ; c -> rbytes -= ( cont - c -> rcurr ) ; c -> rcurr = cont ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; } return 1 ; }",996,-34.45231740104333,-0.03459068012152945
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int try_read_command ( conn * c ) { assert ( c != NULL ) ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; assert ( c -> rbytes > 0 ) ; if ( c -> protocol == negotiating_prot || c -> transport == udp_transport ) { if ( ( unsigned char ) c -> rbuf [ 0 ] == ( unsigned char ) PROTOCOL_BINARY_REQ ) { c -> protocol = binary_prot ; } else { c -> protocol = ascii_prot ; } if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Client using the %s protocol\\n"" , c -> sfd , prot_text ( c -> protocol ) ) ; } } if ( c -> protocol == binary_prot ) { if ( c -> rbytes < sizeof ( c -> binary_header ) ) { return 0 ; } else { # ifdef NEED_ALIGN if ( ( ( long ) ( c -> rcurr ) ) % 8 != 0 ) { memmove ( c -> rbuf , c -> rcurr , c -> rbytes ) ; c -> rcurr = c -> rbuf ; if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Realign input buffer\\n"" , c -> sfd ) ; } } # endif protocol_binary_request_header * req ; req = ( protocol_binary_request_header * ) c -> rcurr ; if ( settings . verbose > 1 ) { int ii ; fprintf ( stderr , ""<%d Read binary protocol data:"" , c -> sfd ) ; for ( ii = 0 ; ii < sizeof ( req -> bytes ) ; ++ ii ) { if ( ii % 4 == 0 ) { fprintf ( stderr , ""\\n<%d   "" , c -> sfd ) ; } fprintf ( stderr , "" 0x%02x"" , req -> bytes [ ii ] ) ; } fprintf ( stderr , ""\\n"" ) ; } c -> binary_header = * req ; c -> binary_header . request . keylen = ntohs ( req -> request . keylen ) ; c -> binary_header . request . bodylen = ntohl ( req -> request . bodylen ) ; c -> binary_header . request . cas = ntohll ( req -> request . cas ) ; if ( c -> binary_header . request . magic != PROTOCOL_BINARY_REQ ) { if ( settings . verbose ) { fprintf ( stderr , ""Invalid magic:  %x\\n"" , c -> binary_header . request . magic ) ; } conn_set_state ( c , conn_closing ) ; return - 1 ; } c -> msgcurr = 0 ; c -> msgused = 0 ; c -> iovused = 0 ; if ( add_msghdr ( c ) != 0 ) { out_string ( c , ""SERVER_ERROR out of memory"" ) ; return 0 ; } c -> cmd = c -> binary_header . request . opcode ; c -> keylen = c -> binary_header . request . keylen ; c -> opaque = c -> binary_header . request . opaque ; c -> cas = 0 ; dispatch_bin_command ( c ) ; c -> rbytes -= sizeof ( c -> binary_header ) ; c -> rcurr += sizeof ( c -> binary_header ) ; } } else { char * el , * cont ; if ( c -> rbytes == 0 ) return 0 ; el = memchr ( c -> rcurr , '\\n' , c -> rbytes ) ; if ( ! el ) return 0 ; cont = el + 1 ; if ( ( el - c -> rcurr ) > 1 && * ( el - 1 ) == '\\r' ) { el -- ; } * el = '\\0' ; assert ( cont <= ( c -> rcurr + c -> rbytes ) ) ; process_command ( c , c -> rcurr ) ; c -> rbytes -= ( cont - c -> rcurr ) ; c -> rcurr = cont ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; } return 1 ; }
Fixed code:","
static int try_read_command ( conn * c ) { assert ( c != NULL ) ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; assert ( c -> rbytes > 0 ) ; if ( c -> protocol == negotiating_prot || c -> transport == udp_transport ) { if ( ( unsigned char ) c -> rbuf [ 0 ] == ( unsigned char ) PROTOCOL_BINARY_REQ ) { c -> protocol = binary_prot ; } else { c -> protocol = ascii_prot ; } if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Client using the %s protocol\\n"" , c -> sfd , prot_text ( c -> protocol ) ) ; } } if ( c -> protocol == binary_prot ) { if ( c -> rbytes < sizeof ( c -> binary_header ) ) { return 0 ; } else { # ifdef NEED_ALIGN if ( ( ( long ) ( c -> rcurr ) ) % 8 != 0 ) { memmove ( c -> rbuf , c -> rcurr , c -> rbytes ) ; c -> rcurr = c -> rbuf ; if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Realign input buffer\\n"" , c -> sfd ) ; } } # endif protocol_binary_request_header * req ; req = ( protocol_binary_request_header * ) c -> rcurr ; if ( settings . verbose > 1 ) { int ii ; fprintf ( stderr , ""<%d Read binary protocol data:"" , c -> sfd ) ; for ( ii = 0 ; ii < sizeof ( req -> bytes ) ; ++ ii ) { if ( ii % 4 == 0 ) { fprintf ( stderr , ""\\n<%d   "" , c -> sfd ) ; } fprintf ( stderr , "" 0x%02x"" , req -> bytes [ ii ] ) ; } fprintf ( stderr , ""\\n"" ) ; } // Validate the incoming protocol if (req->request.magic != PROTOCOL_BINARY_REQ) { if ( settings . verbose ) { fprintf ( stderr , ""Invalid magic:  %x\\n"" , c -> binary_header . request . magic ) ; } conn_set_state ( c , conn_closing ) ; return - 1 ; } c -> binary_header = * req ; c -> binary_header . request . keylen = ntohs ( req -> request . keylen ) ; c -> binary_header . request . bodylen = ntohl ( req -> request . bodylen ) ; c -> binary_header . request . cas = ntohll ( req -> request . cas ) ; c -> msgcurr = 0 ; c -> msgused = 0 ; c -> iovused = 0 ; if ( add_msghdr ( c ) != 0 ) { out_string ( c , ""SERVER_ERROR out of memory"" ) ; return 0 ; } c -> cmd = c -> binary_header . request . opcode ; c -> keylen = c -> binary_header . request . keylen ; c -> opaque = c -> binary_header . request . opaque ; c -> cas = 0 ; dispatch_bin_command ( c ) ; c -> rbytes -= sizeof ( c -> binary_header ) ; c -> rcurr += sizeof ( c -> binary_header ) ; } } else { char * el , * cont ; if ( c -> rbytes == 0 ) return 0 ; el = memchr ( c -> rcurr , '\\n' , c -> rbytes ) ; if ( ! el ) return 0 ; cont = el + 1 ; if ( ( el - c -> rcurr ) > 1 && * ( el - 1 ) == '\\r' ) { el -- ; } * el = '\\0' ; assert ( cont <= ( c -> rcurr + c -> rbytes ) ) ; process_command ( c , c -> rcurr ) ; c -> rbytes -= ( cont - c -> rcurr ) ; c -> rcurr = cont ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; } return 1 ; }",941,-20.259304210444995,-0.021529547513756638
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int try_read_command ( conn * c ) { assert ( c != NULL ) ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; assert ( c -> rbytes > 0 ) ; if ( c -> protocol == negotiating_prot || c -> transport == udp_transport ) { if ( ( unsigned char ) c -> rbuf [ 0 ] == ( unsigned char ) PROTOCOL_BINARY_REQ ) { c -> protocol = binary_prot ; } else { c -> protocol = ascii_prot ; } if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Client using the %s protocol\\n"" , c -> sfd , prot_text ( c -> protocol ) ) ; } } if ( c -> protocol == binary_prot ) { if ( c -> rbytes < sizeof ( c -> binary_header ) ) { return 0 ; } else { # ifdef NEED_ALIGN if ( ( ( long ) ( c -> rcurr ) ) % 8 != 0 ) { memmove ( c -> rbuf , c -> rcurr , c -> rbytes ) ; c -> rcurr = c -> rbuf ; if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Realign input buffer\\n"" , c -> sfd ) ; } } # endif protocol_binary_request_header * req ; req = ( protocol_binary_request_header * ) c -> rcurr ; if ( settings . verbose > 1 ) { int ii ; fprintf ( stderr , ""<%d Read binary protocol data:"" , c -> sfd ) ; for ( ii = 0 ; ii < sizeof ( req -> bytes ) ; ++ ii ) { if ( ii % 4 == 0 ) { fprintf ( stderr , ""\\n<%d   "" , c -> sfd ) ; } fprintf ( stderr , "" 0x%02x"" , req -> bytes [ ii ] ) ; } fprintf ( stderr , ""\\n"" ) ; } c -> binary_header = * req ; c -> binary_header . request . keylen = ntohs ( req -> request . keylen ) ; c -> binary_header . request . bodylen = ntohl ( req -> request . bodylen ) ; c -> binary_header . request . cas = ntohll ( req -> request . cas ) ; if ( c -> binary_header . request . magic != PROTOCOL_BINARY_REQ ) { if ( settings . verbose ) { fprintf ( stderr , ""Invalid magic:  %x\\n"" , c -> binary_header . request . magic ) ; } conn_set_state ( c , conn_closing ) ; return - 1 ; } c -> msgcurr = 0 ; c -> msgused = 0 ; c -> iovused = 0 ; if ( add_msghdr ( c ) != 0 ) { out_string ( c , ""SERVER_ERROR out of memory"" ) ; return 0 ; } c -> cmd = c -> binary_header . request . opcode ; c -> keylen = c -> binary_header . request . keylen ; c -> opaque = c -> binary_header . request . opaque ; c -> cas = 0 ; dispatch_bin_command ( c ) ; c -> rbytes -= sizeof ( c -> binary_header ) ; c -> rcurr += sizeof ( c -> binary_header ) ; } } else { char * el , * cont ; if ( c -> rbytes == 0 ) return 0 ; el = memchr ( c -> rcurr , '\\n' , c -> rbytes ) ; if ( ! el ) return 0 ; cont = el + 1 ; if ( ( el - c -> rcurr ) > 1 && * ( el - 1 ) == '\\r' ) { el -- ; } * el = '\\0' ; assert ( cont <= ( c -> rcurr + c -> rbytes ) ) ; process_command ( c , c -> rcurr ) ; c -> rbytes -= ( cont - c -> rcurr ) ; c -> rcurr = cont ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; } return 1 ; }
Fixed code:","

static int try_read_command ( conn * c ) { assert ( c != NULL ) ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; assert ( c -> rbytes > 0 ) ; // Added input validation to check for valid protocol and transport if ( c -> protocol != negotiating_prot && c -> transport != udp_transport ) { return 0; } if ( c -> protocol == negotiating_prot || c -> transport == udp_transport ) { if ( ( unsigned char ) c -> rbuf [ 0 ] == ( unsigned char ) PROTOCOL_BINARY_REQ ) { c -> protocol = binary_prot ; } else { c -> protocol = ascii_prot ; } if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Client using the %s protocol\\n"" , c -> sfd , prot_text ( c -> protocol ) ) ; } } if ( c -> protocol == binary_prot ) { if ( c -> rbytes < sizeof ( c -> binary_header ) ) { return 0 ; } else { # ifdef NEED_ALIGN if ( ( ( long ) ( c -> rcurr ) ) % 8 != 0 ) { memmove ( c -> rbuf , c -> rcurr , c -> rbytes ) ; c -> rcurr = c -> rbuf ; if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Realign input buffer\\n"" , c -> sfd ) ; } } # endif protocol_binary_request_header * req ; req = ( protocol_binary_request_header * ) c -> rcurr ; if ( settings . verbose > 1 ) { int ii ; fprintf ( stderr , ""<%d Read binary protocol data:"" , c -> sfd ) ; for ( ii = 0 ; ii < sizeof ( req -> bytes ) ; ++ ii ) { if ( ii % 4 == 0 ) { fprintf ( stderr , ""\\n<%d   "" , c -> sfd ) ; } fprintf ( stderr , "" 0x%02x"" , req -> bytes [ ii ] ) ; } fprintf ( stderr , ""\\n"" ) ; } c -> binary_header = * req ; c -> binary_header . request . keylen = ntohs ( req -> request . keylen ) ; c -> binary_header . request . bodylen = ntohl ( req -> request . bodylen ) ; c -> binary_header . request . cas = ntohll ( req -> request . cas ) ; // Added input validation to check for valid protocol binary if ( c -> binary_header . request . magic != PROTOCOL_BINARY_REQ ) { if ( settings . verbose ) { fprintf ( stderr , ""Invalid magic:  %x\\n"" , c -> binary_header . request . magic ) ; } conn_set_state ( c , conn_closing ) ; return - 1 ; } c -> msgcurr = 0 ; c -> msgused = 0 ; c -> iovused = 0 ; if ( add_msghdr ( c ) != 0 ) { out_string ( c , ""SERVER_ERROR out of memory"" ) ; return 0 ; } c -> cmd = c -> binary_header . request . opcode ; c -> keylen = c -> binary_header . request . keylen ; c -> opaque = c -> binary_header . request . opaque ; c -> cas = 0 ; dispatch_bin_command ( c ) ; c -> rbytes -= sizeof ( c -> binary_header ) ; c -> rcurr += sizeof ( c -> binary_header ) ; } } else { char * el , * cont ; if ( c -> rbytes == 0 ) return 0 ; el = memchr ( c -> rcurr , '\\n' , c -> rbytes ) ; if ( ! el ) return 0 ; cont = el + 1 ; if ( ( el - c -> rcurr ) > 1 && * ( el - 1 ) == '\\r' ) { el -- ; } * el = '\\0' ; assert ( cont <= ( c -> rcurr + c -> rbytes ) ) ; process_command ( c , c -> rcurr ) ; c -> rbytes -= ( cont - c -> rcurr ) ; c -> rcurr = cont ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; } return 1 ; }",986,-22.39850769575779,-0.022716539245190456
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int try_read_command ( conn * c ) { assert ( c != NULL ) ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; assert ( c -> rbytes > 0 ) ; if ( c -> protocol == negotiating_prot || c -> transport == udp_transport ) { if ( ( unsigned char ) c -> rbuf [ 0 ] == ( unsigned char ) PROTOCOL_BINARY_REQ ) { c -> protocol = binary_prot ; } else { c -> protocol = ascii_prot ; } if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Client using the %s protocol\\n"" , c -> sfd , prot_text ( c -> protocol ) ) ; } } if ( c -> protocol == binary_prot ) { if ( c -> rbytes < sizeof ( c -> binary_header ) ) { return 0 ; } else { # ifdef NEED_ALIGN if ( ( ( long ) ( c -> rcurr ) ) % 8 != 0 ) { memmove ( c -> rbuf , c -> rcurr , c -> rbytes ) ; c -> rcurr = c -> rbuf ; if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Realign input buffer\\n"" , c -> sfd ) ; } } # endif protocol_binary_request_header * req ; req = ( protocol_binary_request_header * ) c -> rcurr ; if ( settings . verbose > 1 ) { int ii ; fprintf ( stderr , ""<%d Read binary protocol data:"" , c -> sfd ) ; for ( ii = 0 ; ii < sizeof ( req -> bytes ) ; ++ ii ) { if ( ii % 4 == 0 ) { fprintf ( stderr , ""\\n<%d   "" , c -> sfd ) ; } fprintf ( stderr , "" 0x%02x"" , req -> bytes [ ii ] ) ; } fprintf ( stderr , ""\\n"" ) ; } c -> binary_header = * req ; c -> binary_header . request . keylen = ntohs ( req -> request . keylen ) ; c -> binary_header . request . bodylen = ntohl ( req -> request . bodylen ) ; c -> binary_header . request . cas = ntohll ( req -> request . cas ) ; if ( c -> binary_header . request . magic != PROTOCOL_BINARY_REQ ) { if ( settings . verbose ) { fprintf ( stderr , ""Invalid magic:  %x\\n"" , c -> binary_header . request . magic ) ; } conn_set_state ( c , conn_closing ) ; return - 1 ; } c -> msgcurr = 0 ; c -> msgused = 0 ; c -> iovused = 0 ; if ( add_msghdr ( c ) != 0 ) { out_string ( c , ""SERVER_ERROR out of memory"" ) ; return 0 ; } c -> cmd = c -> binary_header . request . opcode ; c -> keylen = c -> binary_header . request . keylen ; c -> opaque = c -> binary_header . request . opaque ; c -> cas = 0 ; dispatch_bin_command ( c ) ; c -> rbytes -= sizeof ( c -> binary_header ) ; c -> rcurr += sizeof ( c -> binary_header ) ; } } else { char * el , * cont ; if ( c -> rbytes == 0 ) return 0 ; el = memchr ( c -> rcurr , '\\n' , c -> rbytes ) ; if ( ! el ) return 0 ; cont = el + 1 ; if ( ( el - c -> rcurr ) > 1 && * ( el - 1 ) == '\\r' ) { el -- ; } * el = '\\0' ; assert ( cont <= ( c -> rcurr + c -> rbytes ) ) ; process_command ( c , c -> rcurr ) ; c -> rbytes -= ( cont - c -> rcurr ) ; c -> rcurr = cont ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; } return 1 ; }
Fixed code:"," 
static int try_read_command ( conn * c ) { assert ( c != NULL ) ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; assert ( c -> rbytes > 0 ) ; 
//Validate the input received from client before proceeding. 
if (!validateInput(c->rcurr)){
  conn_set_state ( c , conn_closing ) ; 
  return - 1 ; 
}

if ( c -> protocol == negotiating_prot || c -> transport == udp_transport ) { if ( ( unsigned char ) c -> rbuf [ 0 ] == ( unsigned char ) PROTOCOL_BINARY_REQ ) { c -> protocol = binary_prot ; } else { c -> protocol = ascii_prot ; } if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Client using the %s protocol\\n"" , c -> sfd , prot_text ( c -> protocol ) ) ; } } if ( c -> protocol == binary_prot ) { if ( c -> rbytes < sizeof ( c -> binary_header ) ) { return 0 ; } else { # ifdef NEED_ALIGN if ( ( ( long ) ( c -> rcurr ) ) % 8 != 0 ) { memmove ( c -> rbuf , c -> rcurr , c -> rbytes ) ; c -> rcurr = c -> rbuf ; if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Realign input buffer\\n"" , c -> sfd ) ; } } # endif protocol_binary_request_header * req ; req = ( protocol_binary_request_header * ) c -> rcurr ; if ( settings . verbose > 1 ) { int ii ; fprintf ( stderr , ""<%d Read binary protocol data:"" , c -> sfd ) ; for ( ii = 0 ; ii < sizeof ( req -> bytes ) ; ++ ii ) { if ( ii % 4 == 0 ) { fprintf ( stderr , ""\\n<%d   "" , c -> sfd ) ; } fprintf ( stderr , "" 0x%02x"" , req -> bytes [ ii ] ) ; } fprintf ( stderr , ""\\n"" ) ; } c -> binary_header = * req ; c -> binary_header . request . keylen = ntohs ( req -> request . keylen ) ; c -> binary_header . request . bodylen = ntohl ( req -> request . bodylen ) ; c -> binary_header . request . cas = ntohll ( req -> request . cas ) ; if ( c -> binary_header . request . magic != PROTOCOL_BINARY_REQ ) { if ( settings . verbose ) { fprintf ( stderr , ""Invalid magic:  %x\\n"" , c -> binary_header . request . magic ) ; } conn_set_state ( c , conn_closing ) ; return - 1 ; } c -> msgcurr = 0 ; c -> msgused = 0 ; c -> iovused = 0 ; if ( add_msghdr ( c ) != 0 ) { out_string ( c , ""SERVER_ERROR out of memory"" ) ; return 0 ; } c -> cmd = c -> binary_header . request . opcode ; c -> keylen = c -> binary_header . request . keylen ; c -> opaque = c -> binary_header . request . opaque ; c -> cas = 0 ; dispatch_bin_command ( c ) ; c -> rbytes -= sizeof ( c -> binary_header ) ; c -> rcurr += sizeof ( c -> binary_header ) ; } } else { char * el , * cont ; if ( c -> rbytes == 0 ) return 0 ; el = memchr ( c -> rcurr , '\\n' , c -> rbytes ) ; if ( ! el ) return 0 ; cont = el + 1 ; if ( ( el - c -> rcurr ) > 1 && * ( el - 1 ) == '\\r' ) { el -- ; } * el = '\\0' ; assert ( cont <= ( c -> rcurr + c -> rbytes ) ) ; process_command ( c , c -> rcurr ) ; c -> rbytes -= ( cont - c -> rcurr ) ; c -> rcurr = cont ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; } return 1 ; }

//Added",1000,-41.72756208998231,-0.04172756208998231
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int try_read_command ( conn * c ) { assert ( c != NULL ) ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; assert ( c -> rbytes > 0 ) ; if ( c -> protocol == negotiating_prot || c -> transport == udp_transport ) { if ( ( unsigned char ) c -> rbuf [ 0 ] == ( unsigned char ) PROTOCOL_BINARY_REQ ) { c -> protocol = binary_prot ; } else { c -> protocol = ascii_prot ; } if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Client using the %s protocol\\n"" , c -> sfd , prot_text ( c -> protocol ) ) ; } } if ( c -> protocol == binary_prot ) { if ( c -> rbytes < sizeof ( c -> binary_header ) ) { return 0 ; } else { # ifdef NEED_ALIGN if ( ( ( long ) ( c -> rcurr ) ) % 8 != 0 ) { memmove ( c -> rbuf , c -> rcurr , c -> rbytes ) ; c -> rcurr = c -> rbuf ; if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Realign input buffer\\n"" , c -> sfd ) ; } } # endif protocol_binary_request_header * req ; req = ( protocol_binary_request_header * ) c -> rcurr ; if ( settings . verbose > 1 ) { int ii ; fprintf ( stderr , ""<%d Read binary protocol data:"" , c -> sfd ) ; for ( ii = 0 ; ii < sizeof ( req -> bytes ) ; ++ ii ) { if ( ii % 4 == 0 ) { fprintf ( stderr , ""\\n<%d   "" , c -> sfd ) ; } fprintf ( stderr , "" 0x%02x"" , req -> bytes [ ii ] ) ; } fprintf ( stderr , ""\\n"" ) ; } c -> binary_header = * req ; c -> binary_header . request . keylen = ntohs ( req -> request . keylen ) ; c -> binary_header . request . bodylen = ntohl ( req -> request . bodylen ) ; c -> binary_header . request . cas = ntohll ( req -> request . cas ) ; if ( c -> binary_header . request . magic != PROTOCOL_BINARY_REQ ) { if ( settings . verbose ) { fprintf ( stderr , ""Invalid magic:  %x\\n"" , c -> binary_header . request . magic ) ; } conn_set_state ( c , conn_closing ) ; return - 1 ; } c -> msgcurr = 0 ; c -> msgused = 0 ; c -> iovused = 0 ; if ( add_msghdr ( c ) != 0 ) { out_string ( c , ""SERVER_ERROR out of memory"" ) ; return 0 ; } c -> cmd = c -> binary_header . request . opcode ; c -> keylen = c -> binary_header . request . keylen ; c -> opaque = c -> binary_header . request . opaque ; c -> cas = 0 ; dispatch_bin_command ( c ) ; c -> rbytes -= sizeof ( c -> binary_header ) ; c -> rcurr += sizeof ( c -> binary_header ) ; } } else { char * el , * cont ; if ( c -> rbytes == 0 ) return 0 ; el = memchr ( c -> rcurr , '\\n' , c -> rbytes ) ; if ( ! el ) return 0 ; cont = el + 1 ; if ( ( el - c -> rcurr ) > 1 && * ( el - 1 ) == '\\r' ) { el -- ; } * el = '\\0' ; assert ( cont <= ( c -> rcurr + c -> rbytes ) ) ; process_command ( c , c -> rcurr ) ; c -> rbytes -= ( cont - c -> rcurr ) ; c -> rcurr = cont ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; } return 1 ; }
Fixed code:","
static int try_read_command ( conn * c ) { 
  assert ( c != NULL ) ; 
  assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; 
  assert ( c -> rbytes > 0 ) ; 
  if ( c -> protocol == negotiating_prot || c -> transport == udp_transport ) { 
    if ( ( unsigned char ) c -> rbuf [ 0 ] == ( unsigned char ) PROTOCOL_BINARY_REQ ) { 
      c -> protocol = binary_prot ; 
    } else { 
      c -> protocol = ascii_prot ; 
    } 
    if ( settings . verbose > 1 ) { 
      fprintf ( stderr , ""%d: Client using the %s protocol\\n"" , c -> sfd , prot_text ( c -> protocol ) ) ; 
    } 
  } 
  if ( c -> protocol == binary_prot ) { 
    if ( c -> rbytes < sizeof ( c -> binary_header ) ) { 
      return 0 ; 
    } else { 
     # ifdef NEED_ALIGN 
      if ( ( ( long ) ( c -> rcurr ) ) % 8 != 0 ) { 
        memmove ( c -> rbuf , c -> rcurr , c -> rbytes ) ; 
        c -> rcurr = c -> rbuf ; 
        if ( settings . verbose > 1 ) { 
          fprintf ( stderr , ""%d: Realign input buffer\\n"" , c -> sfd ) ; 
        } 
      } 
     # endif 
      protocol_binary_request_header * req ; 
      req = ( protocol_binary_request_header * ) c -> rcurr ; 
      if ( settings . verbose > 1 ) { 
        int ii ; 
        fprintf ( stderr , ""<%d Read binary protocol data:"" , c -> sfd ) ; 
        for ( ii = 0 ; ii < sizeof ( req -> bytes ) ; ++ ii ) { 
          if ( ii % 4 == 0 ) { 
            fprintf ( stderr , ""\\n<%d   "" , c -> sfd ) ; 
          } 
          fprintf ( stderr , "" 0x%02x"" , req -> bytes [ ii ] ) ; 
        } 
        fprintf ( stderr , ""\\n"" ) ; 
      } 
      if (req->request.magic != PROTOCOL_BINARY_REQ) { // Add if statement to validate magic
        if ( settings . verbose ) { 
          fprintf ( stderr , ""Invalid magic:  %x\\n"" , c -> binary_header . request . magic ) ; 
        } 
        conn_set_state ( c , conn_closing ) ; 
        return - 1 ; 
      }
      c -> binary_header = * req ; 
      c -> binary_header . request . keylen = ntohs ( req -> request . keylen ) ; 
      c -> binary_header . request . bodylen = ntohl ( req -> request . bodylen ) ; 
      c -> binary_header . request . cas = ntohll ( req -> request . cas ) ; 
      c -> msgcurr = 0 ; 
      c -> msgused = 0 ; 
      c -> iovused = 0 ; 
      if ( add_msghdr ( c ) != 0 ) { 
        out_string ( c , ""SERVER_ERROR out of memory"" ) ; 
        return 0 ; 
      } 
      c -> cmd = c -> binary_header . request . opcode ; 
      c -> keylen = c -> binary_header . request . keylen ; 
      c -> opaque = c -> binary_header . request . opaque ; 
      c -> cas = 0 ; 
      dispatch_bin_command ( c ) ; 
      c -> rbytes -= sizeof ( c -> binary_header ) ; 
      c -> rcurr += sizeof ( c -> binary_header ) ; 
    } 
  } else { 
    char * el , * cont ; 
    if ( c -> rbytes == 0 ) return 0 ; 
    el = memchr ( c -> r",1000,-32.34164378909883,-0.03234164378909883
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int try_read_command ( conn * c ) { assert ( c != NULL ) ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; assert ( c -> rbytes > 0 ) ; if ( c -> protocol == negotiating_prot || c -> transport == udp_transport ) { if ( ( unsigned char ) c -> rbuf [ 0 ] == ( unsigned char ) PROTOCOL_BINARY_REQ ) { c -> protocol = binary_prot ; } else { c -> protocol = ascii_prot ; } if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Client using the %s protocol\\n"" , c -> sfd , prot_text ( c -> protocol ) ) ; } } if ( c -> protocol == binary_prot ) { if ( c -> rbytes < sizeof ( c -> binary_header ) ) { return 0 ; } else { # ifdef NEED_ALIGN if ( ( ( long ) ( c -> rcurr ) ) % 8 != 0 ) { memmove ( c -> rbuf , c -> rcurr , c -> rbytes ) ; c -> rcurr = c -> rbuf ; if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Realign input buffer\\n"" , c -> sfd ) ; } } # endif protocol_binary_request_header * req ; req = ( protocol_binary_request_header * ) c -> rcurr ; if ( settings . verbose > 1 ) { int ii ; fprintf ( stderr , ""<%d Read binary protocol data:"" , c -> sfd ) ; for ( ii = 0 ; ii < sizeof ( req -> bytes ) ; ++ ii ) { if ( ii % 4 == 0 ) { fprintf ( stderr , ""\\n<%d   "" , c -> sfd ) ; } fprintf ( stderr , "" 0x%02x"" , req -> bytes [ ii ] ) ; } fprintf ( stderr , ""\\n"" ) ; } c -> binary_header = * req ; c -> binary_header . request . keylen = ntohs ( req -> request . keylen ) ; c -> binary_header . request . bodylen = ntohl ( req -> request . bodylen ) ; c -> binary_header . request . cas = ntohll ( req -> request . cas ) ; if ( c -> binary_header . request . magic != PROTOCOL_BINARY_REQ ) { if ( settings . verbose ) { fprintf ( stderr , ""Invalid magic:  %x\\n"" , c -> binary_header . request . magic ) ; } conn_set_state ( c , conn_closing ) ; return - 1 ; } c -> msgcurr = 0 ; c -> msgused = 0 ; c -> iovused = 0 ; if ( add_msghdr ( c ) != 0 ) { out_string ( c , ""SERVER_ERROR out of memory"" ) ; return 0 ; } c -> cmd = c -> binary_header . request . opcode ; c -> keylen = c -> binary_header . request . keylen ; c -> opaque = c -> binary_header . request . opaque ; c -> cas = 0 ; dispatch_bin_command ( c ) ; c -> rbytes -= sizeof ( c -> binary_header ) ; c -> rcurr += sizeof ( c -> binary_header ) ; } } else { char * el , * cont ; if ( c -> rbytes == 0 ) return 0 ; el = memchr ( c -> rcurr , '\\n' , c -> rbytes ) ; if ( ! el ) return 0 ; cont = el + 1 ; if ( ( el - c -> rcurr ) > 1 && * ( el - 1 ) == '\\r' ) { el -- ; } * el = '\\0' ; assert ( cont <= ( c -> rcurr + c -> rbytes ) ) ; process_command ( c , c -> rcurr ) ; c -> rbytes -= ( cont - c -> rcurr ) ; c -> rcurr = cont ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; } return 1 ; }
Fixed code:","
static int try_read_command ( conn * c ) { assert ( c != NULL ) ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; assert ( c -> rbytes > 0 ) ; if ( c -> protocol == negotiating_prot || c -> transport == udp_transport ) { if ( ( unsigned char ) c -> rbuf [ 0 ] == ( unsigned char ) PROTOCOL_BINARY_REQ ) { c -> protocol = binary_prot ; } else { c -> protocol = ascii_prot ; } if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Client using the %s protocol\\n"" , c -> sfd , prot_text ( c -> protocol ) ) ; } } if ( c -> protocol == binary_prot ) { if ( c -> rbytes < sizeof ( c -> binary_header ) ) { return 0 ; } else { # ifdef NEED_ALIGN if ( ( ( long ) ( c -> rcurr ) ) % 8 != 0 ) { memmove ( c -> rbuf , c -> rcurr , c -> rbytes ) ; c -> rcurr = c -> rbuf ; if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Realign input buffer\\n"" , c -> sfd ) ; } } # endif protocol_binary_request_header * req ; req = ( protocol_binary_request_header * ) c -> rcurr ; // Validate input here  if ( c -> binary_header . request . magic != PROTOCOL_BINARY_REQ ) { if ( settings . verbose ) { fprintf ( stderr , ""Invalid magic:  %x\\n"" , c -> binary_header . request . magic ) ; } conn_set_state ( c , conn_closing ) ; return - 1 ; } if ( settings . verbose > 1 ) { int ii ; fprintf ( stderr , ""<%d Read binary protocol data:"" , c -> sfd ) ; for ( ii = 0 ; ii < sizeof ( req -> bytes ) ; ++ ii ) { if ( ii % 4 == 0 ) { fprintf ( stderr , ""\\n<%d   "" , c -> sfd ) ; } fprintf ( stderr , "" 0x%02x"" , req -> bytes [ ii ] ) ; } fprintf ( stderr , ""\\n"" ) ; } c -> binary_header = * req ; c -> binary_header . request . keylen = ntohs ( req -> request . keylen ) ; c -> binary_header . request . bodylen = ntohl ( req -> request . bodylen ) ; c -> binary_header . request . cas = ntohll ( req -> request . cas ) ; c -> msgcurr = 0 ; c -> msgused = 0 ; c -> iovused = 0 ; if ( add_msghdr ( c ) != 0 ) { out_string ( c , ""SERVER_ERROR out of memory"" ) ; return 0 ; } c -> cmd = c -> binary_header . request . opcode ; c -> keylen = c -> binary_header . request . keylen ; c -> opaque = c -> binary_header . request . opaque ; c -> cas = 0 ; dispatch_bin_command ( c ) ; c -> rbytes -= sizeof ( c -> binary_header ) ; c -> rcurr += sizeof ( c -> binary_header ) ; } } else { char * el , * cont ; if ( c -> rbytes == 0 ) return 0 ; el = memchr ( c -> rcurr , '\\n' , c -> rbytes ) ; if ( ! el ) return 0 ; cont = el + 1 ; if ( ( el - c -> rcurr ) > 1 && * ( el - 1 ) == '\\r' ) { el -- ; } * el = '\\0' ; assert ( cont <= ( c -> rcurr + c -> rbytes ) ) ; process_command ( c , c -> rcurr ) ; c -> rbytes -= ( cont - c -> rcurr ) ; c -> rcurr = cont ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; } return 1 ; }",945,-18.758897890287344,-0.019850685598187666
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int try_read_command ( conn * c ) { assert ( c != NULL ) ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; assert ( c -> rbytes > 0 ) ; if ( c -> protocol == negotiating_prot || c -> transport == udp_transport ) { if ( ( unsigned char ) c -> rbuf [ 0 ] == ( unsigned char ) PROTOCOL_BINARY_REQ ) { c -> protocol = binary_prot ; } else { c -> protocol = ascii_prot ; } if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Client using the %s protocol\\n"" , c -> sfd , prot_text ( c -> protocol ) ) ; } } if ( c -> protocol == binary_prot ) { if ( c -> rbytes < sizeof ( c -> binary_header ) ) { return 0 ; } else { # ifdef NEED_ALIGN if ( ( ( long ) ( c -> rcurr ) ) % 8 != 0 ) { memmove ( c -> rbuf , c -> rcurr , c -> rbytes ) ; c -> rcurr = c -> rbuf ; if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Realign input buffer\\n"" , c -> sfd ) ; } } # endif protocol_binary_request_header * req ; req = ( protocol_binary_request_header * ) c -> rcurr ; if ( settings . verbose > 1 ) { int ii ; fprintf ( stderr , ""<%d Read binary protocol data:"" , c -> sfd ) ; for ( ii = 0 ; ii < sizeof ( req -> bytes ) ; ++ ii ) { if ( ii % 4 == 0 ) { fprintf ( stderr , ""\\n<%d   "" , c -> sfd ) ; } fprintf ( stderr , "" 0x%02x"" , req -> bytes [ ii ] ) ; } fprintf ( stderr , ""\\n"" ) ; } c -> binary_header = * req ; c -> binary_header . request . keylen = ntohs ( req -> request . keylen ) ; c -> binary_header . request . bodylen = ntohl ( req -> request . bodylen ) ; c -> binary_header . request . cas = ntohll ( req -> request . cas ) ; if ( c -> binary_header . request . magic != PROTOCOL_BINARY_REQ ) { if ( settings . verbose ) { fprintf ( stderr , ""Invalid magic:  %x\\n"" , c -> binary_header . request . magic ) ; } conn_set_state ( c , conn_closing ) ; return - 1 ; } c -> msgcurr = 0 ; c -> msgused = 0 ; c -> iovused = 0 ; if ( add_msghdr ( c ) != 0 ) { out_string ( c , ""SERVER_ERROR out of memory"" ) ; return 0 ; } c -> cmd = c -> binary_header . request . opcode ; c -> keylen = c -> binary_header . request . keylen ; c -> opaque = c -> binary_header . request . opaque ; c -> cas = 0 ; dispatch_bin_command ( c ) ; c -> rbytes -= sizeof ( c -> binary_header ) ; c -> rcurr += sizeof ( c -> binary_header ) ; } } else { char * el , * cont ; if ( c -> rbytes == 0 ) return 0 ; el = memchr ( c -> rcurr , '\\n' , c -> rbytes ) ; if ( ! el ) return 0 ; cont = el + 1 ; if ( ( el - c -> rcurr ) > 1 && * ( el - 1 ) == '\\r' ) { el -- ; } * el = '\\0' ; assert ( cont <= ( c -> rcurr + c -> rbytes ) ) ; process_command ( c , c -> rcurr ) ; c -> rbytes -= ( cont - c -> rcurr ) ; c -> rcurr = cont ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; } return 1 ; }
Fixed code:","
static int try_read_command ( conn * c ) { assert ( c != NULL ) ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; assert ( c -> rbytes > 0 ) ; if ( c -> protocol == negotiating_prot || c -> transport == udp_transport ) { if ( ( unsigned char ) c -> rbuf [ 0 ] == ( unsigned char ) PROTOCOL_BINARY_REQ ) { c -> protocol = binary_prot ; } else { c -> protocol = ascii_prot ; } if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Client using the %s protocol\\n"" , c -> sfd , prot_text ( c -> protocol ) ) ; } } //Check for valid inputs before processing. if ( c -> protocol == binary_prot && ( c -> rbytes < sizeof ( c -> binary_header ) || ( unsigned char ) c -> rbuf [ 0 ] != ( unsigned char ) PROTOCOL_BINARY_REQ ) ) { return 0 ; } else { # ifdef NEED_ALIGN if ( ( ( long ) ( c -> rcurr ) ) % 8 != 0 ) { memmove ( c -> rbuf , c -> rcurr , c -> rbytes ) ; c -> rcurr = c -> rbuf ; if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Realign input buffer\\n"" , c -> sfd ) ; } } # endif protocol_binary_request_header * req ; req = ( protocol_binary_request_header * ) c -> rcurr ; if ( settings . verbose > 1 ) { int ii ; fprintf ( stderr , ""<%d Read binary protocol data:"" , c -> sfd ) ; for ( ii = 0 ; ii < sizeof ( req -> bytes ) ; ++ ii ) { if ( ii % 4 == 0 ) { fprintf ( stderr , ""\\n<%d   "" , c -> sfd ) ; } fprintf ( stderr , "" 0x%02x"" , req -> bytes [ ii ] ) ; } fprintf ( stderr , ""\\n"" ) ; } c -> binary_header = * req ; c -> binary_header . request . keylen = ntohs ( req -> request . keylen ) ; c -> binary_header . request . bodylen = ntohl ( req -> request . bodylen ) ; c -> binary_header . request . cas = ntohll ( req -> request . cas ) ; if ( c -> binary_header . request . magic != PROTOCOL_BINARY_REQ ) { if ( settings . verbose ) { fprintf ( stderr , ""Invalid magic:  %x\\n"" , c -> binary_header . request . magic ) ; } conn_set_state ( c , conn_closing ) ; return - 1 ; } c -> msgcurr = 0 ; c -> msgused = 0 ; c -> iovused = 0 ; if ( add_msghdr ( c ) != 0 ) { out_string ( c , ""SERVER_ERROR out of memory"" ) ; return 0 ; } c -> cmd = c -> binary_header . request . opcode ; c -> keylen = c -> binary_header . request . keylen ; c -> opaque = c -> binary_header . request . opaque ; c -> cas = 0 ; dispatch_bin_command ( c ) ; c -> rbytes -= sizeof ( c -> binary_header ) ; c -> rcurr += sizeof ( c -> binary_header ) ; } } else { char * el , * cont ; if ( c -> rbytes == 0 ) return 0 ; el = memchr ( c -> rcurr , '\\n' , c -> rbytes ) ; if ( ! el ) return 0 ; cont = el + 1 ; if ( ( el - c -> rcurr ) > 1 && * ( el - 1 ) == '\\r' ) { el -- ; } * el = '\\0' ; assert ( cont <= ( c -> rcurr + c -> rbytes ) ) ; process_command ( c , c -> rcurr ) ; c -> rbytes -= ( cont - c -> rcurr ) ; c -> rcurr = cont ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; } return 1 ; }",973,-27.767351145828993,-0.028537873736720443
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int try_read_command ( conn * c ) { assert ( c != NULL ) ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; assert ( c -> rbytes > 0 ) ; if ( c -> protocol == negotiating_prot || c -> transport == udp_transport ) { if ( ( unsigned char ) c -> rbuf [ 0 ] == ( unsigned char ) PROTOCOL_BINARY_REQ ) { c -> protocol = binary_prot ; } else { c -> protocol = ascii_prot ; } if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Client using the %s protocol\\n"" , c -> sfd , prot_text ( c -> protocol ) ) ; } } if ( c -> protocol == binary_prot ) { if ( c -> rbytes < sizeof ( c -> binary_header ) ) { return 0 ; } else { # ifdef NEED_ALIGN if ( ( ( long ) ( c -> rcurr ) ) % 8 != 0 ) { memmove ( c -> rbuf , c -> rcurr , c -> rbytes ) ; c -> rcurr = c -> rbuf ; if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Realign input buffer\\n"" , c -> sfd ) ; } } # endif protocol_binary_request_header * req ; req = ( protocol_binary_request_header * ) c -> rcurr ; if ( settings . verbose > 1 ) { int ii ; fprintf ( stderr , ""<%d Read binary protocol data:"" , c -> sfd ) ; for ( ii = 0 ; ii < sizeof ( req -> bytes ) ; ++ ii ) { if ( ii % 4 == 0 ) { fprintf ( stderr , ""\\n<%d   "" , c -> sfd ) ; } fprintf ( stderr , "" 0x%02x"" , req -> bytes [ ii ] ) ; } fprintf ( stderr , ""\\n"" ) ; } c -> binary_header = * req ; c -> binary_header . request . keylen = ntohs ( req -> request . keylen ) ; c -> binary_header . request . bodylen = ntohl ( req -> request . bodylen ) ; c -> binary_header . request . cas = ntohll ( req -> request . cas ) ; if ( c -> binary_header . request . magic != PROTOCOL_BINARY_REQ ) { if ( settings . verbose ) { fprintf ( stderr , ""Invalid magic:  %x\\n"" , c -> binary_header . request . magic ) ; } conn_set_state ( c , conn_closing ) ; return - 1 ; } c -> msgcurr = 0 ; c -> msgused = 0 ; c -> iovused = 0 ; if ( add_msghdr ( c ) != 0 ) { out_string ( c , ""SERVER_ERROR out of memory"" ) ; return 0 ; } c -> cmd = c -> binary_header . request . opcode ; c -> keylen = c -> binary_header . request . keylen ; c -> opaque = c -> binary_header . request . opaque ; c -> cas = 0 ; dispatch_bin_command ( c ) ; c -> rbytes -= sizeof ( c -> binary_header ) ; c -> rcurr += sizeof ( c -> binary_header ) ; } } else { char * el , * cont ; if ( c -> rbytes == 0 ) return 0 ; el = memchr ( c -> rcurr , '\\n' , c -> rbytes ) ; if ( ! el ) return 0 ; cont = el + 1 ; if ( ( el - c -> rcurr ) > 1 && * ( el - 1 ) == '\\r' ) { el -- ; } * el = '\\0' ; assert ( cont <= ( c -> rcurr + c -> rbytes ) ) ; process_command ( c , c -> rcurr ) ; c -> rbytes -= ( cont - c -> rcurr ) ; c -> rcurr = cont ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; } return 1 ; }
Fixed code:","
static int try_read_command ( conn * c ) { assert ( c != NULL ) ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; assert ( c -> rbytes > 0 ) ; if ( c -> protocol == negotiating_prot || c -> transport == udp_transport ) { 
if ( ( unsigned char ) c -> rbuf [ 0 ] == ( unsigned char ) PROTOCOL_BINARY_REQ && c->rbytes >= sizeof ( c -> binary_header ) ) { 
c -> protocol = binary_prot ; } else { c -> protocol = ascii_prot ; } if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Client using the %s protocol\\n"" , c -> sfd , prot_text ( c -> protocol ) ) ; } } if ( c -> protocol == binary_prot ) { if ( c -> rbytes < sizeof ( c -> binary_header ) ) { return 0 ; } else { # ifdef NEED_ALIGN if ( ( ( long ) ( c -> rcurr ) ) % 8 != 0 ) { memmove ( c -> rbuf , c -> rcurr , c -> rbytes ) ; c -> rcurr = c -> rbuf ; if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Realign input buffer\\n"" , c -> sfd ) ; } } # endif protocol_binary_request_header * req ; req = ( protocol_binary_request_header * ) c -> rcurr ; if ( settings . verbose > 1 ) { int ii ; fprintf ( stderr , ""<%d Read binary protocol data:"" , c -> sfd ) ; for ( ii = 0 ; ii < sizeof ( req -> bytes ) ; ++ ii ) { if ( ii % 4 == 0 ) { fprintf ( stderr , ""\\n<%d   "" , c -> sfd ) ; } fprintf ( stderr , "" 0x%02x"" , req -> bytes [ ii ] ) ; } fprintf ( stderr , ""\\n"" ) ; } c -> binary_header = * req ; c -> binary_header . request . keylen = ntohs ( req -> request . keylen ) ; c -> binary_header . request . bodylen = ntohl ( req -> request . bodylen ) ; c -> binary_header . request . cas = ntohll ( req -> request . cas ) ; 
if ( c -> binary_header . request . magic != PROTOCOL_BINARY_REQ ) { 
if ( settings . verbose ) { fprintf ( stderr , ""Invalid magic:  %x\\n"" , c -> binary_header . request . magic ) ; } conn_set_state ( c , conn_closing ) ; return - 1 ; } c -> msgcurr = 0 ; c -> msgused = 0 ; c -> iovused = 0 ; if ( add_msghdr ( c ) != 0 ) { out_string ( c , ""SERVER_ERROR out of memory"" ) ; return 0 ; } c -> cmd = c -> binary_header . request . opcode ; c -> keylen = c -> binary_header . request . keylen ; c -> opaque = c -> binary_header . request . opaque ; c -> cas = 0 ; dispatch_bin_command ( c ) ; c -> rbytes -= sizeof ( c -> binary_header ) ; c -> rcurr += sizeof ( c -> binary_header ) ; } } else { char * el , * cont ; if ( c -> rbytes == 0 ) return 0 ; el = memchr ( c -> rcurr , '\\n' , c -> rbytes ) ; if ( ! el ) return 0 ; cont = el + 1 ; if ( ( el - c -> rcurr ) > 1 && * ( el - 1 ) == '\\r' ) { el -- ; } * el = '\\0' ; assert ( cont <= ( c -> rcurr + c -> rbytes ) ) ; 
if (strlen(c->rcurr) > 0) {
    process_command ( c , c -> rcurr ) ;
	c -> rbytes -= ( cont - c -> rcurr ) ; c -> rcurr = cont ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ;
}
} return 1 ; }",985,-44.11652303912596,-0.04478834826307204
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int try_read_command ( conn * c ) { assert ( c != NULL ) ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; assert ( c -> rbytes > 0 ) ; if ( c -> protocol == negotiating_prot || c -> transport == udp_transport ) { if ( ( unsigned char ) c -> rbuf [ 0 ] == ( unsigned char ) PROTOCOL_BINARY_REQ ) { c -> protocol = binary_prot ; } else { c -> protocol = ascii_prot ; } if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Client using the %s protocol\\n"" , c -> sfd , prot_text ( c -> protocol ) ) ; } } if ( c -> protocol == binary_prot ) { if ( c -> rbytes < sizeof ( c -> binary_header ) ) { return 0 ; } else { # ifdef NEED_ALIGN if ( ( ( long ) ( c -> rcurr ) ) % 8 != 0 ) { memmove ( c -> rbuf , c -> rcurr , c -> rbytes ) ; c -> rcurr = c -> rbuf ; if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Realign input buffer\\n"" , c -> sfd ) ; } } # endif protocol_binary_request_header * req ; req = ( protocol_binary_request_header * ) c -> rcurr ; if ( settings . verbose > 1 ) { int ii ; fprintf ( stderr , ""<%d Read binary protocol data:"" , c -> sfd ) ; for ( ii = 0 ; ii < sizeof ( req -> bytes ) ; ++ ii ) { if ( ii % 4 == 0 ) { fprintf ( stderr , ""\\n<%d   "" , c -> sfd ) ; } fprintf ( stderr , "" 0x%02x"" , req -> bytes [ ii ] ) ; } fprintf ( stderr , ""\\n"" ) ; } c -> binary_header = * req ; c -> binary_header . request . keylen = ntohs ( req -> request . keylen ) ; c -> binary_header . request . bodylen = ntohl ( req -> request . bodylen ) ; c -> binary_header . request . cas = ntohll ( req -> request . cas ) ; if ( c -> binary_header . request . magic != PROTOCOL_BINARY_REQ ) { if ( settings . verbose ) { fprintf ( stderr , ""Invalid magic:  %x\\n"" , c -> binary_header . request . magic ) ; } conn_set_state ( c , conn_closing ) ; return - 1 ; } c -> msgcurr = 0 ; c -> msgused = 0 ; c -> iovused = 0 ; if ( add_msghdr ( c ) != 0 ) { out_string ( c , ""SERVER_ERROR out of memory"" ) ; return 0 ; } c -> cmd = c -> binary_header . request . opcode ; c -> keylen = c -> binary_header . request . keylen ; c -> opaque = c -> binary_header . request . opaque ; c -> cas = 0 ; dispatch_bin_command ( c ) ; c -> rbytes -= sizeof ( c -> binary_header ) ; c -> rcurr += sizeof ( c -> binary_header ) ; } } else { char * el , * cont ; if ( c -> rbytes == 0 ) return 0 ; el = memchr ( c -> rcurr , '\\n' , c -> rbytes ) ; if ( ! el ) return 0 ; cont = el + 1 ; if ( ( el - c -> rcurr ) > 1 && * ( el - 1 ) == '\\r' ) { el -- ; } * el = '\\0' ; assert ( cont <= ( c -> rcurr + c -> rbytes ) ) ; process_command ( c , c -> rcurr ) ; c -> rbytes -= ( cont - c -> rcurr ) ; c -> rcurr = cont ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; } return 1 ; }
Fixed code:","
static int try_read_command ( conn * c ) { assert ( c != NULL ) ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; assert ( c -> rbytes > 0 ) ; if ( c -> protocol == negotiating_prot || c -> transport == udp_transport ) { if ( ( unsigned char ) c -> rbuf [ 0 ] == ( unsigned char ) PROTOCOL_BINARY_REQ ) { c -> protocol = binary_prot ; } else { c -> protocol = ascii_prot ; } if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Client using the %s protocol\\n"" , c -> sfd , prot_text ( c -> protocol ) ) ; } } if ( c -> protocol == binary_prot ) { if ( c -> rbytes < sizeof ( c -> binary_header ) ) { return 0 ; } else { # ifdef NEED_ALIGN if ( ( ( long ) ( c -> rcurr ) ) % 8 != 0 ) { memmove ( c -> rbuf , c -> rcurr , c -> rbytes ) ; c -> rcurr = c -> rbuf ; if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Realign input buffer\\n"" , c -> sfd ) ; } } # endif protocol_binary_request_header * req ; req = ( protocol_binary_request_header * ) c -> rcurr ; if ( settings . verbose > 1 ) { int ii ; fprintf ( stderr , ""<%d Read binary protocol data:"" , c -> sfd ) ; for ( ii = 0 ; ii < sizeof ( req -> bytes ) ; ++ ii ) { if ( ii % 4 == 0 ) { fprintf ( stderr , ""\\n<%d   "" , c -> sfd ) ; } fprintf ( stderr , "" 0x%02x"" , req -> bytes [ ii ] ) ; } fprintf ( stderr , ""\\n"" ) ; } //Validate input data before proceeding if(!validate_input_data(req)) { conn_set_state ( c , conn_closing ) ; return - 1 ; } c -> binary_header = * req ; c -> binary_header . request . keylen = ntohs ( req -> request . keylen ) ; c -> binary_header . request . bodylen = ntohl ( req -> request . bodylen ) ; c -> binary_header . request . cas = ntohll ( req -> request . cas ) ; if ( c -> binary_header . request . magic != PROTOCOL_BINARY_REQ ) { if ( settings . verbose ) { fprintf ( stderr , ""Invalid magic:  %x\\n"" , c -> binary_header . request . magic ) ; } conn_set_state ( c , conn_closing ) ; return - 1 ; } c -> msgcurr = 0 ; c -> msgused = 0 ; c -> iovused = 0 ; if ( add_msghdr ( c ) != 0 ) { out_string ( c , ""SERVER_ERROR out of memory"" ) ; return 0 ; } c -> cmd = c -> binary_header . request . opcode ; c -> keylen = c -> binary_header . request . keylen ; c -> opaque = c -> binary_header . request . opaque ; c -> cas = 0 ; dispatch_bin_command ( c ) ; c -> rbytes -= sizeof ( c -> binary_header ) ; c -> rcurr += sizeof ( c -> binary_header ) ; } } else { char * el , * cont ; if ( c -> rbytes == 0 ) return 0 ; el = memchr ( c -> rcurr , '\\n' , c -> rbytes ) ; if ( ! el ) return 0 ; cont = el + 1 ; if ( ( el - c -> rcurr ) > 1 && * ( el - 1 ) == '\\r' ) { el -- ; } * el = '\\0' ; // Validate input data before proceeding if(!validate_input_data(c->rcurr)) { return -1; } assert ( cont <= ( c -> rcurr + c -> rbytes ) ) ; process_command ( c , c -> rcurr ) ; c -> rbytes -= ( cont - c -> rcurr ) ; c -> rcurr = cont ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize )",1000,-30.583689205269717,-0.03058368920526972
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int try_read_command ( conn * c ) { assert ( c != NULL ) ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; assert ( c -> rbytes > 0 ) ; if ( c -> protocol == negotiating_prot || c -> transport == udp_transport ) { if ( ( unsigned char ) c -> rbuf [ 0 ] == ( unsigned char ) PROTOCOL_BINARY_REQ ) { c -> protocol = binary_prot ; } else { c -> protocol = ascii_prot ; } if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Client using the %s protocol\\n"" , c -> sfd , prot_text ( c -> protocol ) ) ; } } if ( c -> protocol == binary_prot ) { if ( c -> rbytes < sizeof ( c -> binary_header ) ) { return 0 ; } else { # ifdef NEED_ALIGN if ( ( ( long ) ( c -> rcurr ) ) % 8 != 0 ) { memmove ( c -> rbuf , c -> rcurr , c -> rbytes ) ; c -> rcurr = c -> rbuf ; if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Realign input buffer\\n"" , c -> sfd ) ; } } # endif protocol_binary_request_header * req ; req = ( protocol_binary_request_header * ) c -> rcurr ; if ( settings . verbose > 1 ) { int ii ; fprintf ( stderr , ""<%d Read binary protocol data:"" , c -> sfd ) ; for ( ii = 0 ; ii < sizeof ( req -> bytes ) ; ++ ii ) { if ( ii % 4 == 0 ) { fprintf ( stderr , ""\\n<%d   "" , c -> sfd ) ; } fprintf ( stderr , "" 0x%02x"" , req -> bytes [ ii ] ) ; } fprintf ( stderr , ""\\n"" ) ; } c -> binary_header = * req ; c -> binary_header . request . keylen = ntohs ( req -> request . keylen ) ; c -> binary_header . request . bodylen = ntohl ( req -> request . bodylen ) ; c -> binary_header . request . cas = ntohll ( req -> request . cas ) ; if ( c -> binary_header . request . magic != PROTOCOL_BINARY_REQ ) { if ( settings . verbose ) { fprintf ( stderr , ""Invalid magic:  %x\\n"" , c -> binary_header . request . magic ) ; } conn_set_state ( c , conn_closing ) ; return - 1 ; } c -> msgcurr = 0 ; c -> msgused = 0 ; c -> iovused = 0 ; if ( add_msghdr ( c ) != 0 ) { out_string ( c , ""SERVER_ERROR out of memory"" ) ; return 0 ; } c -> cmd = c -> binary_header . request . opcode ; c -> keylen = c -> binary_header . request . keylen ; c -> opaque = c -> binary_header . request . opaque ; c -> cas = 0 ; dispatch_bin_command ( c ) ; c -> rbytes -= sizeof ( c -> binary_header ) ; c -> rcurr += sizeof ( c -> binary_header ) ; } } else { char * el , * cont ; if ( c -> rbytes == 0 ) return 0 ; el = memchr ( c -> rcurr , '\\n' , c -> rbytes ) ; if ( ! el ) return 0 ; cont = el + 1 ; if ( ( el - c -> rcurr ) > 1 && * ( el - 1 ) == '\\r' ) { el -- ; } * el = '\\0' ; assert ( cont <= ( c -> rcurr + c -> rbytes ) ) ; process_command ( c , c -> rcurr ) ; c -> rbytes -= ( cont - c -> rcurr ) ; c -> rcurr = cont ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; } return 1 ; }
Fixed code:","
static int try_read_command ( conn * c ) { assert ( c != NULL ) ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; assert ( c -> rbytes > 0 ) ; if ( c -> protocol == negotiating_prot || c -> transport == udp_transport ) { if ( ( unsigned char ) c -> rbuf [ 0 ] == ( unsigned char ) PROTOCOL_BINARY_REQ ) { c -> protocol = binary_prot ; } else { c -> protocol = ascii_prot ; } if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Client using the %s protocol\\n"" , c -> sfd , prot_text ( c -> protocol ) ) ; } } if ( c -> protocol == binary_prot ) { if ( c -> rbytes < sizeof ( c -> binary_header ) ) { return 0 ; } else { # ifdef NEED_ALIGN if ( ( ( long ) ( c -> rcurr ) ) % 8 != 0 ) { memmove ( c -> rbuf , c -> rcurr , c -> rbytes ) ; c -> rcurr = c -> rbuf ; if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Realign input buffer\\n"" , c -> sfd ) ; } } # endif protocol_binary_request_header * req ; req = ( protocol_binary_request_header * ) c -> rcurr ; if ( settings . verbose > 1 ) { int ii ; fprintf ( stderr , ""<%d Read binary protocol data:"" , c -> sfd ) ; for ( ii = 0 ; ii < sizeof ( req -> bytes ) ; ++ ii ) { if ( ii % 4 == 0 ) { fprintf ( stderr , ""\\n<%d   "" , c -> sfd ) ; } fprintf ( stderr , "" 0x%02x"" , req -> bytes [ ii ] ) ; } fprintf ( stderr , ""\\n"" ) ; } c -> binary_header = * req ; if ( c -> binary_header . request . magic != PROTOCOL_BINARY_REQ ) { if ( settings . verbose ) { fprintf ( stderr , ""Invalid magic:  %x\\n"" , c -> binary_header . request . magic ) ; } conn_set_state ( c , conn_closing ) ; return - 1 ; } c -> binary_header . request . keylen = ntohs ( req -> request . keylen ) ; c -> binary_header . request . bodylen = ntohl ( req -> request . bodylen ) ; c -> binary_header . request . cas = ntohll ( req -> request . cas ) ; if ( c -> binary_header . request . keylen + c -> binary_header . request . bodylen > c -> rbytes ) { /* Not enough bytes to read the full request */ return 0 ; } c -> msgcurr = 0 ; c -> msgused = 0 ; c -> iovused = 0 ; if ( add_msghdr ( c ) != 0 ) { out_string ( c , ""SERVER_ERROR out of memory"" ) ; return 0 ; } c -> cmd = c -> binary_header . request . opcode ; c -> keylen = c -> binary_header . request . keylen ; c -> opaque = c -> binary_header . request . opaque ; c -> cas = 0 ; dispatch_bin_command ( c ) ; c -> rbytes -= sizeof ( c -> binary_header ) ; c -> rcurr += sizeof ( c -> binary_header ) ; } } else { char * el , * cont ; if ( c -> rbytes == 0 ) return 0 ; el = memchr ( c -> rcurr , '\\n' , c -> rbytes ) ; if ( ! el ) return 0 ; cont = el + 1 ; if ( ( el - c -> rcurr ) > 1 && * ( el - 1 ) == '\\r' ) { el -- ; } * el = '\\0' ; assert ( cont <= ( c -> rcurr + c -> rbytes ) ) ; process_command ( c , c -> rcurr ) ; c -> rbytes -= ( cont - c -> rcurr ) ; c -> rcurr = cont ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; } return 1 ; }",983,-24.19747983062153,-0.024615950997580394
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int try_read_command ( conn * c ) { assert ( c != NULL ) ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; assert ( c -> rbytes > 0 ) ; if ( c -> protocol == negotiating_prot || c -> transport == udp_transport ) { if ( ( unsigned char ) c -> rbuf [ 0 ] == ( unsigned char ) PROTOCOL_BINARY_REQ ) { c -> protocol = binary_prot ; } else { c -> protocol = ascii_prot ; } if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Client using the %s protocol\\n"" , c -> sfd , prot_text ( c -> protocol ) ) ; } } if ( c -> protocol == binary_prot ) { if ( c -> rbytes < sizeof ( c -> binary_header ) ) { return 0 ; } else { # ifdef NEED_ALIGN if ( ( ( long ) ( c -> rcurr ) ) % 8 != 0 ) { memmove ( c -> rbuf , c -> rcurr , c -> rbytes ) ; c -> rcurr = c -> rbuf ; if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Realign input buffer\\n"" , c -> sfd ) ; } } # endif protocol_binary_request_header * req ; req = ( protocol_binary_request_header * ) c -> rcurr ; if ( settings . verbose > 1 ) { int ii ; fprintf ( stderr , ""<%d Read binary protocol data:"" , c -> sfd ) ; for ( ii = 0 ; ii < sizeof ( req -> bytes ) ; ++ ii ) { if ( ii % 4 == 0 ) { fprintf ( stderr , ""\\n<%d   "" , c -> sfd ) ; } fprintf ( stderr , "" 0x%02x"" , req -> bytes [ ii ] ) ; } fprintf ( stderr , ""\\n"" ) ; } c -> binary_header = * req ; c -> binary_header . request . keylen = ntohs ( req -> request . keylen ) ; c -> binary_header . request . bodylen = ntohl ( req -> request . bodylen ) ; c -> binary_header . request . cas = ntohll ( req -> request . cas ) ; if ( c -> binary_header . request . magic != PROTOCOL_BINARY_REQ ) { if ( settings . verbose ) { fprintf ( stderr , ""Invalid magic:  %x\\n"" , c -> binary_header . request . magic ) ; } conn_set_state ( c , conn_closing ) ; return - 1 ; } c -> msgcurr = 0 ; c -> msgused = 0 ; c -> iovused = 0 ; if ( add_msghdr ( c ) != 0 ) { out_string ( c , ""SERVER_ERROR out of memory"" ) ; return 0 ; } c -> cmd = c -> binary_header . request . opcode ; c -> keylen = c -> binary_header . request . keylen ; c -> opaque = c -> binary_header . request . opaque ; c -> cas = 0 ; dispatch_bin_command ( c ) ; c -> rbytes -= sizeof ( c -> binary_header ) ; c -> rcurr += sizeof ( c -> binary_header ) ; } } else { char * el , * cont ; if ( c -> rbytes == 0 ) return 0 ; el = memchr ( c -> rcurr , '\\n' , c -> rbytes ) ; if ( ! el ) return 0 ; cont = el + 1 ; if ( ( el - c -> rcurr ) > 1 && * ( el - 1 ) == '\\r' ) { el -- ; } * el = '\\0' ; assert ( cont <= ( c -> rcurr + c -> rbytes ) ) ; process_command ( c , c -> rcurr ) ; c -> rbytes -= ( cont - c -> rcurr ) ; c -> rcurr = cont ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; } return 1 ; }
Fixed code:","
static int try_read_command ( conn * c ) { assert ( c != NULL ) ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; assert ( c -> rbytes > 0 ) ; if ( c -> protocol == negotiating_prot || c -> transport == udp_transport ) { if ( ( unsigned char ) c -> rbuf [ 0 ] == ( unsigned char ) PROTOCOL_BINARY_REQ ) { c -> protocol = binary_prot ; } else { c -> protocol = ascii_prot ; } if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Client using the %s protocol\\n"" , c -> sfd , prot_text ( c -> protocol ) ) ; } } if ( c -> protocol == binary_prot ) { if ( c -> rbytes < sizeof ( c -> binary_header ) ) { return 0 ; } else { # ifdef NEED_ALIGN if ( ( ( long ) ( c -> rcurr ) ) % 8 != 0 ) { memmove ( c -> rbuf , c -> rcurr , c -> rbytes ) ; c -> rcurr = c -> rbuf ; if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Realign input buffer\\n"" , c -> sfd ) ; } } # endif protocol_binary_request_header * req ; req = ( protocol_binary_request_header * ) c -> rcurr ; // Validate binary header if ( c -> binary_header . request . magic != PROTOCOL_BINARY_REQ ) { if ( settings . verbose ) { fprintf ( stderr , ""Invalid magic:  %x\\n"" , c -> binary_header . request . magic ) ; } conn_set_state ( c , conn_closing ) ; return - 1 ; } if ( settings . verbose > 1 ) { int ii ; fprintf ( stderr , ""<%d Read binary protocol data:"" , c -> sfd ) ; for ( ii = 0 ; ii < sizeof ( req -> bytes ) ; ++ ii ) { if ( ii % 4 == 0 ) { fprintf ( stderr , ""\\n<%d   "" , c -> sfd ) ; } fprintf ( stderr , "" 0x%02x"" , req -> bytes [ ii ] ) ; } fprintf ( stderr , ""\\n"" ) ; } c -> binary_header = * req ; c -> binary_header . request . keylen = ntohs ( req -> request . keylen ) ; c -> binary_header . request . bodylen = ntohl ( req -> request . bodylen ) ; c -> binary_header . request . cas = ntohll ( req -> request . cas ) ; c -> msgcurr = 0 ; c -> msgused = 0 ; c -> iovused = 0 ; if ( add_msghdr ( c ) != 0 ) { out_string ( c , ""SERVER_ERROR out of memory"" ) ; return 0 ; } c -> cmd = c -> binary_header . request . opcode ; c -> keylen = c -> binary_header . request . keylen ; c -> opaque = c -> binary_header . request . opaque ; c -> cas = 0 ; dispatch_bin_command ( c ) ; c -> rbytes -= sizeof ( c -> binary_header ) ; c -> rcurr += sizeof ( c -> binary_header ) ; } } else { char * el , * cont ; if ( c -> rbytes == 0 ) return 0 ; el = memchr ( c -> rcurr , '\\n' , c -> rbytes ) ; if ( ! el ) return 0 ; cont = el + 1 ; if ( ( el - c -> rcurr ) > 1 && * ( el - 1 ) == '\\r' ) { el -- ; } * el = '\\0' ; assert ( cont <= ( c -> rcurr + c -> rbytes ) ) ; process_command ( c , c -> rcurr ) ; c -> rbytes -= ( cont - c -> rcurr ) ; c -> rcurr = cont ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; } return 1 ; }",944,-14.795856929400818,-0.015673577255721206
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int try_read_command ( conn * c ) { assert ( c != NULL ) ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; assert ( c -> rbytes > 0 ) ; if ( c -> protocol == negotiating_prot || c -> transport == udp_transport ) { if ( ( unsigned char ) c -> rbuf [ 0 ] == ( unsigned char ) PROTOCOL_BINARY_REQ ) { c -> protocol = binary_prot ; } else { c -> protocol = ascii_prot ; } if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Client using the %s protocol\\n"" , c -> sfd , prot_text ( c -> protocol ) ) ; } } if ( c -> protocol == binary_prot ) { if ( c -> rbytes < sizeof ( c -> binary_header ) ) { return 0 ; } else { # ifdef NEED_ALIGN if ( ( ( long ) ( c -> rcurr ) ) % 8 != 0 ) { memmove ( c -> rbuf , c -> rcurr , c -> rbytes ) ; c -> rcurr = c -> rbuf ; if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Realign input buffer\\n"" , c -> sfd ) ; } } # endif protocol_binary_request_header * req ; req = ( protocol_binary_request_header * ) c -> rcurr ; if ( settings . verbose > 1 ) { int ii ; fprintf ( stderr , ""<%d Read binary protocol data:"" , c -> sfd ) ; for ( ii = 0 ; ii < sizeof ( req -> bytes ) ; ++ ii ) { if ( ii % 4 == 0 ) { fprintf ( stderr , ""\\n<%d   "" , c -> sfd ) ; } fprintf ( stderr , "" 0x%02x"" , req -> bytes [ ii ] ) ; } fprintf ( stderr , ""\\n"" ) ; } c -> binary_header = * req ; c -> binary_header . request . keylen = ntohs ( req -> request . keylen ) ; c -> binary_header . request . bodylen = ntohl ( req -> request . bodylen ) ; c -> binary_header . request . cas = ntohll ( req -> request . cas ) ; if ( c -> binary_header . request . magic != PROTOCOL_BINARY_REQ ) { if ( settings . verbose ) { fprintf ( stderr , ""Invalid magic:  %x\\n"" , c -> binary_header . request . magic ) ; } conn_set_state ( c , conn_closing ) ; return - 1 ; } c -> msgcurr = 0 ; c -> msgused = 0 ; c -> iovused = 0 ; if ( add_msghdr ( c ) != 0 ) { out_string ( c , ""SERVER_ERROR out of memory"" ) ; return 0 ; } c -> cmd = c -> binary_header . request . opcode ; c -> keylen = c -> binary_header . request . keylen ; c -> opaque = c -> binary_header . request . opaque ; c -> cas = 0 ; dispatch_bin_command ( c ) ; c -> rbytes -= sizeof ( c -> binary_header ) ; c -> rcurr += sizeof ( c -> binary_header ) ; } } else { char * el , * cont ; if ( c -> rbytes == 0 ) return 0 ; el = memchr ( c -> rcurr , '\\n' , c -> rbytes ) ; if ( ! el ) return 0 ; cont = el + 1 ; if ( ( el - c -> rcurr ) > 1 && * ( el - 1 ) == '\\r' ) { el -- ; } * el = '\\0' ; assert ( cont <= ( c -> rcurr + c -> rbytes ) ) ; process_command ( c , c -> rcurr ) ; c -> rbytes -= ( cont - c -> rcurr ) ; c -> rcurr = cont ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; } return 1 ; }
Fixed code:"," 
static int try_read_command ( conn * c ) { assert ( c != NULL ) ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; assert ( c -> rbytes > 0 ) ; // Validate input data before processing it if (!validate_input(c->rbuf, c->rbytes)) { return 0; } if ( c -> protocol == negotiating_prot || c -> transport == udp_transport ) { if ( ( unsigned char ) c -> rbuf [ 0 ] == ( unsigned char ) PROTOCOL_BINARY_REQ ) { c -> protocol = binary_prot ; } else { c -> protocol = ascii_prot ; } if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Client using the %s protocol\\n"" , c -> sfd , prot_text ( c -> protocol ) ) ; } } if ( c -> protocol == binary_prot ) { if ( c -> rbytes < sizeof ( c -> binary_header ) ) { return 0 ; } else { # ifdef NEED_ALIGN if ( ( ( long ) ( c -> rcurr ) ) % 8 != 0 ) { memmove ( c -> rbuf , c -> rcurr , c -> rbytes ) ; c -> rcurr = c -> rbuf ; if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Realign input buffer\\n"" , c -> sfd ) ; } } # endif protocol_binary_request_header * req ; req = ( protocol_binary_request_header * ) c -> rcurr ; if ( settings . verbose > 1 ) { int ii ; fprintf ( stderr , ""<%d Read binary protocol data:"" , c -> sfd ) ; for ( ii = 0 ; ii < sizeof ( req -> bytes ) ; ++ ii ) { if ( ii % 4 == 0 ) { fprintf ( stderr , ""\\n<%d   "" , c -> sfd ) ; } fprintf ( stderr , "" 0x%02x"" , req -> bytes [ ii ] ) ; } fprintf ( stderr , ""\\n"" ) ; } c -> binary_header = * req ; c -> binary_header . request . keylen = ntohs ( req -> request . keylen ) ; c -> binary_header . request . bodylen = ntohl ( req -> request . bodylen ) ; c -> binary_header . request . cas = ntohll ( req -> request . cas ) ; if ( c -> binary_header . request . magic != PROTOCOL_BINARY_REQ ) { if ( settings . verbose ) { fprintf ( stderr , ""Invalid magic:  %x\\n"" , c -> binary_header . request . magic ) ; } conn_set_state ( c , conn_closing ) ; return - 1 ; } c -> msgcurr = 0 ; c -> msgused = 0 ; c -> iovused = 0 ; if ( add_msghdr ( c ) != 0 ) { out_string ( c , ""SERVER_ERROR out of memory"" ) ; return 0 ; } c -> cmd = c -> binary_header . request . opcode ; c -> keylen = c -> binary_header . request . keylen ; c -> opaque = c -> binary_header . request . opaque ; c -> cas = 0 ; dispatch_bin_command ( c ) ; c -> rbytes -= sizeof ( c -> binary_header ) ; c -> rcurr += sizeof ( c -> binary_header ) ; } } else { char * el , * cont ; if ( c -> rbytes == 0 ) return 0 ; el = memchr ( c -> rcurr , '\\n' , c -> rbytes ) ; if ( ! el ) return 0 ; cont = el + 1 ; if ( ( el - c -> rcurr ) > 1 && * ( el - 1 ) == '\\r' ) { el -- ; } * el = '\\0' ; assert ( cont <= ( c -> rcurr + c -> rbytes ) ) ; process_command ( c , c -> rcurr ) ; c -> rbytes -= ( cont - c -> rcurr ) ; c -> rcurr = cont ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; } return 1 ; }

// validate_input function
bool validate_input(char* input, size_t length) {
  for (size_t",1000,-34.565515207344546,-0.03456551520734455
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int try_read_command ( conn * c ) { assert ( c != NULL ) ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; assert ( c -> rbytes > 0 ) ; if ( c -> protocol == negotiating_prot || c -> transport == udp_transport ) { if ( ( unsigned char ) c -> rbuf [ 0 ] == ( unsigned char ) PROTOCOL_BINARY_REQ ) { c -> protocol = binary_prot ; } else { c -> protocol = ascii_prot ; } if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Client using the %s protocol\\n"" , c -> sfd , prot_text ( c -> protocol ) ) ; } } if ( c -> protocol == binary_prot ) { if ( c -> rbytes < sizeof ( c -> binary_header ) ) { return 0 ; } else { # ifdef NEED_ALIGN if ( ( ( long ) ( c -> rcurr ) ) % 8 != 0 ) { memmove ( c -> rbuf , c -> rcurr , c -> rbytes ) ; c -> rcurr = c -> rbuf ; if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Realign input buffer\\n"" , c -> sfd ) ; } } # endif protocol_binary_request_header * req ; req = ( protocol_binary_request_header * ) c -> rcurr ; if ( settings . verbose > 1 ) { int ii ; fprintf ( stderr , ""<%d Read binary protocol data:"" , c -> sfd ) ; for ( ii = 0 ; ii < sizeof ( req -> bytes ) ; ++ ii ) { if ( ii % 4 == 0 ) { fprintf ( stderr , ""\\n<%d   "" , c -> sfd ) ; } fprintf ( stderr , "" 0x%02x"" , req -> bytes [ ii ] ) ; } fprintf ( stderr , ""\\n"" ) ; } c -> binary_header = * req ; c -> binary_header . request . keylen = ntohs ( req -> request . keylen ) ; c -> binary_header . request . bodylen = ntohl ( req -> request . bodylen ) ; c -> binary_header . request . cas = ntohll ( req -> request . cas ) ; if ( c -> binary_header . request . magic != PROTOCOL_BINARY_REQ ) { if ( settings . verbose ) { fprintf ( stderr , ""Invalid magic:  %x\\n"" , c -> binary_header . request . magic ) ; } conn_set_state ( c , conn_closing ) ; return - 1 ; } c -> msgcurr = 0 ; c -> msgused = 0 ; c -> iovused = 0 ; if ( add_msghdr ( c ) != 0 ) { out_string ( c , ""SERVER_ERROR out of memory"" ) ; return 0 ; } c -> cmd = c -> binary_header . request . opcode ; c -> keylen = c -> binary_header . request . keylen ; c -> opaque = c -> binary_header . request . opaque ; c -> cas = 0 ; dispatch_bin_command ( c ) ; c -> rbytes -= sizeof ( c -> binary_header ) ; c -> rcurr += sizeof ( c -> binary_header ) ; } } else { char * el , * cont ; if ( c -> rbytes == 0 ) return 0 ; el = memchr ( c -> rcurr , '\\n' , c -> rbytes ) ; if ( ! el ) return 0 ; cont = el + 1 ; if ( ( el - c -> rcurr ) > 1 && * ( el - 1 ) == '\\r' ) { el -- ; } * el = '\\0' ; assert ( cont <= ( c -> rcurr + c -> rbytes ) ) ; process_command ( c , c -> rcurr ) ; c -> rbytes -= ( cont - c -> rcurr ) ; c -> rcurr = cont ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; } return 1 ; }
Fixed code:","

static int try_read_command ( conn * c ) { assert ( c != NULL ) ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; assert ( c -> rbytes > 0 ) ; if ( c -> protocol == negotiating_prot || c -> transport == udp_transport ) { if ( ( unsigned char ) c -> rbuf [ 0 ] == ( unsigned char ) PROTOCOL_BINARY_REQ ) { c -> protocol = binary_prot ; } else { c -> protocol = ascii_prot ; } if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Client using the %s protocol\\n"" , c -> sfd , prot_text ( c -> protocol ) ) ; } } if ( c -> protocol == binary_prot ) { if ( c -> rbytes < sizeof ( c -> binary_header ) ) { return 0 ; } else { # ifdef NEED_ALIGN if ( ( ( long ) ( c -> rcurr ) ) % 8 != 0 ) { memmove ( c -> rbuf , c -> rcurr , c -> rbytes ) ; c -> rcurr = c -> rbuf ; if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Realign input buffer\\n"" , c -> sfd ) ; } } # endif protocol_binary_request_header * req ; req = ( protocol_binary_request_header * ) c -> rcurr ; if ( settings . verbose > 1 ) { int ii ; fprintf ( stderr , ""<%d Read binary protocol data:"" , c -> sfd ) ; for ( ii = 0 ; ii < sizeof ( req -> bytes ) ; ++ ii ) { if ( ii % 4 == 0 ) { fprintf ( stderr , ""\\n<%d   "" , c -> sfd ) ; } fprintf ( stderr , "" 0x%02x"" , req -> bytes [ ii ] ) ; } fprintf ( stderr , ""\\n"" ) ; } c -> binary_header = * req ; c -> binary_header . request . keylen = ntohs ( req -> request . keylen ) ; c -> binary_header . request . bodylen = ntohl ( req -> request . bodylen ) ; c -> binary_header . request . cas = ntohll ( req -> request . cas ) ; //Validate that the magic is valid before setting the command if ( c -> binary_header . request . magic == PROTOCOL_BINARY_REQ ) { c -> cmd = c -> binary_header . request . opcode ; } else { if ( settings . verbose ) { fprintf ( stderr , ""Invalid magic:  %x\\n"" , c -> binary_header . request . magic ) ; } conn_set_state ( c , conn_closing ) ; return - 1 ; } c -> msgcurr = 0 ; c -> msgused = 0 ; c -> iovused = 0 ; if ( add_msghdr ( c ) != 0 ) { out_string ( c , ""SERVER_ERROR out of memory"" ) ; return 0 ; }  c -> keylen = c -> binary_header . request . keylen ; c -> opaque = c -> binary_header . request . opaque ; c -> cas = 0 ; dispatch_bin_command ( c ) ; c -> rbytes -= sizeof ( c -> binary_header ) ; c -> rcurr += sizeof ( c -> binary_header ) ; } } else { char * el , * cont ; if ( c -> rbytes == 0 ) return 0 ; el = memchr ( c -> rcurr , '\\n' , c -> rbytes ) ; if ( ! el ) return 0 ; cont = el + 1 ; if ( ( el - c -> rcurr ) > 1 && * ( el - 1 ) == '\\r' ) { el -- ; } * el = '\\0' ; assert ( cont <= ( c -> rcurr + c -> rbytes ) ) ; process_command ( c , c -> rcurr ) ; c -> rbytes -= ( cont - c -> rcurr ) ; c -> rcurr = cont ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; } return 1 ; }",956,-30.42446687947322,-0.031824756150076586
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int try_read_command ( conn * c ) { assert ( c != NULL ) ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; assert ( c -> rbytes > 0 ) ; if ( c -> protocol == negotiating_prot || c -> transport == udp_transport ) { if ( ( unsigned char ) c -> rbuf [ 0 ] == ( unsigned char ) PROTOCOL_BINARY_REQ ) { c -> protocol = binary_prot ; } else { c -> protocol = ascii_prot ; } if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Client using the %s protocol\\n"" , c -> sfd , prot_text ( c -> protocol ) ) ; } } if ( c -> protocol == binary_prot ) { if ( c -> rbytes < sizeof ( c -> binary_header ) ) { return 0 ; } else { # ifdef NEED_ALIGN if ( ( ( long ) ( c -> rcurr ) ) % 8 != 0 ) { memmove ( c -> rbuf , c -> rcurr , c -> rbytes ) ; c -> rcurr = c -> rbuf ; if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Realign input buffer\\n"" , c -> sfd ) ; } } # endif protocol_binary_request_header * req ; req = ( protocol_binary_request_header * ) c -> rcurr ; if ( settings . verbose > 1 ) { int ii ; fprintf ( stderr , ""<%d Read binary protocol data:"" , c -> sfd ) ; for ( ii = 0 ; ii < sizeof ( req -> bytes ) ; ++ ii ) { if ( ii % 4 == 0 ) { fprintf ( stderr , ""\\n<%d   "" , c -> sfd ) ; } fprintf ( stderr , "" 0x%02x"" , req -> bytes [ ii ] ) ; } fprintf ( stderr , ""\\n"" ) ; } c -> binary_header = * req ; c -> binary_header . request . keylen = ntohs ( req -> request . keylen ) ; c -> binary_header . request . bodylen = ntohl ( req -> request . bodylen ) ; c -> binary_header . request . cas = ntohll ( req -> request . cas ) ; if ( c -> binary_header . request . magic != PROTOCOL_BINARY_REQ ) { if ( settings . verbose ) { fprintf ( stderr , ""Invalid magic:  %x\\n"" , c -> binary_header . request . magic ) ; } conn_set_state ( c , conn_closing ) ; return - 1 ; } c -> msgcurr = 0 ; c -> msgused = 0 ; c -> iovused = 0 ; if ( add_msghdr ( c ) != 0 ) { out_string ( c , ""SERVER_ERROR out of memory"" ) ; return 0 ; } c -> cmd = c -> binary_header . request . opcode ; c -> keylen = c -> binary_header . request . keylen ; c -> opaque = c -> binary_header . request . opaque ; c -> cas = 0 ; dispatch_bin_command ( c ) ; c -> rbytes -= sizeof ( c -> binary_header ) ; c -> rcurr += sizeof ( c -> binary_header ) ; } } else { char * el , * cont ; if ( c -> rbytes == 0 ) return 0 ; el = memchr ( c -> rcurr , '\\n' , c -> rbytes ) ; if ( ! el ) return 0 ; cont = el + 1 ; if ( ( el - c -> rcurr ) > 1 && * ( el - 1 ) == '\\r' ) { el -- ; } * el = '\\0' ; assert ( cont <= ( c -> rcurr + c -> rbytes ) ) ; process_command ( c , c -> rcurr ) ; c -> rbytes -= ( cont - c -> rcurr ) ; c -> rcurr = cont ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; } return 1 ; }
Fixed code:","
static int try_read_command ( conn * c ) { assert ( c != NULL ) ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; assert ( c -> rbytes > 0 ) ; if ( c -> protocol == negotiating_prot || c -> transport == udp_transport ) { if ( ( unsigned char ) c -> rbuf [ 0 ] == ( unsigned char ) PROTOCOL_BINARY_REQ ) { c -> protocol = binary_prot ; } else { c -> protocol = ascii_prot ; } if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Client using the %s protocol\\n"" , c -> sfd , prot_text ( c -> protocol ) ) ; } } if ( c -> protocol == binary_prot ) { if ( c -> rbytes < sizeof ( c -> binary_header ) ) { return 0 ; } else {  # ifdef NEED_ALIGN if ( ( ( long ) ( c -> rcurr ) ) % 8 != 0 ) { memmove ( c -> rbuf , c -> rcurr , c -> rbytes ) ; c -> rcurr = c -> rbuf ; if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Realign input buffer\\n"" , c -> sfd ) ; } } # endif protocol_binary_request_header * req ; req = ( protocol_binary_request_header * ) c -> rcurr ; //validate the request header is not malformatted before proceeding if (!validate_request(req)) { conn_set_state ( c , conn_closing ) ; return - 1 ; } if ( settings . verbose > 1 ) { int ii ; fprintf ( stderr , ""<%d Read binary protocol data:"" , c -> sfd ) ; for ( ii = 0 ; ii < sizeof ( req -> bytes ) ; ++ ii ) { if ( ii % 4 == 0 ) { fprintf ( stderr , ""\\n<%d   "" , c -> sfd ) ; } fprintf ( stderr , "" 0x%02x"" , req -> bytes [ ii ] ) ; } fprintf ( stderr , ""\\n"" ) ; } c -> binary_header = * req ; c -> binary_header . request . keylen = ntohs ( req -> request . keylen ) ; c -> binary_header . request . bodylen = ntohl ( req -> request . bodylen ) ; c -> binary_header . request . cas = ntohll ( req -> request . cas ) ; if ( c -> binary_header . request . magic != PROTOCOL_BINARY_REQ ) { if ( settings . verbose ) { fprintf ( stderr , ""Invalid magic:  %x\\n"" , c -> binary_header . request . magic ) ; } conn_set_state ( c , conn_closing ) ; return - 1 ; } c -> msgcurr = 0 ; c -> msgused = 0 ; c -> iovused = 0 ; if ( add_msghdr ( c ) != 0 ) { out_string ( c , ""SERVER_ERROR out of memory"" ) ; return 0 ; } c -> cmd = c -> binary_header . request . opcode ; c -> keylen = c -> binary_header . request . keylen ; c -> opaque = c -> binary_header . request . opaque ; c -> cas = 0 ; dispatch_bin_command ( c ) ; c -> rbytes -= sizeof ( c -> binary_header ) ; c -> rcurr += sizeof ( c -> binary_header ) ; } } else { char * el , * cont ; if ( c -> rbytes == 0 ) return 0 ; el = memchr ( c -> rcurr , '\\n' , c -> rbytes ) ; if ( ! el ) return 0 ; cont = el + 1 ; if ( ( el - c -> rcurr ) > 1 && * ( el - 1 ) == '\\r' ) { el -- ; } //validate the ASCII command is not malformatted before proceeding if (!validate_ascii_command(c -> rcurr)) { return 0; } * el = '\\0' ; assert ( cont <= ( c -> rcurr + c -> rbytes ) ) ; process_command ( c , c -> rcurr ) ; c -> rbytes -= ( cont - c -> rcurr ) ; c -> rcurr = cont ; assert ( c -> rcurr <= (",1000,-59.047495749877605,-0.0590474957498776
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int try_read_command ( conn * c ) { assert ( c != NULL ) ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; assert ( c -> rbytes > 0 ) ; if ( c -> protocol == negotiating_prot || c -> transport == udp_transport ) { if ( ( unsigned char ) c -> rbuf [ 0 ] == ( unsigned char ) PROTOCOL_BINARY_REQ ) { c -> protocol = binary_prot ; } else { c -> protocol = ascii_prot ; } if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Client using the %s protocol\\n"" , c -> sfd , prot_text ( c -> protocol ) ) ; } } if ( c -> protocol == binary_prot ) { if ( c -> rbytes < sizeof ( c -> binary_header ) ) { return 0 ; } else { # ifdef NEED_ALIGN if ( ( ( long ) ( c -> rcurr ) ) % 8 != 0 ) { memmove ( c -> rbuf , c -> rcurr , c -> rbytes ) ; c -> rcurr = c -> rbuf ; if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Realign input buffer\\n"" , c -> sfd ) ; } } # endif protocol_binary_request_header * req ; req = ( protocol_binary_request_header * ) c -> rcurr ; if ( settings . verbose > 1 ) { int ii ; fprintf ( stderr , ""<%d Read binary protocol data:"" , c -> sfd ) ; for ( ii = 0 ; ii < sizeof ( req -> bytes ) ; ++ ii ) { if ( ii % 4 == 0 ) { fprintf ( stderr , ""\\n<%d   "" , c -> sfd ) ; } fprintf ( stderr , "" 0x%02x"" , req -> bytes [ ii ] ) ; } fprintf ( stderr , ""\\n"" ) ; } c -> binary_header = * req ; c -> binary_header . request . keylen = ntohs ( req -> request . keylen ) ; c -> binary_header . request . bodylen = ntohl ( req -> request . bodylen ) ; c -> binary_header . request . cas = ntohll ( req -> request . cas ) ; if ( c -> binary_header . request . magic != PROTOCOL_BINARY_REQ ) { if ( settings . verbose ) { fprintf ( stderr , ""Invalid magic:  %x\\n"" , c -> binary_header . request . magic ) ; } conn_set_state ( c , conn_closing ) ; return - 1 ; } c -> msgcurr = 0 ; c -> msgused = 0 ; c -> iovused = 0 ; if ( add_msghdr ( c ) != 0 ) { out_string ( c , ""SERVER_ERROR out of memory"" ) ; return 0 ; } c -> cmd = c -> binary_header . request . opcode ; c -> keylen = c -> binary_header . request . keylen ; c -> opaque = c -> binary_header . request . opaque ; c -> cas = 0 ; dispatch_bin_command ( c ) ; c -> rbytes -= sizeof ( c -> binary_header ) ; c -> rcurr += sizeof ( c -> binary_header ) ; } } else { char * el , * cont ; if ( c -> rbytes == 0 ) return 0 ; el = memchr ( c -> rcurr , '\\n' , c -> rbytes ) ; if ( ! el ) return 0 ; cont = el + 1 ; if ( ( el - c -> rcurr ) > 1 && * ( el - 1 ) == '\\r' ) { el -- ; } * el = '\\0' ; assert ( cont <= ( c -> rcurr + c -> rbytes ) ) ; process_command ( c , c -> rcurr ) ; c -> rbytes -= ( cont - c -> rcurr ) ; c -> rcurr = cont ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; } return 1 ; }
Fixed code:","
static int try_read_command ( conn * c ) { assert ( c != NULL ) ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; assert ( c -> rbytes > 0 ) ; if ( c -> protocol == negotiating_prot || c -> transport == udp_transport ) { if ( ( unsigned char ) c -> rbuf [ 0 ] == ( unsigned char ) PROTOCOL_BINARY_REQ ) { c -> protocol = binary_prot ; } else { c -> protocol = ascii_prot ; } if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Client using the %s protocol\\n"" , c -> sfd , prot_text ( c -> protocol ) ) ; } } if ( c -> protocol == binary_prot ) { if ( c -> rbytes < sizeof ( c -> binary_header ) ) { return 0 ; } else { # ifdef NEED_ALIGN if ( ( ( long ) ( c -> rcurr ) ) % 8 != 0 ) { memmove ( c -> rbuf , c -> rcurr , c -> rbytes ) ; c -> rcurr = c -> rbuf ; if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Realign input buffer\\n"" , c -> sfd ) ; } } # endif protocol_binary_request_header * req ; req = ( protocol_binary_request_header * ) c -> rcurr ; if ( settings . verbose > 1 ) { int ii ; fprintf ( stderr , ""<%d Read binary protocol data:"" , c -> sfd ) ; for ( ii = 0 ; ii < sizeof ( req -> bytes ) ; ++ ii ) { if ( ii % 4 == 0 ) { fprintf ( stderr , ""\\n<%d   "" , c -> sfd ) ; } fprintf ( stderr , "" 0x%02x"" , req -> bytes [ ii ] ) ; } fprintf ( stderr , ""\\n"" ) ; } c -> binary_header = * req ; if ( req -> request . magic != PROTOCOL_BINARY_REQ ) { if ( settings . verbose ) { fprintf ( stderr , ""Invalid magic:  %x\\n"" , c -> binary_header . request . magic ) ; } conn_set_state ( c , conn_closing ) ; return - 1 ; } c -> binary_header . request . keylen = ntohs ( req -> request . keylen ) ; c -> binary_header . request . bodylen = ntohl ( req -> request . bodylen ) ; c -> binary_header . request . cas = ntohll ( req -> request . cas ) ; c -> msgcurr = 0 ; c -> msgused = 0 ; c -> iovused = 0 ; if ( add_msghdr ( c ) != 0 ) { out_string ( c , ""SERVER_ERROR out of memory"" ) ; return 0 ; } c -> cmd = c -> binary_header . request . opcode ; c -> keylen = c -> binary_header . request . keylen ; c -> opaque = c -> binary_header . request . opaque ; c -> cas = 0 ; dispatch_bin_command ( c ) ; c -> rbytes -= sizeof ( c -> binary_header ) ; c -> rcurr += sizeof ( c -> binary_header ) ; } } else { char * el , * cont ; if ( c -> rbytes == 0 ) return 0 ; el = memchr ( c -> rcurr , '\\n' , c -> rbytes ) ; if ( ! el ) return 0 ; cont = el + 1 ; if ( ( el - c -> rcurr ) > 1 && * ( el - 1 ) == '\\r' ) { el -- ; } * el = '\\0' ; assert ( cont <= ( c -> rcurr + c -> rbytes ) ) ; process_command ( c , c -> rcurr ) ; c -> rbytes -= ( cont - c -> rcurr ) ; c -> rcurr = cont ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; } return 1 ; }",935,-10.018284792914054,-0.010714743094025727
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int try_read_command ( conn * c ) { assert ( c != NULL ) ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; assert ( c -> rbytes > 0 ) ; if ( c -> protocol == negotiating_prot || c -> transport == udp_transport ) { if ( ( unsigned char ) c -> rbuf [ 0 ] == ( unsigned char ) PROTOCOL_BINARY_REQ ) { c -> protocol = binary_prot ; } else { c -> protocol = ascii_prot ; } if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Client using the %s protocol\\n"" , c -> sfd , prot_text ( c -> protocol ) ) ; } } if ( c -> protocol == binary_prot ) { if ( c -> rbytes < sizeof ( c -> binary_header ) ) { return 0 ; } else { # ifdef NEED_ALIGN if ( ( ( long ) ( c -> rcurr ) ) % 8 != 0 ) { memmove ( c -> rbuf , c -> rcurr , c -> rbytes ) ; c -> rcurr = c -> rbuf ; if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Realign input buffer\\n"" , c -> sfd ) ; } } # endif protocol_binary_request_header * req ; req = ( protocol_binary_request_header * ) c -> rcurr ; if ( settings . verbose > 1 ) { int ii ; fprintf ( stderr , ""<%d Read binary protocol data:"" , c -> sfd ) ; for ( ii = 0 ; ii < sizeof ( req -> bytes ) ; ++ ii ) { if ( ii % 4 == 0 ) { fprintf ( stderr , ""\\n<%d   "" , c -> sfd ) ; } fprintf ( stderr , "" 0x%02x"" , req -> bytes [ ii ] ) ; } fprintf ( stderr , ""\\n"" ) ; } c -> binary_header = * req ; c -> binary_header . request . keylen = ntohs ( req -> request . keylen ) ; c -> binary_header . request . bodylen = ntohl ( req -> request . bodylen ) ; c -> binary_header . request . cas = ntohll ( req -> request . cas ) ; if ( c -> binary_header . request . magic != PROTOCOL_BINARY_REQ ) { if ( settings . verbose ) { fprintf ( stderr , ""Invalid magic:  %x\\n"" , c -> binary_header . request . magic ) ; } conn_set_state ( c , conn_closing ) ; return - 1 ; } c -> msgcurr = 0 ; c -> msgused = 0 ; c -> iovused = 0 ; if ( add_msghdr ( c ) != 0 ) { out_string ( c , ""SERVER_ERROR out of memory"" ) ; return 0 ; } c -> cmd = c -> binary_header . request . opcode ; c -> keylen = c -> binary_header . request . keylen ; c -> opaque = c -> binary_header . request . opaque ; c -> cas = 0 ; dispatch_bin_command ( c ) ; c -> rbytes -= sizeof ( c -> binary_header ) ; c -> rcurr += sizeof ( c -> binary_header ) ; } } else { char * el , * cont ; if ( c -> rbytes == 0 ) return 0 ; el = memchr ( c -> rcurr , '\\n' , c -> rbytes ) ; if ( ! el ) return 0 ; cont = el + 1 ; if ( ( el - c -> rcurr ) > 1 && * ( el - 1 ) == '\\r' ) { el -- ; } * el = '\\0' ; assert ( cont <= ( c -> rcurr + c -> rbytes ) ) ; process_command ( c , c -> rcurr ) ; c -> rbytes -= ( cont - c -> rcurr ) ; c -> rcurr = cont ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; } return 1 ; }
Fixed code:","
static int try_read_command ( conn * c ) { assert ( c != NULL ) ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; assert ( c -> rbytes > 0 ) ; if ( c -> protocol == negotiating_prot || c -> transport == udp_transport ) { if ( ( unsigned char ) c -> rbuf [ 0 ] == ( unsigned char ) PROTOCOL_BINARY_REQ ) { c -> protocol = binary_prot ; } else if ( isprint((unsigned char) c->rbuf[0]) ) { // Validate input c->protocol = ascii_prot ; } else { // Reject invalid input conn_set_state ( c , conn_closing ) ; return - 1 ; } if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Client using the %s protocol\\n"" , c -> sfd , prot_text ( c -> protocol ) ) ; } } if ( c -> protocol == binary_prot ) { if ( c -> rbytes < sizeof ( c -> binary_header ) ) { return 0 ; } else { # ifdef NEED_ALIGN if ( ( ( long ) ( c -> rcurr ) ) % 8 != 0 ) { memmove ( c -> rbuf , c -> rcurr , c -> rbytes ) ; c -> rcurr = c -> rbuf ; if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Realign input buffer\\n"" , c -> sfd ) ; } } # endif protocol_binary_request_header * req ; req = ( protocol_binary_request_header * ) c -> rcurr ; if ( settings . verbose > 1 ) { int ii ; fprintf ( stderr , ""<%d Read binary protocol data:"" , c -> sfd ) ; for ( ii = 0 ; ii < sizeof ( req -> bytes ) ; ++ ii ) { if ( ii % 4 == 0 ) { fprintf ( stderr , ""\\n<%d   "" , c -> sfd ) ; } fprintf ( stderr , "" 0x%02x"" , req -> bytes [ ii ] ) ; } fprintf ( stderr , ""\\n"" ) ; } c -> binary_header = * req ; c -> binary_header . request . keylen = ntohs ( req -> request . keylen ) ; c -> binary_header . request . bodylen = ntohl ( req -> request . bodylen ) ; c -> binary_header . request . cas = ntohll ( req -> request . cas ) ; if ( c -> binary_header . request . magic != PROTOCOL_BINARY_REQ ) { if ( settings . verbose ) { fprintf ( stderr , ""Invalid magic:  %x\\n"" , c -> binary_header . request . magic ) ; } conn_set_state ( c , conn_closing ) ; return - 1 ; } c -> msgcurr = 0 ; c -> msgused = 0 ; c -> iovused = 0 ; if ( add_msghdr ( c ) != 0 ) { out_string ( c , ""SERVER_ERROR out of memory"" ) ; return 0 ; } c -> cmd = c -> binary_header . request . opcode ; c -> keylen = c -> binary_header . request . keylen ; c -> opaque = c -> binary_header . request . opaque ; c -> cas = 0 ; dispatch_bin_command ( c ) ; c -> rbytes -= sizeof ( c -> binary_header ) ; c -> rcurr += sizeof ( c -> binary_header ) ; } } else { char * el , * cont ; if ( c -> rbytes == 0 ) return 0 ; el = memchr ( c -> rcurr , '\\n' , c -> rbytes ) ; if ( ! el ) return 0 ; cont = el + 1 ; if ( ( el - c -> rcurr ) > 1 && * ( el - 1 ) == '\\r' ) { el -- ; } * el = '\\0' ; assert ( cont <= ( c -> rcurr + c -> rbytes ) ) ; if ( isprint ( ( unsigned char ) c -> rcurr [ 0 ] ) ) { // Validate input process_command ( c , c -> rcurr ) ; } else { // Reject invalid input conn_set_state ( c , conn_closing ) ; return - 1 ; } c -> rbytes -= ( cont - c -> rcur",1000,-27.92181355693621,-0.027921813556936213
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int try_read_command ( conn * c ) { assert ( c != NULL ) ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; assert ( c -> rbytes > 0 ) ; if ( c -> protocol == negotiating_prot || c -> transport == udp_transport ) { if ( ( unsigned char ) c -> rbuf [ 0 ] == ( unsigned char ) PROTOCOL_BINARY_REQ ) { c -> protocol = binary_prot ; } else { c -> protocol = ascii_prot ; } if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Client using the %s protocol\\n"" , c -> sfd , prot_text ( c -> protocol ) ) ; } } if ( c -> protocol == binary_prot ) { if ( c -> rbytes < sizeof ( c -> binary_header ) ) { return 0 ; } else { # ifdef NEED_ALIGN if ( ( ( long ) ( c -> rcurr ) ) % 8 != 0 ) { memmove ( c -> rbuf , c -> rcurr , c -> rbytes ) ; c -> rcurr = c -> rbuf ; if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Realign input buffer\\n"" , c -> sfd ) ; } } # endif protocol_binary_request_header * req ; req = ( protocol_binary_request_header * ) c -> rcurr ; if ( settings . verbose > 1 ) { int ii ; fprintf ( stderr , ""<%d Read binary protocol data:"" , c -> sfd ) ; for ( ii = 0 ; ii < sizeof ( req -> bytes ) ; ++ ii ) { if ( ii % 4 == 0 ) { fprintf ( stderr , ""\\n<%d   "" , c -> sfd ) ; } fprintf ( stderr , "" 0x%02x"" , req -> bytes [ ii ] ) ; } fprintf ( stderr , ""\\n"" ) ; } c -> binary_header = * req ; c -> binary_header . request . keylen = ntohs ( req -> request . keylen ) ; c -> binary_header . request . bodylen = ntohl ( req -> request . bodylen ) ; c -> binary_header . request . cas = ntohll ( req -> request . cas ) ; if ( c -> binary_header . request . magic != PROTOCOL_BINARY_REQ ) { if ( settings . verbose ) { fprintf ( stderr , ""Invalid magic:  %x\\n"" , c -> binary_header . request . magic ) ; } conn_set_state ( c , conn_closing ) ; return - 1 ; } c -> msgcurr = 0 ; c -> msgused = 0 ; c -> iovused = 0 ; if ( add_msghdr ( c ) != 0 ) { out_string ( c , ""SERVER_ERROR out of memory"" ) ; return 0 ; } c -> cmd = c -> binary_header . request . opcode ; c -> keylen = c -> binary_header . request . keylen ; c -> opaque = c -> binary_header . request . opaque ; c -> cas = 0 ; dispatch_bin_command ( c ) ; c -> rbytes -= sizeof ( c -> binary_header ) ; c -> rcurr += sizeof ( c -> binary_header ) ; } } else { char * el , * cont ; if ( c -> rbytes == 0 ) return 0 ; el = memchr ( c -> rcurr , '\\n' , c -> rbytes ) ; if ( ! el ) return 0 ; cont = el + 1 ; if ( ( el - c -> rcurr ) > 1 && * ( el - 1 ) == '\\r' ) { el -- ; } * el = '\\0' ; assert ( cont <= ( c -> rcurr + c -> rbytes ) ) ; process_command ( c , c -> rcurr ) ; c -> rbytes -= ( cont - c -> rcurr ) ; c -> rcurr = cont ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; } return 1 ; }
Fixed code:","

static int try_read_command ( conn * c ) { assert ( c != NULL ) ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; assert ( c -> rbytes > 0 ) ; if ( c -> protocol == negotiating_prot || c -> transport == udp_transport ) { if ( ( unsigned char ) c -> rbuf [ 0 ] == ( unsigned char ) PROTOCOL_BINARY_REQ ) { c -> protocol = binary_prot ; } else { c -> protocol = ascii_prot ; } if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Client using the %s protocol\\n"" , c -> sfd , prot_text ( c -> protocol ) ) ; } } if ( c -> protocol == binary_prot ) { if ( c -> rbytes < sizeof ( c -> binary_header ) ) { return 0 ; } else { # ifdef NEED_ALIGN if ( ( ( long ) ( c -> rcurr ) ) % 8 != 0 ) { memmove ( c -> rbuf , c -> rcurr , c -> rbytes ) ; c -> rcurr = c -> rbuf ; if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Realign input buffer\\n"" , c -> sfd ) ; } } # endif protocol_binary_request_header * req ; req = ( protocol_binary_request_header * ) c -> rcurr ; if ( settings . verbose > 1 ) { int ii ; fprintf ( stderr , ""<%d Read binary protocol data:"" , c -> sfd ) ; for ( ii = 0 ; ii < sizeof ( req -> bytes ) ; ++ ii ) { if ( ii % 4 == 0 ) { fprintf ( stderr , ""\\n<%d   "" , c -> sfd ) ; } fprintf ( stderr , "" 0x%02x"" , req -> bytes [ ii ] ) ; } fprintf ( stderr , ""\\n"" ) ; } if (c->rbytes > sizeof(c->binary_header)) { c -> binary_header = * req ; c -> binary_header . request . keylen = ntohs ( req -> request . keylen ) ; c -> binary_header . request . bodylen = ntohl ( req -> request . bodylen ) ; c -> binary_header . request . cas = ntohll ( req -> request . cas ) ; } else { return 0; } if ( c -> binary_header . request . magic != PROTOCOL_BINARY_REQ ) { if ( settings . verbose ) { fprintf ( stderr , ""Invalid magic:  %x\\n"" , c -> binary_header . request . magic ) ; } conn_set_state ( c , conn_closing ) ; return - 1 ; } c -> msgcurr = 0 ; c -> msgused = 0 ; c -> iovused = 0 ; if ( add_msghdr ( c ) != 0 ) { out_string ( c , ""SERVER_ERROR out of memory"" ) ; return 0 ; } c -> cmd = c -> binary_header . request . opcode ; c -> keylen = c -> binary_header . request . keylen ; c -> opaque = c -> binary_header . request . opaque ; c -> cas = 0 ; dispatch_bin_command ( c ) ; c -> rbytes -= sizeof ( c -> binary_header ) ; c -> rcurr += sizeof ( c -> binary_header ) ; } } else { char * el , * cont ; if ( c -> rbytes == 0 ) return 0 ; el = memchr ( c -> rcurr , '\\n' , c -> rbytes ) ; if ( ! el ) return 0 ; cont = el + 1 ; if ( ( el - c -> rcurr ) > 1 && * ( el - 1 ) == '\\r' ) { el -- ; } * el = '\\0' ; assert ( cont <= ( c -> rcurr + c -> rbytes ) ) ; process_command ( c , c -> rcurr ) ; c -> rbytes -= ( cont - c -> rcurr ) ; c -> rcurr = cont ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; } return 1 ; }",963,-19.714630691402235,-0.020472098329597337
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int try_read_command ( conn * c ) { assert ( c != NULL ) ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; assert ( c -> rbytes > 0 ) ; if ( c -> protocol == negotiating_prot || c -> transport == udp_transport ) { if ( ( unsigned char ) c -> rbuf [ 0 ] == ( unsigned char ) PROTOCOL_BINARY_REQ ) { c -> protocol = binary_prot ; } else { c -> protocol = ascii_prot ; } if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Client using the %s protocol\\n"" , c -> sfd , prot_text ( c -> protocol ) ) ; } } if ( c -> protocol == binary_prot ) { if ( c -> rbytes < sizeof ( c -> binary_header ) ) { return 0 ; } else { # ifdef NEED_ALIGN if ( ( ( long ) ( c -> rcurr ) ) % 8 != 0 ) { memmove ( c -> rbuf , c -> rcurr , c -> rbytes ) ; c -> rcurr = c -> rbuf ; if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Realign input buffer\\n"" , c -> sfd ) ; } } # endif protocol_binary_request_header * req ; req = ( protocol_binary_request_header * ) c -> rcurr ; if ( settings . verbose > 1 ) { int ii ; fprintf ( stderr , ""<%d Read binary protocol data:"" , c -> sfd ) ; for ( ii = 0 ; ii < sizeof ( req -> bytes ) ; ++ ii ) { if ( ii % 4 == 0 ) { fprintf ( stderr , ""\\n<%d   "" , c -> sfd ) ; } fprintf ( stderr , "" 0x%02x"" , req -> bytes [ ii ] ) ; } fprintf ( stderr , ""\\n"" ) ; } c -> binary_header = * req ; c -> binary_header . request . keylen = ntohs ( req -> request . keylen ) ; c -> binary_header . request . bodylen = ntohl ( req -> request . bodylen ) ; c -> binary_header . request . cas = ntohll ( req -> request . cas ) ; if ( c -> binary_header . request . magic != PROTOCOL_BINARY_REQ ) { if ( settings . verbose ) { fprintf ( stderr , ""Invalid magic:  %x\\n"" , c -> binary_header . request . magic ) ; } conn_set_state ( c , conn_closing ) ; return - 1 ; } c -> msgcurr = 0 ; c -> msgused = 0 ; c -> iovused = 0 ; if ( add_msghdr ( c ) != 0 ) { out_string ( c , ""SERVER_ERROR out of memory"" ) ; return 0 ; } c -> cmd = c -> binary_header . request . opcode ; c -> keylen = c -> binary_header . request . keylen ; c -> opaque = c -> binary_header . request . opaque ; c -> cas = 0 ; dispatch_bin_command ( c ) ; c -> rbytes -= sizeof ( c -> binary_header ) ; c -> rcurr += sizeof ( c -> binary_header ) ; } } else { char * el , * cont ; if ( c -> rbytes == 0 ) return 0 ; el = memchr ( c -> rcurr , '\\n' , c -> rbytes ) ; if ( ! el ) return 0 ; cont = el + 1 ; if ( ( el - c -> rcurr ) > 1 && * ( el - 1 ) == '\\r' ) { el -- ; } * el = '\\0' ; assert ( cont <= ( c -> rcurr + c -> rbytes ) ) ; process_command ( c , c -> rcurr ) ; c -> rbytes -= ( cont - c -> rcurr ) ; c -> rcurr = cont ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; } return 1 ; }
Fixed code:","
static int try_read_command ( conn * c ) { assert ( c != NULL ) ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; assert ( c -> rbytes > 0 ) ; if ( c -> protocol == negotiating_prot || c -> transport == udp_transport ) { if ( ( unsigned char ) c -> rbuf [ 0 ] == ( unsigned char ) PROTOCOL_BINARY_REQ ) { c -> protocol = binary_prot ; } else { c -> protocol = ascii_prot ; } if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Client using the %s protocol\\n"" , c -> sfd , prot_text ( c -> protocol ) ) ; } } if ( c -> protocol == binary_prot ) { if ( c -> rbytes < sizeof ( c -> binary_header ) ) { return 0 ; } else { # ifdef NEED_ALIGN if ( ( ( long ) ( c -> rcurr ) ) % 8 != 0 ) { memmove ( c -> rbuf , c -> rcurr , c -> rbytes ) ; c -> rcurr = c -> rbuf ; if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Realign input buffer\\n"" , c -> sfd ) ; } } # endif protocol_binary_request_header * req ; req = ( protocol_binary_request_header * ) c -> rcurr ; if ( settings . verbose > 1 ) { int ii ; fprintf ( stderr , ""<%d Read binary protocol data:"" , c -> sfd ) ; for ( ii = 0 ; ii < sizeof ( req -> bytes ) ; ++ ii ) { if ( ii % 4 == 0 ) { fprintf ( stderr , ""\\n<%d   "" , c -> sfd ) ; } fprintf ( stderr , "" 0x%02x"" , req -> bytes [ ii ] ) ; } fprintf ( stderr , ""\\n"" ) ; } //Validation code added if (req->request.magic != PROTOCOL_BINARY_REQ) { fprintf(stderr, ""Invalid magic value! Closing connection\n""); conn_set_state(c, conn_closing); return -1; } c -> binary_header = * req ; c -> binary_header . request . keylen = ntohs ( req -> request . keylen ) ; c -> binary_header . request . bodylen = ntohl ( req -> request . bodylen ) ; c -> binary_header . request . cas = ntohll ( req -> request . cas ) ; c -> msgcurr = 0 ; c -> msgused = 0 ; c -> iovused = 0 ; if ( add_msghdr ( c ) != 0 ) { out_string ( c , ""SERVER_ERROR out of memory"" ) ; return 0 ; } c -> cmd = c -> binary_header . request . opcode ; c -> keylen = c -> binary_header . request . keylen ; c -> opaque = c -> binary_header . request . opaque ; c -> cas = 0 ; dispatch_bin_command ( c ) ; c -> rbytes -= sizeof ( c -> binary_header ) ; c -> rcurr += sizeof ( c -> binary_header ) ; } } else { char * el , * cont ; if ( c -> rbytes == 0 ) return 0 ; el = memchr ( c -> rcurr , '\\n' , c -> rbytes ) ; if ( ! el ) return 0 ; cont = el + 1 ; if ( ( el - c -> rcurr ) > 1 && * ( el - 1 ) == '\\r' ) { el -- ; } * el = '\\0' ; assert ( cont <= ( c -> rcurr + c -> rbytes ) ) ; process_command ( c , c -> rcurr ) ; c -> rbytes -= ( cont - c -> rcurr ) ; c -> rcurr = cont ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; } return 1 ; }",918,-31.674389856900625,-0.03450369265457585
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int try_read_command ( conn * c ) { assert ( c != NULL ) ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; assert ( c -> rbytes > 0 ) ; if ( c -> protocol == negotiating_prot || c -> transport == udp_transport ) { if ( ( unsigned char ) c -> rbuf [ 0 ] == ( unsigned char ) PROTOCOL_BINARY_REQ ) { c -> protocol = binary_prot ; } else { c -> protocol = ascii_prot ; } if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Client using the %s protocol\\n"" , c -> sfd , prot_text ( c -> protocol ) ) ; } } if ( c -> protocol == binary_prot ) { if ( c -> rbytes < sizeof ( c -> binary_header ) ) { return 0 ; } else { # ifdef NEED_ALIGN if ( ( ( long ) ( c -> rcurr ) ) % 8 != 0 ) { memmove ( c -> rbuf , c -> rcurr , c -> rbytes ) ; c -> rcurr = c -> rbuf ; if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Realign input buffer\\n"" , c -> sfd ) ; } } # endif protocol_binary_request_header * req ; req = ( protocol_binary_request_header * ) c -> rcurr ; if ( settings . verbose > 1 ) { int ii ; fprintf ( stderr , ""<%d Read binary protocol data:"" , c -> sfd ) ; for ( ii = 0 ; ii < sizeof ( req -> bytes ) ; ++ ii ) { if ( ii % 4 == 0 ) { fprintf ( stderr , ""\\n<%d   "" , c -> sfd ) ; } fprintf ( stderr , "" 0x%02x"" , req -> bytes [ ii ] ) ; } fprintf ( stderr , ""\\n"" ) ; } c -> binary_header = * req ; c -> binary_header . request . keylen = ntohs ( req -> request . keylen ) ; c -> binary_header . request . bodylen = ntohl ( req -> request . bodylen ) ; c -> binary_header . request . cas = ntohll ( req -> request . cas ) ; if ( c -> binary_header . request . magic != PROTOCOL_BINARY_REQ ) { if ( settings . verbose ) { fprintf ( stderr , ""Invalid magic:  %x\\n"" , c -> binary_header . request . magic ) ; } conn_set_state ( c , conn_closing ) ; return - 1 ; } c -> msgcurr = 0 ; c -> msgused = 0 ; c -> iovused = 0 ; if ( add_msghdr ( c ) != 0 ) { out_string ( c , ""SERVER_ERROR out of memory"" ) ; return 0 ; } c -> cmd = c -> binary_header . request . opcode ; c -> keylen = c -> binary_header . request . keylen ; c -> opaque = c -> binary_header . request . opaque ; c -> cas = 0 ; dispatch_bin_command ( c ) ; c -> rbytes -= sizeof ( c -> binary_header ) ; c -> rcurr += sizeof ( c -> binary_header ) ; } } else { char * el , * cont ; if ( c -> rbytes == 0 ) return 0 ; el = memchr ( c -> rcurr , '\\n' , c -> rbytes ) ; if ( ! el ) return 0 ; cont = el + 1 ; if ( ( el - c -> rcurr ) > 1 && * ( el - 1 ) == '\\r' ) { el -- ; } * el = '\\0' ; assert ( cont <= ( c -> rcurr + c -> rbytes ) ) ; process_command ( c , c -> rcurr ) ; c -> rbytes -= ( cont - c -> rcurr ) ; c -> rcurr = cont ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; } return 1 ; }
Fixed code:","
static int try_read_command ( conn * c ) { assert ( c != NULL ) ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; assert ( c -> rbytes > 0 ) ; if ( c -> protocol == negotiating_prot || c -> transport == udp_transport ) { if ( ( unsigned char ) c -> rbuf [ 0 ] == ( unsigned char ) PROTOCOL_BINARY_REQ ) { c -> protocol = binary_prot ; } else if(c->rbuf[0] == '\0' || c->rbuf[0] == '\n' || c->rbuf[0] == '\r'){ //Fix for CWE-20 return 0; } else { c -> protocol = ascii_prot ; } if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Client using the %s protocol\\n"" , c -> sfd , prot_text ( c -> protocol ) ) ; } } if ( c -> protocol == binary_prot ) { if ( c -> rbytes < sizeof ( c -> binary_header ) ) { return 0 ; } else { # ifdef NEED_ALIGN if ( ( ( long ) ( c -> rcurr ) ) % 8 != 0 ) { memmove ( c -> rbuf , c -> rcurr , c -> rbytes ) ; c -> rcurr = c -> rbuf ; if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Realign input buffer\\n"" , c -> sfd ) ; } } # endif protocol_binary_request_header * req ; req = ( protocol_binary_request_header * ) c -> rcurr ; if ( settings . verbose > 1 ) { int ii ; fprintf ( stderr , ""<%d Read binary protocol data:"" , c -> sfd ) ; for ( ii = 0 ; ii < sizeof ( req -> bytes ) ; ++ ii ) { if ( ii % 4 == 0 ) { fprintf ( stderr , ""\\n<%d   "" , c -> sfd ) ; } fprintf ( stderr , "" 0x%02x"" , req -> bytes [ ii ] ) ; } fprintf ( stderr , ""\\n"" ) ; } c -> binary_header = * req ; c -> binary_header . request . keylen = ntohs ( req -> request . keylen ) ; c -> binary_header . request . bodylen = ntohl ( req -> request . bodylen ) ; c -> binary_header . request . cas = ntohll ( req -> request . cas ) ; if ( c -> binary_header . request . magic != PROTOCOL_BINARY_REQ ) { if ( settings . verbose ) { fprintf ( stderr , ""Invalid magic:  %x\\n"" , c -> binary_header . request . magic ) ; } conn_set_state ( c , conn_closing ) ; return - 1 ; } c -> msgcurr = 0 ; c -> msgused = 0 ; c -> iovused = 0 ; if ( add_msghdr ( c ) != 0 ) { out_string ( c , ""SERVER_ERROR out of memory"" ) ; return 0 ; } c -> cmd = c -> binary_header . request . opcode ; c -> keylen = c -> binary_header . request . keylen ; c -> opaque = c -> binary_header . request . opaque ; c -> cas = 0 ; dispatch_bin_command ( c ) ; c -> rbytes -= sizeof ( c -> binary_header ) ; c -> rcurr += sizeof ( c -> binary_header ) ; } } else { char * el , * cont ; if ( c -> rbytes == 0 ) return 0 ; el = memchr ( c -> rcurr , '\\n' , c -> rbytes ) ; if ( ! el ) return 0 ; cont = el + 1 ; if ( ( el - c -> rcurr ) > 1 && * ( el - 1 ) == '\\r' ) { el -- ; } * el = '\\0' ; assert ( cont <= ( c -> rcurr + c -> rbytes ) ) ; process_command ( c , c -> rcurr ) ; c -> rbytes -= ( cont - c -> rcurr ) ; c -> rcurr = cont ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; } return 1 ; }",992,-24.636744103937616,-0.024835427524130663
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int try_read_command ( conn * c ) { assert ( c != NULL ) ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; assert ( c -> rbytes > 0 ) ; if ( c -> protocol == negotiating_prot || c -> transport == udp_transport ) { if ( ( unsigned char ) c -> rbuf [ 0 ] == ( unsigned char ) PROTOCOL_BINARY_REQ ) { c -> protocol = binary_prot ; } else { c -> protocol = ascii_prot ; } if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Client using the %s protocol\\n"" , c -> sfd , prot_text ( c -> protocol ) ) ; } } if ( c -> protocol == binary_prot ) { if ( c -> rbytes < sizeof ( c -> binary_header ) ) { return 0 ; } else { # ifdef NEED_ALIGN if ( ( ( long ) ( c -> rcurr ) ) % 8 != 0 ) { memmove ( c -> rbuf , c -> rcurr , c -> rbytes ) ; c -> rcurr = c -> rbuf ; if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Realign input buffer\\n"" , c -> sfd ) ; } } # endif protocol_binary_request_header * req ; req = ( protocol_binary_request_header * ) c -> rcurr ; if ( settings . verbose > 1 ) { int ii ; fprintf ( stderr , ""<%d Read binary protocol data:"" , c -> sfd ) ; for ( ii = 0 ; ii < sizeof ( req -> bytes ) ; ++ ii ) { if ( ii % 4 == 0 ) { fprintf ( stderr , ""\\n<%d   "" , c -> sfd ) ; } fprintf ( stderr , "" 0x%02x"" , req -> bytes [ ii ] ) ; } fprintf ( stderr , ""\\n"" ) ; } c -> binary_header = * req ; c -> binary_header . request . keylen = ntohs ( req -> request . keylen ) ; c -> binary_header . request . bodylen = ntohl ( req -> request . bodylen ) ; c -> binary_header . request . cas = ntohll ( req -> request . cas ) ; if ( c -> binary_header . request . magic != PROTOCOL_BINARY_REQ ) { if ( settings . verbose ) { fprintf ( stderr , ""Invalid magic:  %x\\n"" , c -> binary_header . request . magic ) ; } conn_set_state ( c , conn_closing ) ; return - 1 ; } c -> msgcurr = 0 ; c -> msgused = 0 ; c -> iovused = 0 ; if ( add_msghdr ( c ) != 0 ) { out_string ( c , ""SERVER_ERROR out of memory"" ) ; return 0 ; } c -> cmd = c -> binary_header . request . opcode ; c -> keylen = c -> binary_header . request . keylen ; c -> opaque = c -> binary_header . request . opaque ; c -> cas = 0 ; dispatch_bin_command ( c ) ; c -> rbytes -= sizeof ( c -> binary_header ) ; c -> rcurr += sizeof ( c -> binary_header ) ; } } else { char * el , * cont ; if ( c -> rbytes == 0 ) return 0 ; el = memchr ( c -> rcurr , '\\n' , c -> rbytes ) ; if ( ! el ) return 0 ; cont = el + 1 ; if ( ( el - c -> rcurr ) > 1 && * ( el - 1 ) == '\\r' ) { el -- ; } * el = '\\0' ; assert ( cont <= ( c -> rcurr + c -> rbytes ) ) ; process_command ( c , c -> rcurr ) ; c -> rbytes -= ( cont - c -> rcurr ) ; c -> rcurr = cont ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; } return 1 ; }
Fixed code:","
static int try_read_command ( conn * c ) { assert ( c != NULL ) ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; assert ( c -> rbytes > 0 ) ; if ( c -> protocol == negotiating_prot || c -> transport == udp_transport ) { if ( ( unsigned char ) c -> rbuf [ 0 ] == ( unsigned char ) PROTOCOL_BINARY_REQ ) { c -> protocol = binary_prot ; } else { c -> protocol = ascii_prot ; } if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Client using the %s protocol\\n"" , c -> sfd , prot_text ( c -> protocol ) ) ; } } if ( c -> protocol == binary_prot ) { if ( c -> rbytes < sizeof ( c -> binary_header ) ) { return 0 ; } else { # ifdef NEED_ALIGN if ( ( ( long ) ( c -> rcurr ) ) % 8 != 0 ) { memmove ( c -> rbuf , c -> rcurr , c -> rbytes ) ; c -> rcurr = c -> rbuf ; if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Realign input buffer\\n"" , c -> sfd ) ; } } # endif protocol_binary_request_header * req ; req = ( protocol_binary_request_header * ) c -> rcurr ; if ( settings . verbose > 1 ) { int ii ; fprintf ( stderr , ""<%d Read binary protocol data:"" , c -> sfd ) ; for ( ii = 0 ; ii < sizeof ( req -> bytes ) ; ++ ii ) { if ( ii % 4 == 0 ) { fprintf ( stderr , ""\\n<%d   "" , c -> sfd ) ; } fprintf ( stderr , "" 0x%02x"" , req -> bytes [ ii ] ) ; } fprintf ( stderr , ""\\n"" ) ; } c -> binary_header = * req ; c -> binary_header . request . keylen = ntohs ( req -> request . keylen ) ; c -> binary_header . request . bodylen = ntohl ( req -> request . bodylen ) ; c -> binary_header . request . cas = ntohll ( req -> request . cas ) ; if ( c -> binary_header . request . magic != PROTOCOL_BINARY_REQ || c->binary_header.request.keylen < 0 || c->binary_header.request.bodylen < 0) { // Validate keylen and bodylen values to prevent buffer overlows if ( settings . verbose ) { fprintf ( stderr , ""Invalid magic:  %x\\n"" , c -> binary_header . request . magic ) ; } conn_set_state ( c , conn_closing ) ; return - 1 ; } c -> msgcurr = 0 ; c -> msgused = 0 ; c -> iovused = 0 ; if ( add_msghdr ( c ) != 0 ) { out_string ( c , ""SERVER_ERROR out of memory"" ) ; return 0 ; } c -> cmd = c -> binary_header . request . opcode ; c -> keylen = c -> binary_header . request . keylen ; c -> opaque = c -> binary_header . request . opaque ; c -> cas = 0 ; dispatch_bin_command ( c ) ; c -> rbytes -= sizeof ( c -> binary_header ) ; c -> rcurr += sizeof ( c -> binary_header ) ; } } else { char * el , * cont ; if ( c -> rbytes == 0 ) return 0 ; el = memchr ( c -> rcurr , '\\n' , c -> rbytes ) ; if ( ! el ) return 0 ; cont = el + 1 ; if ( ( el - c -> rcurr ) > 1 && * ( el - 1 ) == '\\r' ) { el -- ; } * el = '\\0' ; assert ( cont <= ( c -> rcurr + c -> rbytes ) ) ; process_command ( c , c -> rcurr ) ; c -> rbytes -= ( cont - c -> rcurr ) ; c -> rcurr = cont ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; } return 1 ; }",979,-29.72561280868936,-0.030363240866894136
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int try_read_command ( conn * c ) { assert ( c != NULL ) ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; assert ( c -> rbytes > 0 ) ; if ( c -> protocol == negotiating_prot || c -> transport == udp_transport ) { if ( ( unsigned char ) c -> rbuf [ 0 ] == ( unsigned char ) PROTOCOL_BINARY_REQ ) { c -> protocol = binary_prot ; } else { c -> protocol = ascii_prot ; } if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Client using the %s protocol\\n"" , c -> sfd , prot_text ( c -> protocol ) ) ; } } if ( c -> protocol == binary_prot ) { if ( c -> rbytes < sizeof ( c -> binary_header ) ) { return 0 ; } else { # ifdef NEED_ALIGN if ( ( ( long ) ( c -> rcurr ) ) % 8 != 0 ) { memmove ( c -> rbuf , c -> rcurr , c -> rbytes ) ; c -> rcurr = c -> rbuf ; if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Realign input buffer\\n"" , c -> sfd ) ; } } # endif protocol_binary_request_header * req ; req = ( protocol_binary_request_header * ) c -> rcurr ; if ( settings . verbose > 1 ) { int ii ; fprintf ( stderr , ""<%d Read binary protocol data:"" , c -> sfd ) ; for ( ii = 0 ; ii < sizeof ( req -> bytes ) ; ++ ii ) { if ( ii % 4 == 0 ) { fprintf ( stderr , ""\\n<%d   "" , c -> sfd ) ; } fprintf ( stderr , "" 0x%02x"" , req -> bytes [ ii ] ) ; } fprintf ( stderr , ""\\n"" ) ; } c -> binary_header = * req ; c -> binary_header . request . keylen = ntohs ( req -> request . keylen ) ; c -> binary_header . request . bodylen = ntohl ( req -> request . bodylen ) ; c -> binary_header . request . cas = ntohll ( req -> request . cas ) ; if ( c -> binary_header . request . magic != PROTOCOL_BINARY_REQ ) { if ( settings . verbose ) { fprintf ( stderr , ""Invalid magic:  %x\\n"" , c -> binary_header . request . magic ) ; } conn_set_state ( c , conn_closing ) ; return - 1 ; } c -> msgcurr = 0 ; c -> msgused = 0 ; c -> iovused = 0 ; if ( add_msghdr ( c ) != 0 ) { out_string ( c , ""SERVER_ERROR out of memory"" ) ; return 0 ; } c -> cmd = c -> binary_header . request . opcode ; c -> keylen = c -> binary_header . request . keylen ; c -> opaque = c -> binary_header . request . opaque ; c -> cas = 0 ; dispatch_bin_command ( c ) ; c -> rbytes -= sizeof ( c -> binary_header ) ; c -> rcurr += sizeof ( c -> binary_header ) ; } } else { char * el , * cont ; if ( c -> rbytes == 0 ) return 0 ; el = memchr ( c -> rcurr , '\\n' , c -> rbytes ) ; if ( ! el ) return 0 ; cont = el + 1 ; if ( ( el - c -> rcurr ) > 1 && * ( el - 1 ) == '\\r' ) { el -- ; } * el = '\\0' ; assert ( cont <= ( c -> rcurr + c -> rbytes ) ) ; process_command ( c , c -> rcurr ) ; c -> rbytes -= ( cont - c -> rcurr ) ; c -> rcurr = cont ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; } return 1 ; }
Fixed code:","
static int try_read_command ( conn * c ) { assert ( c != NULL ) ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; assert ( c -> rbytes > 0 ) ; if ( c -> protocol == negotiating_prot || c -> transport == udp_transport ) { if ( ( unsigned char ) c -> rbuf [ 0 ] == ( unsigned char ) PROTOCOL_BINARY_REQ ) { c -> protocol = binary_prot ; } else { c -> protocol = ascii_prot ; } if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Client using the %s protocol\\n"" , c -> sfd , prot_text ( c -> protocol ) ) ; } } if ( c -> protocol == binary_prot ) { //Added validations for input data if (c->rbytes < sizeof ( c -> binary_header ) || c->rbuf[0] != (unsigned char) PROTOCOL_BINARY_REQ){ return 0 ; } else { # ifdef NEED_ALIGN if ( ( ( long ) ( c -> rcurr ) ) % 8 != 0 ) { memmove ( c -> rbuf , c -> rcurr , c -> rbytes ) ; c -> rcurr = c -> rbuf ; if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Realign input buffer\\n"" , c -> sfd ) ; } } # endif protocol_binary_request_header * req ; req = ( protocol_binary_request_header * ) c -> rcurr ; if ( settings . verbose > 1 ) { int ii ; fprintf ( stderr , ""<%d Read binary protocol data:"" , c -> sfd ) ; for ( ii = 0 ; ii < sizeof ( req -> bytes ) ; ++ ii ) { if ( ii % 4 == 0 ) { fprintf ( stderr , ""\\n<%d   "" , c -> sfd ) ; } fprintf ( stderr , "" 0x%02x"" , req -> bytes [ ii ] ) ; } fprintf ( stderr , ""\\n"" ) ; } c -> binary_header = * req ; c -> binary_header . request . keylen = ntohs ( req -> request . keylen ) ; c -> binary_header . request . bodylen = ntohl ( req -> request . bodylen ) ; c -> binary_header . request . cas = ntohll ( req -> request . cas ) ; if ( c -> binary_header . request . magic != PROTOCOL_BINARY_REQ ) { if ( settings . verbose ) { fprintf ( stderr , ""Invalid magic:  %x\\n"" , c -> binary_header . request . magic ) ; } conn_set_state ( c , conn_closing ) ; return - 1 ; } c -> msgcurr = 0 ; c -> msgused = 0 ; c -> iovused = 0 ; if ( add_msghdr ( c ) != 0 ) { out_string ( c , ""SERVER_ERROR out of memory"" ) ; return 0 ; } c -> cmd = c -> binary_header . request . opcode ; c -> keylen = c -> binary_header . request . keylen ; c -> opaque = c -> binary_header . request . opaque ; c -> cas = 0 ; dispatch_bin_command ( c ) ; c -> rbytes -= sizeof ( c -> binary_header ) ; c -> rcurr += sizeof ( c -> binary_header ) ; } } else { char * el , * cont ; if ( c -> rbytes == 0 ) return 0 ; el = memchr ( c -> rcurr , '\\n' , c -> rbytes ) ; if ( ! el ) return 0 ; cont = el + 1 ; if ( ( el - c -> rcurr ) > 1 && * ( el - 1 ) == '\\r' ) { el -- ; } * el = '\\0' ; assert ( cont <= ( c -> rcurr + c -> rbytes ) ) ; //Added validations for input data if (!is_valid_input(c->rcurr)){ return 0; } process_command ( c , c -> rcurr ) ; c -> rbytes -= ( cont - c -> rcurr ) ; c -> rcurr = cont ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; } return 1 ; }",994,-45.43377806781722,-0.04570802622516823
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int try_read_command ( conn * c ) { assert ( c != NULL ) ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; assert ( c -> rbytes > 0 ) ; if ( c -> protocol == negotiating_prot || c -> transport == udp_transport ) { if ( ( unsigned char ) c -> rbuf [ 0 ] == ( unsigned char ) PROTOCOL_BINARY_REQ ) { c -> protocol = binary_prot ; } else { c -> protocol = ascii_prot ; } if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Client using the %s protocol\\n"" , c -> sfd , prot_text ( c -> protocol ) ) ; } } if ( c -> protocol == binary_prot ) { if ( c -> rbytes < sizeof ( c -> binary_header ) ) { return 0 ; } else { # ifdef NEED_ALIGN if ( ( ( long ) ( c -> rcurr ) ) % 8 != 0 ) { memmove ( c -> rbuf , c -> rcurr , c -> rbytes ) ; c -> rcurr = c -> rbuf ; if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Realign input buffer\\n"" , c -> sfd ) ; } } # endif protocol_binary_request_header * req ; req = ( protocol_binary_request_header * ) c -> rcurr ; if ( settings . verbose > 1 ) { int ii ; fprintf ( stderr , ""<%d Read binary protocol data:"" , c -> sfd ) ; for ( ii = 0 ; ii < sizeof ( req -> bytes ) ; ++ ii ) { if ( ii % 4 == 0 ) { fprintf ( stderr , ""\\n<%d   "" , c -> sfd ) ; } fprintf ( stderr , "" 0x%02x"" , req -> bytes [ ii ] ) ; } fprintf ( stderr , ""\\n"" ) ; } c -> binary_header = * req ; c -> binary_header . request . keylen = ntohs ( req -> request . keylen ) ; c -> binary_header . request . bodylen = ntohl ( req -> request . bodylen ) ; c -> binary_header . request . cas = ntohll ( req -> request . cas ) ; if ( c -> binary_header . request . magic != PROTOCOL_BINARY_REQ ) { if ( settings . verbose ) { fprintf ( stderr , ""Invalid magic:  %x\\n"" , c -> binary_header . request . magic ) ; } conn_set_state ( c , conn_closing ) ; return - 1 ; } c -> msgcurr = 0 ; c -> msgused = 0 ; c -> iovused = 0 ; if ( add_msghdr ( c ) != 0 ) { out_string ( c , ""SERVER_ERROR out of memory"" ) ; return 0 ; } c -> cmd = c -> binary_header . request . opcode ; c -> keylen = c -> binary_header . request . keylen ; c -> opaque = c -> binary_header . request . opaque ; c -> cas = 0 ; dispatch_bin_command ( c ) ; c -> rbytes -= sizeof ( c -> binary_header ) ; c -> rcurr += sizeof ( c -> binary_header ) ; } } else { char * el , * cont ; if ( c -> rbytes == 0 ) return 0 ; el = memchr ( c -> rcurr , '\\n' , c -> rbytes ) ; if ( ! el ) return 0 ; cont = el + 1 ; if ( ( el - c -> rcurr ) > 1 && * ( el - 1 ) == '\\r' ) { el -- ; } * el = '\\0' ; assert ( cont <= ( c -> rcurr + c -> rbytes ) ) ; process_command ( c , c -> rcurr ) ; c -> rbytes -= ( cont - c -> rcurr ) ; c -> rcurr = cont ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; } return 1 ; }
Fixed code:","
static int try_read_command ( conn * c ) { assert ( c != NULL ) ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; assert ( c -> rbytes > 0 ) ; if ( c -> protocol == negotiating_prot || c -> transport == udp_transport ) { if ( ( unsigned char ) c -> rbuf [ 0 ] == ( unsigned char ) PROTOCOL_BINARY_REQ ) { c -> protocol = binary_prot ; } else { c -> protocol = ascii_prot ; } if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Client using the %s protocol\\n"" , c -> sfd , prot_text ( c -> protocol ) ) ; } } if ( c -> protocol == binary_prot ) { if ( c -> rbytes < sizeof ( c -> binary_header ) ) { return 0 ; } else { # ifdef NEED_ALIGN if ( ( ( long ) ( c -> rcurr ) ) % 8 != 0 ) { memmove ( c -> rbuf , c -> rcurr , c -> rbytes ) ; c -> rcurr = c -> rbuf ; if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Realign input buffer\\n"" , c -> sfd ) ; } } # endif protocol_binary_request_header * req ; req = ( protocol_binary_request_header * ) c -> rcurr ; if ( settings . verbose > 1 ) { int ii ; fprintf ( stderr , ""<%d Read binary protocol data:"" , c -> sfd ) ; for ( ii = 0 ; ii < sizeof ( req -> bytes ) ; ++ ii ) { if ( ii % 4 == 0 ) { fprintf ( stderr , ""\\n<%d   "" , c -> sfd ) ; } fprintf ( stderr , "" 0x%02x"" , req -> bytes [ ii ] ) ; } fprintf ( stderr , ""\\n"" ) ; } c -> binary_header = * req ; c -> binary_header . request . keylen = ntohs ( req -> request . keylen ) ; c -> binary_header . request . bodylen = ntohl ( req -> request . bodylen ) ; c -> binary_header . request . cas = ntohll ( req -> request . cas ) ; if ( c -> binary_header . request . magic != PROTOCOL_BINARY_REQ || c -> binary_header.request.keylen > 250 || c->binary_header.request.bodylen > MAX_BODY_LENGTH ) {  //Check for improper input if ( settings . verbose ) { fprintf ( stderr , ""Invalid magic:  %x\\n"" , c -> binary_header . request . magic ) ; } conn_set_state ( c , conn_closing ) ; return - 1 ; } c -> msgcurr = 0 ; c -> msgused = 0 ; c -> iovused = 0 ; if ( add_msghdr ( c ) != 0 ) { out_string ( c , ""SERVER_ERROR out of memory"" ) ; return 0 ; } c -> cmd = c -> binary_header . request . opcode ; c -> keylen = c -> binary_header . request . keylen ; c -> opaque = c -> binary_header . request . opaque ; c -> cas = 0 ; dispatch_bin_command ( c ) ; c -> rbytes -= sizeof ( c -> binary_header ) ; c -> rcurr += sizeof ( c -> binary_header ) ; } } else { char * el , * cont ; if ( c -> rbytes == 0 ) return 0 ; el = memchr ( c -> rcurr , '\\n' , c -> rbytes ) ; if ( ! el ) return 0 ; cont = el + 1 ; if ( ( el - c -> rcurr ) > 1 && * ( el - 1 ) == '\\r' ) { el -- ; } * el = '\\0' ; assert ( cont <= ( c -> rcurr + c -> rbytes ) ) ; process_command ( c , c -> rcurr ) ; c -> rbytes -= ( cont - c -> rcurr ) ; c -> rcurr = cont ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; } return 1 ; }",977,-29.595571064761238,-0.030292293822682944
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int try_read_command ( conn * c ) { assert ( c != NULL ) ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; assert ( c -> rbytes > 0 ) ; if ( c -> protocol == negotiating_prot || c -> transport == udp_transport ) { if ( ( unsigned char ) c -> rbuf [ 0 ] == ( unsigned char ) PROTOCOL_BINARY_REQ ) { c -> protocol = binary_prot ; } else { c -> protocol = ascii_prot ; } if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Client using the %s protocol\\n"" , c -> sfd , prot_text ( c -> protocol ) ) ; } } if ( c -> protocol == binary_prot ) { if ( c -> rbytes < sizeof ( c -> binary_header ) ) { return 0 ; } else { # ifdef NEED_ALIGN if ( ( ( long ) ( c -> rcurr ) ) % 8 != 0 ) { memmove ( c -> rbuf , c -> rcurr , c -> rbytes ) ; c -> rcurr = c -> rbuf ; if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Realign input buffer\\n"" , c -> sfd ) ; } } # endif protocol_binary_request_header * req ; req = ( protocol_binary_request_header * ) c -> rcurr ; if ( settings . verbose > 1 ) { int ii ; fprintf ( stderr , ""<%d Read binary protocol data:"" , c -> sfd ) ; for ( ii = 0 ; ii < sizeof ( req -> bytes ) ; ++ ii ) { if ( ii % 4 == 0 ) { fprintf ( stderr , ""\\n<%d   "" , c -> sfd ) ; } fprintf ( stderr , "" 0x%02x"" , req -> bytes [ ii ] ) ; } fprintf ( stderr , ""\\n"" ) ; } c -> binary_header = * req ; c -> binary_header . request . keylen = ntohs ( req -> request . keylen ) ; c -> binary_header . request . bodylen = ntohl ( req -> request . bodylen ) ; c -> binary_header . request . cas = ntohll ( req -> request . cas ) ; if ( c -> binary_header . request . magic != PROTOCOL_BINARY_REQ ) { if ( settings . verbose ) { fprintf ( stderr , ""Invalid magic:  %x\\n"" , c -> binary_header . request . magic ) ; } conn_set_state ( c , conn_closing ) ; return - 1 ; } c -> msgcurr = 0 ; c -> msgused = 0 ; c -> iovused = 0 ; if ( add_msghdr ( c ) != 0 ) { out_string ( c , ""SERVER_ERROR out of memory"" ) ; return 0 ; } c -> cmd = c -> binary_header . request . opcode ; c -> keylen = c -> binary_header . request . keylen ; c -> opaque = c -> binary_header . request . opaque ; c -> cas = 0 ; dispatch_bin_command ( c ) ; c -> rbytes -= sizeof ( c -> binary_header ) ; c -> rcurr += sizeof ( c -> binary_header ) ; } } else { char * el , * cont ; if ( c -> rbytes == 0 ) return 0 ; el = memchr ( c -> rcurr , '\\n' , c -> rbytes ) ; if ( ! el ) return 0 ; cont = el + 1 ; if ( ( el - c -> rcurr ) > 1 && * ( el - 1 ) == '\\r' ) { el -- ; } * el = '\\0' ; assert ( cont <= ( c -> rcurr + c -> rbytes ) ) ; process_command ( c , c -> rcurr ) ; c -> rbytes -= ( cont - c -> rcurr ) ; c -> rcurr = cont ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; } return 1 ; }
Fixed code:","
static int try_read_command ( conn * c ) { assert ( c != NULL ) ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; assert ( c -> rbytes > 0 ) ; if ( c -> protocol == negotiating_prot || c -> transport == udp_transport ) { if ( ( unsigned char ) c -> rbuf [ 0 ] == ( unsigned char ) PROTOCOL_BINARY_REQ ) { c -> protocol = binary_prot ; } else { c -> protocol = ascii_prot ; } if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Client using the %s protocol\\n"" , c -> sfd , prot_text ( c -> protocol ) ) ; } } if ( c -> protocol == binary_prot ) { if ( c -> rbytes < sizeof ( c -> binary_header ) ) { return 0 ; } else { # ifdef NEED_ALIGN if ( ( ( long ) ( c -> rcurr ) ) % 8 != 0 ) { memmove ( c -> rbuf , c -> rcurr , c -> rbytes ) ; c -> rcurr = c -> rbuf ; if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Realign input buffer\\n"" , c -> sfd ) ; } } # endif protocol_binary_request_header * req ; req = ( protocol_binary_request_header * ) c -> rcurr ; if ( ! isValidBinaryHeader ( req ) ) { conn_set_state ( c , conn_closing ) ; return - 1 ; } c -> binary_header = * req ; c -> binary_header . request . keylen = ntohs ( req -> request . keylen ) ; c -> binary_header . request . bodylen = ntohl ( req -> request . bodylen ) ; c -> binary_header . request . cas = ntohll ( req -> request . cas ) ; c -> msgcurr = 0 ; c -> msgused = 0 ; c -> iovused = 0 ; if ( add_msghdr ( c ) != 0 ) { out_string ( c , ""SERVER_ERROR out of memory"" ) ; return 0 ; } c -> cmd = c -> binary_header . request . opcode ; c -> keylen = c -> binary_header . request . keylen ; c -> opaque = c -> binary_header . request . opaque ; c -> cas = 0 ; dispatch_bin_command ( c ) ; c -> rbytes -= sizeof ( c -> binary_header ) ; c -> rcurr += sizeof ( c -> binary_header ) ; } } else { char * el , * cont ; if ( c -> rbytes == 0 ) { return 0 ; } if ( ! isValidAsciiHeader ( c -> rcurr ) ) { conn_set_state ( c , conn_closing ) ; return - 1 ; } el = memchr ( c -> rcurr , '\\n' , c -> rbytes ) ; if ( ! el ) { return 0 ; } cont = el + 1 ; if ( ( el - c -> rcurr ) > 1 && * ( el - 1 ) == '\\r' ) { el -- ; } * el = '\\0' ; assert ( cont <= ( c -> rcurr + c -> rbytes ) ) ; process_command ( c , c -> rcurr ) ; c -> rbytes -= ( cont - c -> rcurr ) ; c -> rcurr = cont ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; } return 1 ; }

/*Helper function to validate binary header*/
int isValidBinaryHeader ( protocol_binary_request_header * req ) { if ( settings . verbose > 1 ) { int ii ; fprintf ( stderr , ""<%d Read binary protocol data:"" , c -> sfd ) ; for ( ii = 0 ; ii < sizeof ( req -> bytes ) ; ++ ii ) { if ( ii % 4 == 0 ) { fprintf ( stderr , ""\\n<%d   "" , c -> sfd ) ; } fprintf ( stderr , "" 0x%02x"" , req -> bytes [ ii ] ) ; } fprintf ( stderr , ""\\n"" ) ; } if ( req -> request . magic != PROTOCOL_BINARY_REQ ) { if ( settings . verbose ) { fprintf ( stderr , ""Invalid magic: ",1000,-45.92529550834044,-0.04592529550834044
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int try_read_command ( conn * c ) { assert ( c != NULL ) ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; assert ( c -> rbytes > 0 ) ; if ( c -> protocol == negotiating_prot || c -> transport == udp_transport ) { if ( ( unsigned char ) c -> rbuf [ 0 ] == ( unsigned char ) PROTOCOL_BINARY_REQ ) { c -> protocol = binary_prot ; } else { c -> protocol = ascii_prot ; } if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Client using the %s protocol\\n"" , c -> sfd , prot_text ( c -> protocol ) ) ; } } if ( c -> protocol == binary_prot ) { if ( c -> rbytes < sizeof ( c -> binary_header ) ) { return 0 ; } else { # ifdef NEED_ALIGN if ( ( ( long ) ( c -> rcurr ) ) % 8 != 0 ) { memmove ( c -> rbuf , c -> rcurr , c -> rbytes ) ; c -> rcurr = c -> rbuf ; if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Realign input buffer\\n"" , c -> sfd ) ; } } # endif protocol_binary_request_header * req ; req = ( protocol_binary_request_header * ) c -> rcurr ; if ( settings . verbose > 1 ) { int ii ; fprintf ( stderr , ""<%d Read binary protocol data:"" , c -> sfd ) ; for ( ii = 0 ; ii < sizeof ( req -> bytes ) ; ++ ii ) { if ( ii % 4 == 0 ) { fprintf ( stderr , ""\\n<%d   "" , c -> sfd ) ; } fprintf ( stderr , "" 0x%02x"" , req -> bytes [ ii ] ) ; } fprintf ( stderr , ""\\n"" ) ; } c -> binary_header = * req ; c -> binary_header . request . keylen = ntohs ( req -> request . keylen ) ; c -> binary_header . request . bodylen = ntohl ( req -> request . bodylen ) ; c -> binary_header . request . cas = ntohll ( req -> request . cas ) ; if ( c -> binary_header . request . magic != PROTOCOL_BINARY_REQ ) { if ( settings . verbose ) { fprintf ( stderr , ""Invalid magic:  %x\\n"" , c -> binary_header . request . magic ) ; } conn_set_state ( c , conn_closing ) ; return - 1 ; } c -> msgcurr = 0 ; c -> msgused = 0 ; c -> iovused = 0 ; if ( add_msghdr ( c ) != 0 ) { out_string ( c , ""SERVER_ERROR out of memory"" ) ; return 0 ; } c -> cmd = c -> binary_header . request . opcode ; c -> keylen = c -> binary_header . request . keylen ; c -> opaque = c -> binary_header . request . opaque ; c -> cas = 0 ; dispatch_bin_command ( c ) ; c -> rbytes -= sizeof ( c -> binary_header ) ; c -> rcurr += sizeof ( c -> binary_header ) ; } } else { char * el , * cont ; if ( c -> rbytes == 0 ) return 0 ; el = memchr ( c -> rcurr , '\\n' , c -> rbytes ) ; if ( ! el ) return 0 ; cont = el + 1 ; if ( ( el - c -> rcurr ) > 1 && * ( el - 1 ) == '\\r' ) { el -- ; } * el = '\\0' ; assert ( cont <= ( c -> rcurr + c -> rbytes ) ) ; process_command ( c , c -> rcurr ) ; c -> rbytes -= ( cont - c -> rcurr ) ; c -> rcurr = cont ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; } return 1 ; }
Fixed code:","
static int try_read_command ( conn * c ) { assert ( c != NULL ) ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; assert ( c -> rbytes > 0 ) ; char * el , * cont ; if ( c -> rbytes == 0 ) return 0 ; el = memchr ( c -> rcurr , '\\n' , c -> rbytes ) ; if ( ! el ) return 0 ; cont = el + 1 ; if ( ( el - c -> rcurr ) > 1 && * ( el - 1 ) == '\\r' ) { el -- ; } * el = '\\0' ; assert ( cont <= ( c -> rcurr + c -> rbytes ) ) ; 
if ( c -> protocol == negotiating_prot || c -> transport == udp_transport ) { if ( ( unsigned char ) c -> rbuf [ 0 ] == ( unsigned char ) PROTOCOL_BINARY_REQ ) { c -> protocol = binary_prot ; } else if ( c -> rbuf [ 0 ] == '\\0' ) { // Detect null-byte attack c -> protocol = ascii_prot ; } else { // Reject non-ascii input connection conn_set_state ( c , conn_closing ) ; return - 1 ; } if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Client using the %s protocol\\n"" , c -> sfd , prot_text ( c -> protocol ) ) ; } } 
if ( c -> protocol == binary_prot ) { if ( c -> rbytes < sizeof ( c -> binary_header ) ) { return 0 ; } else { # ifdef NEED_ALIGN if ( ( ( long ) ( c -> rcurr ) ) % 8 != 0 ) { memmove ( c -> rbuf , c -> rcurr , c -> rbytes ) ; c -> rcurr = c -> rbuf ; if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Realign input buffer\\n"" , c -> sfd ) ; } } # endif protocol_binary_request_header * req ; req = ( protocol_binary_request_header * ) c -> rcurr ; if ( settings . verbose > 1 ) { int ii ; fprintf ( stderr , ""<%d Read binary protocol data:"" , c -> sfd ) ; for ( ii = 0 ; ii < sizeof ( req -> bytes ) ; ++ ii ) { if ( ii % 4 == 0 ) { fprintf ( stderr , ""\\n<%d   "" , c -> sfd ) ; } fprintf ( stderr , "" 0x%02x"" , req -> bytes [ ii ] ) ; } fprintf ( stderr , ""\\n"" ) ; } c -> binary_header = * req ; c -> binary_header . request . keylen = ntohs ( req -> request . keylen ) ; c -> binary_header . request . bodylen = ntohl ( req -> request . bodylen ) ; c -> binary_header . request . cas = ntohll ( req -> request . cas ) ; if ( c -> binary_header . request . magic != PROTOCOL_BINARY_REQ ) { if ( settings . verbose ) { fprintf ( stderr , ""Invalid magic:  %x\\n"" , c -> binary_header . request . magic ) ; } conn_set_state ( c , conn_closing ) ; return - 1 ; } c -> msgcurr = 0 ; c -> msgused = 0 ; c -> iovused = 0 ; if ( add_msghdr ( c ) != 0 ) { out_string ( c , ""SERVER_ERROR out of memory"" ) ; return 0 ; } c -> cmd = c -> binary_header . request . opcode ; c -> keylen = c -> binary_header . request . keylen ; c -> opaque = c -> binary_header . request . opaque ; c -> cas = 0 ; dispatch_bin_command ( c ) ; c -> rbytes -= sizeof ( c -> binary_header ) ; c -> rcurr += sizeof ( c -> binary_header ) ; } } else { process_command ( c , c -> rcurr ) ; c -> rbytes -= ( cont - c -> rcurr ) ; c -> rcurr = cont ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; } return 1 ; }",995,-52.049772436192484,-0.05231132908160049
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int try_read_command ( conn * c ) { assert ( c != NULL ) ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; assert ( c -> rbytes > 0 ) ; if ( c -> protocol == negotiating_prot || c -> transport == udp_transport ) { if ( ( unsigned char ) c -> rbuf [ 0 ] == ( unsigned char ) PROTOCOL_BINARY_REQ ) { c -> protocol = binary_prot ; } else { c -> protocol = ascii_prot ; } if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Client using the %s protocol\\n"" , c -> sfd , prot_text ( c -> protocol ) ) ; } } if ( c -> protocol == binary_prot ) { if ( c -> rbytes < sizeof ( c -> binary_header ) ) { return 0 ; } else { # ifdef NEED_ALIGN if ( ( ( long ) ( c -> rcurr ) ) % 8 != 0 ) { memmove ( c -> rbuf , c -> rcurr , c -> rbytes ) ; c -> rcurr = c -> rbuf ; if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Realign input buffer\\n"" , c -> sfd ) ; } } # endif protocol_binary_request_header * req ; req = ( protocol_binary_request_header * ) c -> rcurr ; if ( settings . verbose > 1 ) { int ii ; fprintf ( stderr , ""<%d Read binary protocol data:"" , c -> sfd ) ; for ( ii = 0 ; ii < sizeof ( req -> bytes ) ; ++ ii ) { if ( ii % 4 == 0 ) { fprintf ( stderr , ""\\n<%d   "" , c -> sfd ) ; } fprintf ( stderr , "" 0x%02x"" , req -> bytes [ ii ] ) ; } fprintf ( stderr , ""\\n"" ) ; } c -> binary_header = * req ; c -> binary_header . request . keylen = ntohs ( req -> request . keylen ) ; c -> binary_header . request . bodylen = ntohl ( req -> request . bodylen ) ; c -> binary_header . request . cas = ntohll ( req -> request . cas ) ; if ( c -> binary_header . request . magic != PROTOCOL_BINARY_REQ ) { if ( settings . verbose ) { fprintf ( stderr , ""Invalid magic:  %x\\n"" , c -> binary_header . request . magic ) ; } conn_set_state ( c , conn_closing ) ; return - 1 ; } c -> msgcurr = 0 ; c -> msgused = 0 ; c -> iovused = 0 ; if ( add_msghdr ( c ) != 0 ) { out_string ( c , ""SERVER_ERROR out of memory"" ) ; return 0 ; } c -> cmd = c -> binary_header . request . opcode ; c -> keylen = c -> binary_header . request . keylen ; c -> opaque = c -> binary_header . request . opaque ; c -> cas = 0 ; dispatch_bin_command ( c ) ; c -> rbytes -= sizeof ( c -> binary_header ) ; c -> rcurr += sizeof ( c -> binary_header ) ; } } else { char * el , * cont ; if ( c -> rbytes == 0 ) return 0 ; el = memchr ( c -> rcurr , '\\n' , c -> rbytes ) ; if ( ! el ) return 0 ; cont = el + 1 ; if ( ( el - c -> rcurr ) > 1 && * ( el - 1 ) == '\\r' ) { el -- ; } * el = '\\0' ; assert ( cont <= ( c -> rcurr + c -> rbytes ) ) ; process_command ( c , c -> rcurr ) ; c -> rbytes -= ( cont - c -> rcurr ) ; c -> rcurr = cont ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; } return 1 ; }
Fixed code:","
static int try_read_command ( conn * c ) { assert ( c != NULL ) ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; assert ( c -> rbytes > 0 ) ; if ( c -> protocol == negotiating_prot || c -> transport == udp_transport ) { if ( ( unsigned char ) c -> rbuf [ 0 ] == ( unsigned char ) PROTOCOL_BINARY_REQ && c->rbytes >= sizeof(c->binary_header)) { c -> protocol = binary_prot ; } else { c -> protocol = ascii_prot ; } if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Client using the %s protocol\\n"" , c -> sfd , prot_text ( c -> protocol ) ) ; } } if ( c -> protocol == binary_prot ) { if ( c -> rbytes < sizeof ( c -> binary_header ) ) { return 0 ; } else { # ifdef NEED_ALIGN if ( ( ( long ) ( c -> rcurr ) ) % 8 != 0 ) { memmove ( c -> rbuf , c -> rcurr , c -> rbytes ) ; c -> rcurr = c -> rbuf ; if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Realign input buffer\\n"" , c -> sfd ) ; } } # endif protocol_binary_request_header * req ; req = ( protocol_binary_request_header * ) c -> rcurr ; if ( settings . verbose > 1 ) { int ii ; fprintf ( stderr , ""<%d Read binary protocol data:"" , c -> sfd ) ; for ( ii = 0 ; ii < sizeof ( req -> bytes ) ; ++ ii ) { if ( ii % 4 == 0 ) { fprintf ( stderr , ""\\n<%d   "" , c -> sfd ) ; } fprintf ( stderr , "" 0x%02x"" , req -> bytes [ ii ] ) ; } fprintf ( stderr , ""\\n"" ) ; } c -> binary_header = * req ; c -> binary_header . request . keylen = ntohs ( req -> request . keylen ) ; c -> binary_header . request . bodylen = ntohl ( req -> request . bodylen ) ; c -> binary_header . request . cas = ntohll ( req -> request . cas ) ; if ( c -> binary_header . request . magic != PROTOCOL_BINARY_REQ ) { if ( settings . verbose ) { fprintf ( stderr , ""Invalid magic:  %x\\n"" , c -> binary_header . request . magic ) ; } conn_set_state ( c , conn_closing ) ; return - 1 ; } c -> msgcurr = 0 ; c -> msgused = 0 ; c -> iovused = 0 ; if ( add_msghdr ( c ) != 0 ) { out_string ( c , ""SERVER_ERROR out of memory"" ) ; return 0 ; } c -> cmd = c -> binary_header . request . opcode ; c -> keylen = c -> binary_header . request . keylen ; c -> opaque = c -> binary_header . request . opaque ; c -> cas = 0 ; dispatch_bin_command ( c ) ; c -> rbytes -= sizeof ( c -> binary_header ) ; c -> rcurr += sizeof ( c -> binary_header ) ; } } else { char * el , * cont ; if ( c -> rbytes == 0 ) return 0 ; el = memchr ( c -> rcurr , '\\n' , c -> rbytes ) ; if ( ! el ) return 0 ; cont = el + 1 ; if ( ( el - c -> rcurr ) > 1 && * ( el - 1 ) == '\\r' ) { el -- ; } * el = '\\0' ; assert ( cont <= ( c -> rcurr + c -> rbytes ) ) ; process_command ( c , c -> rcurr ) ; c -> rbytes -= ( cont - c -> rcurr ) ; c -> rcurr = cont ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; } return 1 ; }",952,-10.30541407307785,-0.0108250147826448
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int try_read_command ( conn * c ) { assert ( c != NULL ) ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; assert ( c -> rbytes > 0 ) ; if ( c -> protocol == negotiating_prot || c -> transport == udp_transport ) { if ( ( unsigned char ) c -> rbuf [ 0 ] == ( unsigned char ) PROTOCOL_BINARY_REQ ) { c -> protocol = binary_prot ; } else { c -> protocol = ascii_prot ; } if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Client using the %s protocol\\n"" , c -> sfd , prot_text ( c -> protocol ) ) ; } } if ( c -> protocol == binary_prot ) { if ( c -> rbytes < sizeof ( c -> binary_header ) ) { return 0 ; } else { # ifdef NEED_ALIGN if ( ( ( long ) ( c -> rcurr ) ) % 8 != 0 ) { memmove ( c -> rbuf , c -> rcurr , c -> rbytes ) ; c -> rcurr = c -> rbuf ; if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Realign input buffer\\n"" , c -> sfd ) ; } } # endif protocol_binary_request_header * req ; req = ( protocol_binary_request_header * ) c -> rcurr ; if ( settings . verbose > 1 ) { int ii ; fprintf ( stderr , ""<%d Read binary protocol data:"" , c -> sfd ) ; for ( ii = 0 ; ii < sizeof ( req -> bytes ) ; ++ ii ) { if ( ii % 4 == 0 ) { fprintf ( stderr , ""\\n<%d   "" , c -> sfd ) ; } fprintf ( stderr , "" 0x%02x"" , req -> bytes [ ii ] ) ; } fprintf ( stderr , ""\\n"" ) ; } c -> binary_header = * req ; c -> binary_header . request . keylen = ntohs ( req -> request . keylen ) ; c -> binary_header . request . bodylen = ntohl ( req -> request . bodylen ) ; c -> binary_header . request . cas = ntohll ( req -> request . cas ) ; if ( c -> binary_header . request . magic != PROTOCOL_BINARY_REQ ) { if ( settings . verbose ) { fprintf ( stderr , ""Invalid magic:  %x\\n"" , c -> binary_header . request . magic ) ; } conn_set_state ( c , conn_closing ) ; return - 1 ; } c -> msgcurr = 0 ; c -> msgused = 0 ; c -> iovused = 0 ; if ( add_msghdr ( c ) != 0 ) { out_string ( c , ""SERVER_ERROR out of memory"" ) ; return 0 ; } c -> cmd = c -> binary_header . request . opcode ; c -> keylen = c -> binary_header . request . keylen ; c -> opaque = c -> binary_header . request . opaque ; c -> cas = 0 ; dispatch_bin_command ( c ) ; c -> rbytes -= sizeof ( c -> binary_header ) ; c -> rcurr += sizeof ( c -> binary_header ) ; } } else { char * el , * cont ; if ( c -> rbytes == 0 ) return 0 ; el = memchr ( c -> rcurr , '\\n' , c -> rbytes ) ; if ( ! el ) return 0 ; cont = el + 1 ; if ( ( el - c -> rcurr ) > 1 && * ( el - 1 ) == '\\r' ) { el -- ; } * el = '\\0' ; assert ( cont <= ( c -> rcurr + c -> rbytes ) ) ; process_command ( c , c -> rcurr ) ; c -> rbytes -= ( cont - c -> rcurr ) ; c -> rcurr = cont ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; } return 1 ; }
Fixed code:","
static int try_read_command ( conn * c ) { assert ( c != NULL ) ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; assert ( c -> rbytes > 0 ) ; if ( c -> protocol == negotiating_prot || c -> transport == udp_transport ) { if ( ( unsigned char ) c -> rbuf [ 0 ] == ( unsigned char ) PROTOCOL_BINARY_REQ ) { c -> protocol = binary_prot ; } else { c -> protocol = ascii_prot ; } if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Client using the %s protocol\\n"" , c -> sfd , prot_text ( c -> protocol ) ) ; } } if ( c -> protocol == binary_prot ) { if ( c -> rbytes < sizeof ( c -> binary_header ) ) { return 0 ; } else { # ifdef NEED_ALIGN if ( ( ( long ) ( c -> rcurr ) ) % 8 != 0 ) { memmove ( c -> rbuf , c -> rcurr , c -> rbytes ) ; c -> rcurr = c -> rbuf ; if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Realign input buffer\\n"" , c -> sfd ) ; } } # endif protocol_binary_request_header * req ; req = ( protocol_binary_request_header * ) c -> rcurr ; if ( settings . verbose > 1 ) { int ii ; fprintf ( stderr , ""<%d Read binary protocol data:"" , c -> sfd ) ; for ( ii = 0 ; ii < sizeof ( req -> bytes ) ; ++ ii ) { if ( ii % 4 == 0 ) { fprintf ( stderr , ""\\n<%d   "" , c -> sfd ) ; } fprintf ( stderr , "" 0x%02x"" , req -> bytes [ ii ] ) ; } fprintf ( stderr , ""\\n"" ) ; } if ( c -> binary_header . request . magic != PROTOCOL_BINARY_REQ ) { if ( settings . verbose ) { fprintf ( stderr , ""Invalid magic:  %x\\n"" , c -> binary_header . request . magic ) ; } conn_set_state ( c , conn_closing ) ; return - 1 ; } c -> binary_header = * req ; c -> binary_header . request . keylen = ntohs ( req -> request . keylen ) ; c -> binary_header . request . bodylen = ntohl ( req -> request . bodylen ) ; c -> binary_header . request . cas = ntohll ( req -> request . cas ) ; c -> msgcurr = 0 ; c -> msgused = 0 ; c -> iovused = 0 ; if ( add_msghdr ( c ) != 0 ) { out_string ( c , ""SERVER_ERROR out of memory"" ) ; return 0 ; } c -> cmd = c -> binary_header . request . opcode ; c -> keylen = c -> binary_header . request . keylen ; c -> opaque = c -> binary_header . request . opaque ; c -> cas = 0 ; dispatch_bin_command ( c ) ; c -> rbytes -= sizeof ( c -> binary_header ) ; c -> rcurr += sizeof ( c -> binary_header ) ; } } else { char * el , * cont ; if ( c -> rbytes == 0 ) return 0 ; el = memchr ( c -> rcurr , '\\n' , c -> rbytes ) ; if ( ! el ) return 0 ; cont = el + 1 ; if ( ( el - c -> rcurr ) > 1 && * ( el - 1 ) == '\\r' ) { el -- ; } * el = '\\0' ; assert ( cont <= ( c -> rcurr + c -> rbytes ) ) ; //ADD INPUT VALIDATION - START: if (!input_string_validation(c->rcurr)) { if (settings.verbose) { fprintf(stderr, ""Input validation failed""); } conn_set_state(c, conn_closing); return -1; } //ADD INPUT VALIDATION - END process_command ( c , c -> rcurr ) ; c -> rbytes -= ( cont - c -> rcurr ) ; c -> rcurr = cont ; assert ( c -> rcurr <= ( c -> rbuf",1000,-53.05013188563744,-0.05305013188563744
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int try_read_command ( conn * c ) { assert ( c != NULL ) ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; assert ( c -> rbytes > 0 ) ; if ( c -> protocol == negotiating_prot || c -> transport == udp_transport ) { if ( ( unsigned char ) c -> rbuf [ 0 ] == ( unsigned char ) PROTOCOL_BINARY_REQ ) { c -> protocol = binary_prot ; } else { c -> protocol = ascii_prot ; } if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Client using the %s protocol\\n"" , c -> sfd , prot_text ( c -> protocol ) ) ; } } if ( c -> protocol == binary_prot ) { if ( c -> rbytes < sizeof ( c -> binary_header ) ) { return 0 ; } else { # ifdef NEED_ALIGN if ( ( ( long ) ( c -> rcurr ) ) % 8 != 0 ) { memmove ( c -> rbuf , c -> rcurr , c -> rbytes ) ; c -> rcurr = c -> rbuf ; if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Realign input buffer\\n"" , c -> sfd ) ; } } # endif protocol_binary_request_header * req ; req = ( protocol_binary_request_header * ) c -> rcurr ; if ( settings . verbose > 1 ) { int ii ; fprintf ( stderr , ""<%d Read binary protocol data:"" , c -> sfd ) ; for ( ii = 0 ; ii < sizeof ( req -> bytes ) ; ++ ii ) { if ( ii % 4 == 0 ) { fprintf ( stderr , ""\\n<%d   "" , c -> sfd ) ; } fprintf ( stderr , "" 0x%02x"" , req -> bytes [ ii ] ) ; } fprintf ( stderr , ""\\n"" ) ; } c -> binary_header = * req ; c -> binary_header . request . keylen = ntohs ( req -> request . keylen ) ; c -> binary_header . request . bodylen = ntohl ( req -> request . bodylen ) ; c -> binary_header . request . cas = ntohll ( req -> request . cas ) ; if ( c -> binary_header . request . magic != PROTOCOL_BINARY_REQ ) { if ( settings . verbose ) { fprintf ( stderr , ""Invalid magic:  %x\\n"" , c -> binary_header . request . magic ) ; } conn_set_state ( c , conn_closing ) ; return - 1 ; } c -> msgcurr = 0 ; c -> msgused = 0 ; c -> iovused = 0 ; if ( add_msghdr ( c ) != 0 ) { out_string ( c , ""SERVER_ERROR out of memory"" ) ; return 0 ; } c -> cmd = c -> binary_header . request . opcode ; c -> keylen = c -> binary_header . request . keylen ; c -> opaque = c -> binary_header . request . opaque ; c -> cas = 0 ; dispatch_bin_command ( c ) ; c -> rbytes -= sizeof ( c -> binary_header ) ; c -> rcurr += sizeof ( c -> binary_header ) ; } } else { char * el , * cont ; if ( c -> rbytes == 0 ) return 0 ; el = memchr ( c -> rcurr , '\\n' , c -> rbytes ) ; if ( ! el ) return 0 ; cont = el + 1 ; if ( ( el - c -> rcurr ) > 1 && * ( el - 1 ) == '\\r' ) { el -- ; } * el = '\\0' ; assert ( cont <= ( c -> rcurr + c -> rbytes ) ) ; process_command ( c , c -> rcurr ) ; c -> rbytes -= ( cont - c -> rcurr ) ; c -> rcurr = cont ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; } return 1 ; }
Fixed code:","
static int try_read_command ( conn * c ) { assert ( c != NULL ) ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; assert ( c -> rbytes > 0 ) ; if ( c -> protocol == negotiating_prot || c -> transport == udp_transport ) { if ( ( unsigned char ) c -> rbuf [ 0 ] == ( unsigned char ) PROTOCOL_BINARY_REQ ) { c -> protocol = binary_prot ; } else { c -> protocol = ascii_prot ; } if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Client using the %s protocol\\n"" , c -> sfd , prot_text ( c -> protocol ) ) ; } } if ( c -> protocol == binary_prot ) { if ( c -> rbytes < sizeof ( c -> binary_header ) ) { return 0 ; } else { # ifdef NEED_ALIGN if ( ( ( long ) ( c -> rcurr ) ) % 8 != 0 ) { memmove ( c -> rbuf , c -> rcurr , c -> rbytes ) ; c -> rcurr = c -> rbuf ; if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Realign input buffer\\n"" , c -> sfd ) ; } } # endif protocol_binary_request_header * req ; req = ( protocol_binary_request_header * ) c -> rcurr ; if ( settings . verbose > 1 ) { int ii ; fprintf ( stderr , ""<%d Read binary protocol data:"" , c -> sfd ) ; for ( ii = 0 ; ii < sizeof ( req -> bytes ) ; ++ ii ) { if ( ii % 4 == 0 ) { fprintf ( stderr , ""\\n<%d   "" , c -> sfd ) ; } fprintf ( stderr , "" 0x%02x"" , req -> bytes [ ii ] ) ; } fprintf ( stderr , ""\\n"" ) ; } c -> binary_header = * req ; c -> binary_header . request . keylen = ntohs ( req -> request . keylen ) ; c -> binary_header . request . bodylen = ntohl ( req -> request . bodylen ) ; c -> binary_header . request . cas = ntohll ( req -> request . cas ) ; //Check the validity of the request before processing if ( c -> binary_header . request . magic != PROTOCOL_BINARY_REQ || c -> binary_header . request . keylen > KEY_MAX_LENGTH || c -> binary_header . request . bodylen > BODY_MAX_LENGTH ) { if ( settings . verbose ) { fprintf ( stderr , ""Invalid request\\n"" ) ; } conn_set_state ( c , conn_closing ) ; return - 1 ; } c -> msgcurr = 0 ; c -> msgused = 0 ; c -> iovused = 0 ; if ( add_msghdr ( c ) != 0 ) { out_string ( c , ""SERVER_ERROR out of memory"" ) ; return 0 ; } c -> cmd = c -> binary_header . request . opcode ; c -> keylen = c -> binary_header . request . keylen ; c -> opaque = c -> binary_header . request . opaque ; c -> cas = 0 ; dispatch_bin_command ( c ) ; c -> rbytes -= sizeof ( c -> binary_header ) ; c -> rcurr += sizeof ( c -> binary_header ) ; } } else { char * el , * cont ; if ( c -> rbytes == 0 ) return 0 ; el = memchr ( c -> rcurr , '\\n' , c -> rbytes ) ; if ( ! el ) return 0 ; cont = el + 1 ; if ( ( el - c -> rcurr ) > 1 && * ( el - 1 ) == '\\r' ) { el -- ; } * el = '\\0' ; assert ( cont <= ( c -> rcurr + c -> rbytes ) ) ; process_command ( c , c -> rcurr ) ; c -> rbytes -= ( cont - c -> rcurr ) ; c -> rcurr = cont ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; } return 1 ; }",971,-24.330031554420575,-0.025056675133285865
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int try_read_command ( conn * c ) { assert ( c != NULL ) ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; assert ( c -> rbytes > 0 ) ; if ( c -> protocol == negotiating_prot || c -> transport == udp_transport ) { if ( ( unsigned char ) c -> rbuf [ 0 ] == ( unsigned char ) PROTOCOL_BINARY_REQ ) { c -> protocol = binary_prot ; } else { c -> protocol = ascii_prot ; } if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Client using the %s protocol\\n"" , c -> sfd , prot_text ( c -> protocol ) ) ; } } if ( c -> protocol == binary_prot ) { if ( c -> rbytes < sizeof ( c -> binary_header ) ) { return 0 ; } else { # ifdef NEED_ALIGN if ( ( ( long ) ( c -> rcurr ) ) % 8 != 0 ) { memmove ( c -> rbuf , c -> rcurr , c -> rbytes ) ; c -> rcurr = c -> rbuf ; if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Realign input buffer\\n"" , c -> sfd ) ; } } # endif protocol_binary_request_header * req ; req = ( protocol_binary_request_header * ) c -> rcurr ; if ( settings . verbose > 1 ) { int ii ; fprintf ( stderr , ""<%d Read binary protocol data:"" , c -> sfd ) ; for ( ii = 0 ; ii < sizeof ( req -> bytes ) ; ++ ii ) { if ( ii % 4 == 0 ) { fprintf ( stderr , ""\\n<%d   "" , c -> sfd ) ; } fprintf ( stderr , "" 0x%02x"" , req -> bytes [ ii ] ) ; } fprintf ( stderr , ""\\n"" ) ; } c -> binary_header = * req ; c -> binary_header . request . keylen = ntohs ( req -> request . keylen ) ; c -> binary_header . request . bodylen = ntohl ( req -> request . bodylen ) ; c -> binary_header . request . cas = ntohll ( req -> request . cas ) ; if ( c -> binary_header . request . magic != PROTOCOL_BINARY_REQ ) { if ( settings . verbose ) { fprintf ( stderr , ""Invalid magic:  %x\\n"" , c -> binary_header . request . magic ) ; } conn_set_state ( c , conn_closing ) ; return - 1 ; } c -> msgcurr = 0 ; c -> msgused = 0 ; c -> iovused = 0 ; if ( add_msghdr ( c ) != 0 ) { out_string ( c , ""SERVER_ERROR out of memory"" ) ; return 0 ; } c -> cmd = c -> binary_header . request . opcode ; c -> keylen = c -> binary_header . request . keylen ; c -> opaque = c -> binary_header . request . opaque ; c -> cas = 0 ; dispatch_bin_command ( c ) ; c -> rbytes -= sizeof ( c -> binary_header ) ; c -> rcurr += sizeof ( c -> binary_header ) ; } } else { char * el , * cont ; if ( c -> rbytes == 0 ) return 0 ; el = memchr ( c -> rcurr , '\\n' , c -> rbytes ) ; if ( ! el ) return 0 ; cont = el + 1 ; if ( ( el - c -> rcurr ) > 1 && * ( el - 1 ) == '\\r' ) { el -- ; } * el = '\\0' ; assert ( cont <= ( c -> rcurr + c -> rbytes ) ) ; process_command ( c , c -> rcurr ) ; c -> rbytes -= ( cont - c -> rcurr ) ; c -> rcurr = cont ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; } return 1 ; }
Fixed code:","
static int try_read_command ( conn * c ) { assert ( c != NULL ) ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; assert ( c -> rbytes > 0 ) ; if ( c -> protocol == negotiating_prot || c -> transport == udp_transport ) { if ( ( unsigned char ) c -> rbuf [ 0 ] == ( unsigned char ) PROTOCOL_BINARY_REQ ) { c -> protocol = binary_prot ; } else { c -> protocol = ascii_prot ; } if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Client using the %s protocol\\n"" , c -> sfd , prot_text ( c -> protocol ) ) ; } } if ( c -> protocol == binary_prot ) { if ( c -> rbytes < sizeof ( c -> binary_header ) ) { return 0 ; } else { # ifdef NEED_ALIGN if ( ( ( long ) ( c -> rcurr ) ) % 8 != 0 ) { memmove ( c -> rbuf , c -> rcurr , c -> rbytes ) ; c -> rcurr = c -> rbuf ; if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Realign input buffer\\n"" , c -> sfd ) ; } } # endif protocol_binary_request_header * req ; req = ( protocol_binary_request_header * ) c -> rcurr ; if ( settings . verbose > 1 ) { int ii ; fprintf ( stderr , ""<%d Read binary protocol data:"" , c -> sfd ) ; for ( ii = 0 ; ii < sizeof ( req -> bytes ) ; ++ ii ) { if ( ii % 4 == 0 ) { fprintf ( stderr , ""\\n<%d   "" , c -> sfd ) ; } fprintf ( stderr , "" 0x%02x"" , req -> bytes [ ii ] ) ; } fprintf ( stderr , ""\\n"" ) ; } c -> binary_header = * req ; // Validate magic before proceeding if ( c -> binary_header . request . magic != PROTOCOL_BINARY_REQ ) { if ( settings . verbose ) { fprintf ( stderr , ""Invalid magic:  %x\\n"" , c -> binary_header . request . magic ) ; } conn_set_state ( c , conn_closing ) ; return - 1 ; } c -> binary_header . request . keylen = ntohs ( req -> request . keylen ) ; c -> binary_header . request . bodylen = ntohl ( req -> request . bodylen ) ; c -> binary_header . request . cas = ntohll ( req -> request . cas ) ; c -> msgcurr = 0 ; c -> msgused = 0 ; c -> iovused = 0 ; if ( add_msghdr ( c ) != 0 ) { out_string ( c , ""SERVER_ERROR out of memory"" ) ; return 0 ; } c -> cmd = c -> binary_header . request . opcode ; c -> keylen = c -> binary_header . request . keylen ; c -> opaque = c -> binary_header . request . opaque ; c -> cas = 0 ; dispatch_bin_command ( c ) ; c -> rbytes -= sizeof ( c -> binary_header ) ; c -> rcurr += sizeof ( c -> binary_header ) ; } } else { char * el , * cont ; if ( c -> rbytes == 0 ) return 0 ; el = memchr ( c -> rcurr , '\\n' , c -> rbytes ) ; if ( ! el ) return 0 ; cont = el + 1 ; if ( ( el - c -> rcurr ) > 1 && * ( el - 1 ) == '\\r' ) { el -- ; } * el = '\\0' ; assert ( cont <= ( c -> rcurr + c -> rbytes ) ) ; process_command ( c , c -> rcurr ) ; c -> rbytes -= ( cont - c -> rcurr ) ; c -> rcurr = cont ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; } return 1 ; }",945,-15.192096909428617,-0.01607629302585039
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int try_read_command ( conn * c ) { assert ( c != NULL ) ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; assert ( c -> rbytes > 0 ) ; if ( c -> protocol == negotiating_prot || c -> transport == udp_transport ) { if ( ( unsigned char ) c -> rbuf [ 0 ] == ( unsigned char ) PROTOCOL_BINARY_REQ ) { c -> protocol = binary_prot ; } else { c -> protocol = ascii_prot ; } if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Client using the %s protocol\\n"" , c -> sfd , prot_text ( c -> protocol ) ) ; } } if ( c -> protocol == binary_prot ) { if ( c -> rbytes < sizeof ( c -> binary_header ) ) { return 0 ; } else { # ifdef NEED_ALIGN if ( ( ( long ) ( c -> rcurr ) ) % 8 != 0 ) { memmove ( c -> rbuf , c -> rcurr , c -> rbytes ) ; c -> rcurr = c -> rbuf ; if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Realign input buffer\\n"" , c -> sfd ) ; } } # endif protocol_binary_request_header * req ; req = ( protocol_binary_request_header * ) c -> rcurr ; if ( settings . verbose > 1 ) { int ii ; fprintf ( stderr , ""<%d Read binary protocol data:"" , c -> sfd ) ; for ( ii = 0 ; ii < sizeof ( req -> bytes ) ; ++ ii ) { if ( ii % 4 == 0 ) { fprintf ( stderr , ""\\n<%d   "" , c -> sfd ) ; } fprintf ( stderr , "" 0x%02x"" , req -> bytes [ ii ] ) ; } fprintf ( stderr , ""\\n"" ) ; } c -> binary_header = * req ; c -> binary_header . request . keylen = ntohs ( req -> request . keylen ) ; c -> binary_header . request . bodylen = ntohl ( req -> request . bodylen ) ; c -> binary_header . request . cas = ntohll ( req -> request . cas ) ; if ( c -> binary_header . request . magic != PROTOCOL_BINARY_REQ ) { if ( settings . verbose ) { fprintf ( stderr , ""Invalid magic:  %x\\n"" , c -> binary_header . request . magic ) ; } conn_set_state ( c , conn_closing ) ; return - 1 ; } c -> msgcurr = 0 ; c -> msgused = 0 ; c -> iovused = 0 ; if ( add_msghdr ( c ) != 0 ) { out_string ( c , ""SERVER_ERROR out of memory"" ) ; return 0 ; } c -> cmd = c -> binary_header . request . opcode ; c -> keylen = c -> binary_header . request . keylen ; c -> opaque = c -> binary_header . request . opaque ; c -> cas = 0 ; dispatch_bin_command ( c ) ; c -> rbytes -= sizeof ( c -> binary_header ) ; c -> rcurr += sizeof ( c -> binary_header ) ; } } else { char * el , * cont ; if ( c -> rbytes == 0 ) return 0 ; el = memchr ( c -> rcurr , '\\n' , c -> rbytes ) ; if ( ! el ) return 0 ; cont = el + 1 ; if ( ( el - c -> rcurr ) > 1 && * ( el - 1 ) == '\\r' ) { el -- ; } * el = '\\0' ; assert ( cont <= ( c -> rcurr + c -> rbytes ) ) ; process_command ( c , c -> rcurr ) ; c -> rbytes -= ( cont - c -> rcurr ) ; c -> rcurr = cont ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; } return 1 ; }
Fixed code:","
static int try_read_command ( conn * c ) { 
  assert ( c != NULL ) ; 
  assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; 
  assert ( c -> rbytes > 0 ) ; 
  if ( c -> protocol == negotiating_prot || c -> transport == udp_transport ) { 
    if ( ( unsigned char ) c -> rbuf [ 0 ] == ( unsigned char ) PROTOCOL_BINARY_REQ ) { 
      c -> protocol = binary_prot ; 
    } else { 
      c -> protocol = ascii_prot ; 
    } 
    if ( settings . verbose > 1 ) { 
      fprintf ( stderr , ""%d: Client using the %s protocol\\n"" , c -> sfd , prot_text ( c -> protocol ) ) ; 
    } 
  } 
  if ( c -> protocol == binary_prot ) { 
    if ( c -> rbytes < sizeof ( c -> binary_header ) ) {
      return 0 ; 
    } else { 
      # ifdef NEED_ALIGN 
      if ( ( ( long ) ( c -> rcurr ) ) % 8 != 0 ) {
        memmove ( c -> rbuf , c -> rcurr , c -> rbytes ) ; 
        c -> rcurr = c -> rbuf ; 
        if ( settings . verbose > 1 ) { 
          fprintf ( stderr , ""%d: Realign input buffer\\n"" , c -> sfd ) ; 
        } 
      } 
      # endif 
      protocol_binary_request_header * req ; 
      req = ( protocol_binary_request_header * ) c -> rcurr ; 
      if ( settings . verbose > 1 ) { 
        int ii ; 
        fprintf ( stderr , ""<%d Read binary protocol data:"" , c -> sfd ) ; 
        for ( ii = 0 ; ii < sizeof ( req -> bytes ) ; ++ ii ) {
         if ( ii % 4 == 0 ) { 
           fprintf ( stderr , ""\\n<%d   "" , c -> sfd ) ; 
         } 
         fprintf ( stderr , "" 0x%02x"" , req -> bytes [ ii ] ) ; 
       } 
       fprintf ( stderr , ""\\n"" ) ; 
     } 
     if (req->bytes[0] != PROTOCOL_BINARY_REQ) { // ADDED CHECK
       conn_set_state ( c , conn_closing ) ; 
       return - 1 ; 
     }
     c -> binary_header = * req ; 
     c -> binary_header . request . keylen = ntohs ( req -> request . keylen ) ; 
     c -> binary_header . request . bodylen = ntohl ( req -> request . bodylen ) ; 
     c -> binary_header . request . cas = ntohll ( req -> request . cas ) ;
     c -> msgcurr = 0 ; 
     c -> msgused = 0 ; 
     c -> iovused = 0 ; 
     if ( add_msghdr ( c ) != 0 ) { 
       out_string ( c , ""SERVER_ERROR out of memory"" ) ; 
       return 0 ; 
     } 
     c -> cmd = c -> binary_header . request . opcode ; 
     c -> keylen = c -> binary_header . request . keylen ; 
     c -> opaque = c -> binary_header . request . opaque ; 
     c -> cas = 0 ; 
     dispatch_bin_command ( c ) ; 
     c -> rbytes -= sizeof ( c -> binary_header ) ; 
     c -> rcurr += sizeof ( c -> binary_header ) ; 
   } 
 } else { 
   char * el , * cont ; 
   if ( c -> rbytes == 0 ) return 0 ; 
   el = memchr ( c -> rcurr , '\\n' , c -> rbytes ) ; 
   if ( ! el ) return 0 ; 
   cont = el + 1 ; 
   if ( ( el - c -> rcurr ) > 1 && * (",1000,-50.85048517272903,-0.05085048517272903
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int try_read_command ( conn * c ) { assert ( c != NULL ) ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; assert ( c -> rbytes > 0 ) ; if ( c -> protocol == negotiating_prot || c -> transport == udp_transport ) { if ( ( unsigned char ) c -> rbuf [ 0 ] == ( unsigned char ) PROTOCOL_BINARY_REQ ) { c -> protocol = binary_prot ; } else { c -> protocol = ascii_prot ; } if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Client using the %s protocol\\n"" , c -> sfd , prot_text ( c -> protocol ) ) ; } } if ( c -> protocol == binary_prot ) { if ( c -> rbytes < sizeof ( c -> binary_header ) ) { return 0 ; } else { # ifdef NEED_ALIGN if ( ( ( long ) ( c -> rcurr ) ) % 8 != 0 ) { memmove ( c -> rbuf , c -> rcurr , c -> rbytes ) ; c -> rcurr = c -> rbuf ; if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Realign input buffer\\n"" , c -> sfd ) ; } } # endif protocol_binary_request_header * req ; req = ( protocol_binary_request_header * ) c -> rcurr ; if ( settings . verbose > 1 ) { int ii ; fprintf ( stderr , ""<%d Read binary protocol data:"" , c -> sfd ) ; for ( ii = 0 ; ii < sizeof ( req -> bytes ) ; ++ ii ) { if ( ii % 4 == 0 ) { fprintf ( stderr , ""\\n<%d   "" , c -> sfd ) ; } fprintf ( stderr , "" 0x%02x"" , req -> bytes [ ii ] ) ; } fprintf ( stderr , ""\\n"" ) ; } c -> binary_header = * req ; c -> binary_header . request . keylen = ntohs ( req -> request . keylen ) ; c -> binary_header . request . bodylen = ntohl ( req -> request . bodylen ) ; c -> binary_header . request . cas = ntohll ( req -> request . cas ) ; if ( c -> binary_header . request . magic != PROTOCOL_BINARY_REQ ) { if ( settings . verbose ) { fprintf ( stderr , ""Invalid magic:  %x\\n"" , c -> binary_header . request . magic ) ; } conn_set_state ( c , conn_closing ) ; return - 1 ; } c -> msgcurr = 0 ; c -> msgused = 0 ; c -> iovused = 0 ; if ( add_msghdr ( c ) != 0 ) { out_string ( c , ""SERVER_ERROR out of memory"" ) ; return 0 ; } c -> cmd = c -> binary_header . request . opcode ; c -> keylen = c -> binary_header . request . keylen ; c -> opaque = c -> binary_header . request . opaque ; c -> cas = 0 ; dispatch_bin_command ( c ) ; c -> rbytes -= sizeof ( c -> binary_header ) ; c -> rcurr += sizeof ( c -> binary_header ) ; } } else { char * el , * cont ; if ( c -> rbytes == 0 ) return 0 ; el = memchr ( c -> rcurr , '\\n' , c -> rbytes ) ; if ( ! el ) return 0 ; cont = el + 1 ; if ( ( el - c -> rcurr ) > 1 && * ( el - 1 ) == '\\r' ) { el -- ; } * el = '\\0' ; assert ( cont <= ( c -> rcurr + c -> rbytes ) ) ; process_command ( c , c -> rcurr ) ; c -> rbytes -= ( cont - c -> rcurr ) ; c -> rcurr = cont ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; } return 1 ; }
Fixed code:","
static int try_read_command ( conn * c ) { assert ( c != NULL ) ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; assert ( c -> rbytes > 0 ) ; if ( c -> protocol == negotiating_prot || c -> transport == udp_transport ) { if ( ( unsigned char ) c -> rbuf [ 0 ] == ( unsigned char ) PROTOCOL_BINARY_REQ ) { c -> protocol = binary_prot ; } else { c -> protocol = ascii_prot ; } if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Client using the %s protocol\\n"" , c -> sfd , prot_text ( c -> protocol ) ) ; } } if ( c -> protocol == binary_prot ) { if ( c -> rbytes < sizeof ( c -> binary_header ) ) { return 0 ; } else { # ifdef NEED_ALIGN if ( ( ( long ) ( c -> rcurr ) ) % 8 != 0 ) { memmove ( c -> rbuf , c -> rcurr , c -> rbytes ) ; c -> rcurr = c -> rbuf ; if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Realign input buffer\\n"" , c -> sfd ) ; } } # endif protocol_binary_request_header * req ; req = ( protocol_binary_request_header * ) c -> rcurr ; if ( settings . verbose > 1 ) { int ii ; fprintf ( stderr , ""<%d Read binary protocol data:"" , c -> sfd ) ; for ( ii = 0 ; ii < sizeof ( req -> bytes ) ; ++ ii ) { if ( ii % 4 == 0 ) { fprintf ( stderr , ""\\n<%d   "" , c -> sfd ) ; } fprintf ( stderr , "" 0x%02x"" , req -> bytes [ ii ] ) ; } fprintf ( stderr , ""\\n"" ) ; } if (req->request.keylen > KEY_MAX_LENGTH) { if ( settings . verbose ) { fprintf ( stderr , ""Invalid key length:  %x\\n"" , req -> request . keylen ) ; } conn_set_state ( c , conn_closing ) ; return - 1 ; } c -> binary_header = * req ; c -> binary_header . request . keylen = ntohs ( req -> request . keylen ) ; c -> binary_header . request . bodylen = ntohl ( req -> request . bodylen ) ; c -> binary_header . request . cas = ntohll ( req -> request . cas ) ; if ( c -> binary_header . request . magic != PROTOCOL_BINARY_REQ ) { if ( settings . verbose ) { fprintf ( stderr , ""Invalid magic:  %x\\n"" , c -> binary_header . request . magic ) ; } conn_set_state ( c , conn_closing ) ; return - 1 ; } c -> msgcurr = 0 ; c -> msgused = 0 ; c -> iovused = 0 ; if ( add_msghdr ( c ) != 0 ) { out_string ( c , ""SERVER_ERROR out of memory"" ) ; return 0 ; } c -> cmd = c -> binary_header . request . opcode ; c -> keylen = c -> binary_header . request . keylen ; c -> opaque = c -> binary_header . request . opaque ; c -> cas = 0 ; dispatch_bin_command ( c ) ; c -> rbytes -= sizeof ( c -> binary_header ) ; c -> rcurr += sizeof ( c -> binary_header ) ; } } else { char * el , * cont ; if ( c -> rbytes == 0 ) return 0 ; el = memchr ( c -> rcurr , '\\n' , c -> rbytes ) ; if ( ! el ) return 0 ; cont = el + 1 ; if ( ( el - c -> rcurr ) > 1 && * ( el - 1 ) == '\\r' ) { el -- ; } * el = '\\0' ; assert ( cont <= ( c -> rcurr + c -> rbytes ) ) ; process_command ( c , c -> rcurr ) ; c -> rbytes -= ( cont - c -> rcurr ) ; c -> rcurr = cont ; assert ( c -> rcurr <= ( c -> rbuf + c",1000,-16.890597716468942,-0.016890597716468943
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int try_read_command ( conn * c ) { assert ( c != NULL ) ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; assert ( c -> rbytes > 0 ) ; if ( c -> protocol == negotiating_prot || c -> transport == udp_transport ) { if ( ( unsigned char ) c -> rbuf [ 0 ] == ( unsigned char ) PROTOCOL_BINARY_REQ ) { c -> protocol = binary_prot ; } else { c -> protocol = ascii_prot ; } if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Client using the %s protocol\\n"" , c -> sfd , prot_text ( c -> protocol ) ) ; } } if ( c -> protocol == binary_prot ) { if ( c -> rbytes < sizeof ( c -> binary_header ) ) { return 0 ; } else { # ifdef NEED_ALIGN if ( ( ( long ) ( c -> rcurr ) ) % 8 != 0 ) { memmove ( c -> rbuf , c -> rcurr , c -> rbytes ) ; c -> rcurr = c -> rbuf ; if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Realign input buffer\\n"" , c -> sfd ) ; } } # endif protocol_binary_request_header * req ; req = ( protocol_binary_request_header * ) c -> rcurr ; if ( settings . verbose > 1 ) { int ii ; fprintf ( stderr , ""<%d Read binary protocol data:"" , c -> sfd ) ; for ( ii = 0 ; ii < sizeof ( req -> bytes ) ; ++ ii ) { if ( ii % 4 == 0 ) { fprintf ( stderr , ""\\n<%d   "" , c -> sfd ) ; } fprintf ( stderr , "" 0x%02x"" , req -> bytes [ ii ] ) ; } fprintf ( stderr , ""\\n"" ) ; } c -> binary_header = * req ; c -> binary_header . request . keylen = ntohs ( req -> request . keylen ) ; c -> binary_header . request . bodylen = ntohl ( req -> request . bodylen ) ; c -> binary_header . request . cas = ntohll ( req -> request . cas ) ; if ( c -> binary_header . request . magic != PROTOCOL_BINARY_REQ ) { if ( settings . verbose ) { fprintf ( stderr , ""Invalid magic:  %x\\n"" , c -> binary_header . request . magic ) ; } conn_set_state ( c , conn_closing ) ; return - 1 ; } c -> msgcurr = 0 ; c -> msgused = 0 ; c -> iovused = 0 ; if ( add_msghdr ( c ) != 0 ) { out_string ( c , ""SERVER_ERROR out of memory"" ) ; return 0 ; } c -> cmd = c -> binary_header . request . opcode ; c -> keylen = c -> binary_header . request . keylen ; c -> opaque = c -> binary_header . request . opaque ; c -> cas = 0 ; dispatch_bin_command ( c ) ; c -> rbytes -= sizeof ( c -> binary_header ) ; c -> rcurr += sizeof ( c -> binary_header ) ; } } else { char * el , * cont ; if ( c -> rbytes == 0 ) return 0 ; el = memchr ( c -> rcurr , '\\n' , c -> rbytes ) ; if ( ! el ) return 0 ; cont = el + 1 ; if ( ( el - c -> rcurr ) > 1 && * ( el - 1 ) == '\\r' ) { el -- ; } * el = '\\0' ; assert ( cont <= ( c -> rcurr + c -> rbytes ) ) ; process_command ( c , c -> rcurr ) ; c -> rbytes -= ( cont - c -> rcurr ) ; c -> rcurr = cont ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; } return 1 ; }
Fixed code:","
static int try_read_command ( conn * c ) { 
    assert ( c != NULL ) ;
    assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ;
    assert ( c -> rbytes > 0 ) ;
    
    if ( c -> protocol == negotiating_prot || c -> transport == udp_transport ) {
        if ( ( unsigned char ) c -> rbuf [ 0 ] == ( unsigned char ) PROTOCOL_BINARY_REQ ) {
            c -> protocol = binary_prot ;
        } else {
            c -> protocol = ascii_prot ;
        }
        if ( settings . verbose > 1 ) {
            fprintf ( stderr , ""%d: Client using the %s protocol\\n"" , c -> sfd , prot_text ( c -> protocol ) ) ;
        }
    }
    if ( c -> protocol == binary_prot ) {
        if ( c -> rbytes < sizeof ( c -> binary_header ) ) {
            return 0 ;
        } else { 
            # ifdef NEED_ALIGN
            if ( ( ( long ) ( c -> rcurr ) ) % 8 != 0 ) {
                memmove ( c -> rbuf , c -> rcurr , c -> rbytes ) ;
                c -> rcurr = c -> rbuf ;
                if ( settings . verbose > 1 ) {
                    fprintf ( stderr , ""%d: Realign input buffer\\n"" , c -> sfd ) ;
                }
            } 
            # endif 
            protocol_binary_request_header * req ;
            req = ( protocol_binary_request_header * ) c -> rcurr ;
            if ( settings . verbose > 1 ) {
                int ii ;
                fprintf ( stderr , ""<%d Read binary protocol data:"" , c -> sfd ) ;
                for ( ii = 0 ; ii < sizeof ( req -> bytes ) ; ++ ii ) {
                    if ( ii % 4 == 0 ) {
                        fprintf ( stderr , ""\\n<%d   "" , c -> sfd ) ;
                    }
                    fprintf ( stderr , "" 0x%02x"" , req -> bytes [ ii ] ) ;
                }
                fprintf ( stderr , ""\\n"" ) ;
            }
            c -> binary_header = * req ;
            c -> binary_header . request . keylen = ntohs ( req -> request . keylen ) ;
            c -> binary_header . request . bodylen = ntohl ( req -> request . bodylen ) ;
            c -> binary_header . request . cas = ntohll ( req -> request . cas ) ;
            //Added Line of Code
            if ( c -> binary_header . request . magic != PROTOCOL_BINARY_REQ || c -> binary_header . request . keylen > KEY_MAX_LENGTH) {
                if ( settings . verbose ) {
                    fprintf ( stderr , ""Invalid magic:  %x\\n"" , c -> binary_header . request . magic ) ;
                }
                conn_set_state ( c , conn_closing ) ;
                return - 1 ;
            }
            c -> msgcurr = 0 ;
            c -> msgused = 0 ;
            c -> iovused = 0 ;
            if ( add_msghdr ( c ) != 0 ) {
                out_string ( c , ""SERVER_ERROR out of memory"" ) ;
                return 0 ;
            }
            c -> cmd = c -> binary_header . request . opcode ;
            c -> keylen = c -> binary_header . request . keylen ;
            c -> opaque = c -> binary_header . request . opaque ;
            c -> cas = 0 ;
            dispatch_bin_command ( c ) ;
            c -> rbytes -= sizeof ( c -> binary_header ) ;
            c -> rcurr += sizeof ( c -> binary_header ) ;
        }
    } else {
        char * el , * cont ;
        if ( c -> rbytes == 0 ) return 0 ;
        el = memchr ( c -> rcurr , '\\n' , c -> rbytes ) ;
        if ( ! el ) return 0 ;
        cont = el + 1 ;
        if ( ( el -",1000,-39.5700043159909,-0.0395700043159909
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int try_read_command ( conn * c ) { assert ( c != NULL ) ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; assert ( c -> rbytes > 0 ) ; if ( c -> protocol == negotiating_prot || c -> transport == udp_transport ) { if ( ( unsigned char ) c -> rbuf [ 0 ] == ( unsigned char ) PROTOCOL_BINARY_REQ ) { c -> protocol = binary_prot ; } else { c -> protocol = ascii_prot ; } if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Client using the %s protocol\\n"" , c -> sfd , prot_text ( c -> protocol ) ) ; } } if ( c -> protocol == binary_prot ) { if ( c -> rbytes < sizeof ( c -> binary_header ) ) { return 0 ; } else { # ifdef NEED_ALIGN if ( ( ( long ) ( c -> rcurr ) ) % 8 != 0 ) { memmove ( c -> rbuf , c -> rcurr , c -> rbytes ) ; c -> rcurr = c -> rbuf ; if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Realign input buffer\\n"" , c -> sfd ) ; } } # endif protocol_binary_request_header * req ; req = ( protocol_binary_request_header * ) c -> rcurr ; if ( settings . verbose > 1 ) { int ii ; fprintf ( stderr , ""<%d Read binary protocol data:"" , c -> sfd ) ; for ( ii = 0 ; ii < sizeof ( req -> bytes ) ; ++ ii ) { if ( ii % 4 == 0 ) { fprintf ( stderr , ""\\n<%d   "" , c -> sfd ) ; } fprintf ( stderr , "" 0x%02x"" , req -> bytes [ ii ] ) ; } fprintf ( stderr , ""\\n"" ) ; } c -> binary_header = * req ; c -> binary_header . request . keylen = ntohs ( req -> request . keylen ) ; c -> binary_header . request . bodylen = ntohl ( req -> request . bodylen ) ; c -> binary_header . request . cas = ntohll ( req -> request . cas ) ; if ( c -> binary_header . request . magic != PROTOCOL_BINARY_REQ ) { if ( settings . verbose ) { fprintf ( stderr , ""Invalid magic:  %x\\n"" , c -> binary_header . request . magic ) ; } conn_set_state ( c , conn_closing ) ; return - 1 ; } c -> msgcurr = 0 ; c -> msgused = 0 ; c -> iovused = 0 ; if ( add_msghdr ( c ) != 0 ) { out_string ( c , ""SERVER_ERROR out of memory"" ) ; return 0 ; } c -> cmd = c -> binary_header . request . opcode ; c -> keylen = c -> binary_header . request . keylen ; c -> opaque = c -> binary_header . request . opaque ; c -> cas = 0 ; dispatch_bin_command ( c ) ; c -> rbytes -= sizeof ( c -> binary_header ) ; c -> rcurr += sizeof ( c -> binary_header ) ; } } else { char * el , * cont ; if ( c -> rbytes == 0 ) return 0 ; el = memchr ( c -> rcurr , '\\n' , c -> rbytes ) ; if ( ! el ) return 0 ; cont = el + 1 ; if ( ( el - c -> rcurr ) > 1 && * ( el - 1 ) == '\\r' ) { el -- ; } * el = '\\0' ; assert ( cont <= ( c -> rcurr + c -> rbytes ) ) ; process_command ( c , c -> rcurr ) ; c -> rbytes -= ( cont - c -> rcurr ) ; c -> rcurr = cont ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; } return 1 ; }
Fixed code:","
static int try_read_command (conn *c ) {
    assert ( c != NULL ) ;
    assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ;
    assert ( c -> rbytes > 0 ) ;
    
    if ( c -> protocol == negotiating_prot || c -> transport == udp_transport ) {
        if ( ( unsigned char ) c -> rbuf [ 0 ] == ( unsigned char ) PROTOCOL_BINARY_REQ ) {
            c -> protocol = binary_prot ;
        } else {
            c -> protocol = ascii_prot ;
        }
        if ( settings . verbose > 1 ) {
            fprintf ( stderr , ""%d: Client using the %s protocol\\n"" , c -> sfd , prot_text ( c -> protocol ) ) ;
        }
    }
    
    if ( c -> protocol == binary_prot ) {
        if ( c -> rbytes < sizeof ( c -> binary_header ) ) {
            return 0 ;
        } else {
            //Sanity Check
            if ( c -> rbytes > MAX_BINARY_PACKET_LENGTH ) {
                return 0;
            }
            # ifdef NEED_ALIGN
            if ( ( ( long ) ( c -> rcurr ) ) % 8 != 0 ) {
                memmove ( c -> rbuf , c -> rcurr , c -> rbytes ) ;
                c -> rcurr = c -> rbuf ;
                if ( settings . verbose > 1 ) {
                    fprintf ( stderr , ""%d: Realign input buffer\\n"" , c -> sfd ) ;
                }
            }
            # endif
            protocol_binary_request_header * req ;
            req = ( protocol_binary_request_header * ) c -> rcurr ;
            if ( settings . verbose > 1 ) {
                int ii ;
                fprintf ( stderr , ""<%d Read binary protocol data:"" , c -> sfd ) ;
                for ( ii = 0 ; ii < sizeof ( req -> bytes ) ; ++ ii ) {
                    if ( ii % 4 == 0 ) {
                        fprintf ( stderr , ""\\n<%d   "" , c -> sfd ) ;
                    }
                    fprintf ( stderr , "" 0x%02x"" , req -> bytes [ ii ] ) ;
                }
                fprintf ( stderr , ""\\n"" ) ;
            }
            c -> binary_header = * req ;
            c -> binary_header . request . keylen = ntohs ( req -> request . keylen ) ;
            c -> binary_header . request . bodylen = ntohl ( req -> request . bodylen ) ;
            c -> binary_header . request . cas = ntohll ( req -> request . cas ) ;
            if ( c -> binary_header . request . magic != PROTOCOL_BINARY_REQ ) {
                if ( settings . verbose ) {
                    fprintf ( stderr , ""Invalid magic:  %x\\n"" , c -> binary_header . request . magic ) ;
                }
                conn_set_state ( c , conn_closing ) ;
                return - 1 ;
            }
            c -> msgcurr = 0 ;
            c -> msgused = 0 ;
            c -> iovused = 0 ;
            if ( add_msghdr ( c ) != 0 ) {
                out_string ( c , ""SERVER_ERROR out of memory"" ) ;
                return 0 ;
            }
            c -> cmd = c -> binary_header . request . opcode ;
            c -> keylen = c -> binary_header . request . keylen ;
            c -> opaque = c -> binary_header . request . opaque ;
            c -> cas = 0 ;
            dispatch_bin_command ( c ) ;
            c -> rbytes -= sizeof ( c -> binary_header ) ;
            c -> rcurr += sizeof ( c -> binary_header ) ;
        }
    } else {
        char * el , * cont ;
        if ( c -> rbytes == 0 ) return 0 ;
        el = memchr ( c -> rcurr , '\\n' , c -> rbytes ) ;
        if ( ! el ) return 0 ;
        cont = el",1000,-42.44629185857397,-0.04244629185857397
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int try_read_command ( conn * c ) { assert ( c != NULL ) ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; assert ( c -> rbytes > 0 ) ; if ( c -> protocol == negotiating_prot || c -> transport == udp_transport ) { if ( ( unsigned char ) c -> rbuf [ 0 ] == ( unsigned char ) PROTOCOL_BINARY_REQ ) { c -> protocol = binary_prot ; } else { c -> protocol = ascii_prot ; } if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Client using the %s protocol\\n"" , c -> sfd , prot_text ( c -> protocol ) ) ; } } if ( c -> protocol == binary_prot ) { if ( c -> rbytes < sizeof ( c -> binary_header ) ) { return 0 ; } else { # ifdef NEED_ALIGN if ( ( ( long ) ( c -> rcurr ) ) % 8 != 0 ) { memmove ( c -> rbuf , c -> rcurr , c -> rbytes ) ; c -> rcurr = c -> rbuf ; if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d: Realign input buffer\\n"" , c -> sfd ) ; } } # endif protocol_binary_request_header * req ; req = ( protocol_binary_request_header * ) c -> rcurr ; if ( settings . verbose > 1 ) { int ii ; fprintf ( stderr , ""<%d Read binary protocol data:"" , c -> sfd ) ; for ( ii = 0 ; ii < sizeof ( req -> bytes ) ; ++ ii ) { if ( ii % 4 == 0 ) { fprintf ( stderr , ""\\n<%d   "" , c -> sfd ) ; } fprintf ( stderr , "" 0x%02x"" , req -> bytes [ ii ] ) ; } fprintf ( stderr , ""\\n"" ) ; } c -> binary_header = * req ; c -> binary_header . request . keylen = ntohs ( req -> request . keylen ) ; c -> binary_header . request . bodylen = ntohl ( req -> request . bodylen ) ; c -> binary_header . request . cas = ntohll ( req -> request . cas ) ; if ( c -> binary_header . request . magic != PROTOCOL_BINARY_REQ ) { if ( settings . verbose ) { fprintf ( stderr , ""Invalid magic:  %x\\n"" , c -> binary_header . request . magic ) ; } conn_set_state ( c , conn_closing ) ; return - 1 ; } c -> msgcurr = 0 ; c -> msgused = 0 ; c -> iovused = 0 ; if ( add_msghdr ( c ) != 0 ) { out_string ( c , ""SERVER_ERROR out of memory"" ) ; return 0 ; } c -> cmd = c -> binary_header . request . opcode ; c -> keylen = c -> binary_header . request . keylen ; c -> opaque = c -> binary_header . request . opaque ; c -> cas = 0 ; dispatch_bin_command ( c ) ; c -> rbytes -= sizeof ( c -> binary_header ) ; c -> rcurr += sizeof ( c -> binary_header ) ; } } else { char * el , * cont ; if ( c -> rbytes == 0 ) return 0 ; el = memchr ( c -> rcurr , '\\n' , c -> rbytes ) ; if ( ! el ) return 0 ; cont = el + 1 ; if ( ( el - c -> rcurr ) > 1 && * ( el - 1 ) == '\\r' ) { el -- ; } * el = '\\0' ; assert ( cont <= ( c -> rcurr + c -> rbytes ) ) ; process_command ( c , c -> rcurr ) ; c -> rbytes -= ( cont - c -> rcurr ) ; c -> rcurr = cont ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; } return 1 ; }
Fixed code:","
static int try_read_command(conn *c) 
{ 
  assert(c != NULL); 
  assert(c->rcurr <= (c->rbuf + c->rsize)); 
  assert(c->rbytes > 0); 

  // begin fix
  if (!c->rbytes || c->rbytes < sizeof(c->binary_header)) {
    return 0;
  }
  // end fix

  if (c->protocol == negotiating_prot || c->transport == udp_transport) {
    if ((unsigned char)c->rbuf[0] == (unsigned char)PROTOCOL_BINARY_REQ) {
      c->protocol = binary_prot;
    } else {
      c->protocol = ascii_prot;
    }
    if (settings.verbose > 1) {
      fprintf(stderr, ""%d: Client using the %s protocol\n"",
              c->sfd, prot_text(c->protocol));
    }
  }
  if (c->protocol == binary_prot) {
    if (c->rbytes < sizeof(c->binary_header)) {
      return 0;
    } else {
#ifdef NEED_ALIGN
      if (((long)(c->rcurr)) % 8 != 0) {
        memmove(c->rbuf, c->rcurr, c->rbytes);
        c->rcurr = c->rbuf;
        if (settings.verbose > 1) {
          fprintf(stderr, ""%d: Realign input buffer\n"", c->sfd);
        }
      }
#endif
      protocol_binary_request_header *req;
      req = (protocol_binary_request_header *)c->rcurr;

      if (settings.verbose > 1) {
        int ii;
        fprintf(stderr, ""<%d Read binary protocol data:"", c->sfd);
        for (ii = 0; ii < sizeof(req->bytes); ++ii) {
          if (ii % 4 == 0) {
            fprintf(stderr, ""\n<%d   "", c->sfd);
          }
          fprintf(stderr, "" 0x%02x"", req->bytes[ii]);
        }
        fprintf(stderr, ""\n"");
      }
      c->binary_header = *req;
      c->binary_header.request.keylen = ntohs(req->request.keylen);
      c->binary_header.request.bodylen = ntohl(req->request.bodylen);
      c->binary_header.request.cas = ntohll(req->request.cas);

      // begin fix
      if (c->binary_header.request.magic != PROTOCOL_BINARY_REQ) {
        if (settings.verbose) {
          fprintf(stderr, ""Invalid magic:  %x\n"", c->binary_header.request.magic);
        }
        conn_set_state(c, conn_closing);
        return -1;
      }
      // end fix

      c->msgcurr = 0;
      c->msgused = 0;
      c->iovused = 0;
      if (add_msghdr(c) != 0) {
        out_string(c, ""SERVER_ERROR out of memory"");
        return 0;
      }
      c->cmd = c->binary_header.request.opcode;
      c->keylen = c->binary_header.request.keylen;
      c->opaque = c->binary_header.request.opaque;
      c->cas = 0;
      dispatch_bin_command(c);
      c->rbytes -= sizeof(c->binary_header);
      c->rcurr += sizeof(c->binary_header);
    }
  } else {
    char *el, *cont;

    // begin fix
    if (c->rbytes == 0) {
      return 0;
    }
    // end fix

    el = memchr(c->rcurr, '\n', c->rbytes);
    if (!el) {
      return 0;
   ",1000,-43.1051372120152,-0.0431051372120152
