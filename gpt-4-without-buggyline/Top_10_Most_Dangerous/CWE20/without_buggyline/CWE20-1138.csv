Original code,Plausible Program,Total Tokens,Sum Entropy,Mean Entropy
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int processCommand ( redisClient * c ) { struct redisCommand * cmd ; if ( ! strcasecmp ( c -> argv [ 0 ] -> ptr , ""quit"" ) ) { addReply ( c , shared . ok ) ; c -> flags |= REDIS_CLOSE_AFTER_REPLY ; return REDIS_ERR ; } cmd = lookupCommand ( c -> argv [ 0 ] -> ptr ) ; if ( ! cmd ) { addReplyErrorFormat ( c , ""unknown command \'%s\'"" , ( char * ) c -> argv [ 0 ] -> ptr ) ; return REDIS_OK ; } else if ( ( cmd -> arity > 0 && cmd -> arity != c -> argc ) || ( c -> argc < - cmd -> arity ) ) { addReplyErrorFormat ( c , ""wrong number of arguments for \'%s\' command"" , cmd -> name ) ; return REDIS_OK ; } if ( server . requirepass && ! c -> authenticated && cmd -> proc != authCommand ) { addReplyError ( c , ""operation not permitted"" ) ; return REDIS_OK ; } if ( server . maxmemory ) freeMemoryIfNeeded ( ) ; if ( server . maxmemory && ( cmd -> flags & REDIS_CMD_DENYOOM ) && zmalloc_used_memory ( ) > server . maxmemory ) { addReplyError ( c , ""command not allowed when used memory > \'maxmemory\'"" ) ; return REDIS_OK ; } if ( ( dictSize ( c -> pubsub_channels ) > 0 || listLength ( c -> pubsub_patterns ) > 0 ) && cmd -> proc != subscribeCommand && cmd -> proc != unsubscribeCommand && cmd -> proc != psubscribeCommand && cmd -> proc != punsubscribeCommand ) { addReplyError ( c , ""only (P)SUBSCRIBE / (P)UNSUBSCRIBE / QUIT allowed in this context"" ) ; return REDIS_OK ; } if ( server . masterhost && server . replstate != REDIS_REPL_CONNECTED && server . repl_serve_stale_data == 0 && cmd -> proc != infoCommand && cmd -> proc != slaveofCommand ) { addReplyError ( c , ""link with MASTER is down and slave-serve-stale-data is set to no"" ) ; return REDIS_OK ; } if ( server . loading && cmd -> proc != infoCommand ) { addReply ( c , shared . loadingerr ) ; return REDIS_OK ; } if ( c -> flags & REDIS_MULTI && cmd -> proc != execCommand && cmd -> proc != discardCommand && cmd -> proc != multiCommand && cmd -> proc != watchCommand ) { queueMultiCommand ( c , cmd ) ; addReply ( c , shared . queued ) ; } else { if ( server . vm_enabled && server . vm_max_threads > 0 && blockClientOnSwappedKeys ( c , cmd ) ) return REDIS_ERR ; call ( c , cmd ) ; } return REDIS_OK ; }
Fixed code:","
int processCommand ( redisClient * c ) { if ( ! c ) { return REDIS_ERR ; } struct redisCommand * cmd ; char * cmd_str = ( char * ) c -> argv [ 0 ] -> ptr ; if ( ! cmd_str || strlen ( cmd_str ) == 0 ) { return REDIS_ERR ; } if ( ! strcasecmp ( cmd_str , ""quit"" ) ) { addReply ( c , shared . ok ) ; c -> flags |= REDIS_CLOSE_AFTER_REPLY ; return REDIS_ERR ; } cmd = lookupCommand ( cmd_str ) ; if ( ! cmd ) { addReplyErrorFormat ( c , ""unknown command \'%s\'"" , cmd_str ) ; return REDIS_OK ; } else if ( ( cmd -> arity > 0 && cmd -> arity != c -> argc ) || ( c -> argc < - cmd -> arity ) ) { addReplyErrorFormat ( c , ""wrong number of arguments for \'%s\' command"" , cmd -> name ) ; return REDIS_OK ; } if ( server . requirepass && ! c -> authenticated && cmd -> proc != authCommand ) { addReplyError ( c , ""operation not permitted"" ) ; return REDIS_OK ; } if ( server . maxmemory ) freeMemoryIfNeeded ( ) ; if ( server . maxmemory && ( cmd -> flags & REDIS_CMD_DENYOOM ) && zmalloc_used_memory ( ) > server . maxmemory ) { addReplyError ( c , ""command not allowed when used memory > \'maxmemory\'"" ) ; return REDIS_OK ; } if ( ( dictSize ( c -> pubsub_channels ) > 0 || listLength ( c -> pubsub_patterns ) > 0 ) && cmd -> proc != subscribeCommand && cmd -> proc != unsubscribeCommand && cmd -> proc != psubscribeCommand && cmd -> proc != punsubscribeCommand ) { addReplyError ( c , ""only (P)SUBSCRIBE / (P)UNSUBSCRIBE / QUIT allowed in this context"" ) ; return REDIS_OK ; } if ( server . masterhost && server . replstate != REDIS_REPL_CONNECTED && server . repl_serve_stale_data == 0 && cmd -> proc != infoCommand && cmd -> proc != slaveofCommand ) { addReplyError ( c , ""link with MASTER is down and slave-serve-stale-data is set to no"" ) ; return REDIS_OK ; } if ( server . loading && cmd -> proc != infoCommand ) { addReply ( c , shared . loadingerr ) ; return REDIS_OK ; } if ( c -> flags & REDIS_MULTI && cmd -> proc != execCommand && cmd -> proc != discardCommand && cmd -> proc != multiCommand && cmd -> proc != watchCommand ) { queueMultiCommand ( c , cmd ) ; addReply ( c , shared . queued ) ; } else { if ( server . vm_enabled && server . vm_max_threads > 0 && blockClientOnSwappedKeys ( c , cmd ) ) return REDIS_ERR ; call ( c , cmd ) ; } return REDIS_OK ; }",715,-22.99259687627407,-0.032157478148635066
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int processCommand ( redisClient * c ) { struct redisCommand * cmd ; if ( ! strcasecmp ( c -> argv [ 0 ] -> ptr , ""quit"" ) ) { addReply ( c , shared . ok ) ; c -> flags |= REDIS_CLOSE_AFTER_REPLY ; return REDIS_ERR ; } cmd = lookupCommand ( c -> argv [ 0 ] -> ptr ) ; if ( ! cmd ) { addReplyErrorFormat ( c , ""unknown command \'%s\'"" , ( char * ) c -> argv [ 0 ] -> ptr ) ; return REDIS_OK ; } else if ( ( cmd -> arity > 0 && cmd -> arity != c -> argc ) || ( c -> argc < - cmd -> arity ) ) { addReplyErrorFormat ( c , ""wrong number of arguments for \'%s\' command"" , cmd -> name ) ; return REDIS_OK ; } if ( server . requirepass && ! c -> authenticated && cmd -> proc != authCommand ) { addReplyError ( c , ""operation not permitted"" ) ; return REDIS_OK ; } if ( server . maxmemory ) freeMemoryIfNeeded ( ) ; if ( server . maxmemory && ( cmd -> flags & REDIS_CMD_DENYOOM ) && zmalloc_used_memory ( ) > server . maxmemory ) { addReplyError ( c , ""command not allowed when used memory > \'maxmemory\'"" ) ; return REDIS_OK ; } if ( ( dictSize ( c -> pubsub_channels ) > 0 || listLength ( c -> pubsub_patterns ) > 0 ) && cmd -> proc != subscribeCommand && cmd -> proc != unsubscribeCommand && cmd -> proc != psubscribeCommand && cmd -> proc != punsubscribeCommand ) { addReplyError ( c , ""only (P)SUBSCRIBE / (P)UNSUBSCRIBE / QUIT allowed in this context"" ) ; return REDIS_OK ; } if ( server . masterhost && server . replstate != REDIS_REPL_CONNECTED && server . repl_serve_stale_data == 0 && cmd -> proc != infoCommand && cmd -> proc != slaveofCommand ) { addReplyError ( c , ""link with MASTER is down and slave-serve-stale-data is set to no"" ) ; return REDIS_OK ; } if ( server . loading && cmd -> proc != infoCommand ) { addReply ( c , shared . loadingerr ) ; return REDIS_OK ; } if ( c -> flags & REDIS_MULTI && cmd -> proc != execCommand && cmd -> proc != discardCommand && cmd -> proc != multiCommand && cmd -> proc != watchCommand ) { queueMultiCommand ( c , cmd ) ; addReply ( c , shared . queued ) ; } else { if ( server . vm_enabled && server . vm_max_threads > 0 && blockClientOnSwappedKeys ( c , cmd ) ) return REDIS_ERR ; call ( c , cmd ) ; } return REDIS_OK ; }
Fixed code:","
int processCommand ( redisClient * c ) { struct redisCommand * cmd ; 

// Add input validation 
if (c->argv[0] == NULL || c->argv[0]->ptr == NULL) {
    addReplyErrorFormat(c, ""Invalid input given"");
    return REDIS_ERR;
}

if ( ! strcasecmp ( c -> argv [ 0 ] -> ptr , ""quit"" ) ) { addReply ( c , shared . ok ) ; c -> flags |= REDIS_CLOSE_AFTER_REPLY ; return REDIS_ERR ; } cmd = lookupCommand ( c -> argv [ 0 ] -> ptr ) ; if ( ! cmd ) { addReplyErrorFormat ( c , ""unknown command \'%s\'"" , ( char * ) c -> argv [ 0 ] -> ptr ) ; return REDIS_OK ; } else if ( ( cmd -> arity > 0 && cmd -> arity != c -> argc ) || ( c -> argc < - cmd -> arity ) ) { addReplyErrorFormat ( c , ""wrong number of arguments for \'%s\' command"" , cmd -> name ) ; return REDIS_OK ; } if ( server . requirepass && ! c -> authenticated && cmd -> proc != authCommand ) { addReplyError ( c , ""operation not permitted"" ) ; return REDIS_OK ; } if ( server . maxmemory ) freeMemoryIfNeeded ( ) ; if ( server . maxmemory && ( cmd -> flags & REDIS_CMD_DENYOOM ) && zmalloc_used_memory ( ) > server . maxmemory ) { addReplyError ( c , ""command not allowed when used memory > \'maxmemory\'"" ) ; return REDIS_OK ; } if ( ( dictSize ( c -> pubsub_channels ) > 0 || listLength ( c -> pubsub_patterns ) > 0 ) && cmd -> proc != subscribeCommand && cmd -> proc != unsubscribeCommand && cmd -> proc != psubscribeCommand && cmd -> proc != punsubscribeCommand ) { addReplyError ( c , ""only (P)SUBSCRIBE / (P)UNSUBSCRIBE / QUIT allowed in this context"" ) ; return REDIS_OK ; } if ( server . masterhost && server . replstate != REDIS_REPL_CONNECTED && server . repl_serve_stale_data == 0 && cmd -> proc != infoCommand && cmd -> proc != slaveofCommand ) { addReplyError ( c , ""link with MASTER is down and slave-serve-stale-data is set to no"" ) ; return REDIS_OK ; } if ( server . loading && cmd -> proc != infoCommand ) { addReply ( c , shared . loadingerr ) ; return REDIS_OK ; } if ( c -> flags & REDIS_MULTI && cmd -> proc != execCommand && cmd -> proc != discardCommand && cmd -> proc != multiCommand && cmd -> proc != watchCommand ) { queueMultiCommand ( c , cmd ) ; addReply ( c , shared . queued ) ; } else { if ( server . vm_enabled && server . vm_max_threads > 0 && blockClientOnSwappedKeys ( c , cmd ) ) return REDIS_ERR ; call ( c , cmd ) ; } return REDIS_OK ; }",738,-24.657574736610588,-0.03341134788158616
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int processCommand ( redisClient * c ) { struct redisCommand * cmd ; if ( ! strcasecmp ( c -> argv [ 0 ] -> ptr , ""quit"" ) ) { addReply ( c , shared . ok ) ; c -> flags |= REDIS_CLOSE_AFTER_REPLY ; return REDIS_ERR ; } cmd = lookupCommand ( c -> argv [ 0 ] -> ptr ) ; if ( ! cmd ) { addReplyErrorFormat ( c , ""unknown command \'%s\'"" , ( char * ) c -> argv [ 0 ] -> ptr ) ; return REDIS_OK ; } else if ( ( cmd -> arity > 0 && cmd -> arity != c -> argc ) || ( c -> argc < - cmd -> arity ) ) { addReplyErrorFormat ( c , ""wrong number of arguments for \'%s\' command"" , cmd -> name ) ; return REDIS_OK ; } if ( server . requirepass && ! c -> authenticated && cmd -> proc != authCommand ) { addReplyError ( c , ""operation not permitted"" ) ; return REDIS_OK ; } if ( server . maxmemory ) freeMemoryIfNeeded ( ) ; if ( server . maxmemory && ( cmd -> flags & REDIS_CMD_DENYOOM ) && zmalloc_used_memory ( ) > server . maxmemory ) { addReplyError ( c , ""command not allowed when used memory > \'maxmemory\'"" ) ; return REDIS_OK ; } if ( ( dictSize ( c -> pubsub_channels ) > 0 || listLength ( c -> pubsub_patterns ) > 0 ) && cmd -> proc != subscribeCommand && cmd -> proc != unsubscribeCommand && cmd -> proc != psubscribeCommand && cmd -> proc != punsubscribeCommand ) { addReplyError ( c , ""only (P)SUBSCRIBE / (P)UNSUBSCRIBE / QUIT allowed in this context"" ) ; return REDIS_OK ; } if ( server . masterhost && server . replstate != REDIS_REPL_CONNECTED && server . repl_serve_stale_data == 0 && cmd -> proc != infoCommand && cmd -> proc != slaveofCommand ) { addReplyError ( c , ""link with MASTER is down and slave-serve-stale-data is set to no"" ) ; return REDIS_OK ; } if ( server . loading && cmd -> proc != infoCommand ) { addReply ( c , shared . loadingerr ) ; return REDIS_OK ; } if ( c -> flags & REDIS_MULTI && cmd -> proc != execCommand && cmd -> proc != discardCommand && cmd -> proc != multiCommand && cmd -> proc != watchCommand ) { queueMultiCommand ( c , cmd ) ; addReply ( c , shared . queued ) ; } else { if ( server . vm_enabled && server . vm_max_threads > 0 && blockClientOnSwappedKeys ( c , cmd ) ) return REDIS_ERR ; call ( c , cmd ) ; } return REDIS_OK ; }
Fixed code:","
int processCommand ( redisClient * c ) { struct redisCommand * cmd ; // Validate argument if ( ! c -> argv [ 0 ] || ! c -> argv [ 0 ] -> ptr ) return REDIS_ERR ; if ( ! strcasecmp ( c -> argv [ 0 ] -> ptr , ""quit"" ) ) { addReply ( c , shared . ok ) ; c -> flags |= REDIS_CLOSE_AFTER_REPLY ; return REDIS_ERR ; } // Validate command cmd = lookupCommand ( c -> argv [ 0 ] -> ptr ) ; if ( ! cmd ) { addReplyErrorFormat ( c , ""unknown command \'%s\'"" , ( char * ) c -> argv [ 0 ] -> ptr ) ; return REDIS_OK ; } else if ( ( cmd -> arity > 0 && cmd -> arity != c -> argc ) || ( c -> argc < - cmd -> arity ) ) { addReplyErrorFormat ( c , ""wrong number of arguments for \'%s\' command"" , cmd -> name ) ; return REDIS_OK ; } if ( server . requirepass && ! c -> authenticated && cmd -> proc != authCommand ) { addReplyError ( c , ""operation not permitted"" ) ; return REDIS_OK ; } if ( server . maxmemory ) freeMemoryIfNeeded ( ) ; if ( server . maxmemory && ( cmd -> flags & REDIS_CMD_DENYOOM ) && zmalloc_used_memory ( ) > server . maxmemory ) { addReplyError ( c , ""command not allowed when used memory > \'maxmemory\'"" ) ; return REDIS_OK ; } if ( ( dictSize ( c -> pubsub_channels ) > 0 || listLength ( c -> pubsub_patterns ) > 0 ) && cmd -> proc != subscribeCommand && cmd -> proc != unsubscribeCommand && cmd -> proc != psubscribeCommand && cmd -> proc != punsubscribeCommand ) { addReplyError ( c , ""only (P)SUBSCRIBE / (P)UNSUBSCRIBE / QUIT allowed in this context"" ) ; return REDIS_OK ; } if ( server . masterhost && server . replstate != REDIS_REPL_CONNECTED && server . repl_serve_stale_data == 0 && cmd -> proc != infoCommand && cmd -> proc != slaveofCommand ) { addReplyError ( c , ""link with MASTER is down and slave-serve-stale-data is set to no"" ) ; return REDIS_OK ; } if ( server . loading && cmd -> proc != infoCommand ) { addReply ( c , shared . loadingerr ) ; return REDIS_OK ; } if ( c -> flags & REDIS_MULTI && cmd -> proc != execCommand && cmd -> proc != discardCommand && cmd -> proc != multiCommand && cmd -> proc != watchCommand ) { queueMultiCommand ( c , cmd ) ; addReply ( c , shared . queued ) ; } else { if ( server . vm_enabled && server . vm_max_threads > 0 && blockClientOnSwappedKeys ( c , cmd ) ) return REDIS_ERR ; call ( c , cmd ) ; } return REDIS_OK ; }",714,-20.026029013656192,-0.028047659682991867
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int processCommand ( redisClient * c ) { struct redisCommand * cmd ; if ( ! strcasecmp ( c -> argv [ 0 ] -> ptr , ""quit"" ) ) { addReply ( c , shared . ok ) ; c -> flags |= REDIS_CLOSE_AFTER_REPLY ; return REDIS_ERR ; } cmd = lookupCommand ( c -> argv [ 0 ] -> ptr ) ; if ( ! cmd ) { addReplyErrorFormat ( c , ""unknown command \'%s\'"" , ( char * ) c -> argv [ 0 ] -> ptr ) ; return REDIS_OK ; } else if ( ( cmd -> arity > 0 && cmd -> arity != c -> argc ) || ( c -> argc < - cmd -> arity ) ) { addReplyErrorFormat ( c , ""wrong number of arguments for \'%s\' command"" , cmd -> name ) ; return REDIS_OK ; } if ( server . requirepass && ! c -> authenticated && cmd -> proc != authCommand ) { addReplyError ( c , ""operation not permitted"" ) ; return REDIS_OK ; } if ( server . maxmemory ) freeMemoryIfNeeded ( ) ; if ( server . maxmemory && ( cmd -> flags & REDIS_CMD_DENYOOM ) && zmalloc_used_memory ( ) > server . maxmemory ) { addReplyError ( c , ""command not allowed when used memory > \'maxmemory\'"" ) ; return REDIS_OK ; } if ( ( dictSize ( c -> pubsub_channels ) > 0 || listLength ( c -> pubsub_patterns ) > 0 ) && cmd -> proc != subscribeCommand && cmd -> proc != unsubscribeCommand && cmd -> proc != psubscribeCommand && cmd -> proc != punsubscribeCommand ) { addReplyError ( c , ""only (P)SUBSCRIBE / (P)UNSUBSCRIBE / QUIT allowed in this context"" ) ; return REDIS_OK ; } if ( server . masterhost && server . replstate != REDIS_REPL_CONNECTED && server . repl_serve_stale_data == 0 && cmd -> proc != infoCommand && cmd -> proc != slaveofCommand ) { addReplyError ( c , ""link with MASTER is down and slave-serve-stale-data is set to no"" ) ; return REDIS_OK ; } if ( server . loading && cmd -> proc != infoCommand ) { addReply ( c , shared . loadingerr ) ; return REDIS_OK ; } if ( c -> flags & REDIS_MULTI && cmd -> proc != execCommand && cmd -> proc != discardCommand && cmd -> proc != multiCommand && cmd -> proc != watchCommand ) { queueMultiCommand ( c , cmd ) ; addReply ( c , shared . queued ) ; } else { if ( server . vm_enabled && server . vm_max_threads > 0 && blockClientOnSwappedKeys ( c , cmd ) ) return REDIS_ERR ; call ( c , cmd ) ; } return REDIS_OK ; }
Fixed code:","
int processCommand ( redisClient * c ) { struct redisCommand * cmd ; 

//Check if input is valid
if ( ! c->argv[0] || ! c->argv[0]->ptr ) {
    addReplyError(c, ""invalid command"");
    return REDIS_OK;
}

if ( ! strcasecmp ( c -> argv [ 0 ] -> ptr , ""quit"" ) ) { 
    addReply ( c , shared . ok ) ; 
    c -> flags |= REDIS_CLOSE_AFTER_REPLY ; 
    return REDIS_ERR ; 
} 

cmd = lookupCommand ( c -> argv [ 0 ] -> ptr ) ; 
if ( ! cmd ) { 
    addReplyErrorFormat ( c , ""unknown command \'%s\'"" , ( char * ) c -> argv [ 0 ] -> ptr ) ; 
    return REDIS_OK ; 
} else if ( ( cmd -> arity > 0 && cmd -> arity != c -> argc ) || ( c -> argc < - cmd -> arity ) ) { 
    addReplyErrorFormat ( c , ""wrong number of arguments for \'%s\' command"" , cmd -> name ) ; 
    return REDIS_OK ; 
} 

if ( server . requirepass && ! c -> authenticated && cmd -> proc != authCommand ) { 
    addReplyError ( c , ""operation not permitted"" ) ; 
    return REDIS_OK ; 
} 

if ( server . maxmemory ) freeMemoryIfNeeded ( ) ; 
if ( server . maxmemory && ( cmd -> flags & REDIS_CMD_DENYOOM ) && zmalloc_used_memory ( ) > server . maxmemory ) { 
    addReplyError ( c , ""command not allowed when used memory > \'maxmemory\'"" ) ; 
    return REDIS_OK ; 
} 

if ( ( dictSize ( c -> pubsub_channels ) > 0 || listLength ( c -> pubsub_patterns ) > 0 ) && cmd -> proc != subscribeCommand && cmd -> proc != unsubscribeCommand && cmd -> proc != psubscribeCommand && cmd -> proc != punsubscribeCommand ) { 
    addReplyError ( c , ""only (P)SUBSCRIBE / (P)UNSUBSCRIBE / QUIT allowed in this context"" ) ; 
    return REDIS_OK ; 
} 

if ( server . masterhost && server . replstate != REDIS_REPL_CONNECTED && server . repl_serve_stale_data == 0 && cmd -> proc != infoCommand && cmd -> proc != slaveofCommand ) { 
    addReplyError ( c , ""link with MASTER is down and slave-serve-stale-data is set to no"" ) ; 
    return REDIS_OK ; 
} 

if ( server . loading && cmd -> proc != infoCommand ) { 
    addReply ( c , shared . loadingerr ) ; 
    return REDIS_OK ; 
} 

if ( c -> flags & REDIS_MULTI && cmd -> proc != execCommand && cmd -> proc != discardCommand && cmd -> proc != multiCommand && cmd -> proc != watchCommand ) { 
    queueMultiCommand ( c , cmd ) ; 
    addReply ( c , shared . queued ) ; 
} else { 
    if ( server . vm_enabled && server . vm_max_threads > 0 && blockClientOnSwappedKeys ( c , cmd ) ) return REDIS_ERR ; 
    call ( c , cmd ) ; 
} 
return REDIS_OK ; 
}",847,-25.176341557827932,-0.0297241340706351
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int processCommand ( redisClient * c ) { struct redisCommand * cmd ; if ( ! strcasecmp ( c -> argv [ 0 ] -> ptr , ""quit"" ) ) { addReply ( c , shared . ok ) ; c -> flags |= REDIS_CLOSE_AFTER_REPLY ; return REDIS_ERR ; } cmd = lookupCommand ( c -> argv [ 0 ] -> ptr ) ; if ( ! cmd ) { addReplyErrorFormat ( c , ""unknown command \'%s\'"" , ( char * ) c -> argv [ 0 ] -> ptr ) ; return REDIS_OK ; } else if ( ( cmd -> arity > 0 && cmd -> arity != c -> argc ) || ( c -> argc < - cmd -> arity ) ) { addReplyErrorFormat ( c , ""wrong number of arguments for \'%s\' command"" , cmd -> name ) ; return REDIS_OK ; } if ( server . requirepass && ! c -> authenticated && cmd -> proc != authCommand ) { addReplyError ( c , ""operation not permitted"" ) ; return REDIS_OK ; } if ( server . maxmemory ) freeMemoryIfNeeded ( ) ; if ( server . maxmemory && ( cmd -> flags & REDIS_CMD_DENYOOM ) && zmalloc_used_memory ( ) > server . maxmemory ) { addReplyError ( c , ""command not allowed when used memory > \'maxmemory\'"" ) ; return REDIS_OK ; } if ( ( dictSize ( c -> pubsub_channels ) > 0 || listLength ( c -> pubsub_patterns ) > 0 ) && cmd -> proc != subscribeCommand && cmd -> proc != unsubscribeCommand && cmd -> proc != psubscribeCommand && cmd -> proc != punsubscribeCommand ) { addReplyError ( c , ""only (P)SUBSCRIBE / (P)UNSUBSCRIBE / QUIT allowed in this context"" ) ; return REDIS_OK ; } if ( server . masterhost && server . replstate != REDIS_REPL_CONNECTED && server . repl_serve_stale_data == 0 && cmd -> proc != infoCommand && cmd -> proc != slaveofCommand ) { addReplyError ( c , ""link with MASTER is down and slave-serve-stale-data is set to no"" ) ; return REDIS_OK ; } if ( server . loading && cmd -> proc != infoCommand ) { addReply ( c , shared . loadingerr ) ; return REDIS_OK ; } if ( c -> flags & REDIS_MULTI && cmd -> proc != execCommand && cmd -> proc != discardCommand && cmd -> proc != multiCommand && cmd -> proc != watchCommand ) { queueMultiCommand ( c , cmd ) ; addReply ( c , shared . queued ) ; } else { if ( server . vm_enabled && server . vm_max_threads > 0 && blockClientOnSwappedKeys ( c , cmd ) ) return REDIS_ERR ; call ( c , cmd ) ; } return REDIS_OK ; }
Fixed code:","
int processCommand ( redisClient * c ) {
  struct redisCommand * cmd ;
  int i ;
  if ( ! c -> argc || c -> argv [ 0 ] -> len == 0 ) {
    addReplyError ( c , ""wrong number of arguments for \'\' command"" ) ;
    return REDIS_OK ;
  }
  if ( ! strcasecmp ( c -> argv [ 0 ] -> ptr , ""quit"" ) ) {
    addReply ( c , shared . ok ) ;
    c -> flags |= REDIS_CLOSE_AFTER_REPLY ;
    return REDIS_ERR ;
  }
  cmd = lookupCommand ( c -> argv [ 0 ] -> ptr ) ;
  if ( ! cmd ) {
    addReplyErrorFormat ( c , ""unknown command \'%s\'"" , ( char * ) c -> argv [ 0 ] -> ptr ) ;
    return REDIS_OK ;
  } else if ( ( cmd -> arity > 0 && cmd -> arity != c -> argc ) || ( c -> argc < - cmd -> arity ) ) {
    addReplyErrorFormat ( c , ""wrong number of arguments for \'%s\' command"" , cmd -> name ) ;
    return REDIS_OK ;
  }
  for ( i = 0 ; i < c -> argc ; i ++ ) {
    if ( ! c -> argv [ i ] -> len || ! c -> argv [ i ] -> ptr ) {
      addReplyErrorFormat ( c , ""wrong number of arguments for \'%s\' command"" , cmd -> name ) ;
      return REDIS_OK ;
    }
  }
  if ( server . requirepass && ! c -> authenticated && cmd -> proc != authCommand ) {
    addReplyError ( c , ""operation not permitted"" ) ;
    return REDIS_OK ;
  }
  if ( server . maxmemory ) freeMemoryIfNeeded ( ) ;
  if ( server . maxmemory && ( cmd -> flags & REDIS_CMD_DENYOOM ) && zmalloc_used_memory ( ) > server . maxmemory ) {
    addReplyError ( c , ""command not allowed when used memory > \'maxmemory\'"" ) ;
    return REDIS_OK ;
  }
  if ( ( dictSize ( c -> pubsub_channels ) > 0 || listLength ( c -> pubsub_patterns ) > 0 ) && cmd -> proc != subscribeCommand && cmd -> proc != unsubscribeCommand && cmd -> proc != psubscribeCommand && cmd -> proc != punsubscribeCommand ) {
    addReplyError ( c , ""only (P)SUBSCRIBE / (P)UNSUBSCRIBE / QUIT allowed in this context"" ) ;
    return REDIS_OK ;
  }
  if ( server . masterhost && server . replstate != REDIS_REPL_CONNECTED && server . repl_serve_stale_data == 0 && cmd -> proc != infoCommand && cmd -> proc != slaveofCommand ) {
    addReplyError ( c , ""link with MASTER is down and slave-serve-stale-data is set to no"" ) ;
    return REDIS_OK ;
  }
  if ( server . loading && cmd -> proc != infoCommand ) {
    addReply ( c , shared . loadingerr ) ;
    return REDIS_OK ;
  }
  if ( c -> flags & REDIS_MULTI && cmd -> proc != execCommand && cmd -> proc != discardCommand && cmd -> proc != multiCommand && cmd -> proc != watchCommand ) {
    queueMultiCommand ( c , cmd ) ;
    addReply ( c , shared . queued ) ;
  } else {
    if ( server . vm_enabled && server . vm_max_threads > 0 && blockClientOnSwappedKeys ( c , cmd ) ) return REDIS_ERR ;
    call ( c , cmd ) ;
  }
  return REDIS_OK ;
}",910,-36.647913118356136,-0.04027243199819356
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int processCommand ( redisClient * c ) { struct redisCommand * cmd ; if ( ! strcasecmp ( c -> argv [ 0 ] -> ptr , ""quit"" ) ) { addReply ( c , shared . ok ) ; c -> flags |= REDIS_CLOSE_AFTER_REPLY ; return REDIS_ERR ; } cmd = lookupCommand ( c -> argv [ 0 ] -> ptr ) ; if ( ! cmd ) { addReplyErrorFormat ( c , ""unknown command \'%s\'"" , ( char * ) c -> argv [ 0 ] -> ptr ) ; return REDIS_OK ; } else if ( ( cmd -> arity > 0 && cmd -> arity != c -> argc ) || ( c -> argc < - cmd -> arity ) ) { addReplyErrorFormat ( c , ""wrong number of arguments for \'%s\' command"" , cmd -> name ) ; return REDIS_OK ; } if ( server . requirepass && ! c -> authenticated && cmd -> proc != authCommand ) { addReplyError ( c , ""operation not permitted"" ) ; return REDIS_OK ; } if ( server . maxmemory ) freeMemoryIfNeeded ( ) ; if ( server . maxmemory && ( cmd -> flags & REDIS_CMD_DENYOOM ) && zmalloc_used_memory ( ) > server . maxmemory ) { addReplyError ( c , ""command not allowed when used memory > \'maxmemory\'"" ) ; return REDIS_OK ; } if ( ( dictSize ( c -> pubsub_channels ) > 0 || listLength ( c -> pubsub_patterns ) > 0 ) && cmd -> proc != subscribeCommand && cmd -> proc != unsubscribeCommand && cmd -> proc != psubscribeCommand && cmd -> proc != punsubscribeCommand ) { addReplyError ( c , ""only (P)SUBSCRIBE / (P)UNSUBSCRIBE / QUIT allowed in this context"" ) ; return REDIS_OK ; } if ( server . masterhost && server . replstate != REDIS_REPL_CONNECTED && server . repl_serve_stale_data == 0 && cmd -> proc != infoCommand && cmd -> proc != slaveofCommand ) { addReplyError ( c , ""link with MASTER is down and slave-serve-stale-data is set to no"" ) ; return REDIS_OK ; } if ( server . loading && cmd -> proc != infoCommand ) { addReply ( c , shared . loadingerr ) ; return REDIS_OK ; } if ( c -> flags & REDIS_MULTI && cmd -> proc != execCommand && cmd -> proc != discardCommand && cmd -> proc != multiCommand && cmd -> proc != watchCommand ) { queueMultiCommand ( c , cmd ) ; addReply ( c , shared . queued ) ; } else { if ( server . vm_enabled && server . vm_max_threads > 0 && blockClientOnSwappedKeys ( c , cmd ) ) return REDIS_ERR ; call ( c , cmd ) ; } return REDIS_OK ; }
Fixed code:","
int processCommand ( redisClient * c ) { 
	struct redisCommand * cmd ; 
	if ( c -> argv [ 0 ] -> len > 128 ) {
		addReplyError ( c , ""command too long"" ) ;
		return REDIS_OK ;
	}
	if ( ! strcasecmp ( c -> argv [ 0 ] -> ptr , ""quit"" ) ) { 
		addReply ( c , shared . ok ) ; 
		c -> flags |= REDIS_CLOSE_AFTER_REPLY ; 
		return REDIS_ERR ; 
	} 
	cmd = lookupCommand ( c -> argv [ 0 ] -> ptr ) ; 
	if ( ! cmd ) { 
		addReplyErrorFormat ( c , ""unknown command \'%s\'"" , ( char * ) c -> argv [ 0 ] -> ptr ) ; 
		return REDIS_OK ; 
	} else if ( ( cmd -> arity > 0 && cmd -> arity != c -> argc ) || ( c -> argc < - cmd -> arity ) ) { 
		addReplyErrorFormat ( c , ""wrong number of arguments for \'%s\' command"" , cmd -> name ) ; 
		return REDIS_OK ; 
	} 
	if ( server . requirepass && ! c -> authenticated && cmd -> proc != authCommand ) { 
		addReplyError ( c , ""operation not permitted"" ) ; 
		return REDIS_OK ; 
	} 
	if ( server . maxmemory ) freeMemoryIfNeeded ( ) ; 
	if ( server . maxmemory && ( cmd -> flags & REDIS_CMD_DENYOOM ) && zmalloc_used_memory ( ) > server . maxmemory ) { 
		addReplyError ( c , ""command not allowed when used memory > \'maxmemory\'"" ) ; 
		return REDIS_OK ; 
	} 
	if ( ( dictSize ( c -> pubsub_channels ) > 0 || listLength ( c -> pubsub_patterns ) > 0 ) && cmd -> proc != subscribeCommand && cmd -> proc != unsubscribeCommand && cmd -> proc != psubscribeCommand && cmd -> proc != punsubscribeCommand ) { 
		addReplyError ( c , ""only (P)SUBSCRIBE / (P)UNSUBSCRIBE / QUIT allowed in this context"" ) ; 
		return REDIS_OK ; 
	} 
	if ( server . masterhost && server . replstate != REDIS_REPL_CONNECTED && server . repl_serve_stale_data == 0 && cmd -> proc != infoCommand && cmd -> proc != slaveofCommand ) { 
		addReplyError ( c , ""link with MASTER is down and slave-serve-stale-data is set to no"" ) ; 
		return REDIS_OK ; 
	} 
	if ( server . loading && cmd -> proc != infoCommand ) { 
		addReply ( c , shared . loadingerr ) ; 
		return REDIS_OK ; 
	} 
	if ( c -> flags & REDIS_MULTI && cmd -> proc != execCommand && cmd -> proc != discardCommand && cmd -> proc != multiCommand && cmd -> proc != watchCommand ) { 
		queueMultiCommand ( c , cmd ) ; 
		addReply ( c , shared . queued ) ; 
	} else { 
		if ( server . vm_enabled && server . vm_max_threads > 0 && blockClientOnSwappedKeys ( c , cmd ) ) return REDIS_ERR ; 
		call ( c , cmd ) ; 
	} 
	return REDIS_OK ; 
}",874,-19.286728567115258,-0.022067195156882446
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int processCommand ( redisClient * c ) { struct redisCommand * cmd ; if ( ! strcasecmp ( c -> argv [ 0 ] -> ptr , ""quit"" ) ) { addReply ( c , shared . ok ) ; c -> flags |= REDIS_CLOSE_AFTER_REPLY ; return REDIS_ERR ; } cmd = lookupCommand ( c -> argv [ 0 ] -> ptr ) ; if ( ! cmd ) { addReplyErrorFormat ( c , ""unknown command \'%s\'"" , ( char * ) c -> argv [ 0 ] -> ptr ) ; return REDIS_OK ; } else if ( ( cmd -> arity > 0 && cmd -> arity != c -> argc ) || ( c -> argc < - cmd -> arity ) ) { addReplyErrorFormat ( c , ""wrong number of arguments for \'%s\' command"" , cmd -> name ) ; return REDIS_OK ; } if ( server . requirepass && ! c -> authenticated && cmd -> proc != authCommand ) { addReplyError ( c , ""operation not permitted"" ) ; return REDIS_OK ; } if ( server . maxmemory ) freeMemoryIfNeeded ( ) ; if ( server . maxmemory && ( cmd -> flags & REDIS_CMD_DENYOOM ) && zmalloc_used_memory ( ) > server . maxmemory ) { addReplyError ( c , ""command not allowed when used memory > \'maxmemory\'"" ) ; return REDIS_OK ; } if ( ( dictSize ( c -> pubsub_channels ) > 0 || listLength ( c -> pubsub_patterns ) > 0 ) && cmd -> proc != subscribeCommand && cmd -> proc != unsubscribeCommand && cmd -> proc != psubscribeCommand && cmd -> proc != punsubscribeCommand ) { addReplyError ( c , ""only (P)SUBSCRIBE / (P)UNSUBSCRIBE / QUIT allowed in this context"" ) ; return REDIS_OK ; } if ( server . masterhost && server . replstate != REDIS_REPL_CONNECTED && server . repl_serve_stale_data == 0 && cmd -> proc != infoCommand && cmd -> proc != slaveofCommand ) { addReplyError ( c , ""link with MASTER is down and slave-serve-stale-data is set to no"" ) ; return REDIS_OK ; } if ( server . loading && cmd -> proc != infoCommand ) { addReply ( c , shared . loadingerr ) ; return REDIS_OK ; } if ( c -> flags & REDIS_MULTI && cmd -> proc != execCommand && cmd -> proc != discardCommand && cmd -> proc != multiCommand && cmd -> proc != watchCommand ) { queueMultiCommand ( c , cmd ) ; addReply ( c , shared . queued ) ; } else { if ( server . vm_enabled && server . vm_max_threads > 0 && blockClientOnSwappedKeys ( c , cmd ) ) return REDIS_ERR ; call ( c , cmd ) ; } return REDIS_OK ; }
Fixed code:","
int processCommand ( redisClient * c ) { struct redisCommand * cmd ; if ( ! strcasecmp ( c -> argv [ 0 ] -> ptr , ""quit"" ) ) { addReply ( c , shared . ok ) ; c -> flags |= REDIS_CLOSE_AFTER_REPLY ; return REDIS_ERR ; } if ( c -> argv [ 0 ] -> len > REDIS_MAX_COMMAND_SIZE ) { addReplyError(c, ""Command too long""); return REDIS_OK; } cmd = lookupCommand ( c -> argv [ 0 ] -> ptr ) ; if ( ! cmd ) { addReplyErrorFormat ( c , ""unknown command \'%s\'"" , ( char * ) c -> argv [ 0 ] -> ptr ) ; return REDIS_OK ; } else if ( ( cmd -> arity > 0 && cmd -> arity != c -> argc ) || ( c -> argc < - cmd -> arity ) ) { addReplyErrorFormat ( c , ""wrong number of arguments for \'%s\' command"" , cmd -> name ) ; return REDIS_OK ; } if ( server . requirepass && ! c -> authenticated && cmd -> proc != authCommand ) { addReplyError ( c , ""operation not permitted"" ) ; return REDIS_OK ; } if ( server . maxmemory ) freeMemoryIfNeeded ( ) ; if ( server . maxmemory && ( cmd -> flags & REDIS_CMD_DENYOOM ) && zmalloc_used_memory ( ) > server . maxmemory ) { addReplyError ( c , ""command not allowed when used memory > \'maxmemory\'"" ) ; return REDIS_OK ; } if ( ( dictSize ( c -> pubsub_channels ) > 0 || listLength ( c -> pubsub_patterns ) > 0 ) && cmd -> proc != subscribeCommand && cmd -> proc != unsubscribeCommand && cmd -> proc != psubscribeCommand && cmd -> proc != punsubscribeCommand ) { addReplyError ( c , ""only (P)SUBSCRIBE / (P)UNSUBSCRIBE / QUIT allowed in this context"" ) ; return REDIS_OK ; } if ( server . masterhost && server . replstate != REDIS_REPL_CONNECTED && server . repl_serve_stale_data == 0 && cmd -> proc != infoCommand && cmd -> proc != slaveofCommand ) { addReplyError ( c , ""link with MASTER is down and slave-serve-stale-data is set to no"" ) ; return REDIS_OK ; } if ( server . loading && cmd -> proc != infoCommand ) { addReply ( c , shared . loadingerr ) ; return REDIS_OK ; } if ( c -> flags & REDIS_MULTI && cmd -> proc != execCommand && cmd -> proc != discardCommand && cmd -> proc != multiCommand && cmd -> proc != watchCommand ) { queueMultiCommand ( c , cmd ) ; addReply ( c , shared . queued ) ; } else { if ( server . vm_enabled && server . vm_max_threads > 0 && blockClientOnSwappedKeys ( c , cmd ) ) return REDIS_ERR ; call ( c , cmd ) ; } return REDIS_OK ; }",719,-16.330958205169665,-0.022713432830555862
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int processCommand ( redisClient * c ) { struct redisCommand * cmd ; if ( ! strcasecmp ( c -> argv [ 0 ] -> ptr , ""quit"" ) ) { addReply ( c , shared . ok ) ; c -> flags |= REDIS_CLOSE_AFTER_REPLY ; return REDIS_ERR ; } cmd = lookupCommand ( c -> argv [ 0 ] -> ptr ) ; if ( ! cmd ) { addReplyErrorFormat ( c , ""unknown command \'%s\'"" , ( char * ) c -> argv [ 0 ] -> ptr ) ; return REDIS_OK ; } else if ( ( cmd -> arity > 0 && cmd -> arity != c -> argc ) || ( c -> argc < - cmd -> arity ) ) { addReplyErrorFormat ( c , ""wrong number of arguments for \'%s\' command"" , cmd -> name ) ; return REDIS_OK ; } if ( server . requirepass && ! c -> authenticated && cmd -> proc != authCommand ) { addReplyError ( c , ""operation not permitted"" ) ; return REDIS_OK ; } if ( server . maxmemory ) freeMemoryIfNeeded ( ) ; if ( server . maxmemory && ( cmd -> flags & REDIS_CMD_DENYOOM ) && zmalloc_used_memory ( ) > server . maxmemory ) { addReplyError ( c , ""command not allowed when used memory > \'maxmemory\'"" ) ; return REDIS_OK ; } if ( ( dictSize ( c -> pubsub_channels ) > 0 || listLength ( c -> pubsub_patterns ) > 0 ) && cmd -> proc != subscribeCommand && cmd -> proc != unsubscribeCommand && cmd -> proc != psubscribeCommand && cmd -> proc != punsubscribeCommand ) { addReplyError ( c , ""only (P)SUBSCRIBE / (P)UNSUBSCRIBE / QUIT allowed in this context"" ) ; return REDIS_OK ; } if ( server . masterhost && server . replstate != REDIS_REPL_CONNECTED && server . repl_serve_stale_data == 0 && cmd -> proc != infoCommand && cmd -> proc != slaveofCommand ) { addReplyError ( c , ""link with MASTER is down and slave-serve-stale-data is set to no"" ) ; return REDIS_OK ; } if ( server . loading && cmd -> proc != infoCommand ) { addReply ( c , shared . loadingerr ) ; return REDIS_OK ; } if ( c -> flags & REDIS_MULTI && cmd -> proc != execCommand && cmd -> proc != discardCommand && cmd -> proc != multiCommand && cmd -> proc != watchCommand ) { queueMultiCommand ( c , cmd ) ; addReply ( c , shared . queued ) ; } else { if ( server . vm_enabled && server . vm_max_threads > 0 && blockClientOnSwappedKeys ( c , cmd ) ) return REDIS_ERR ; call ( c , cmd ) ; } return REDIS_OK ; }
Fixed code:","
int processCommand ( redisClient * c ) { struct redisCommand * cmd ; if ( ! c -> argv [ 0 ] -> ptr || ! strcasecmp ( c -> argv [ 0 ] -> ptr , """" ) || ! c -> argv [ 0 ] -> len ) { addReplyError ( c , ""No command sent."" ) ; return REDIS_ERR ; } else if ( ! strcasecmp ( c -> argv [ 0 ] -> ptr , ""quit"" ) ) { addReply ( c , shared . ok ) ; c -> flags |= REDIS_CLOSE_AFTER_REPLY ; return REDIS_ERR ; } cmd = lookupCommand ( c -> argv [ 0 ] -> ptr ) ; if ( ! cmd ) { addReplyErrorFormat ( c , ""unknown command \'%s\'"" , c -> argv [ 0 ] -> ptr ) ; return REDIS_OK ; } else if ( ( cmd -> arity > 0 && cmd -> arity != c -> argc ) || ( c -> argc < - cmd -> arity ) ) { addReplyErrorFormat ( c , ""wrong number of arguments for \'%s\' command"" , cmd -> name ) ; return REDIS_OK ; } if ( server . requirepass && ! c -> authenticated && cmd -> proc != authCommand ) { addReplyError ( c , ""operation not permitted"" ) ; return REDIS_OK ; } if ( server . maxmemory ) freeMemoryIfNeeded ( ) ; if ( server . maxmemory && ( cmd -> flags & REDIS_CMD_DENYOOM ) && zmalloc_used_memory ( ) > server . maxmemory ) { addReplyError ( c , ""command not allowed when used memory > \'maxmemory\'"" ) ; return REDIS_OK ; } if ( ( dictSize ( c -> pubsub_channels ) > 0 || listLength ( c -> pubsub_patterns ) > 0 ) && cmd -> proc != subscribeCommand && cmd -> proc != unsubscribeCommand && cmd -> proc != psubscribeCommand && cmd -> proc != punsubscribeCommand ) { addReplyError ( c , ""only (P)SUBSCRIBE / (P)UNSUBSCRIBE / QUIT allowed in this context"" ) ; return REDIS_OK ; } if ( server . masterhost && server . replstate != REDIS_REPL_CONNECTED && server . repl_serve_stale_data == 0 && cmd -> proc != infoCommand && cmd -> proc != slaveofCommand ) { addReplyError ( c , ""link with MASTER is down and slave-serve-stale-data is set to no"" ) ; return REDIS_OK ; } if ( server . loading && cmd -> proc != infoCommand ) { addReply ( c , shared . loadingerr ) ; return REDIS_OK ; } if ( c -> flags & REDIS_MULTI && cmd -> proc != execCommand && cmd -> proc != discardCommand && cmd -> proc != multiCommand && cmd -> proc != watchCommand ) { queueMultiCommand ( c , cmd ) ; addReply ( c , shared . queued ) ; } else { if ( server . vm_enabled && server . vm_max_threads > 0 && blockClientOnSwappedKeys ( c , cmd ) ) return REDIS_ERR ; call ( c , cmd ) ; } return REDIS_OK ; }",738,-33.201639112769435,-0.04498867088451143
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int processCommand ( redisClient * c ) { struct redisCommand * cmd ; if ( ! strcasecmp ( c -> argv [ 0 ] -> ptr , ""quit"" ) ) { addReply ( c , shared . ok ) ; c -> flags |= REDIS_CLOSE_AFTER_REPLY ; return REDIS_ERR ; } cmd = lookupCommand ( c -> argv [ 0 ] -> ptr ) ; if ( ! cmd ) { addReplyErrorFormat ( c , ""unknown command \'%s\'"" , ( char * ) c -> argv [ 0 ] -> ptr ) ; return REDIS_OK ; } else if ( ( cmd -> arity > 0 && cmd -> arity != c -> argc ) || ( c -> argc < - cmd -> arity ) ) { addReplyErrorFormat ( c , ""wrong number of arguments for \'%s\' command"" , cmd -> name ) ; return REDIS_OK ; } if ( server . requirepass && ! c -> authenticated && cmd -> proc != authCommand ) { addReplyError ( c , ""operation not permitted"" ) ; return REDIS_OK ; } if ( server . maxmemory ) freeMemoryIfNeeded ( ) ; if ( server . maxmemory && ( cmd -> flags & REDIS_CMD_DENYOOM ) && zmalloc_used_memory ( ) > server . maxmemory ) { addReplyError ( c , ""command not allowed when used memory > \'maxmemory\'"" ) ; return REDIS_OK ; } if ( ( dictSize ( c -> pubsub_channels ) > 0 || listLength ( c -> pubsub_patterns ) > 0 ) && cmd -> proc != subscribeCommand && cmd -> proc != unsubscribeCommand && cmd -> proc != psubscribeCommand && cmd -> proc != punsubscribeCommand ) { addReplyError ( c , ""only (P)SUBSCRIBE / (P)UNSUBSCRIBE / QUIT allowed in this context"" ) ; return REDIS_OK ; } if ( server . masterhost && server . replstate != REDIS_REPL_CONNECTED && server . repl_serve_stale_data == 0 && cmd -> proc != infoCommand && cmd -> proc != slaveofCommand ) { addReplyError ( c , ""link with MASTER is down and slave-serve-stale-data is set to no"" ) ; return REDIS_OK ; } if ( server . loading && cmd -> proc != infoCommand ) { addReply ( c , shared . loadingerr ) ; return REDIS_OK ; } if ( c -> flags & REDIS_MULTI && cmd -> proc != execCommand && cmd -> proc != discardCommand && cmd -> proc != multiCommand && cmd -> proc != watchCommand ) { queueMultiCommand ( c , cmd ) ; addReply ( c , shared . queued ) ; } else { if ( server . vm_enabled && server . vm_max_threads > 0 && blockClientOnSwappedKeys ( c , cmd ) ) return REDIS_ERR ; call ( c , cmd ) ; } return REDIS_OK ; }
Fixed code:","
int processCommand ( redisClient * c ) { 
    struct redisCommand * cmd ; 
    if ( ! c -> argv || c -> argv[0]->len < 1) {
        return REDIS_ERR;
    }

    if ( ! strcasecmp ( c -> argv [ 0 ] -> ptr , ""quit"" ) ) { 
        addReply ( c , shared . ok ) ; 
        c -> flags |= REDIS_CLOSE_AFTER_REPLY ; 
        return REDIS_ERR ; 
    } 

    cmd = lookupCommand ( c -> argv [ 0 ] -> ptr ) ; 
    if ( ! cmd ) { 
        addReplyErrorFormat ( c , ""unknown command \'%s\'"" , ( char * ) c -> argv [ 0 ] -> ptr ) ; 
        return REDIS_OK ; 
    } else if ( ( cmd -> arity > 0 && cmd -> arity != c -> argc ) || ( c -> argc < - cmd -> arity ) ) { 
        addReplyErrorFormat ( c , ""wrong number of arguments for \'%s\' command"" , cmd -> name ) ; 
        return REDIS_OK ; 
    } 
   
    if ( server . requirepass && ! c -> authenticated && cmd -> proc != authCommand ) { 
        addReplyError ( c , ""operation not permitted"" ) ; 
        return REDIS_OK ; 
    } 
    if ( server . maxmemory ) freeMemoryIfNeeded ( ) ; 
    if ( server . maxmemory && ( cmd -> flags & REDIS_CMD_DENYOOM ) && zmalloc_used_memory ( ) > server . maxmemory ) { 
        addReplyError ( c , ""command not allowed when used memory > \'maxmemory\'"" ) ; 
        return REDIS_OK ; 
    } 
    if ( ( dictSize ( c -> pubsub_channels ) > 0 || listLength ( c -> pubsub_patterns ) > 0 ) && cmd -> proc != subscribeCommand && cmd -> proc != unsubscribeCommand && cmd -> proc != psubscribeCommand && cmd -> proc != punsubscribeCommand ) { 
        addReplyError ( c , ""only (P)SUBSCRIBE / (P)UNSUBSCRIBE / QUIT allowed in this context"" ) ; 
        return REDIS_OK ; 
    } 
    if ( server . masterhost && server . replstate != REDIS_REPL_CONNECTED && server . repl_serve_stale_data == 0 && cmd -> proc != infoCommand && cmd -> proc != slaveofCommand ) { 
        addReplyError ( c , ""link with MASTER is down and slave-serve-stale-data is set to no"" ) ; 
        return REDIS_OK ; 
    } 
    if ( server . loading && cmd -> proc != infoCommand ) { 
        addReply ( c , shared . loadingerr ) ; 
        return REDIS_OK ; 
    } 
    if ( c -> flags & REDIS_MULTI && cmd -> proc != execCommand && cmd -> proc != discardCommand && cmd -> proc != multiCommand && cmd -> proc != watchCommand ) { 
        queueMultiCommand ( c , cmd ) ; 
        addReply ( c , shared . queued ) ; 
    } else { 
        if ( server . vm_enabled && server . vm_max_threads > 0 && blockClientOnSwappedKeys ( c , cmd ) ) return REDIS_ERR ; 
        call ( c , cmd ) ; 
    } 
    return REDIS_OK ; 
}",845,-29.815076872744537,-0.035284114642301224
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int processCommand ( redisClient * c ) { struct redisCommand * cmd ; if ( ! strcasecmp ( c -> argv [ 0 ] -> ptr , ""quit"" ) ) { addReply ( c , shared . ok ) ; c -> flags |= REDIS_CLOSE_AFTER_REPLY ; return REDIS_ERR ; } cmd = lookupCommand ( c -> argv [ 0 ] -> ptr ) ; if ( ! cmd ) { addReplyErrorFormat ( c , ""unknown command \'%s\'"" , ( char * ) c -> argv [ 0 ] -> ptr ) ; return REDIS_OK ; } else if ( ( cmd -> arity > 0 && cmd -> arity != c -> argc ) || ( c -> argc < - cmd -> arity ) ) { addReplyErrorFormat ( c , ""wrong number of arguments for \'%s\' command"" , cmd -> name ) ; return REDIS_OK ; } if ( server . requirepass && ! c -> authenticated && cmd -> proc != authCommand ) { addReplyError ( c , ""operation not permitted"" ) ; return REDIS_OK ; } if ( server . maxmemory ) freeMemoryIfNeeded ( ) ; if ( server . maxmemory && ( cmd -> flags & REDIS_CMD_DENYOOM ) && zmalloc_used_memory ( ) > server . maxmemory ) { addReplyError ( c , ""command not allowed when used memory > \'maxmemory\'"" ) ; return REDIS_OK ; } if ( ( dictSize ( c -> pubsub_channels ) > 0 || listLength ( c -> pubsub_patterns ) > 0 ) && cmd -> proc != subscribeCommand && cmd -> proc != unsubscribeCommand && cmd -> proc != psubscribeCommand && cmd -> proc != punsubscribeCommand ) { addReplyError ( c , ""only (P)SUBSCRIBE / (P)UNSUBSCRIBE / QUIT allowed in this context"" ) ; return REDIS_OK ; } if ( server . masterhost && server . replstate != REDIS_REPL_CONNECTED && server . repl_serve_stale_data == 0 && cmd -> proc != infoCommand && cmd -> proc != slaveofCommand ) { addReplyError ( c , ""link with MASTER is down and slave-serve-stale-data is set to no"" ) ; return REDIS_OK ; } if ( server . loading && cmd -> proc != infoCommand ) { addReply ( c , shared . loadingerr ) ; return REDIS_OK ; } if ( c -> flags & REDIS_MULTI && cmd -> proc != execCommand && cmd -> proc != discardCommand && cmd -> proc != multiCommand && cmd -> proc != watchCommand ) { queueMultiCommand ( c , cmd ) ; addReply ( c , shared . queued ) ; } else { if ( server . vm_enabled && server . vm_max_threads > 0 && blockClientOnSwappedKeys ( c , cmd ) ) return REDIS_ERR ; call ( c , cmd ) ; } return REDIS_OK ; }
Fixed code:","
int processCommand ( redisClient * c ) { struct redisCommand * cmd ; 
//Check if command is valid
if(c->argv[0] == NULL || c->argv[0]->ptr == NULL){
    addReplyErrorFormat(c, ""empty command not allowed"");
    return REDIS_OK;
} 
//Check if command is ""quit"" 
if ( ! strcasecmp ( c -> argv [ 0 ] -> ptr , ""quit"" ) ) { 
    addReply ( c , shared . ok ) ; 
    c -> flags |= REDIS_CLOSE_AFTER_REPLY ; 
    return REDIS_ERR ; 
} 
//Lookup command  
cmd = lookupCommand ( c -> argv [ 0 ] -> ptr ) ; 
if ( ! cmd ) { 
    addReplyErrorFormat ( c , ""unknown command \'%s\'"" , ( char * ) c -> argv [ 0 ] -> ptr ) ; 
    return REDIS_OK ; 
} 
//Check arity  
else if ( ( cmd -> arity > 0 && cmd -> arity != c -> argc ) || ( c -> argc < - cmd -> arity ) ) { 
    addReplyErrorFormat ( c , ""wrong number of arguments for \'%s\' command"" , cmd -> name ) ; 
    return REDIS_OK ; 
} 
//Check authentication
if ( server . requirepass && ! c -> authenticated && cmd -> proc != authCommand ) { 
    addReplyError ( c , ""operation not permitted"" ) ; 
    return REDIS_OK ; 
} 
//Check memory  
if ( server . maxmemory ) freeMemoryIfNeeded ( ) ; 
if ( server . maxmemory && ( cmd -> flags & REDIS_CMD_DENYOOM ) && zmalloc_used_memory ( ) > server . maxmemory ) { 
    addReplyError ( c , ""command not allowed when used memory > \'maxmemory\'"" ) ; 
    return REDIS_OK ; 
} 
//Check context 
if ( ( dictSize ( c -> pubsub_channels ) > 0 || listLength ( c -> pubsub_patterns ) > 0 ) && cmd -> proc != subscribeCommand && cmd -> proc != unsubscribeCommand && cmd -> proc != psubscribeCommand && cmd -> proc != punsubscribeCommand ) { 
    addReplyError ( c , ""only (P)SUBSCRIBE / (P)UNSUBSCRIBE / QUIT allowed in this context"" ) ; 
    return REDIS_OK ; 
} 
//Check master 
if ( server . masterhost && server . replstate != REDIS_REPL_CONNECTED && server . repl_serve_stale_data == 0 && cmd -> proc != infoCommand && cmd -> proc != slaveofCommand ) { 
    addReplyError ( c , ""link with MASTER is down and slave-serve-stale-data is set to no"" ) ; 
    return REDIS_OK ; 
} 
//Check loading 
if ( server . loading && cmd -> proc != infoCommand ) { 
    addReply ( c , shared . loadingerr ) ; 
    return REDIS_OK ; 
} 
//Check multi status
if ( c -> flags & REDIS_MULTI && cmd -> proc != execCommand && cmd -> proc != discardCommand && cmd -> proc != multiCommand && cmd -> proc != watchCommand ) { 
    queueMultiCommand ( c , cmd ) ; 
    addReply ( c , shared . queued ) ; 
} else { 
    if ( server . vm_enabled && server . vm_max_threads > 0 && blockClientOnSwappedKeys ( c , cmd ) ) return REDIS_ERR ; 
    call ( c , cmd ) ; 
} 
return REDIS_OK ; 
}",895,-76.30574328503702,-0.08525781372629836
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int processCommand ( redisClient * c ) { struct redisCommand * cmd ; if ( ! strcasecmp ( c -> argv [ 0 ] -> ptr , ""quit"" ) ) { addReply ( c , shared . ok ) ; c -> flags |= REDIS_CLOSE_AFTER_REPLY ; return REDIS_ERR ; } cmd = lookupCommand ( c -> argv [ 0 ] -> ptr ) ; if ( ! cmd ) { addReplyErrorFormat ( c , ""unknown command \'%s\'"" , ( char * ) c -> argv [ 0 ] -> ptr ) ; return REDIS_OK ; } else if ( ( cmd -> arity > 0 && cmd -> arity != c -> argc ) || ( c -> argc < - cmd -> arity ) ) { addReplyErrorFormat ( c , ""wrong number of arguments for \'%s\' command"" , cmd -> name ) ; return REDIS_OK ; } if ( server . requirepass && ! c -> authenticated && cmd -> proc != authCommand ) { addReplyError ( c , ""operation not permitted"" ) ; return REDIS_OK ; } if ( server . maxmemory ) freeMemoryIfNeeded ( ) ; if ( server . maxmemory && ( cmd -> flags & REDIS_CMD_DENYOOM ) && zmalloc_used_memory ( ) > server . maxmemory ) { addReplyError ( c , ""command not allowed when used memory > \'maxmemory\'"" ) ; return REDIS_OK ; } if ( ( dictSize ( c -> pubsub_channels ) > 0 || listLength ( c -> pubsub_patterns ) > 0 ) && cmd -> proc != subscribeCommand && cmd -> proc != unsubscribeCommand && cmd -> proc != psubscribeCommand && cmd -> proc != punsubscribeCommand ) { addReplyError ( c , ""only (P)SUBSCRIBE / (P)UNSUBSCRIBE / QUIT allowed in this context"" ) ; return REDIS_OK ; } if ( server . masterhost && server . replstate != REDIS_REPL_CONNECTED && server . repl_serve_stale_data == 0 && cmd -> proc != infoCommand && cmd -> proc != slaveofCommand ) { addReplyError ( c , ""link with MASTER is down and slave-serve-stale-data is set to no"" ) ; return REDIS_OK ; } if ( server . loading && cmd -> proc != infoCommand ) { addReply ( c , shared . loadingerr ) ; return REDIS_OK ; } if ( c -> flags & REDIS_MULTI && cmd -> proc != execCommand && cmd -> proc != discardCommand && cmd -> proc != multiCommand && cmd -> proc != watchCommand ) { queueMultiCommand ( c , cmd ) ; addReply ( c , shared . queued ) ; } else { if ( server . vm_enabled && server . vm_max_threads > 0 && blockClientOnSwappedKeys ( c , cmd ) ) return REDIS_ERR ; call ( c , cmd ) ; } return REDIS_OK ; }
Fixed code:","
int processCommand ( redisClient * c ) { struct redisCommand * cmd ;
 // check for valid input 
if ( c -> argv [ 0 ] == NULL || ! isValidString ( c -> argv [ 0 ] -> ptr ) ) {
        addReplyError ( c , ""invalid command"" ) ;
        return REDIS_OK ;
    }
if ( ! strcasecmp ( c -> argv [ 0 ] -> ptr , ""quit"" ) ) {
 addReply ( c , shared . ok ) ; c -> flags |= REDIS_CLOSE_AFTER_REPLY ; return REDIS_ERR ; } cmd = lookupCommand ( c -> argv [ 0 ] -> ptr ) ; if ( ! cmd ) { addReplyErrorFormat ( c , ""unknown command \'%s\'"" , ( char * ) c -> argv [ 0 ] -> ptr ) ; return REDIS_OK ; } else if ( ( cmd -> arity > 0 && cmd -> arity != c -> argc ) || ( c -> argc < - cmd -> arity ) ) { addReplyErrorFormat ( c , ""wrong number of arguments for \'%s\' command"" , cmd -> name ) ; return REDIS_OK ; } if ( server . requirepass && ! c -> authenticated && cmd -> proc != authCommand ) { addReplyError ( c , ""operation not permitted"" ) ; return REDIS_OK ; } if ( server . maxmemory ) freeMemoryIfNeeded ( ) ; if ( server . maxmemory && ( cmd -> flags & REDIS_CMD_DENYOOM ) && zmalloc_used_memory ( ) > server . maxmemory ) { addReplyError ( c , ""command not allowed when used memory > \'maxmemory\'"" ) ; return REDIS_OK ; } if ( ( dictSize ( c -> pubsub_channels ) > 0 || listLength ( c -> pubsub_patterns ) > 0 ) && cmd -> proc != subscribeCommand && cmd -> proc != unsubscribeCommand && cmd -> proc != psubscribeCommand && cmd -> proc != punsubscribeCommand ) { addReplyError ( c , ""only (P)SUBSCRIBE / (P)UNSUBSCRIBE / QUIT allowed in this context"" ) ; return REDIS_OK ; } if ( server . masterhost && server . replstate != REDIS_REPL_CONNECTED && server . repl_serve_stale_data == 0 && cmd -> proc != infoCommand && cmd -> proc != slaveofCommand ) { addReplyError ( c , ""link with MASTER is down and slave-serve-stale-data is set to no"" ) ; return REDIS_OK ; } if ( server . loading && cmd -> proc != infoCommand ) { addReply ( c , shared . loadingerr ) ; return REDIS_OK ; } if ( c -> flags & REDIS_MULTI && cmd -> proc != execCommand && cmd -> proc != discardCommand && cmd -> proc != multiCommand && cmd -> proc != watchCommand ) { queueMultiCommand ( c , cmd ) ; addReply ( c , shared . queued ) ; } else { if ( server . vm_enabled && server . vm_max_threads > 0 && blockClientOnSwappedKeys ( c , cmd ) ) return REDIS_ERR ; call ( c , cmd ) ; } return REDIS_OK ; }",742,-35.115877837684785,-0.04732598091332181
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int processCommand ( redisClient * c ) { struct redisCommand * cmd ; if ( ! strcasecmp ( c -> argv [ 0 ] -> ptr , ""quit"" ) ) { addReply ( c , shared . ok ) ; c -> flags |= REDIS_CLOSE_AFTER_REPLY ; return REDIS_ERR ; } cmd = lookupCommand ( c -> argv [ 0 ] -> ptr ) ; if ( ! cmd ) { addReplyErrorFormat ( c , ""unknown command \'%s\'"" , ( char * ) c -> argv [ 0 ] -> ptr ) ; return REDIS_OK ; } else if ( ( cmd -> arity > 0 && cmd -> arity != c -> argc ) || ( c -> argc < - cmd -> arity ) ) { addReplyErrorFormat ( c , ""wrong number of arguments for \'%s\' command"" , cmd -> name ) ; return REDIS_OK ; } if ( server . requirepass && ! c -> authenticated && cmd -> proc != authCommand ) { addReplyError ( c , ""operation not permitted"" ) ; return REDIS_OK ; } if ( server . maxmemory ) freeMemoryIfNeeded ( ) ; if ( server . maxmemory && ( cmd -> flags & REDIS_CMD_DENYOOM ) && zmalloc_used_memory ( ) > server . maxmemory ) { addReplyError ( c , ""command not allowed when used memory > \'maxmemory\'"" ) ; return REDIS_OK ; } if ( ( dictSize ( c -> pubsub_channels ) > 0 || listLength ( c -> pubsub_patterns ) > 0 ) && cmd -> proc != subscribeCommand && cmd -> proc != unsubscribeCommand && cmd -> proc != psubscribeCommand && cmd -> proc != punsubscribeCommand ) { addReplyError ( c , ""only (P)SUBSCRIBE / (P)UNSUBSCRIBE / QUIT allowed in this context"" ) ; return REDIS_OK ; } if ( server . masterhost && server . replstate != REDIS_REPL_CONNECTED && server . repl_serve_stale_data == 0 && cmd -> proc != infoCommand && cmd -> proc != slaveofCommand ) { addReplyError ( c , ""link with MASTER is down and slave-serve-stale-data is set to no"" ) ; return REDIS_OK ; } if ( server . loading && cmd -> proc != infoCommand ) { addReply ( c , shared . loadingerr ) ; return REDIS_OK ; } if ( c -> flags & REDIS_MULTI && cmd -> proc != execCommand && cmd -> proc != discardCommand && cmd -> proc != multiCommand && cmd -> proc != watchCommand ) { queueMultiCommand ( c , cmd ) ; addReply ( c , shared . queued ) ; } else { if ( server . vm_enabled && server . vm_max_threads > 0 && blockClientOnSwappedKeys ( c , cmd ) ) return REDIS_ERR ; call ( c , cmd ) ; } return REDIS_OK ; }
Fixed code:","
int processCommand ( redisClient * c ) { struct redisCommand * cmd ; 
 
//Check for valid command 
if(c->argv[0]->ptr == NULL || strlen(c->argv[0]->ptr) > REDIS_COMMAND_MAX_LEN || !isCommandAllowed(c->argv[0]->ptr)){ 
    addReplyErrorFormat( c , ""unknown command \'%s\'"" , ( char * ) c -> argv[0]->ptr ) ; 
    return REDIS_OK ; 
} 
 
if ( ! strcasecmp ( c -> argv [ 0 ] -> ptr , ""quit"" ) ) { 
    addReply ( c , shared . ok ) ; c -> flags |= REDIS_CLOSE_AFTER_REPLY ; 
    return REDIS_ERR ; 
} 
cmd = lookupCommand ( c -> argv [ 0 ] -> ptr ) ; 
if ( ( cmd -> arity > 0 && cmd -> arity != c -> argc ) || ( c -> argc < - cmd -> arity ) ) { 
    addReplyErrorFormat ( c , ""wrong number of arguments for \'%s\' command"" , cmd -> name ) ; 
    return REDIS_OK ; 
} 
 
if ( server . requirepass && ! c -> authenticated && cmd -> proc != authCommand ) { 
    addReplyError ( c , ""operation not permitted"" ) ; 
    return REDIS_OK ; 
} 
if ( server . maxmemory ) freeMemoryIfNeeded ( ) ; 
if ( server . maxmemory && ( cmd -> flags & REDIS_CMD_DENYOOM ) && zmalloc_used_memory ( ) > server . maxmemory ) { 
    addReplyError ( c , ""command not allowed when used memory > \'maxmemory\'"" ) ; 
    return REDIS_OK ; 
} 
if ( ( dictSize ( c -> pubsub_channels ) > 0 || listLength ( c -> pubsub_patterns ) > 0 ) && cmd -> proc != subscribeCommand && cmd -> proc != unsubscribeCommand && cmd -> proc != psubscribeCommand && cmd -> proc != punsubscribeCommand ) { 
    addReplyError ( c , ""only (P)SUBSCRIBE / (P)UNSUBSCRIBE / QUIT allowed in this context"" ) ; 
    return REDIS_OK ; 
} 
if ( server . masterhost && server . replstate != REDIS_REPL_CONNECTED && server . repl_serve_stale_data == 0 && cmd -> proc != infoCommand && cmd -> proc != slaveofCommand ) { 
    addReplyError ( c , ""link with MASTER is down and slave-serve-stale-data is set to no"" ) ; 
    return REDIS_OK ; 
} 
if ( server . loading && cmd -> proc != infoCommand ) { 
    addReply ( c , shared . loadingerr ) ; 
    return REDIS_OK ; 
} 
if ( c -> flags & REDIS_MULTI && cmd -> proc != execCommand && cmd -> proc != discardCommand && cmd -> proc != multiCommand && cmd -> proc != watchCommand ) { 
    queueMultiCommand ( c , cmd ) ; 
    addReply ( c , shared . queued ) ; 
} else { 
    if ( server . vm_enabled && server . vm_max_threads > 0 && blockClientOnSwappedKeys ( c , cmd ) ) return REDIS_ERR ; 
    call ( c , cmd ) ; 
} 
return REDIS_OK ; 
}",846,-57.10071240736715,-0.06749493192360183
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int processCommand ( redisClient * c ) { struct redisCommand * cmd ; if ( ! strcasecmp ( c -> argv [ 0 ] -> ptr , ""quit"" ) ) { addReply ( c , shared . ok ) ; c -> flags |= REDIS_CLOSE_AFTER_REPLY ; return REDIS_ERR ; } cmd = lookupCommand ( c -> argv [ 0 ] -> ptr ) ; if ( ! cmd ) { addReplyErrorFormat ( c , ""unknown command \'%s\'"" , ( char * ) c -> argv [ 0 ] -> ptr ) ; return REDIS_OK ; } else if ( ( cmd -> arity > 0 && cmd -> arity != c -> argc ) || ( c -> argc < - cmd -> arity ) ) { addReplyErrorFormat ( c , ""wrong number of arguments for \'%s\' command"" , cmd -> name ) ; return REDIS_OK ; } if ( server . requirepass && ! c -> authenticated && cmd -> proc != authCommand ) { addReplyError ( c , ""operation not permitted"" ) ; return REDIS_OK ; } if ( server . maxmemory ) freeMemoryIfNeeded ( ) ; if ( server . maxmemory && ( cmd -> flags & REDIS_CMD_DENYOOM ) && zmalloc_used_memory ( ) > server . maxmemory ) { addReplyError ( c , ""command not allowed when used memory > \'maxmemory\'"" ) ; return REDIS_OK ; } if ( ( dictSize ( c -> pubsub_channels ) > 0 || listLength ( c -> pubsub_patterns ) > 0 ) && cmd -> proc != subscribeCommand && cmd -> proc != unsubscribeCommand && cmd -> proc != psubscribeCommand && cmd -> proc != punsubscribeCommand ) { addReplyError ( c , ""only (P)SUBSCRIBE / (P)UNSUBSCRIBE / QUIT allowed in this context"" ) ; return REDIS_OK ; } if ( server . masterhost && server . replstate != REDIS_REPL_CONNECTED && server . repl_serve_stale_data == 0 && cmd -> proc != infoCommand && cmd -> proc != slaveofCommand ) { addReplyError ( c , ""link with MASTER is down and slave-serve-stale-data is set to no"" ) ; return REDIS_OK ; } if ( server . loading && cmd -> proc != infoCommand ) { addReply ( c , shared . loadingerr ) ; return REDIS_OK ; } if ( c -> flags & REDIS_MULTI && cmd -> proc != execCommand && cmd -> proc != discardCommand && cmd -> proc != multiCommand && cmd -> proc != watchCommand ) { queueMultiCommand ( c , cmd ) ; addReply ( c , shared . queued ) ; } else { if ( server . vm_enabled && server . vm_max_threads > 0 && blockClientOnSwappedKeys ( c , cmd ) ) return REDIS_ERR ; call ( c , cmd ) ; } return REDIS_OK ; }
Fixed code:","
int processCommand ( redisClient * c ) { 
  regex_t regex;
  int reti;

  struct redisCommand * cmd ; 
 
  // check if input is valid with regex
  reti = regcomp(&regex, ""[a-zA-Z0-9_]+"", 0);
  if (reti) {
    addReplyErrorFormat(c, ""input validation failed (%s)"", (char *) c->argv[0]->ptr);
    return REDIS_OK;
  }
  reti = regexec(&regex, (char *) c->argv[0]->ptr, 0, NULL, 0);
  if( !reti ){
    if ( ! strcasecmp ( c -> argv [ 0 ] -> ptr , ""quit"" ) ) { 
      addReply ( c , shared . ok ) ; 
      c -> flags |= REDIS_CLOSE_AFTER_REPLY ; 
      return REDIS_ERR ; 
    } 
    cmd = lookupCommand ( c -> argv [ 0 ] -> ptr ) ; 
    if ( ! cmd ) { 
      addReplyErrorFormat ( c , ""unknown command \'%s\'"" , ( char * ) c -> argv [ 0 ] -> ptr ) ; 
      return REDIS_OK ; 
    } else if ( ( cmd -> arity > 0 && cmd -> arity != c -> argc ) || ( c -> argc < - cmd -> arity ) ) { 
      addReplyErrorFormat ( c , ""wrong number of arguments for \'%s\' command"" , cmd -> name ) ; 
      return REDIS_OK ; 
    } 
    if ( server . requirepass && ! c -> authenticated && cmd -> proc != authCommand ) { 
      addReplyError ( c , ""operation not permitted"" ) ; 
      return REDIS_OK ; 
    } 
    if ( server . maxmemory ) freeMemoryIfNeeded ( ) ; 
    if ( server . maxmemory && ( cmd -> flags & REDIS_CMD_DENYOOM ) && zmalloc_used_memory ( ) > server . maxmemory ) { 
      addReplyError ( c , ""command not allowed when used memory > \'maxmemory\'"" ) ; 
      return REDIS_OK ; 
    } 
    if ( ( dictSize ( c -> pubsub_channels ) > 0 || listLength ( c -> pubsub_patterns ) > 0 ) && cmd -> proc != subscribeCommand && cmd -> proc != unsubscribeCommand && cmd -> proc != psubscribeCommand && cmd -> proc != punsubscribeCommand ) { 
      addReplyError ( c , ""only (P)SUBSCRIBE / (P)UNSUBSCRIBE / QUIT allowed in this context"" ) ; 
      return REDIS_OK ; 
    } 
    if ( server . masterhost && server . replstate != REDIS_REPL_CONNECTED && server . repl_serve_stale_data == 0 && cmd -> proc != infoCommand && cmd -> proc != slaveofCommand ) { 
      addReplyError ( c , ""link with MASTER is down and slave-serve-stale-data is set to no"" ) ; 
      return REDIS_OK ; 
    } 
    if ( server . loading && cmd -> proc != infoCommand ) { 
      addReply ( c , shared . loadingerr ) ; 
      return REDIS_OK ; 
    } 
    if ( c -> flags & REDIS_MULTI && cmd -> proc != execCommand && cmd -> proc != discardCommand && cmd -> proc != multiCommand && cmd -> proc != watchCommand ) { 
      queueMultiCommand ( c , cmd ) ; 
      addReply ( c , shared . queued ) ; 
    } else { 
      if ( server . vm_enabled && server . vm_max_threads > 0 && blockClientOnSwappedKeys ( c , cmd ) ) return REDIS_ERR ; 
      call ( c , cmd ) ; 
    } 
    regfree(&regex);
    return REDIS_OK ; 
  } 
  else if (reti == REG_NOMATCH) {
    addReplyErrorFormat(c, ""unknown command \'%s\'"" , ( char * ) c -> argv [ 0 ]",1000,-74.37864353039089,-0.07437864353039089
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int processCommand ( redisClient * c ) { struct redisCommand * cmd ; if ( ! strcasecmp ( c -> argv [ 0 ] -> ptr , ""quit"" ) ) { addReply ( c , shared . ok ) ; c -> flags |= REDIS_CLOSE_AFTER_REPLY ; return REDIS_ERR ; } cmd = lookupCommand ( c -> argv [ 0 ] -> ptr ) ; if ( ! cmd ) { addReplyErrorFormat ( c , ""unknown command \'%s\'"" , ( char * ) c -> argv [ 0 ] -> ptr ) ; return REDIS_OK ; } else if ( ( cmd -> arity > 0 && cmd -> arity != c -> argc ) || ( c -> argc < - cmd -> arity ) ) { addReplyErrorFormat ( c , ""wrong number of arguments for \'%s\' command"" , cmd -> name ) ; return REDIS_OK ; } if ( server . requirepass && ! c -> authenticated && cmd -> proc != authCommand ) { addReplyError ( c , ""operation not permitted"" ) ; return REDIS_OK ; } if ( server . maxmemory ) freeMemoryIfNeeded ( ) ; if ( server . maxmemory && ( cmd -> flags & REDIS_CMD_DENYOOM ) && zmalloc_used_memory ( ) > server . maxmemory ) { addReplyError ( c , ""command not allowed when used memory > \'maxmemory\'"" ) ; return REDIS_OK ; } if ( ( dictSize ( c -> pubsub_channels ) > 0 || listLength ( c -> pubsub_patterns ) > 0 ) && cmd -> proc != subscribeCommand && cmd -> proc != unsubscribeCommand && cmd -> proc != psubscribeCommand && cmd -> proc != punsubscribeCommand ) { addReplyError ( c , ""only (P)SUBSCRIBE / (P)UNSUBSCRIBE / QUIT allowed in this context"" ) ; return REDIS_OK ; } if ( server . masterhost && server . replstate != REDIS_REPL_CONNECTED && server . repl_serve_stale_data == 0 && cmd -> proc != infoCommand && cmd -> proc != slaveofCommand ) { addReplyError ( c , ""link with MASTER is down and slave-serve-stale-data is set to no"" ) ; return REDIS_OK ; } if ( server . loading && cmd -> proc != infoCommand ) { addReply ( c , shared . loadingerr ) ; return REDIS_OK ; } if ( c -> flags & REDIS_MULTI && cmd -> proc != execCommand && cmd -> proc != discardCommand && cmd -> proc != multiCommand && cmd -> proc != watchCommand ) { queueMultiCommand ( c , cmd ) ; addReply ( c , shared . queued ) ; } else { if ( server . vm_enabled && server . vm_max_threads > 0 && blockClientOnSwappedKeys ( c , cmd ) ) return REDIS_ERR ; call ( c , cmd ) ; } return REDIS_OK ; }
Fixed code:","
int processCommand ( redisClient * c ) { struct redisCommand * cmd ; if ( ! strcasecmp ( c -> argv [ 0 ] -> ptr , ""quit"" ) ) { addReply ( c , shared . ok ) ; c -> flags |= REDIS_CLOSE_AFTER_REPLY ; return REDIS_ERR ; } //Validation step added here if(!c->argv[0]->ptr) { addReplyError(c, ""invalid command specified""); return REDIS_OK; } cmd = lookupCommand ( c -> argv [ 0 ] -> ptr ) ; if ( ! cmd ) { addReplyErrorFormat ( c , ""unknown command \'%s\'"" , ( char * ) c -> argv [ 0 ] -> ptr ) ; return REDIS_OK ; } else if ( ( cmd -> arity > 0 && cmd -> arity != c -> argc ) || ( c -> argc < - cmd -> arity ) ) { addReplyErrorFormat ( c , ""wrong number of arguments for \'%s\' command"" , cmd -> name ) ; return REDIS_OK ; } if ( server . requirepass && ! c -> authenticated && cmd -> proc != authCommand ) { addReplyError ( c , ""operation not permitted"" ) ; return REDIS_OK ; } if ( server . maxmemory ) freeMemoryIfNeeded ( ) ; if ( server . maxmemory && ( cmd -> flags & REDIS_CMD_DENYOOM ) && zmalloc_used_memory ( ) > server . maxmemory ) { addReplyError ( c , ""command not allowed when used memory > \'maxmemory\'"" ) ; return REDIS_OK ; } if ( ( dictSize ( c -> pubsub_channels ) > 0 || listLength ( c -> pubsub_patterns ) > 0 ) && cmd -> proc != subscribeCommand && cmd -> proc != unsubscribeCommand && cmd -> proc != psubscribeCommand && cmd -> proc != punsubscribeCommand ) { addReplyError ( c , ""only (P)SUBSCRIBE / (P)UNSUBSCRIBE / QUIT allowed in this context"" ) ; return REDIS_OK ; } if ( server . masterhost && server . replstate != REDIS_REPL_CONNECTED && server . repl_serve_stale_data == 0 && cmd -> proc != infoCommand && cmd -> proc != slaveofCommand ) { addReplyError ( c , ""link with MASTER is down and slave-serve-stale-data is set to no"" ) ; return REDIS_OK ; } if ( server . loading && cmd -> proc != infoCommand ) { addReply ( c , shared . loadingerr ) ; return REDIS_OK ; } if ( c -> flags & REDIS_MULTI && cmd -> proc != execCommand && cmd -> proc != discardCommand && cmd -> proc != multiCommand && cmd -> proc != watchCommand ) { queueMultiCommand ( c , cmd ) ; addReply ( c , shared . queued ) ; } else { if ( server . vm_enabled && server . vm_max_threads > 0 && blockClientOnSwappedKeys ( c , cmd ) ) return REDIS_ERR ; call ( c , cmd ) ; } return REDIS_OK ; }",716,-30.639881836912622,-0.042793131057140534
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int processCommand ( redisClient * c ) { struct redisCommand * cmd ; if ( ! strcasecmp ( c -> argv [ 0 ] -> ptr , ""quit"" ) ) { addReply ( c , shared . ok ) ; c -> flags |= REDIS_CLOSE_AFTER_REPLY ; return REDIS_ERR ; } cmd = lookupCommand ( c -> argv [ 0 ] -> ptr ) ; if ( ! cmd ) { addReplyErrorFormat ( c , ""unknown command \'%s\'"" , ( char * ) c -> argv [ 0 ] -> ptr ) ; return REDIS_OK ; } else if ( ( cmd -> arity > 0 && cmd -> arity != c -> argc ) || ( c -> argc < - cmd -> arity ) ) { addReplyErrorFormat ( c , ""wrong number of arguments for \'%s\' command"" , cmd -> name ) ; return REDIS_OK ; } if ( server . requirepass && ! c -> authenticated && cmd -> proc != authCommand ) { addReplyError ( c , ""operation not permitted"" ) ; return REDIS_OK ; } if ( server . maxmemory ) freeMemoryIfNeeded ( ) ; if ( server . maxmemory && ( cmd -> flags & REDIS_CMD_DENYOOM ) && zmalloc_used_memory ( ) > server . maxmemory ) { addReplyError ( c , ""command not allowed when used memory > \'maxmemory\'"" ) ; return REDIS_OK ; } if ( ( dictSize ( c -> pubsub_channels ) > 0 || listLength ( c -> pubsub_patterns ) > 0 ) && cmd -> proc != subscribeCommand && cmd -> proc != unsubscribeCommand && cmd -> proc != psubscribeCommand && cmd -> proc != punsubscribeCommand ) { addReplyError ( c , ""only (P)SUBSCRIBE / (P)UNSUBSCRIBE / QUIT allowed in this context"" ) ; return REDIS_OK ; } if ( server . masterhost && server . replstate != REDIS_REPL_CONNECTED && server . repl_serve_stale_data == 0 && cmd -> proc != infoCommand && cmd -> proc != slaveofCommand ) { addReplyError ( c , ""link with MASTER is down and slave-serve-stale-data is set to no"" ) ; return REDIS_OK ; } if ( server . loading && cmd -> proc != infoCommand ) { addReply ( c , shared . loadingerr ) ; return REDIS_OK ; } if ( c -> flags & REDIS_MULTI && cmd -> proc != execCommand && cmd -> proc != discardCommand && cmd -> proc != multiCommand && cmd -> proc != watchCommand ) { queueMultiCommand ( c , cmd ) ; addReply ( c , shared . queued ) ; } else { if ( server . vm_enabled && server . vm_max_threads > 0 && blockClientOnSwappedKeys ( c , cmd ) ) return REDIS_ERR ; call ( c , cmd ) ; } return REDIS_OK ; }
Fixed code:","
int processCommand ( redisClient * c ) { 
    struct redisCommand * cmd ; 

    // add input validation
    if (!c || !c->argv || !c->argv[0]) {
        return REDIS_ERR;
    }

    if ( ! strcasecmp ( c -> argv [ 0 ] -> ptr , ""quit"" ) ) { 
        addReply ( c , shared . ok ) ;
        c -> flags |= REDIS_CLOSE_AFTER_REPLY ; 
        return REDIS_ERR ; 
    } 
    cmd = lookupCommand ( c -> argv [ 0 ] -> ptr ) ; 
    if ( ! cmd ) { 
        addReplyErrorFormat ( c , ""unknown command \'%s\'"" , ( char * ) c -> argv [ 0 ] -> ptr ) ; 
        return REDIS_OK ; 
    } else if ( ( cmd -> arity > 0 && cmd -> arity != c -> argc ) || ( c -> argc < - cmd -> arity ) ) { 
        addReplyErrorFormat ( c , ""wrong number of arguments for \'%s\' command"" , cmd -> name ) ; 
        return REDIS_OK ; 
    } 
    if ( server . requirepass && ! c -> authenticated && cmd -> proc != authCommand ) { 
        addReplyError ( c , ""operation not permitted"" ) ; 
        return REDIS_OK ; 
    } 
    if ( server . maxmemory ) freeMemoryIfNeeded ( ) ; 
    if ( server . maxmemory && ( cmd -> flags & REDIS_CMD_DENYOOM ) && zmalloc_used_memory ( ) > server . maxmemory ) { 
        addReplyError ( c , ""command not allowed when used memory > \'maxmemory\'"" ) ; 
        return REDIS_OK ; 
    } 
    if ( ( dictSize ( c -> pubsub_channels ) > 0 || listLength ( c -> pubsub_patterns ) > 0 ) && cmd -> proc != subscribeCommand && cmd -> proc != unsubscribeCommand && cmd -> proc != psubscribeCommand && cmd -> proc != punsubscribeCommand ) { 
        addReplyError ( c , ""only (P)SUBSCRIBE / (P)UNSUBSCRIBE / QUIT allowed in this context"" ) ; 
        return REDIS_OK ; 
    } 
    if ( server . masterhost && server . replstate != REDIS_REPL_CONNECTED && server . repl_serve_stale_data == 0 && cmd -> proc != infoCommand && cmd -> proc != slaveofCommand ) { 
        addReplyError ( c , ""link with MASTER is down and slave-serve-stale-data is set to no"" ) ; 
        return REDIS_OK ; 
    } 
    if ( server . loading && cmd -> proc != infoCommand ) { 
        addReply ( c , shared . loadingerr ) ; 
        return REDIS_OK ; 
    } 
    if ( c -> flags & REDIS_MULTI && cmd -> proc != execCommand && cmd -> proc != discardCommand && cmd -> proc != multiCommand && cmd -> proc != watchCommand ) { 
        queueMultiCommand ( c , cmd ) ; 
        addReply ( c , shared . queued ) ; 
    } else { 
        if ( server . vm_enabled && server . vm_max_threads > 0 && blockClientOnSwappedKeys ( c , cmd ) ) return REDIS_ERR ; 
        call ( c , cmd ) ; 
    } 
    return REDIS_OK ; 
}",846,-25.06017863063407,-0.029621960556305046
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int processCommand ( redisClient * c ) { struct redisCommand * cmd ; if ( ! strcasecmp ( c -> argv [ 0 ] -> ptr , ""quit"" ) ) { addReply ( c , shared . ok ) ; c -> flags |= REDIS_CLOSE_AFTER_REPLY ; return REDIS_ERR ; } cmd = lookupCommand ( c -> argv [ 0 ] -> ptr ) ; if ( ! cmd ) { addReplyErrorFormat ( c , ""unknown command \'%s\'"" , ( char * ) c -> argv [ 0 ] -> ptr ) ; return REDIS_OK ; } else if ( ( cmd -> arity > 0 && cmd -> arity != c -> argc ) || ( c -> argc < - cmd -> arity ) ) { addReplyErrorFormat ( c , ""wrong number of arguments for \'%s\' command"" , cmd -> name ) ; return REDIS_OK ; } if ( server . requirepass && ! c -> authenticated && cmd -> proc != authCommand ) { addReplyError ( c , ""operation not permitted"" ) ; return REDIS_OK ; } if ( server . maxmemory ) freeMemoryIfNeeded ( ) ; if ( server . maxmemory && ( cmd -> flags & REDIS_CMD_DENYOOM ) && zmalloc_used_memory ( ) > server . maxmemory ) { addReplyError ( c , ""command not allowed when used memory > \'maxmemory\'"" ) ; return REDIS_OK ; } if ( ( dictSize ( c -> pubsub_channels ) > 0 || listLength ( c -> pubsub_patterns ) > 0 ) && cmd -> proc != subscribeCommand && cmd -> proc != unsubscribeCommand && cmd -> proc != psubscribeCommand && cmd -> proc != punsubscribeCommand ) { addReplyError ( c , ""only (P)SUBSCRIBE / (P)UNSUBSCRIBE / QUIT allowed in this context"" ) ; return REDIS_OK ; } if ( server . masterhost && server . replstate != REDIS_REPL_CONNECTED && server . repl_serve_stale_data == 0 && cmd -> proc != infoCommand && cmd -> proc != slaveofCommand ) { addReplyError ( c , ""link with MASTER is down and slave-serve-stale-data is set to no"" ) ; return REDIS_OK ; } if ( server . loading && cmd -> proc != infoCommand ) { addReply ( c , shared . loadingerr ) ; return REDIS_OK ; } if ( c -> flags & REDIS_MULTI && cmd -> proc != execCommand && cmd -> proc != discardCommand && cmd -> proc != multiCommand && cmd -> proc != watchCommand ) { queueMultiCommand ( c , cmd ) ; addReply ( c , shared . queued ) ; } else { if ( server . vm_enabled && server . vm_max_threads > 0 && blockClientOnSwappedKeys ( c , cmd ) ) return REDIS_ERR ; call ( c , cmd ) ; } return REDIS_OK ; }
Fixed code:","
int processCommand ( redisClient * c ) { 
    struct redisCommand * cmd ; 
    if ( ! c -> argv [ 0 ] || c -> argv [ 0 ] -> len < 1 ) {
      addReplyError(c,""No command specified""); 
      return REDIS_ERR;
    } 
    if ( ! strcasecmp ( c -> argv [ 0 ] -> ptr , ""quit"" ) ) {
        addReply ( c , shared . ok ) ; 
        c -> flags |= REDIS_CLOSE_AFTER_REPLY ; 
        return REDIS_ERR ; 
    } 
    cmd = lookupCommand ( c -> argv [ 0 ] -> ptr ) ; 
    if ( ! cmd ) { 
        addReplyErrorFormat ( c , ""unknown command \'%s\'"" , ( char * ) c -> argv [ 0 ] -> ptr ) ; 
        return REDIS_OK ; 
    } else if ( ( cmd -> arity > 0 && cmd -> arity != c -> argc ) || ( c -> argc < - cmd -> arity ) ) { 
        addReplyErrorFormat ( c , ""wrong number of arguments for \'%s\' command"" , cmd -> name ) ; 
        return REDIS_OK ; 
    } 
    if ( server . requirepass && ! c -> authenticated && cmd -> proc != authCommand ) { 
        addReplyError ( c , ""operation not permitted"" ) ; 
        return REDIS_OK ; 
    } 
    if ( server . maxmemory ) freeMemoryIfNeeded ( ) ; 
    if ( server . maxmemory && ( cmd -> flags & REDIS_CMD_DENYOOM ) && zmalloc_used_memory ( ) > server . maxmemory ) { 
        addReplyError ( c , ""command not allowed when used memory > \'maxmemory\'"" ) ; 
        return REDIS_OK ; 
    } 
    if ( ( dictSize ( c -> pubsub_channels ) > 0 || listLength ( c -> pubsub_patterns ) > 0 ) && cmd -> proc != subscribeCommand && cmd -> proc != unsubscribeCommand && cmd -> proc != psubscribeCommand && cmd -> proc != punsubscribeCommand ) { 
        addReplyError ( c , ""only (P)SUBSCRIBE / (P)UNSUBSCRIBE / QUIT allowed in this context"" ) ; 
        return REDIS_OK ; 
    } 
    if ( server . masterhost && server . replstate != REDIS_REPL_CONNECTED && server . repl_serve_stale_data == 0 && cmd -> proc != infoCommand && cmd -> proc != slaveofCommand ) { 
        addReplyError ( c , ""link with MASTER is down and slave-serve-stale-data is set to no"" ) ; 
        return REDIS_OK ; 
    } 
    if ( server . loading && cmd -> proc != infoCommand ) { 
        addReply ( c , shared . loadingerr ) ; 
        return REDIS_OK ; 
    } 
    if ( c -> flags & REDIS_MULTI && cmd -> proc != execCommand && cmd -> proc != discardCommand && cmd -> proc != multiCommand && cmd -> proc != watchCommand ) { 
        queueMultiCommand ( c , cmd ) ; 
        addReply ( c , shared . queued ) ; 
    } else { 
        if ( server . vm_enabled && server . vm_max_threads > 0 && blockClientOnSwappedKeys ( c , cmd ) ) return REDIS_ERR ; 
        call ( c , cmd ) ; 
    } 
    return REDIS_OK ; 
}",859,-33.02918808676838,-0.03845074282510871
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int processCommand ( redisClient * c ) { struct redisCommand * cmd ; if ( ! strcasecmp ( c -> argv [ 0 ] -> ptr , ""quit"" ) ) { addReply ( c , shared . ok ) ; c -> flags |= REDIS_CLOSE_AFTER_REPLY ; return REDIS_ERR ; } cmd = lookupCommand ( c -> argv [ 0 ] -> ptr ) ; if ( ! cmd ) { addReplyErrorFormat ( c , ""unknown command \'%s\'"" , ( char * ) c -> argv [ 0 ] -> ptr ) ; return REDIS_OK ; } else if ( ( cmd -> arity > 0 && cmd -> arity != c -> argc ) || ( c -> argc < - cmd -> arity ) ) { addReplyErrorFormat ( c , ""wrong number of arguments for \'%s\' command"" , cmd -> name ) ; return REDIS_OK ; } if ( server . requirepass && ! c -> authenticated && cmd -> proc != authCommand ) { addReplyError ( c , ""operation not permitted"" ) ; return REDIS_OK ; } if ( server . maxmemory ) freeMemoryIfNeeded ( ) ; if ( server . maxmemory && ( cmd -> flags & REDIS_CMD_DENYOOM ) && zmalloc_used_memory ( ) > server . maxmemory ) { addReplyError ( c , ""command not allowed when used memory > \'maxmemory\'"" ) ; return REDIS_OK ; } if ( ( dictSize ( c -> pubsub_channels ) > 0 || listLength ( c -> pubsub_patterns ) > 0 ) && cmd -> proc != subscribeCommand && cmd -> proc != unsubscribeCommand && cmd -> proc != psubscribeCommand && cmd -> proc != punsubscribeCommand ) { addReplyError ( c , ""only (P)SUBSCRIBE / (P)UNSUBSCRIBE / QUIT allowed in this context"" ) ; return REDIS_OK ; } if ( server . masterhost && server . replstate != REDIS_REPL_CONNECTED && server . repl_serve_stale_data == 0 && cmd -> proc != infoCommand && cmd -> proc != slaveofCommand ) { addReplyError ( c , ""link with MASTER is down and slave-serve-stale-data is set to no"" ) ; return REDIS_OK ; } if ( server . loading && cmd -> proc != infoCommand ) { addReply ( c , shared . loadingerr ) ; return REDIS_OK ; } if ( c -> flags & REDIS_MULTI && cmd -> proc != execCommand && cmd -> proc != discardCommand && cmd -> proc != multiCommand && cmd -> proc != watchCommand ) { queueMultiCommand ( c , cmd ) ; addReply ( c , shared . queued ) ; } else { if ( server . vm_enabled && server . vm_max_threads > 0 && blockClientOnSwappedKeys ( c , cmd ) ) return REDIS_ERR ; call ( c , cmd ) ; } return REDIS_OK ; }
Fixed code:","
int processCommand ( redisClient * c ) { 
  struct redisCommand * cmd ; 
  if ( ! c -> argv[0] || ! c -> argv[0]->ptr ) {
    addReplyError(c, ""No command provided"");
    return REDIS_ERR;
  }
  if ( ! strcasecmp ( c -> argv[0] -> ptr , ""quit"" ) ) {
    addReply ( c , shared . ok ) ; 
    c -> flags |= REDIS_CLOSE_AFTER_REPLY ; 
    return REDIS_ERR ; 
  }
  cmd = lookupCommand ( c -> argv[0] -> ptr ) ; 
  if ( ! cmd ) { 
    addReplyErrorFormat ( c , ""unknown command \'%s\'"" , ( char * ) c -> argv[0] -> ptr ) ; 
    return REDIS_OK ; 
  } 
  else if ( ( cmd -> arity > 0 && cmd -> arity != c -> argc ) || ( c -> argc < - cmd -> arity ) ) { 
    addReplyErrorFormat ( c , ""wrong number of arguments for \'%s\' command"" , cmd -> name ) ; 
    return REDIS_OK ; 
  } 
  if ( server . requirepass && ! c -> authenticated && cmd -> proc != authCommand ) { 
    addReplyError ( c , ""operation not permitted"" ) ; 
    return REDIS_OK ; 
  } 
  if ( server . maxmemory ) freeMemoryIfNeeded ( ) ; 
  if ( server . maxmemory && ( cmd -> flags & REDIS_CMD_DENYOOM ) && zmalloc_used_memory ( ) > server . maxmemory ) { 
    addReplyError ( c , ""command not allowed when used memory > \'maxmemory\'"" ) ; 
    return REDIS_OK ; 
  } 
  if ( ( dictSize ( c -> pubsub_channels ) > 0 || listLength ( c -> pubsub_patterns ) > 0 ) && cmd -> proc != subscribeCommand && cmd -> proc != unsubscribeCommand && cmd -> proc != psubscribeCommand && cmd -> proc != punsubscribeCommand ) { 
    addReplyError ( c , ""only (P)SUBSCRIBE / (P)UNSUBSCRIBE / QUIT allowed in this context"" ) ; 
    return REDIS_OK ; 
  } 
  if ( server . masterhost && server . replstate != REDIS_REPL_CONNECTED && server . repl_serve_stale_data == 0 && cmd -> proc != infoCommand && cmd -> proc != slaveofCommand ) { 
    addReplyError ( c , ""link with MASTER is down and slave-serve-stale-data is set to no"" ) ; 
    return REDIS_OK ; 
  } 
  if ( server . loading && cmd -> proc != infoCommand ) { 
    addReply ( c , shared . loadingerr ) ; 
    return REDIS_OK ; 
  } 
  if ( c -> flags & REDIS_MULTI && cmd -> proc != execCommand && cmd -> proc != discardCommand && cmd -> proc != multiCommand && cmd -> proc != watchCommand ) { 
    queueMultiCommand ( c , cmd ) ; 
    addReply ( c , shared . queued ) ; 
  } else { 
    if ( server . vm_enabled && server . vm_max_threads > 0 && blockClientOnSwappedKeys ( c , cmd ) ) return REDIS_ERR ; 
    call ( c , cmd ) ; 
  } 
  return REDIS_OK ; 
}",859,-32.736006128142265,-0.038109436703308804
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int processCommand ( redisClient * c ) { struct redisCommand * cmd ; if ( ! strcasecmp ( c -> argv [ 0 ] -> ptr , ""quit"" ) ) { addReply ( c , shared . ok ) ; c -> flags |= REDIS_CLOSE_AFTER_REPLY ; return REDIS_ERR ; } cmd = lookupCommand ( c -> argv [ 0 ] -> ptr ) ; if ( ! cmd ) { addReplyErrorFormat ( c , ""unknown command \'%s\'"" , ( char * ) c -> argv [ 0 ] -> ptr ) ; return REDIS_OK ; } else if ( ( cmd -> arity > 0 && cmd -> arity != c -> argc ) || ( c -> argc < - cmd -> arity ) ) { addReplyErrorFormat ( c , ""wrong number of arguments for \'%s\' command"" , cmd -> name ) ; return REDIS_OK ; } if ( server . requirepass && ! c -> authenticated && cmd -> proc != authCommand ) { addReplyError ( c , ""operation not permitted"" ) ; return REDIS_OK ; } if ( server . maxmemory ) freeMemoryIfNeeded ( ) ; if ( server . maxmemory && ( cmd -> flags & REDIS_CMD_DENYOOM ) && zmalloc_used_memory ( ) > server . maxmemory ) { addReplyError ( c , ""command not allowed when used memory > \'maxmemory\'"" ) ; return REDIS_OK ; } if ( ( dictSize ( c -> pubsub_channels ) > 0 || listLength ( c -> pubsub_patterns ) > 0 ) && cmd -> proc != subscribeCommand && cmd -> proc != unsubscribeCommand && cmd -> proc != psubscribeCommand && cmd -> proc != punsubscribeCommand ) { addReplyError ( c , ""only (P)SUBSCRIBE / (P)UNSUBSCRIBE / QUIT allowed in this context"" ) ; return REDIS_OK ; } if ( server . masterhost && server . replstate != REDIS_REPL_CONNECTED && server . repl_serve_stale_data == 0 && cmd -> proc != infoCommand && cmd -> proc != slaveofCommand ) { addReplyError ( c , ""link with MASTER is down and slave-serve-stale-data is set to no"" ) ; return REDIS_OK ; } if ( server . loading && cmd -> proc != infoCommand ) { addReply ( c , shared . loadingerr ) ; return REDIS_OK ; } if ( c -> flags & REDIS_MULTI && cmd -> proc != execCommand && cmd -> proc != discardCommand && cmd -> proc != multiCommand && cmd -> proc != watchCommand ) { queueMultiCommand ( c , cmd ) ; addReply ( c , shared . queued ) ; } else { if ( server . vm_enabled && server . vm_max_threads > 0 && blockClientOnSwappedKeys ( c , cmd ) ) return REDIS_ERR ; call ( c , cmd ) ; } return REDIS_OK ; }
Fixed code:"," 
int processCommand ( redisClient * c ) { struct redisCommand * cmd ; if ( ! c -> argv [ 0 ] || ! strcasecmp ( c -> argv [ 0 ] -> ptr , ""quit"" ) ) { addReply ( c , shared . ok ) ; c -> flags |= REDIS_CLOSE_AFTER_REPLY ; return REDIS_ERR ; } if ( ! c -> argv [ 0 ] -> ptr || ( strlen ( c -> argv [ 0 ] -> ptr ) > REDIS_ARG_MAX_LEN ) ) { addReply ( c , shared . arg_max ) ; return REDIS_ERR ; } cmd = lookupCommand ( c -> argv [ 0 ] -> ptr ) ; if ( ! cmd ) { addReplyErrorFormat ( c , ""unknown command \'%s\'"" , ( char * ) c -> argv [ 0 ] -> ptr ) ; return REDIS_OK ; } else if ( ( cmd -> arity > 0 && cmd -> arity != c -> argc ) || ( c -> argc < - cmd -> arity ) ) { addReplyErrorFormat ( c , ""wrong number of arguments for \'%s\' command"" , cmd -> name ) ; return REDIS_OK ; } if ( server . requirepass && ! c -> authenticated && cmd -> proc != authCommand ) { addReplyError ( c , ""operation not permitted"" ) ; return REDIS_OK ; } if ( server . maxmemory ) freeMemoryIfNeeded ( ) ; if ( server . maxmemory && ( cmd -> flags & REDIS_CMD_DENYOOM ) && zmalloc_used_memory ( ) > server . maxmemory ) { addReplyError ( c , ""command not allowed when used memory > \'maxmemory\'"" ) ; return REDIS_OK ; } if ( ( dictSize ( c -> pubsub_channels ) > 0 || listLength ( c -> pubsub_patterns ) > 0 ) && cmd -> proc != subscribeCommand && cmd -> proc != unsubscribeCommand && cmd -> proc != psubscribeCommand && cmd -> proc != punsubscribeCommand ) { addReplyError ( c , ""only (P)SUBSCRIBE / (P)UNSUBSCRIBE / QUIT allowed in this context"" ) ; return REDIS_OK ; } if ( server . masterhost && server . replstate != REDIS_REPL_CONNECTED && server . repl_serve_stale_data == 0 && cmd -> proc != infoCommand && cmd -> proc != slaveofCommand ) { addReplyError ( c , ""link with MASTER is down and slave-serve-stale-data is set to no"" ) ; return REDIS_OK ; } if ( server . loading && cmd -> proc != infoCommand ) { addReply ( c , shared . loadingerr ) ; return REDIS_OK ; } if ( c -> flags & REDIS_MULTI && cmd -> proc != execCommand && cmd -> proc != discardCommand && cmd -> proc != multiCommand && cmd -> proc != watchCommand ) { queueMultiCommand ( c , cmd ) ; addReply ( c , shared . queued ) ; } else { if ( server . vm_enabled && server . vm_max_threads > 0 && blockClientOnSwappedKeys ( c , cmd ) ) return REDIS_ERR ; call ( c , cmd ) ; } return REDIS_OK ; }",748,-32.411617534088926,-0.0433310394840761
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int processCommand ( redisClient * c ) { struct redisCommand * cmd ; if ( ! strcasecmp ( c -> argv [ 0 ] -> ptr , ""quit"" ) ) { addReply ( c , shared . ok ) ; c -> flags |= REDIS_CLOSE_AFTER_REPLY ; return REDIS_ERR ; } cmd = lookupCommand ( c -> argv [ 0 ] -> ptr ) ; if ( ! cmd ) { addReplyErrorFormat ( c , ""unknown command \'%s\'"" , ( char * ) c -> argv [ 0 ] -> ptr ) ; return REDIS_OK ; } else if ( ( cmd -> arity > 0 && cmd -> arity != c -> argc ) || ( c -> argc < - cmd -> arity ) ) { addReplyErrorFormat ( c , ""wrong number of arguments for \'%s\' command"" , cmd -> name ) ; return REDIS_OK ; } if ( server . requirepass && ! c -> authenticated && cmd -> proc != authCommand ) { addReplyError ( c , ""operation not permitted"" ) ; return REDIS_OK ; } if ( server . maxmemory ) freeMemoryIfNeeded ( ) ; if ( server . maxmemory && ( cmd -> flags & REDIS_CMD_DENYOOM ) && zmalloc_used_memory ( ) > server . maxmemory ) { addReplyError ( c , ""command not allowed when used memory > \'maxmemory\'"" ) ; return REDIS_OK ; } if ( ( dictSize ( c -> pubsub_channels ) > 0 || listLength ( c -> pubsub_patterns ) > 0 ) && cmd -> proc != subscribeCommand && cmd -> proc != unsubscribeCommand && cmd -> proc != psubscribeCommand && cmd -> proc != punsubscribeCommand ) { addReplyError ( c , ""only (P)SUBSCRIBE / (P)UNSUBSCRIBE / QUIT allowed in this context"" ) ; return REDIS_OK ; } if ( server . masterhost && server . replstate != REDIS_REPL_CONNECTED && server . repl_serve_stale_data == 0 && cmd -> proc != infoCommand && cmd -> proc != slaveofCommand ) { addReplyError ( c , ""link with MASTER is down and slave-serve-stale-data is set to no"" ) ; return REDIS_OK ; } if ( server . loading && cmd -> proc != infoCommand ) { addReply ( c , shared . loadingerr ) ; return REDIS_OK ; } if ( c -> flags & REDIS_MULTI && cmd -> proc != execCommand && cmd -> proc != discardCommand && cmd -> proc != multiCommand && cmd -> proc != watchCommand ) { queueMultiCommand ( c , cmd ) ; addReply ( c , shared . queued ) ; } else { if ( server . vm_enabled && server . vm_max_threads > 0 && blockClientOnSwappedKeys ( c , cmd ) ) return REDIS_ERR ; call ( c , cmd ) ; } return REDIS_OK ; }
Fixed code:","
int processCommand ( redisClient * c ) { struct redisCommand * cmd ; 
// check input string is valid before processing it
if (c->argv[0]->len < 0) {
  addReplyErrorFormat(c, ""input string is invalid"");
  return REDIS_OK; 
}

if ( ! strcasecmp ( c -> argv [ 0 ] -> ptr , ""quit"" ) ) { addReply ( c , shared . ok ) ; c -> flags |= REDIS_CLOSE_AFTER_REPLY ; return REDIS_ERR ; } cmd = lookupCommand ( c -> argv [ 0 ] -> ptr ) ; if ( ! cmd ) { addReplyErrorFormat ( c , ""unknown command \'%s\'"" , ( char * ) c -> argv [ 0 ] -> ptr ) ; return REDIS_OK ; } else if ( ( cmd -> arity > 0 && cmd -> arity != c -> argc ) || ( c -> argc < - cmd -> arity ) ) { addReplyErrorFormat ( c , ""wrong number of arguments for \'%s\' command"" , cmd -> name ) ; return REDIS_OK ; } if ( server . requirepass && ! c -> authenticated && cmd -> proc != authCommand ) { addReplyError ( c , ""operation not permitted"" ) ; return REDIS_OK ; } if ( server . maxmemory ) freeMemoryIfNeeded ( ) ; if ( server . maxmemory && ( cmd -> flags & REDIS_CMD_DENYOOM ) && zmalloc_used_memory ( ) > server . maxmemory ) { addReplyError ( c , ""command not allowed when used memory > \'maxmemory\'"" ) ; return REDIS_OK ; } if ( ( dictSize ( c -> pubsub_channels ) > 0 || listLength ( c -> pubsub_patterns ) > 0 ) && cmd -> proc != subscribeCommand && cmd -> proc != unsubscribeCommand && cmd -> proc != psubscribeCommand && cmd -> proc != punsubscribeCommand ) { addReplyError ( c , ""only (P)SUBSCRIBE / (P)UNSUBSCRIBE / QUIT allowed in this context"" ) ; return REDIS_OK ; } if ( server . masterhost && server . replstate != REDIS_REPL_CONNECTED && server . repl_serve_stale_data == 0 && cmd -> proc != infoCommand && cmd -> proc != slaveofCommand ) { addReplyError ( c , ""link with MASTER is down and slave-serve-stale-data is set to no"" ) ; return REDIS_OK ; } if ( server . loading && cmd -> proc != infoCommand ) { addReply ( c , shared . loadingerr ) ; return REDIS_OK ; } if ( c -> flags & REDIS_MULTI && cmd -> proc != execCommand && cmd -> proc != discardCommand && cmd -> proc != multiCommand && cmd -> proc != watchCommand ) { queueMultiCommand ( c , cmd ) ; addReply ( c , shared . queued ) ; } else { if ( server . vm_enabled && server . vm_max_threads > 0 && blockClientOnSwappedKeys ( c , cmd ) ) return REDIS_ERR ; call ( c , cmd ) ; } return REDIS_OK ; }",732,-48.656009302072725,-0.06646995806294088
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int processCommand ( redisClient * c ) { struct redisCommand * cmd ; if ( ! strcasecmp ( c -> argv [ 0 ] -> ptr , ""quit"" ) ) { addReply ( c , shared . ok ) ; c -> flags |= REDIS_CLOSE_AFTER_REPLY ; return REDIS_ERR ; } cmd = lookupCommand ( c -> argv [ 0 ] -> ptr ) ; if ( ! cmd ) { addReplyErrorFormat ( c , ""unknown command \'%s\'"" , ( char * ) c -> argv [ 0 ] -> ptr ) ; return REDIS_OK ; } else if ( ( cmd -> arity > 0 && cmd -> arity != c -> argc ) || ( c -> argc < - cmd -> arity ) ) { addReplyErrorFormat ( c , ""wrong number of arguments for \'%s\' command"" , cmd -> name ) ; return REDIS_OK ; } if ( server . requirepass && ! c -> authenticated && cmd -> proc != authCommand ) { addReplyError ( c , ""operation not permitted"" ) ; return REDIS_OK ; } if ( server . maxmemory ) freeMemoryIfNeeded ( ) ; if ( server . maxmemory && ( cmd -> flags & REDIS_CMD_DENYOOM ) && zmalloc_used_memory ( ) > server . maxmemory ) { addReplyError ( c , ""command not allowed when used memory > \'maxmemory\'"" ) ; return REDIS_OK ; } if ( ( dictSize ( c -> pubsub_channels ) > 0 || listLength ( c -> pubsub_patterns ) > 0 ) && cmd -> proc != subscribeCommand && cmd -> proc != unsubscribeCommand && cmd -> proc != psubscribeCommand && cmd -> proc != punsubscribeCommand ) { addReplyError ( c , ""only (P)SUBSCRIBE / (P)UNSUBSCRIBE / QUIT allowed in this context"" ) ; return REDIS_OK ; } if ( server . masterhost && server . replstate != REDIS_REPL_CONNECTED && server . repl_serve_stale_data == 0 && cmd -> proc != infoCommand && cmd -> proc != slaveofCommand ) { addReplyError ( c , ""link with MASTER is down and slave-serve-stale-data is set to no"" ) ; return REDIS_OK ; } if ( server . loading && cmd -> proc != infoCommand ) { addReply ( c , shared . loadingerr ) ; return REDIS_OK ; } if ( c -> flags & REDIS_MULTI && cmd -> proc != execCommand && cmd -> proc != discardCommand && cmd -> proc != multiCommand && cmd -> proc != watchCommand ) { queueMultiCommand ( c , cmd ) ; addReply ( c , shared . queued ) ; } else { if ( server . vm_enabled && server . vm_max_threads > 0 && blockClientOnSwappedKeys ( c , cmd ) ) return REDIS_ERR ; call ( c , cmd ) ; } return REDIS_OK ; }
Fixed code:","
int processCommand ( redisClient * c ) { struct redisCommand * cmd ; if ( ! strcasecmp ( c -> argv [ 0 ] -> ptr , ""quit"" ) ) { addReply ( c , shared . ok ) ; c -> flags |= REDIS_CLOSE_AFTER_REPLY ; return REDIS_ERR ; } 
// Validate user input 
if (!c->argv[0]->ptr || !strlen((char *)c->argv[0]->ptr)) { addReplyError(c, ""Input validation failed""); return REDIS_ERR; }

cmd = lookupCommand ( c -> argv [ 0 ] -> ptr ) ; if ( ! cmd ) { addReplyErrorFormat ( c , ""unknown command \'%s\'"" , ( char * ) c -> argv [ 0 ] -> ptr ) ; return REDIS_OK ; } else if ( ( cmd -> arity > 0 && cmd -> arity != c -> argc ) || ( c -> argc < - cmd -> arity ) ) { addReplyErrorFormat ( c , ""wrong number of arguments for \'%s\' command"" , cmd -> name ) ; return REDIS_OK ; } if ( server . requirepass && ! c -> authenticated && cmd -> proc != authCommand ) { addReplyError ( c , ""operation not permitted"" ) ; return REDIS_OK ; } if ( server . maxmemory ) freeMemoryIfNeeded ( ) ; if ( server . maxmemory && ( cmd -> flags & REDIS_CMD_DENYOOM ) && zmalloc_used_memory ( ) > server . maxmemory ) { addReplyError ( c , ""command not allowed when used memory > \'maxmemory\'"" ) ; return REDIS_OK ; } if ( ( dictSize ( c -> pubsub_channels ) > 0 || listLength ( c -> pubsub_patterns ) > 0 ) && cmd -> proc != subscribeCommand && cmd -> proc != unsubscribeCommand && cmd -> proc != psubscribeCommand && cmd -> proc != punsubscribeCommand ) { addReplyError ( c , ""only (P)SUBSCRIBE / (P)UNSUBSCRIBE / QUIT allowed in this context"" ) ; return REDIS_OK ; } if ( server . masterhost && server . replstate != REDIS_REPL_CONNECTED && server . repl_serve_stale_data == 0 && cmd -> proc != infoCommand && cmd -> proc != slaveofCommand ) { addReplyError ( c , ""link with MASTER is down and slave-serve-stale-data is set to no"" ) ; return REDIS_OK ; } if ( server . loading && cmd -> proc != infoCommand ) { addReply ( c , shared . loadingerr ) ; return REDIS_OK ; } if ( c -> flags & REDIS_MULTI && cmd -> proc != execCommand && cmd -> proc != discardCommand && cmd -> proc != multiCommand && cmd -> proc != watchCommand ) { queueMultiCommand ( c , cmd ) ; addReply ( c , shared . queued ) ; } else { if ( server . vm_enabled && server . vm_max_threads > 0 && blockClientOnSwappedKeys ( c , cmd ) ) return REDIS_ERR ; call ( c , cmd ) ; } return REDIS_OK ; }",736,-28.60009007632656,-0.038858818038487175
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int processCommand ( redisClient * c ) { struct redisCommand * cmd ; if ( ! strcasecmp ( c -> argv [ 0 ] -> ptr , ""quit"" ) ) { addReply ( c , shared . ok ) ; c -> flags |= REDIS_CLOSE_AFTER_REPLY ; return REDIS_ERR ; } cmd = lookupCommand ( c -> argv [ 0 ] -> ptr ) ; if ( ! cmd ) { addReplyErrorFormat ( c , ""unknown command \'%s\'"" , ( char * ) c -> argv [ 0 ] -> ptr ) ; return REDIS_OK ; } else if ( ( cmd -> arity > 0 && cmd -> arity != c -> argc ) || ( c -> argc < - cmd -> arity ) ) { addReplyErrorFormat ( c , ""wrong number of arguments for \'%s\' command"" , cmd -> name ) ; return REDIS_OK ; } if ( server . requirepass && ! c -> authenticated && cmd -> proc != authCommand ) { addReplyError ( c , ""operation not permitted"" ) ; return REDIS_OK ; } if ( server . maxmemory ) freeMemoryIfNeeded ( ) ; if ( server . maxmemory && ( cmd -> flags & REDIS_CMD_DENYOOM ) && zmalloc_used_memory ( ) > server . maxmemory ) { addReplyError ( c , ""command not allowed when used memory > \'maxmemory\'"" ) ; return REDIS_OK ; } if ( ( dictSize ( c -> pubsub_channels ) > 0 || listLength ( c -> pubsub_patterns ) > 0 ) && cmd -> proc != subscribeCommand && cmd -> proc != unsubscribeCommand && cmd -> proc != psubscribeCommand && cmd -> proc != punsubscribeCommand ) { addReplyError ( c , ""only (P)SUBSCRIBE / (P)UNSUBSCRIBE / QUIT allowed in this context"" ) ; return REDIS_OK ; } if ( server . masterhost && server . replstate != REDIS_REPL_CONNECTED && server . repl_serve_stale_data == 0 && cmd -> proc != infoCommand && cmd -> proc != slaveofCommand ) { addReplyError ( c , ""link with MASTER is down and slave-serve-stale-data is set to no"" ) ; return REDIS_OK ; } if ( server . loading && cmd -> proc != infoCommand ) { addReply ( c , shared . loadingerr ) ; return REDIS_OK ; } if ( c -> flags & REDIS_MULTI && cmd -> proc != execCommand && cmd -> proc != discardCommand && cmd -> proc != multiCommand && cmd -> proc != watchCommand ) { queueMultiCommand ( c , cmd ) ; addReply ( c , shared . queued ) ; } else { if ( server . vm_enabled && server . vm_max_threads > 0 && blockClientOnSwappedKeys ( c , cmd ) ) return REDIS_ERR ; call ( c , cmd ) ; } return REDIS_OK ; }
Fixed code:","
int processCommand ( redisClient * c ) { struct redisCommand * cmd ; char * cmdName ; if ( c -> argv [ 0 ] -> len > REDIS_COMMAND_MAX_LEN ) { addReplyError ( c , ""command too long"" ) ; return REDIS_OK ; } cmdName = c -> argv [ 0 ] -> ptr ; if ( ! strcasecmp ( cmdName , ""quit"" ) ) { addReply ( c , shared . ok ) ; c -> flags |= REDIS_CLOSE_AFTER_REPLY ; return REDIS_ERR ; } cmd = lookupCommand ( cmdName ) ; if ( ! cmd ) { addReplyErrorFormat ( c , ""unknown command \'%s\'"" , cmdName ) ; return REDIS_OK ; } else if ( ( cmd -> arity > 0 && cmd -> arity != c -> argc ) || ( c -> argc < - cmd -> arity ) ) { addReplyErrorFormat ( c , ""wrong number of arguments for \'%s\' command"" , cmd -> name ) ; return REDIS_OK ; } if ( server . requirepass && ! c -> authenticated && cmd -> proc != authCommand ) { addReplyError ( c , ""operation not permitted"" ) ; return REDIS_OK ; } if ( server . maxmemory ) freeMemoryIfNeeded ( ) ; if ( server . maxmemory && ( cmd -> flags & REDIS_CMD_DENYOOM ) && zmalloc_used_memory ( ) > server . maxmemory ) { addReplyError ( c , ""command not allowed when used memory > \'maxmemory\'"" ) ; return REDIS_OK ; } if ( ( dictSize ( c -> pubsub_channels ) > 0 || listLength ( c -> pubsub_patterns ) > 0 ) && cmd -> proc != subscribeCommand && cmd -> proc != unsubscribeCommand && cmd -> proc != psubscribeCommand && cmd -> proc != punsubscribeCommand ) { addReplyError ( c , ""only (P)SUBSCRIBE / (P)UNSUBSCRIBE / QUIT allowed in this context"" ) ; return REDIS_OK ; } if ( server . masterhost && server . replstate != REDIS_REPL_CONNECTED && server . repl_serve_stale_data == 0 && cmd -> proc != infoCommand && cmd -> proc != slaveofCommand ) { addReplyError ( c , ""link with MASTER is down and slave-serve-stale-data is set to no"" ) ; return REDIS_OK ; } if ( server . loading && cmd -> proc != infoCommand ) { addReply ( c , shared . loadingerr ) ; return REDIS_OK ; } if ( c -> flags & REDIS_MULTI && cmd -> proc != execCommand && cmd -> proc != discardCommand && cmd -> proc != multiCommand && cmd -> proc != watchCommand ) { queueMultiCommand ( c , cmd ) ; addReply ( c , shared . queued ) ; } else { if ( server . vm_enabled && server . vm_max_threads > 0 && blockClientOnSwappedKeys ( c , cmd ) ) return REDIS_ERR ; call ( c , cmd ) ; } return REDIS_OK ; }",715,-18.325247291071154,-0.025629716491008606
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int processCommand ( redisClient * c ) { struct redisCommand * cmd ; if ( ! strcasecmp ( c -> argv [ 0 ] -> ptr , ""quit"" ) ) { addReply ( c , shared . ok ) ; c -> flags |= REDIS_CLOSE_AFTER_REPLY ; return REDIS_ERR ; } cmd = lookupCommand ( c -> argv [ 0 ] -> ptr ) ; if ( ! cmd ) { addReplyErrorFormat ( c , ""unknown command \'%s\'"" , ( char * ) c -> argv [ 0 ] -> ptr ) ; return REDIS_OK ; } else if ( ( cmd -> arity > 0 && cmd -> arity != c -> argc ) || ( c -> argc < - cmd -> arity ) ) { addReplyErrorFormat ( c , ""wrong number of arguments for \'%s\' command"" , cmd -> name ) ; return REDIS_OK ; } if ( server . requirepass && ! c -> authenticated && cmd -> proc != authCommand ) { addReplyError ( c , ""operation not permitted"" ) ; return REDIS_OK ; } if ( server . maxmemory ) freeMemoryIfNeeded ( ) ; if ( server . maxmemory && ( cmd -> flags & REDIS_CMD_DENYOOM ) && zmalloc_used_memory ( ) > server . maxmemory ) { addReplyError ( c , ""command not allowed when used memory > \'maxmemory\'"" ) ; return REDIS_OK ; } if ( ( dictSize ( c -> pubsub_channels ) > 0 || listLength ( c -> pubsub_patterns ) > 0 ) && cmd -> proc != subscribeCommand && cmd -> proc != unsubscribeCommand && cmd -> proc != psubscribeCommand && cmd -> proc != punsubscribeCommand ) { addReplyError ( c , ""only (P)SUBSCRIBE / (P)UNSUBSCRIBE / QUIT allowed in this context"" ) ; return REDIS_OK ; } if ( server . masterhost && server . replstate != REDIS_REPL_CONNECTED && server . repl_serve_stale_data == 0 && cmd -> proc != infoCommand && cmd -> proc != slaveofCommand ) { addReplyError ( c , ""link with MASTER is down and slave-serve-stale-data is set to no"" ) ; return REDIS_OK ; } if ( server . loading && cmd -> proc != infoCommand ) { addReply ( c , shared . loadingerr ) ; return REDIS_OK ; } if ( c -> flags & REDIS_MULTI && cmd -> proc != execCommand && cmd -> proc != discardCommand && cmd -> proc != multiCommand && cmd -> proc != watchCommand ) { queueMultiCommand ( c , cmd ) ; addReply ( c , shared . queued ) ; } else { if ( server . vm_enabled && server . vm_max_threads > 0 && blockClientOnSwappedKeys ( c , cmd ) ) return REDIS_ERR ; call ( c , cmd ) ; } return REDIS_OK ; }
Fixed code:","
int processCommand ( redisClient * c ) { struct redisCommand * cmd ; if ( ! strcasecmp ( c -> argv [ 0 ] -> ptr , ""quit"" ) ) { addReply ( c , shared . ok ) ; c -> flags |= REDIS_CLOSE_AFTER_REPLY ; return REDIS_ERR ; } // Validate input if (! c->argv[0]->ptr || ! strlen(c->argv[0]->ptr)) { addReply(c, shared.wrongargc); return REDIS_ERR; } cmd = lookupCommand ( c -> argv [ 0 ] -> ptr ) ; if ( ! cmd ) { addReplyErrorFormat ( c , ""unknown command \'%s\'"" , ( char * ) c -> argv [ 0 ] -> ptr ) ; return REDIS_OK ; } else if ( ( cmd -> arity > 0 && cmd -> arity != c -> argc ) || ( c -> argc < - cmd -> arity ) ) { addReplyErrorFormat ( c , ""wrong number of arguments for \'%s\' command"" , cmd -> name ) ; return REDIS_OK ; } if ( server . requirepass && ! c -> authenticated && cmd -> proc != authCommand ) { addReplyError ( c , ""operation not permitted"" ) ; return REDIS_OK ; } if ( server . maxmemory ) freeMemoryIfNeeded ( ) ; if ( server . maxmemory && ( cmd -> flags & REDIS_CMD_DENYOOM ) && zmalloc_used_memory ( ) > server . maxmemory ) { addReplyError ( c , ""command not allowed when used memory > \'maxmemory\'"" ) ; return REDIS_OK ; } if ( ( dictSize ( c -> pubsub_channels ) > 0 || listLength ( c -> pubsub_patterns ) > 0 ) && cmd -> proc != subscribeCommand && cmd -> proc != unsubscribeCommand && cmd -> proc != psubscribeCommand && cmd -> proc != punsubscribeCommand ) { addReplyError ( c , ""only (P)SUBSCRIBE / (P)UNSUBSCRIBE / QUIT allowed in this context"" ) ; return REDIS_OK ; } if ( server . masterhost && server . replstate != REDIS_REPL_CONNECTED && server . repl_serve_stale_data == 0 && cmd -> proc != infoCommand && cmd -> proc != slaveofCommand ) { addReplyError ( c , ""link with MASTER is down and slave-serve-stale-data is set to no"" ) ; return REDIS_OK ; } if ( server . loading && cmd -> proc != infoCommand ) { addReply ( c , shared . loadingerr ) ; return REDIS_OK ; } if ( c -> flags & REDIS_MULTI && cmd -> proc != execCommand && cmd -> proc != discardCommand && cmd -> proc != multiCommand && cmd -> proc != watchCommand ) { queueMultiCommand ( c , cmd ) ; addReply ( c , shared . queued ) ; } else { if ( server . vm_enabled && server . vm_max_threads > 0 && blockClientOnSwappedKeys ( c , cmd ) ) return REDIS_ERR ; call ( c , cmd ) ; } return REDIS_OK ; }",727,-25.37633109009698,-0.03490554482819392
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int processCommand ( redisClient * c ) { struct redisCommand * cmd ; if ( ! strcasecmp ( c -> argv [ 0 ] -> ptr , ""quit"" ) ) { addReply ( c , shared . ok ) ; c -> flags |= REDIS_CLOSE_AFTER_REPLY ; return REDIS_ERR ; } cmd = lookupCommand ( c -> argv [ 0 ] -> ptr ) ; if ( ! cmd ) { addReplyErrorFormat ( c , ""unknown command \'%s\'"" , ( char * ) c -> argv [ 0 ] -> ptr ) ; return REDIS_OK ; } else if ( ( cmd -> arity > 0 && cmd -> arity != c -> argc ) || ( c -> argc < - cmd -> arity ) ) { addReplyErrorFormat ( c , ""wrong number of arguments for \'%s\' command"" , cmd -> name ) ; return REDIS_OK ; } if ( server . requirepass && ! c -> authenticated && cmd -> proc != authCommand ) { addReplyError ( c , ""operation not permitted"" ) ; return REDIS_OK ; } if ( server . maxmemory ) freeMemoryIfNeeded ( ) ; if ( server . maxmemory && ( cmd -> flags & REDIS_CMD_DENYOOM ) && zmalloc_used_memory ( ) > server . maxmemory ) { addReplyError ( c , ""command not allowed when used memory > \'maxmemory\'"" ) ; return REDIS_OK ; } if ( ( dictSize ( c -> pubsub_channels ) > 0 || listLength ( c -> pubsub_patterns ) > 0 ) && cmd -> proc != subscribeCommand && cmd -> proc != unsubscribeCommand && cmd -> proc != psubscribeCommand && cmd -> proc != punsubscribeCommand ) { addReplyError ( c , ""only (P)SUBSCRIBE / (P)UNSUBSCRIBE / QUIT allowed in this context"" ) ; return REDIS_OK ; } if ( server . masterhost && server . replstate != REDIS_REPL_CONNECTED && server . repl_serve_stale_data == 0 && cmd -> proc != infoCommand && cmd -> proc != slaveofCommand ) { addReplyError ( c , ""link with MASTER is down and slave-serve-stale-data is set to no"" ) ; return REDIS_OK ; } if ( server . loading && cmd -> proc != infoCommand ) { addReply ( c , shared . loadingerr ) ; return REDIS_OK ; } if ( c -> flags & REDIS_MULTI && cmd -> proc != execCommand && cmd -> proc != discardCommand && cmd -> proc != multiCommand && cmd -> proc != watchCommand ) { queueMultiCommand ( c , cmd ) ; addReply ( c , shared . queued ) ; } else { if ( server . vm_enabled && server . vm_max_threads > 0 && blockClientOnSwappedKeys ( c , cmd ) ) return REDIS_ERR ; call ( c , cmd ) ; } return REDIS_OK ; }
Fixed code:","
int processCommand ( redisClient * c ) { 

    // Check if the command is alpha-numeric
    char * cmdName = c->argv[0]->ptr;
    for (int i = 0; i < strlen(cmdName); i++) {
        if (!isalpha(cmdName[i]) && !isdigit(cmdName[i])) {
            addReplyErrorFormat ( c , ""invalid command name \'%s\'"" , ( char * ) c -> argv [ 0 ] -> ptr ) ; 
            return REDIS_OK ;
        }
    }

    struct redisCommand * cmd ; 
    if ( ! strcasecmp ( c -> argv [ 0 ] -> ptr , ""quit"" ) ) { 
        addReply ( c , shared . ok ) ; 
        c -> flags |= REDIS_CLOSE_AFTER_REPLY ; 
        return REDIS_ERR ; 
    } 
    cmd = lookupCommand ( c -> argv [ 0 ] -> ptr ) ; 
    if ( ! cmd ) { 
        addReplyErrorFormat ( c , ""unknown command \'%s\'"" , ( char * ) c -> argv [ 0 ] -> ptr ) ; 
        return REDIS_OK ; 
    } else if ( ( cmd -> arity > 0 && cmd -> arity != c -> argc ) || ( c -> argc < - cmd -> arity ) ) { 
        addReplyErrorFormat ( c , ""wrong number of arguments for \'%s\' command"" , cmd -> name ) ; 
        return REDIS_OK ; 
    } 
    if ( server . requirepass && ! c -> authenticated && cmd -> proc != authCommand ) { 
        addReplyError ( c , ""operation not permitted"" ) ; 
        return REDIS_OK ; 
    } 
    if ( server . maxmemory ) freeMemoryIfNeeded ( ) ; 
    if ( server . maxmemory && ( cmd -> flags & REDIS_CMD_DENYOOM ) && zmalloc_used_memory ( ) > server . maxmemory ) { 
        addReplyError ( c , ""command not allowed when used memory > \'maxmemory\'"" ) ; 
        return REDIS_OK ; 
    } 
    if ( ( dictSize ( c -> pubsub_channels ) > 0 || listLength ( c -> pubsub_patterns ) > 0 ) && cmd -> proc != subscribeCommand && cmd -> proc != unsubscribeCommand && cmd -> proc != psubscribeCommand && cmd -> proc != punsubscribeCommand ) { 
        addReplyError ( c , ""only (P)SUBSCRIBE / (P)UNSUBSCRIBE / QUIT allowed in this context"" ) ; 
        return REDIS_OK ; 
    } 
    if ( server . masterhost && server . replstate != REDIS_REPL_CONNECTED && server . repl_serve_stale_data == 0 && cmd -> proc != infoCommand && cmd -> proc != slaveofCommand ) { 
        addReplyError ( c , ""link with MASTER is down and slave-serve-stale-data is set to no"" ) ; 
        return REDIS_OK ; 
    } 
    if ( server . loading && cmd -> proc != infoCommand ) { 
        addReply ( c , shared . loadingerr ) ; 
        return REDIS_OK ; 
    } 
    if ( c -> flags & REDIS_MULTI && cmd -> proc != execCommand && cmd -> proc != discardCommand && cmd -> proc != multiCommand && cmd -> proc != watchCommand ) { 
        queueMultiCommand ( c , cmd ) ; 
        addReply ( c , shared . queued ) ; 
    } else { 
        if ( server . vm_enabled && server . vm_max_threads > 0 && blockClientOnSwappedKeys ( c , cmd ) ) return REDIS_ERR ; 
        call ( c , cmd ) ; 
    } 
    return REDIS_OK ; 
}",932,-38.062554672993066,-0.04083965093668784
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int processCommand ( redisClient * c ) { struct redisCommand * cmd ; if ( ! strcasecmp ( c -> argv [ 0 ] -> ptr , ""quit"" ) ) { addReply ( c , shared . ok ) ; c -> flags |= REDIS_CLOSE_AFTER_REPLY ; return REDIS_ERR ; } cmd = lookupCommand ( c -> argv [ 0 ] -> ptr ) ; if ( ! cmd ) { addReplyErrorFormat ( c , ""unknown command \'%s\'"" , ( char * ) c -> argv [ 0 ] -> ptr ) ; return REDIS_OK ; } else if ( ( cmd -> arity > 0 && cmd -> arity != c -> argc ) || ( c -> argc < - cmd -> arity ) ) { addReplyErrorFormat ( c , ""wrong number of arguments for \'%s\' command"" , cmd -> name ) ; return REDIS_OK ; } if ( server . requirepass && ! c -> authenticated && cmd -> proc != authCommand ) { addReplyError ( c , ""operation not permitted"" ) ; return REDIS_OK ; } if ( server . maxmemory ) freeMemoryIfNeeded ( ) ; if ( server . maxmemory && ( cmd -> flags & REDIS_CMD_DENYOOM ) && zmalloc_used_memory ( ) > server . maxmemory ) { addReplyError ( c , ""command not allowed when used memory > \'maxmemory\'"" ) ; return REDIS_OK ; } if ( ( dictSize ( c -> pubsub_channels ) > 0 || listLength ( c -> pubsub_patterns ) > 0 ) && cmd -> proc != subscribeCommand && cmd -> proc != unsubscribeCommand && cmd -> proc != psubscribeCommand && cmd -> proc != punsubscribeCommand ) { addReplyError ( c , ""only (P)SUBSCRIBE / (P)UNSUBSCRIBE / QUIT allowed in this context"" ) ; return REDIS_OK ; } if ( server . masterhost && server . replstate != REDIS_REPL_CONNECTED && server . repl_serve_stale_data == 0 && cmd -> proc != infoCommand && cmd -> proc != slaveofCommand ) { addReplyError ( c , ""link with MASTER is down and slave-serve-stale-data is set to no"" ) ; return REDIS_OK ; } if ( server . loading && cmd -> proc != infoCommand ) { addReply ( c , shared . loadingerr ) ; return REDIS_OK ; } if ( c -> flags & REDIS_MULTI && cmd -> proc != execCommand && cmd -> proc != discardCommand && cmd -> proc != multiCommand && cmd -> proc != watchCommand ) { queueMultiCommand ( c , cmd ) ; addReply ( c , shared . queued ) ; } else { if ( server . vm_enabled && server . vm_max_threads > 0 && blockClientOnSwappedKeys ( c , cmd ) ) return REDIS_ERR ; call ( c , cmd ) ; } return REDIS_OK ; }
Fixed code:","
int processCommand ( redisClient * c ) { struct redisCommand * cmd ; 

// Validate input 
if ( c -> argv [ 0 ] == NULL || strlen(c->argv[0]->ptr) == 0 ) { 
    addReplyError(c, ""Invalid input, please try again.""); 
    return REDIS_OK; 
} 

if ( ! strcasecmp ( c -> argv [ 0 ] -> ptr , ""quit"" ) ) { addReply ( c , shared . ok ) ; c -> flags |= REDIS_CLOSE_AFTER_REPLY ; return REDIS_ERR ; } cmd = lookupCommand ( c -> argv [ 0 ] -> ptr ) ; if ( ! cmd ) { addReplyErrorFormat ( c , ""unknown command \'%s\'"" , ( char * ) c -> argv [ 0 ] -> ptr ) ; return REDIS_OK ; } else if ( ( cmd -> arity > 0 && cmd -> arity != c -> argc ) || ( c -> argc < - cmd -> arity ) ) { addReplyErrorFormat ( c , ""wrong number of arguments for \'%s\' command"" , cmd -> name ) ; return REDIS_OK ; } if ( server . requirepass && ! c -> authenticated && cmd -> proc != authCommand ) { addReplyError ( c , ""operation not permitted"" ) ; return REDIS_OK ; } if ( server . maxmemory ) freeMemoryIfNeeded ( ) ; if ( server . maxmemory && ( cmd -> flags & REDIS_CMD_DENYOOM ) && zmalloc_used_memory ( ) > server . maxmemory ) { addReplyError ( c , ""command not allowed when used memory > \'maxmemory\'"" ) ; return REDIS_OK ; } if ( ( dictSize ( c -> pubsub_channels ) > 0 || listLength ( c -> pubsub_patterns ) > 0 ) && cmd -> proc != subscribeCommand && cmd -> proc != unsubscribeCommand && cmd -> proc != psubscribeCommand && cmd -> proc != punsubscribeCommand ) { addReplyError ( c , ""only (P)SUBSCRIBE / (P)UNSUBSCRIBE / QUIT allowed in this context"" ) ; return REDIS_OK ; } if ( server . masterhost && server . replstate != REDIS_REPL_CONNECTED && server . repl_serve_stale_data == 0 && cmd -> proc != infoCommand && cmd -> proc != slaveofCommand ) { addReplyError ( c , ""link with MASTER is down and slave-serve-stale-data is set to no"" ) ; return REDIS_OK ; } if ( server . loading && cmd -> proc != infoCommand ) { addReply ( c , shared . loadingerr ) ; return REDIS_OK ; } if ( c -> flags & REDIS_MULTI && cmd -> proc != execCommand && cmd -> proc != discardCommand && cmd -> proc != multiCommand && cmd -> proc != watchCommand ) { queueMultiCommand ( c , cmd ) ; addReply ( c , shared . queued ) ; } else { if ( server . vm_enabled && server . vm_max_threads > 0 && blockClientOnSwappedKeys ( c , cmd ) ) return REDIS_ERR ; call ( c , cmd ) ; } return REDIS_OK ; }",748,-30.581078525512762,-0.040883794820204225
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int processCommand ( redisClient * c ) { struct redisCommand * cmd ; if ( ! strcasecmp ( c -> argv [ 0 ] -> ptr , ""quit"" ) ) { addReply ( c , shared . ok ) ; c -> flags |= REDIS_CLOSE_AFTER_REPLY ; return REDIS_ERR ; } cmd = lookupCommand ( c -> argv [ 0 ] -> ptr ) ; if ( ! cmd ) { addReplyErrorFormat ( c , ""unknown command \'%s\'"" , ( char * ) c -> argv [ 0 ] -> ptr ) ; return REDIS_OK ; } else if ( ( cmd -> arity > 0 && cmd -> arity != c -> argc ) || ( c -> argc < - cmd -> arity ) ) { addReplyErrorFormat ( c , ""wrong number of arguments for \'%s\' command"" , cmd -> name ) ; return REDIS_OK ; } if ( server . requirepass && ! c -> authenticated && cmd -> proc != authCommand ) { addReplyError ( c , ""operation not permitted"" ) ; return REDIS_OK ; } if ( server . maxmemory ) freeMemoryIfNeeded ( ) ; if ( server . maxmemory && ( cmd -> flags & REDIS_CMD_DENYOOM ) && zmalloc_used_memory ( ) > server . maxmemory ) { addReplyError ( c , ""command not allowed when used memory > \'maxmemory\'"" ) ; return REDIS_OK ; } if ( ( dictSize ( c -> pubsub_channels ) > 0 || listLength ( c -> pubsub_patterns ) > 0 ) && cmd -> proc != subscribeCommand && cmd -> proc != unsubscribeCommand && cmd -> proc != psubscribeCommand && cmd -> proc != punsubscribeCommand ) { addReplyError ( c , ""only (P)SUBSCRIBE / (P)UNSUBSCRIBE / QUIT allowed in this context"" ) ; return REDIS_OK ; } if ( server . masterhost && server . replstate != REDIS_REPL_CONNECTED && server . repl_serve_stale_data == 0 && cmd -> proc != infoCommand && cmd -> proc != slaveofCommand ) { addReplyError ( c , ""link with MASTER is down and slave-serve-stale-data is set to no"" ) ; return REDIS_OK ; } if ( server . loading && cmd -> proc != infoCommand ) { addReply ( c , shared . loadingerr ) ; return REDIS_OK ; } if ( c -> flags & REDIS_MULTI && cmd -> proc != execCommand && cmd -> proc != discardCommand && cmd -> proc != multiCommand && cmd -> proc != watchCommand ) { queueMultiCommand ( c , cmd ) ; addReply ( c , shared . queued ) ; } else { if ( server . vm_enabled && server . vm_max_threads > 0 && blockClientOnSwappedKeys ( c , cmd ) ) return REDIS_ERR ; call ( c , cmd ) ; } return REDIS_OK ; }
Fixed code:","
int processCommand ( redisClient * c ) { struct redisCommand * cmd ; 
//Validate command input
if (!c->argv[0] || !strlen((char*) c->argv[0]->ptr) {
    addReplyError(c, ""Command input is invalid"");
    return REDIS_OK;
}

if ( ! strcasecmp ( c -> argv [ 0 ] -> ptr , ""quit"" ) ) { addReply ( c , shared . ok ) ; c -> flags |= REDIS_CLOSE_AFTER_REPLY ; return REDIS_ERR ; } cmd = lookupCommand ( c -> argv [ 0 ] -> ptr ) ; if ( ! cmd ) { addReplyErrorFormat ( c , ""unknown command \'%s\'"" , ( char * ) c -> argv [ 0 ] -> ptr ) ; return REDIS_OK ; } else if ( ( cmd -> arity > 0 && cmd -> arity != c -> argc ) || ( c -> argc < - cmd -> arity ) ) { addReplyErrorFormat ( c , ""wrong number of arguments for \'%s\' command"" , cmd -> name ) ; return REDIS_OK ; } if ( server . requirepass && ! c -> authenticated && cmd -> proc != authCommand ) { addReplyError ( c , ""operation not permitted"" ) ; return REDIS_OK ; } if ( server . maxmemory ) freeMemoryIfNeeded ( ) ; if ( server . maxmemory && ( cmd -> flags & REDIS_CMD_DENYOOM ) && zmalloc_used_memory ( ) > server . maxmemory ) { addReplyError ( c , ""command not allowed when used memory > \'maxmemory\'"" ) ; return REDIS_OK ; } if ( ( dictSize ( c -> pubsub_channels ) > 0 || listLength ( c -> pubsub_patterns ) > 0 ) && cmd -> proc != subscribeCommand && cmd -> proc != unsubscribeCommand && cmd -> proc != psubscribeCommand && cmd -> proc != punsubscribeCommand ) { addReplyError ( c , ""only (P)SUBSCRIBE / (P)UNSUBSCRIBE / QUIT allowed in this context"" ) ; return REDIS_OK ; } if ( server . masterhost && server . replstate != REDIS_REPL_CONNECTED && server . repl_serve_stale_data == 0 && cmd -> proc != infoCommand && cmd -> proc != slaveofCommand ) { addReplyError ( c , ""link with MASTER is down and slave-serve-stale-data is set to no"" ) ; return REDIS_OK ; } if ( server . loading && cmd -> proc != infoCommand ) { addReply ( c , shared . loadingerr ) ; return REDIS_OK ; } if ( c -> flags & REDIS_MULTI && cmd -> proc != execCommand && cmd -> proc != discardCommand && cmd -> proc != multiCommand && cmd -> proc != watchCommand ) { queueMultiCommand ( c , cmd ) ; addReply ( c , shared . queued ) ; } else { if ( server . vm_enabled && server . vm_max_threads > 0 && blockClientOnSwappedKeys ( c , cmd ) ) return REDIS_ERR ; call ( c , cmd ) ; } return REDIS_OK ; }",738,-30.71008151989358,-0.041612576585221654
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int processCommand ( redisClient * c ) { struct redisCommand * cmd ; if ( ! strcasecmp ( c -> argv [ 0 ] -> ptr , ""quit"" ) ) { addReply ( c , shared . ok ) ; c -> flags |= REDIS_CLOSE_AFTER_REPLY ; return REDIS_ERR ; } cmd = lookupCommand ( c -> argv [ 0 ] -> ptr ) ; if ( ! cmd ) { addReplyErrorFormat ( c , ""unknown command \'%s\'"" , ( char * ) c -> argv [ 0 ] -> ptr ) ; return REDIS_OK ; } else if ( ( cmd -> arity > 0 && cmd -> arity != c -> argc ) || ( c -> argc < - cmd -> arity ) ) { addReplyErrorFormat ( c , ""wrong number of arguments for \'%s\' command"" , cmd -> name ) ; return REDIS_OK ; } if ( server . requirepass && ! c -> authenticated && cmd -> proc != authCommand ) { addReplyError ( c , ""operation not permitted"" ) ; return REDIS_OK ; } if ( server . maxmemory ) freeMemoryIfNeeded ( ) ; if ( server . maxmemory && ( cmd -> flags & REDIS_CMD_DENYOOM ) && zmalloc_used_memory ( ) > server . maxmemory ) { addReplyError ( c , ""command not allowed when used memory > \'maxmemory\'"" ) ; return REDIS_OK ; } if ( ( dictSize ( c -> pubsub_channels ) > 0 || listLength ( c -> pubsub_patterns ) > 0 ) && cmd -> proc != subscribeCommand && cmd -> proc != unsubscribeCommand && cmd -> proc != psubscribeCommand && cmd -> proc != punsubscribeCommand ) { addReplyError ( c , ""only (P)SUBSCRIBE / (P)UNSUBSCRIBE / QUIT allowed in this context"" ) ; return REDIS_OK ; } if ( server . masterhost && server . replstate != REDIS_REPL_CONNECTED && server . repl_serve_stale_data == 0 && cmd -> proc != infoCommand && cmd -> proc != slaveofCommand ) { addReplyError ( c , ""link with MASTER is down and slave-serve-stale-data is set to no"" ) ; return REDIS_OK ; } if ( server . loading && cmd -> proc != infoCommand ) { addReply ( c , shared . loadingerr ) ; return REDIS_OK ; } if ( c -> flags & REDIS_MULTI && cmd -> proc != execCommand && cmd -> proc != discardCommand && cmd -> proc != multiCommand && cmd -> proc != watchCommand ) { queueMultiCommand ( c , cmd ) ; addReply ( c , shared . queued ) ; } else { if ( server . vm_enabled && server . vm_max_threads > 0 && blockClientOnSwappedKeys ( c , cmd ) ) return REDIS_ERR ; call ( c , cmd ) ; } return REDIS_OK ; }
Fixed code:","
int processCommand ( redisClient * c ) { struct redisCommand * cmd ; // Validate command input if ( c -> argv [ 0 ] == NULL || ! c -> argv [ 0 ] -> ptr ) { addReplyError ( c , ""No command provided"" ) ; return REDIS_OK ; } if ( ! strcasecmp ( c -> argv [ 0 ] -> ptr , ""quit"" ) ) { addReply ( c , shared . ok ) ; c -> flags |= REDIS_CLOSE_AFTER_REPLY ; return REDIS_ERR ; } cmd = lookupCommand ( c -> argv [ 0 ] -> ptr ) ; if ( ! cmd ) { addReplyErrorFormat ( c , ""unknown command \'%s\'"" , ( char * ) c -> argv [ 0 ] -> ptr ) ; return REDIS_OK ; } else if ( ( cmd -> arity > 0 && cmd -> arity != c -> argc ) || ( c -> argc < - cmd -> arity ) ) { addReplyErrorFormat ( c , ""wrong number of arguments for \'%s\' command"" , cmd -> name ) ; return REDIS_OK ; } if ( server . requirepass && ! c -> authenticated && cmd -> proc != authCommand ) { addReplyError ( c , ""operation not permitted"" ) ; return REDIS_OK ; } if ( server . maxmemory ) freeMemoryIfNeeded ( ) ; if ( server . maxmemory && ( cmd -> flags & REDIS_CMD_DENYOOM ) && zmalloc_used_memory ( ) > server . maxmemory ) { addReplyError ( c , ""command not allowed when used memory > \'maxmemory\'"" ) ; return REDIS_OK ; } if ( ( dictSize ( c -> pubsub_channels ) > 0 || listLength ( c -> pubsub_patterns ) > 0 ) && cmd -> proc != subscribeCommand && cmd -> proc != unsubscribeCommand && cmd -> proc != psubscribeCommand && cmd -> proc != punsubscribeCommand ) { addReplyError ( c , ""only (P)SUBSCRIBE / (P)UNSUBSCRIBE / QUIT allowed in this context"" ) ; return REDIS_OK ; } if ( server . masterhost && server . replstate != REDIS_REPL_CONNECTED && server . repl_serve_stale_data == 0 && cmd -> proc != infoCommand && cmd -> proc != slaveofCommand ) { addReplyError ( c , ""link with MASTER is down and slave-serve-stale-data is set to no"" ) ; return REDIS_OK ; } if ( server . loading && cmd -> proc != infoCommand ) { addReply ( c , shared . loadingerr ) ; return REDIS_OK ; } if ( c -> flags & REDIS_MULTI && cmd -> proc != execCommand && cmd -> proc != discardCommand && cmd -> proc != multiCommand && cmd -> proc != watchCommand ) { queueMultiCommand ( c , cmd ) ; addReply ( c , shared . queued ) ; } else { if ( server . vm_enabled && server . vm_max_threads > 0 && blockClientOnSwappedKeys ( c , cmd ) ) return REDIS_ERR ; call ( c , cmd ) ; } return REDIS_OK ; }",726,-18.529980012231892,-0.025523388446600404
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int processCommand ( redisClient * c ) { struct redisCommand * cmd ; if ( ! strcasecmp ( c -> argv [ 0 ] -> ptr , ""quit"" ) ) { addReply ( c , shared . ok ) ; c -> flags |= REDIS_CLOSE_AFTER_REPLY ; return REDIS_ERR ; } cmd = lookupCommand ( c -> argv [ 0 ] -> ptr ) ; if ( ! cmd ) { addReplyErrorFormat ( c , ""unknown command \'%s\'"" , ( char * ) c -> argv [ 0 ] -> ptr ) ; return REDIS_OK ; } else if ( ( cmd -> arity > 0 && cmd -> arity != c -> argc ) || ( c -> argc < - cmd -> arity ) ) { addReplyErrorFormat ( c , ""wrong number of arguments for \'%s\' command"" , cmd -> name ) ; return REDIS_OK ; } if ( server . requirepass && ! c -> authenticated && cmd -> proc != authCommand ) { addReplyError ( c , ""operation not permitted"" ) ; return REDIS_OK ; } if ( server . maxmemory ) freeMemoryIfNeeded ( ) ; if ( server . maxmemory && ( cmd -> flags & REDIS_CMD_DENYOOM ) && zmalloc_used_memory ( ) > server . maxmemory ) { addReplyError ( c , ""command not allowed when used memory > \'maxmemory\'"" ) ; return REDIS_OK ; } if ( ( dictSize ( c -> pubsub_channels ) > 0 || listLength ( c -> pubsub_patterns ) > 0 ) && cmd -> proc != subscribeCommand && cmd -> proc != unsubscribeCommand && cmd -> proc != psubscribeCommand && cmd -> proc != punsubscribeCommand ) { addReplyError ( c , ""only (P)SUBSCRIBE / (P)UNSUBSCRIBE / QUIT allowed in this context"" ) ; return REDIS_OK ; } if ( server . masterhost && server . replstate != REDIS_REPL_CONNECTED && server . repl_serve_stale_data == 0 && cmd -> proc != infoCommand && cmd -> proc != slaveofCommand ) { addReplyError ( c , ""link with MASTER is down and slave-serve-stale-data is set to no"" ) ; return REDIS_OK ; } if ( server . loading && cmd -> proc != infoCommand ) { addReply ( c , shared . loadingerr ) ; return REDIS_OK ; } if ( c -> flags & REDIS_MULTI && cmd -> proc != execCommand && cmd -> proc != discardCommand && cmd -> proc != multiCommand && cmd -> proc != watchCommand ) { queueMultiCommand ( c , cmd ) ; addReply ( c , shared . queued ) ; } else { if ( server . vm_enabled && server . vm_max_threads > 0 && blockClientOnSwappedKeys ( c , cmd ) ) return REDIS_ERR ; call ( c , cmd ) ; } return REDIS_OK ; }
Fixed code:","
int processCommand ( redisClient * c ) { 
struct redisCommand * cmd ; 
if ( ! strcasecmp ( c -> argv [ 0 ] -> ptr , ""quit"" ) ) { 
    addReply ( c , shared . ok ) ; 
    c -> flags |= REDIS_CLOSE_AFTER_REPLY ; 
    return REDIS_ERR ; 
} 

// Validate input
if (!c->argv[0]->ptr || strlen(c->argv[0]->ptr) > REDIS_MAX_COMMAND_LEN) {
    addReplyError(c, ""Invalid command"");
    return REDIS_OK;
}

cmd = lookupCommand ( c -> argv [ 0 ] -> ptr ) ; 
if ( ! cmd ) { 
    addReplyErrorFormat ( c , ""unknown command \'%s\'"" , ( char * ) c -> argv [ 0 ] -> ptr ) ; 
    return REDIS_OK ; 
} else if ( ( cmd -> arity > 0 && cmd -> arity != c -> argc ) || ( c -> argc < - cmd -> arity ) ) { 
    addReplyErrorFormat ( c , ""wrong number of arguments for \'%s\' command"" , cmd -> name ) ; 
    return REDIS_OK ; 
} 
if ( server . requirepass && ! c -> authenticated && cmd -> proc != authCommand ) { 
    addReplyError ( c , ""operation not permitted"" ) ; 
    return REDIS_OK ; 
} 
if ( server . maxmemory ) freeMemoryIfNeeded ( ) ; 
if ( server . maxmemory && ( cmd -> flags & REDIS_CMD_DENYOOM ) && zmalloc_used_memory ( ) > server . maxmemory ) { 
    addReplyError ( c , ""command not allowed when used memory > \'maxmemory\'"" ) ; 
    return REDIS_OK ; 
} 
if ( ( dictSize ( c -> pubsub_channels ) > 0 || listLength ( c -> pubsub_patterns ) > 0 ) && cmd -> proc != subscribeCommand && cmd -> proc != unsubscribeCommand && cmd -> proc != psubscribeCommand && cmd -> proc != punsubscribeCommand ) { 
    addReplyError ( c , ""only (P)SUBSCRIBE / (P)UNSUBSCRIBE / QUIT allowed in this context"" ) ; 
    return REDIS_OK ; 
} 
if ( server . masterhost && server . replstate != REDIS_REPL_CONNECTED && server . repl_serve_stale_data == 0 && cmd -> proc != infoCommand && cmd -> proc != slaveofCommand ) { 
    addReplyError ( c , ""link with MASTER is down and slave-serve-stale-data is set to no"" ) ; 
    return REDIS_OK ; 
} 
if ( server . loading && cmd -> proc != infoCommand ) { 
    addReply ( c , shared . loadingerr ) ; 
    return REDIS_OK ; 
} 
if ( c -> flags & REDIS_MULTI && cmd -> proc != execCommand && cmd -> proc != discardCommand && cmd -> proc != multiCommand && cmd -> proc != watchCommand ) { 
    queueMultiCommand ( c , cmd ) ; 
    addReply ( c , shared . queued ) ; 
} else { 
    if ( server . vm_enabled && server . vm_max_threads > 0 && blockClientOnSwappedKeys ( c , cmd ) ) return REDIS_ERR ; 
    call ( c , cmd ) ; 
} 
return REDIS_OK ; 
}",855,-26.949932326752265,-0.03152038868625996
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int processCommand ( redisClient * c ) { struct redisCommand * cmd ; if ( ! strcasecmp ( c -> argv [ 0 ] -> ptr , ""quit"" ) ) { addReply ( c , shared . ok ) ; c -> flags |= REDIS_CLOSE_AFTER_REPLY ; return REDIS_ERR ; } cmd = lookupCommand ( c -> argv [ 0 ] -> ptr ) ; if ( ! cmd ) { addReplyErrorFormat ( c , ""unknown command \'%s\'"" , ( char * ) c -> argv [ 0 ] -> ptr ) ; return REDIS_OK ; } else if ( ( cmd -> arity > 0 && cmd -> arity != c -> argc ) || ( c -> argc < - cmd -> arity ) ) { addReplyErrorFormat ( c , ""wrong number of arguments for \'%s\' command"" , cmd -> name ) ; return REDIS_OK ; } if ( server . requirepass && ! c -> authenticated && cmd -> proc != authCommand ) { addReplyError ( c , ""operation not permitted"" ) ; return REDIS_OK ; } if ( server . maxmemory ) freeMemoryIfNeeded ( ) ; if ( server . maxmemory && ( cmd -> flags & REDIS_CMD_DENYOOM ) && zmalloc_used_memory ( ) > server . maxmemory ) { addReplyError ( c , ""command not allowed when used memory > \'maxmemory\'"" ) ; return REDIS_OK ; } if ( ( dictSize ( c -> pubsub_channels ) > 0 || listLength ( c -> pubsub_patterns ) > 0 ) && cmd -> proc != subscribeCommand && cmd -> proc != unsubscribeCommand && cmd -> proc != psubscribeCommand && cmd -> proc != punsubscribeCommand ) { addReplyError ( c , ""only (P)SUBSCRIBE / (P)UNSUBSCRIBE / QUIT allowed in this context"" ) ; return REDIS_OK ; } if ( server . masterhost && server . replstate != REDIS_REPL_CONNECTED && server . repl_serve_stale_data == 0 && cmd -> proc != infoCommand && cmd -> proc != slaveofCommand ) { addReplyError ( c , ""link with MASTER is down and slave-serve-stale-data is set to no"" ) ; return REDIS_OK ; } if ( server . loading && cmd -> proc != infoCommand ) { addReply ( c , shared . loadingerr ) ; return REDIS_OK ; } if ( c -> flags & REDIS_MULTI && cmd -> proc != execCommand && cmd -> proc != discardCommand && cmd -> proc != multiCommand && cmd -> proc != watchCommand ) { queueMultiCommand ( c , cmd ) ; addReply ( c , shared . queued ) ; } else { if ( server . vm_enabled && server . vm_max_threads > 0 && blockClientOnSwappedKeys ( c , cmd ) ) return REDIS_ERR ; call ( c , cmd ) ; } return REDIS_OK ; }
Fixed code:","
int processCommand ( redisClient * c ) { struct redisCommand * cmd ; //Check if the input is valid if(c -> argv[0] == NULL || c -> argc == 0) { addReplyError(c, ""Invalid command""); return REDIS_OK; } if ( ! strcasecmp ( c -> argv [ 0 ] -> ptr , ""quit"" ) ) { addReply ( c , shared . ok ) ; c -> flags |= REDIS_CLOSE_AFTER_REPLY ; return REDIS_ERR ; } cmd = lookupCommand ( c -> argv [ 0 ] -> ptr ) ; if ( ! cmd ) { addReplyErrorFormat ( c , ""unknown command \'%s\'"" , ( char * ) c -> argv [ 0 ] -> ptr ) ; return REDIS_OK ; } else if ( ( cmd -> arity > 0 && cmd -> arity != c -> argc ) || ( c -> argc < - cmd -> arity ) ) { addReplyErrorFormat ( c , ""wrong number of arguments for \'%s\' command"" , cmd -> name ) ; return REDIS_OK ; } if ( server . requirepass && ! c -> authenticated && cmd -> proc != authCommand ) { addReplyError ( c , ""operation not permitted"" ) ; return REDIS_OK ; } if ( server . maxmemory ) freeMemoryIfNeeded ( ) ; if ( server . maxmemory && ( cmd -> flags & REDIS_CMD_DENYOOM ) && zmalloc_used_memory ( ) > server . maxmemory ) { addReplyError ( c , ""command not allowed when used memory > \'maxmemory\'"" ) ; return REDIS_OK ; } if ( ( dictSize ( c -> pubsub_channels ) > 0 || listLength ( c -> pubsub_patterns ) > 0 ) && cmd -> proc != subscribeCommand && cmd -> proc != unsubscribeCommand && cmd -> proc != psubscribeCommand && cmd -> proc != punsubscribeCommand ) { addReplyError ( c , ""only (P)SUBSCRIBE / (P)UNSUBSCRIBE / QUIT allowed in this context"" ) ; return REDIS_OK ; } if ( server . masterhost && server . replstate != REDIS_REPL_CONNECTED && server . repl_serve_stale_data == 0 && cmd -> proc != infoCommand && cmd -> proc != slaveofCommand ) { addReplyError ( c , ""link with MASTER is down and slave-serve-stale-data is set to no"" ) ; return REDIS_OK ; } if ( server . loading && cmd -> proc != infoCommand ) { addReply ( c , shared . loadingerr ) ; return REDIS_OK ; } if ( c -> flags & REDIS_MULTI && cmd -> proc != execCommand && cmd -> proc != discardCommand && cmd -> proc != multiCommand && cmd -> proc != watchCommand ) { queueMultiCommand ( c , cmd ) ; addReply ( c , shared . queued ) ; } else { if ( server . vm_enabled && server . vm_max_threads > 0 && blockClientOnSwappedKeys ( c , cmd ) ) return REDIS_ERR ; call ( c , cmd ) ; } return REDIS_OK ; }",721,-25.53837547527779,-0.03542077042340886
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int processCommand ( redisClient * c ) { struct redisCommand * cmd ; if ( ! strcasecmp ( c -> argv [ 0 ] -> ptr , ""quit"" ) ) { addReply ( c , shared . ok ) ; c -> flags |= REDIS_CLOSE_AFTER_REPLY ; return REDIS_ERR ; } cmd = lookupCommand ( c -> argv [ 0 ] -> ptr ) ; if ( ! cmd ) { addReplyErrorFormat ( c , ""unknown command \'%s\'"" , ( char * ) c -> argv [ 0 ] -> ptr ) ; return REDIS_OK ; } else if ( ( cmd -> arity > 0 && cmd -> arity != c -> argc ) || ( c -> argc < - cmd -> arity ) ) { addReplyErrorFormat ( c , ""wrong number of arguments for \'%s\' command"" , cmd -> name ) ; return REDIS_OK ; } if ( server . requirepass && ! c -> authenticated && cmd -> proc != authCommand ) { addReplyError ( c , ""operation not permitted"" ) ; return REDIS_OK ; } if ( server . maxmemory ) freeMemoryIfNeeded ( ) ; if ( server . maxmemory && ( cmd -> flags & REDIS_CMD_DENYOOM ) && zmalloc_used_memory ( ) > server . maxmemory ) { addReplyError ( c , ""command not allowed when used memory > \'maxmemory\'"" ) ; return REDIS_OK ; } if ( ( dictSize ( c -> pubsub_channels ) > 0 || listLength ( c -> pubsub_patterns ) > 0 ) && cmd -> proc != subscribeCommand && cmd -> proc != unsubscribeCommand && cmd -> proc != psubscribeCommand && cmd -> proc != punsubscribeCommand ) { addReplyError ( c , ""only (P)SUBSCRIBE / (P)UNSUBSCRIBE / QUIT allowed in this context"" ) ; return REDIS_OK ; } if ( server . masterhost && server . replstate != REDIS_REPL_CONNECTED && server . repl_serve_stale_data == 0 && cmd -> proc != infoCommand && cmd -> proc != slaveofCommand ) { addReplyError ( c , ""link with MASTER is down and slave-serve-stale-data is set to no"" ) ; return REDIS_OK ; } if ( server . loading && cmd -> proc != infoCommand ) { addReply ( c , shared . loadingerr ) ; return REDIS_OK ; } if ( c -> flags & REDIS_MULTI && cmd -> proc != execCommand && cmd -> proc != discardCommand && cmd -> proc != multiCommand && cmd -> proc != watchCommand ) { queueMultiCommand ( c , cmd ) ; addReply ( c , shared . queued ) ; } else { if ( server . vm_enabled && server . vm_max_threads > 0 && blockClientOnSwappedKeys ( c , cmd ) ) return REDIS_ERR ; call ( c , cmd ) ; } return REDIS_OK ; }
Fixed code:","
int processCommand ( redisClient * c ) { struct redisCommand * cmd ; 
// Add input validation to check for special characters 
if ( regex ( c -> argv [ 0 ] -> ptr ) ) {
  addReplyError ( c , ""Input contains special characters"" ) ; 
  return REDIS_ERR ; 
} 

if ( ! strcasecmp ( c -> argv [ 0 ] -> ptr , ""quit"" ) ) { addReply ( c , shared . ok ) ; c -> flags |= REDIS_CLOSE_AFTER_REPLY ; return REDIS_ERR ; } cmd = lookupCommand ( c -> argv [ 0 ] -> ptr ) ; if ( ! cmd ) { addReplyErrorFormat ( c , ""unknown command \'%s\'"" , ( char * ) c -> argv [ 0 ] -> ptr ) ; return REDIS_OK ; } else if ( ( cmd -> arity > 0 && cmd -> arity != c -> argc ) || ( c -> argc < - cmd -> arity ) ) { addReplyErrorFormat ( c , ""wrong number of arguments for \'%s\' command"" , cmd -> name ) ; return REDIS_OK ; } if ( server . requirepass && ! c -> authenticated && cmd -> proc != authCommand ) { addReplyError ( c , ""operation not permitted"" ) ; return REDIS_OK ; } if ( server . maxmemory ) freeMemoryIfNeeded ( ) ; if ( server . maxmemory && ( cmd -> flags & REDIS_CMD_DENYOOM ) && zmalloc_used_memory ( ) > server . maxmemory ) { addReplyError ( c , ""command not allowed when used memory > \'maxmemory\'"" ) ; return REDIS_OK ; } if ( ( dictSize ( c -> pubsub_channels ) > 0 || listLength ( c -> pubsub_patterns ) > 0 ) && cmd -> proc != subscribeCommand && cmd -> proc != unsubscribeCommand && cmd -> proc != psubscribeCommand && cmd -> proc != punsubscribeCommand ) { addReplyError ( c , ""only (P)SUBSCRIBE / (P)UNSUBSCRIBE / QUIT allowed in this context"" ) ; return REDIS_OK ; } if ( server . masterhost && server . replstate != REDIS_REPL_CONNECTED && server . repl_serve_stale_data == 0 && cmd -> proc != infoCommand && cmd -> proc != slaveofCommand ) { addReplyError ( c , ""link with MASTER is down and slave-serve-stale-data is set to no"" ) ; return REDIS_OK ; } if ( server . loading && cmd -> proc != infoCommand ) { addReply ( c , shared . loadingerr ) ; return REDIS_OK ; } if ( c -> flags & REDIS_MULTI && cmd -> proc != execCommand && cmd -> proc != discardCommand && cmd -> proc != multiCommand && cmd -> proc != watchCommand ) { queueMultiCommand ( c , cmd ) ; addReply ( c , shared . queued ) ; } else { if ( server . vm_enabled && server . vm_max_threads > 0 && blockClientOnSwappedKeys ( c , cmd ) ) return REDIS_ERR ; call ( c , cmd ) ; } return REDIS_OK ; }",738,-37.73790849056586,-0.05113537735849032
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int processCommand ( redisClient * c ) { struct redisCommand * cmd ; if ( ! strcasecmp ( c -> argv [ 0 ] -> ptr , ""quit"" ) ) { addReply ( c , shared . ok ) ; c -> flags |= REDIS_CLOSE_AFTER_REPLY ; return REDIS_ERR ; } cmd = lookupCommand ( c -> argv [ 0 ] -> ptr ) ; if ( ! cmd ) { addReplyErrorFormat ( c , ""unknown command \'%s\'"" , ( char * ) c -> argv [ 0 ] -> ptr ) ; return REDIS_OK ; } else if ( ( cmd -> arity > 0 && cmd -> arity != c -> argc ) || ( c -> argc < - cmd -> arity ) ) { addReplyErrorFormat ( c , ""wrong number of arguments for \'%s\' command"" , cmd -> name ) ; return REDIS_OK ; } if ( server . requirepass && ! c -> authenticated && cmd -> proc != authCommand ) { addReplyError ( c , ""operation not permitted"" ) ; return REDIS_OK ; } if ( server . maxmemory ) freeMemoryIfNeeded ( ) ; if ( server . maxmemory && ( cmd -> flags & REDIS_CMD_DENYOOM ) && zmalloc_used_memory ( ) > server . maxmemory ) { addReplyError ( c , ""command not allowed when used memory > \'maxmemory\'"" ) ; return REDIS_OK ; } if ( ( dictSize ( c -> pubsub_channels ) > 0 || listLength ( c -> pubsub_patterns ) > 0 ) && cmd -> proc != subscribeCommand && cmd -> proc != unsubscribeCommand && cmd -> proc != psubscribeCommand && cmd -> proc != punsubscribeCommand ) { addReplyError ( c , ""only (P)SUBSCRIBE / (P)UNSUBSCRIBE / QUIT allowed in this context"" ) ; return REDIS_OK ; } if ( server . masterhost && server . replstate != REDIS_REPL_CONNECTED && server . repl_serve_stale_data == 0 && cmd -> proc != infoCommand && cmd -> proc != slaveofCommand ) { addReplyError ( c , ""link with MASTER is down and slave-serve-stale-data is set to no"" ) ; return REDIS_OK ; } if ( server . loading && cmd -> proc != infoCommand ) { addReply ( c , shared . loadingerr ) ; return REDIS_OK ; } if ( c -> flags & REDIS_MULTI && cmd -> proc != execCommand && cmd -> proc != discardCommand && cmd -> proc != multiCommand && cmd -> proc != watchCommand ) { queueMultiCommand ( c , cmd ) ; addReply ( c , shared . queued ) ; } else { if ( server . vm_enabled && server . vm_max_threads > 0 && blockClientOnSwappedKeys ( c , cmd ) ) return REDIS_ERR ; call ( c , cmd ) ; } return REDIS_OK ; }
Fixed code:","
int processCommand ( redisClient * c ) { 
  struct redisCommand * cmd ; 
  char * commandName = c -> argv [ 0 ] -> ptr ;

  // Validate the input
  if ( ! isValidCommandName ( commandName ) ) {
    addReplyErrorFormat ( c , ""invalid command name \'%s\'"" , commandName ) ;
    return REDIS_OK ;
  }
  
  if ( ! strcasecmp ( commandName , ""quit"" ) ) {
    addReply ( c , shared . ok ) ; 
    c -> flags |= REDIS_CLOSE_AFTER_REPLY ; 
    return REDIS_ERR ;
  }

  cmd = lookupCommand ( commandName ) ; 
  if ( ! cmd ) {
    addReplyErrorFormat ( c , ""unknown command \'%s\'"" , commandName ) ; 
    return REDIS_OK ;
  } else if ( ( cmd -> arity > 0 && cmd -> arity != c -> argc ) || ( c -> argc < - cmd -> arity ) ) {
    addReplyErrorFormat ( c , ""wrong number of arguments for \'%s\' command"" , cmd -> name ) ; 
    return REDIS_OK ;
  } 

  if ( server . requirepass && ! c -> authenticated && cmd -> proc != authCommand ) {
    addReplyError ( c , ""operation not permitted"" ) ; 
    return REDIS_OK ;
  } 

  if ( server . maxmemory ) freeMemoryIfNeeded ( ) ; 
  if ( server . maxmemory && ( cmd -> flags & REDIS_CMD_DENYOOM ) && zmalloc_used_memory ( ) > server . maxmemory ) {
    addReplyError ( c , ""command not allowed when used memory > \'maxmemory\'"" ) ; 
    return REDIS_OK ;
  } 

  if ( ( dictSize ( c -> pubsub_channels ) > 0 || listLength ( c -> pubsub_patterns ) > 0 ) && cmd -> proc != subscribeCommand && cmd -> proc != unsubscribeCommand && cmd -> proc != psubscribeCommand && cmd -> proc != punsubscribeCommand ) {
    addReplyError ( c , ""only (P)SUBSCRIBE / (P)UNSUBSCRIBE / QUIT allowed in this context"" ) ; 
    return REDIS_OK ;
  } 

  if ( server . masterhost && server . replstate != REDIS_REPL_CONNECTED && server . repl_serve_stale_data == 0 && cmd -> proc != infoCommand && cmd -> proc != slaveofCommand ) {
    addReplyError ( c , ""link with MASTER is down and slave-serve-stale-data is set to no"" ) ; 
    return REDIS_OK ;
  } 

  if ( server . loading && cmd -> proc != infoCommand ) {
    addReply ( c , shared . loadingerr ) ; 
    return REDIS_OK ;
  } 

  if ( c -> flags & REDIS_MULTI && cmd -> proc != execCommand && cmd -> proc != discardCommand && cmd -> proc != multiCommand && cmd -> proc != watchCommand ) {
    queueMultiCommand ( c , cmd ) ; 
    addReply ( c , shared . queued ) ;
  } else { 
    if ( server . vm_enabled && server . vm_max_threads > 0 && blockClientOnSwappedKeys ( c , cmd ) ) return REDIS_ERR ; 
    call ( c , cmd ) ;
  } 
  return REDIS_OK ;
}

// Validation function for the input
bool isValidCommandName ( char * command ) {
  // Check for valid characters in the string
  for ( int i = 0 ; i < strlen ( command ) ; i ++ ) { 
    if ( ! isalpha ( command [ i ] ) ) {
      return false ; 
    }
  }
  return true ;
}",925,-77.77404728278773,-0.08408005111652728
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int processCommand ( redisClient * c ) { struct redisCommand * cmd ; if ( ! strcasecmp ( c -> argv [ 0 ] -> ptr , ""quit"" ) ) { addReply ( c , shared . ok ) ; c -> flags |= REDIS_CLOSE_AFTER_REPLY ; return REDIS_ERR ; } cmd = lookupCommand ( c -> argv [ 0 ] -> ptr ) ; if ( ! cmd ) { addReplyErrorFormat ( c , ""unknown command \'%s\'"" , ( char * ) c -> argv [ 0 ] -> ptr ) ; return REDIS_OK ; } else if ( ( cmd -> arity > 0 && cmd -> arity != c -> argc ) || ( c -> argc < - cmd -> arity ) ) { addReplyErrorFormat ( c , ""wrong number of arguments for \'%s\' command"" , cmd -> name ) ; return REDIS_OK ; } if ( server . requirepass && ! c -> authenticated && cmd -> proc != authCommand ) { addReplyError ( c , ""operation not permitted"" ) ; return REDIS_OK ; } if ( server . maxmemory ) freeMemoryIfNeeded ( ) ; if ( server . maxmemory && ( cmd -> flags & REDIS_CMD_DENYOOM ) && zmalloc_used_memory ( ) > server . maxmemory ) { addReplyError ( c , ""command not allowed when used memory > \'maxmemory\'"" ) ; return REDIS_OK ; } if ( ( dictSize ( c -> pubsub_channels ) > 0 || listLength ( c -> pubsub_patterns ) > 0 ) && cmd -> proc != subscribeCommand && cmd -> proc != unsubscribeCommand && cmd -> proc != psubscribeCommand && cmd -> proc != punsubscribeCommand ) { addReplyError ( c , ""only (P)SUBSCRIBE / (P)UNSUBSCRIBE / QUIT allowed in this context"" ) ; return REDIS_OK ; } if ( server . masterhost && server . replstate != REDIS_REPL_CONNECTED && server . repl_serve_stale_data == 0 && cmd -> proc != infoCommand && cmd -> proc != slaveofCommand ) { addReplyError ( c , ""link with MASTER is down and slave-serve-stale-data is set to no"" ) ; return REDIS_OK ; } if ( server . loading && cmd -> proc != infoCommand ) { addReply ( c , shared . loadingerr ) ; return REDIS_OK ; } if ( c -> flags & REDIS_MULTI && cmd -> proc != execCommand && cmd -> proc != discardCommand && cmd -> proc != multiCommand && cmd -> proc != watchCommand ) { queueMultiCommand ( c , cmd ) ; addReply ( c , shared . queued ) ; } else { if ( server . vm_enabled && server . vm_max_threads > 0 && blockClientOnSwappedKeys ( c , cmd ) ) return REDIS_ERR ; call ( c , cmd ) ; } return REDIS_OK ; }
Fixed code:","
int processCommand ( redisClient * c ) { 

// Validate input
if (!c || !c->argv || !c->argv[0] || !c->argv[0]->ptr) {
    addReplyError(c, ""Invalid command input"");
    return REDIS_ERR;
}

struct redisCommand * cmd ; 
if ( ! strcasecmp ( c -> argv [ 0 ] -> ptr , ""quit"" ) ) { 
    addReply ( c , shared . ok ) ; 
    c -> flags |= REDIS_CLOSE_AFTER_REPLY ; 
    return REDIS_ERR ; 
} 

cmd = lookupCommand ( c -> argv [ 0 ] -> ptr ) ; 
if ( ! cmd ) { 
    addReplyErrorFormat ( c , ""unknown command \'%s\'"" , ( char * ) c -> argv [ 0 ] -> ptr ) ; 
    return REDIS_OK ; 
} else if ( ( cmd -> arity > 0 && cmd -> arity != c -> argc ) || ( c -> argc < - cmd -> arity ) ) { 
    addReplyErrorFormat ( c , ""wrong number of arguments for \'%s\' command"" , cmd -> name ) ; 
    return REDIS_OK ; 
} 

if ( server . requirepass && ! c -> authenticated && cmd -> proc != authCommand ) { 
    addReplyError ( c , ""operation not permitted"" ) ; 
    return REDIS_OK ; 
} 

if ( server . maxmemory ) freeMemoryIfNeeded ( ) ; 
if ( server . maxmemory && ( cmd -> flags & REDIS_CMD_DENYOOM ) && zmalloc_used_memory ( ) > server . maxmemory ) { 
    addReplyError ( c , ""command not allowed when used memory > \'maxmemory\'"" ) ; 
    return REDIS_OK ; 
} 

if ( ( dictSize ( c -> pubsub_channels ) > 0 || listLength ( c -> pubsub_patterns ) > 0 ) && cmd -> proc != subscribeCommand && cmd -> proc != unsubscribeCommand && cmd -> proc != psubscribeCommand && cmd -> proc != punsubscribeCommand ) { 
    addReplyError ( c , ""only (P)SUBSCRIBE / (P)UNSUBSCRIBE / QUIT allowed in this context"" ) ; 
    return REDIS_OK ; 
} 

if ( server . masterhost && server . replstate != REDIS_REPL_CONNECTED && server . repl_serve_stale_data == 0 && cmd -> proc != infoCommand && cmd -> proc != slaveofCommand ) { 
    addReplyError ( c , ""link with MASTER is down and slave-serve-stale-data is set to no"" ) ; 
    return REDIS_OK ; 
} 

if ( server . loading && cmd -> proc != infoCommand ) { 
    addReply ( c , shared . loadingerr ) ; 
    return REDIS_OK ; 
} 

if ( c -> flags & REDIS_MULTI && cmd -> proc != execCommand && cmd -> proc != discardCommand && cmd -> proc != multiCommand && cmd -> proc != watchCommand ) { 
    queueMultiCommand ( c , cmd ) ; 
    addReply ( c , shared . queued ) ; 
} else { 
    if ( server . vm_enabled && server . vm_max_threads > 0 && blockClientOnSwappedKeys ( c , cmd ) ) return REDIS_ERR ; 
    call ( c , cmd ) ; 
} 

return REDIS_OK ; 
}",857,-25.5832935050227,-0.02985215111437888
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int processCommand ( redisClient * c ) { struct redisCommand * cmd ; if ( ! strcasecmp ( c -> argv [ 0 ] -> ptr , ""quit"" ) ) { addReply ( c , shared . ok ) ; c -> flags |= REDIS_CLOSE_AFTER_REPLY ; return REDIS_ERR ; } cmd = lookupCommand ( c -> argv [ 0 ] -> ptr ) ; if ( ! cmd ) { addReplyErrorFormat ( c , ""unknown command \'%s\'"" , ( char * ) c -> argv [ 0 ] -> ptr ) ; return REDIS_OK ; } else if ( ( cmd -> arity > 0 && cmd -> arity != c -> argc ) || ( c -> argc < - cmd -> arity ) ) { addReplyErrorFormat ( c , ""wrong number of arguments for \'%s\' command"" , cmd -> name ) ; return REDIS_OK ; } if ( server . requirepass && ! c -> authenticated && cmd -> proc != authCommand ) { addReplyError ( c , ""operation not permitted"" ) ; return REDIS_OK ; } if ( server . maxmemory ) freeMemoryIfNeeded ( ) ; if ( server . maxmemory && ( cmd -> flags & REDIS_CMD_DENYOOM ) && zmalloc_used_memory ( ) > server . maxmemory ) { addReplyError ( c , ""command not allowed when used memory > \'maxmemory\'"" ) ; return REDIS_OK ; } if ( ( dictSize ( c -> pubsub_channels ) > 0 || listLength ( c -> pubsub_patterns ) > 0 ) && cmd -> proc != subscribeCommand && cmd -> proc != unsubscribeCommand && cmd -> proc != psubscribeCommand && cmd -> proc != punsubscribeCommand ) { addReplyError ( c , ""only (P)SUBSCRIBE / (P)UNSUBSCRIBE / QUIT allowed in this context"" ) ; return REDIS_OK ; } if ( server . masterhost && server . replstate != REDIS_REPL_CONNECTED && server . repl_serve_stale_data == 0 && cmd -> proc != infoCommand && cmd -> proc != slaveofCommand ) { addReplyError ( c , ""link with MASTER is down and slave-serve-stale-data is set to no"" ) ; return REDIS_OK ; } if ( server . loading && cmd -> proc != infoCommand ) { addReply ( c , shared . loadingerr ) ; return REDIS_OK ; } if ( c -> flags & REDIS_MULTI && cmd -> proc != execCommand && cmd -> proc != discardCommand && cmd -> proc != multiCommand && cmd -> proc != watchCommand ) { queueMultiCommand ( c , cmd ) ; addReply ( c , shared . queued ) ; } else { if ( server . vm_enabled && server . vm_max_threads > 0 && blockClientOnSwappedKeys ( c , cmd ) ) return REDIS_ERR ; call ( c , cmd ) ; } return REDIS_OK ; }
Fixed code:","
int processCommand ( redisClient * c ) { if ( c -> argc < 1 ) { addReplyError ( c , ""No command given"" ) ; return REDIS_ERR ; } struct redisCommand * cmd ; if ( ! strcasecmp ( c -> argv [ 0 ] -> ptr , ""quit"" ) ) { addReply ( c , shared . ok ) ; c -> flags |= REDIS_CLOSE_AFTER_REPLY ; return REDIS_ERR ; } if (!commandIsValid(c->argv[0]->ptr)) { addReplyErrorFormat ( c , ""unknown command \'%s\'"" , ( char * ) c -> argv [ 0 ] -> ptr ) ; return REDIS_OK ; } cmd = lookupCommand ( c -> argv [ 0 ] -> ptr ) ; if ( ( cmd -> arity > 0 && cmd -> arity != c -> argc ) || ( c -> argc < - cmd -> arity ) ) { addReplyErrorFormat ( c , ""wrong number of arguments for \'%s\' command"" , cmd -> name ) ; return REDIS_OK ; } if ( server . requirepass && ! c -> authenticated && cmd -> proc != authCommand ) { addReplyError ( c , ""operation not permitted"" ) ; return REDIS_OK ; } if ( server . maxmemory ) freeMemoryIfNeeded ( ) ; if ( server . maxmemory && ( cmd -> flags & REDIS_CMD_DENYOOM ) && zmalloc_used_memory ( ) > server . maxmemory ) { addReplyError ( c , ""command not allowed when used memory > \'maxmemory\'"" ) ; return REDIS_OK ; } if ( ( dictSize ( c -> pubsub_channels ) > 0 || listLength ( c -> pubsub_patterns ) > 0 ) && cmd -> proc != subscribeCommand && cmd -> proc != unsubscribeCommand && cmd -> proc != psubscribeCommand && cmd -> proc != punsubscribeCommand ) { addReplyError ( c , ""only (P)SUBSCRIBE / (P)UNSUBSCRIBE / QUIT allowed in this context"" ) ; return REDIS_OK ; } if ( server . masterhost && server . replstate != REDIS_REPL_CONNECTED && server . repl_serve_stale_data == 0 && cmd -> proc != infoCommand && cmd -> proc != slaveofCommand ) { addReplyError ( c , ""link with MASTER is down and slave-serve-stale-data is set to no"" ) ; return REDIS_OK ; } if ( server . loading && cmd -> proc != infoCommand ) { addReply ( c , shared . loadingerr ) ; return REDIS_OK ; } if ( c -> flags & REDIS_MULTI && cmd -> proc != execCommand && cmd -> proc != discardCommand && cmd -> proc != multiCommand && cmd -> proc != watchCommand ) { queueMultiCommand ( c , cmd ) ; addReply ( c , shared . queued ) ; } else { if ( server . vm_enabled && server . vm_max_threads > 0 && blockClientOnSwappedKeys ( c , cmd ) ) return REDIS_ERR ; call ( c , cmd ) ; } return REDIS_OK ; }

//Added function
bool commandIsValid(char* command) {
    struct redisCommand * cmd;
    cmd = lookupCommand(command);
    if (cmd) {
        return true;
    } else {
        return false;
    }
}",779,-41.73618295053232,-0.05357661482738423
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int processCommand ( redisClient * c ) { struct redisCommand * cmd ; if ( ! strcasecmp ( c -> argv [ 0 ] -> ptr , ""quit"" ) ) { addReply ( c , shared . ok ) ; c -> flags |= REDIS_CLOSE_AFTER_REPLY ; return REDIS_ERR ; } cmd = lookupCommand ( c -> argv [ 0 ] -> ptr ) ; if ( ! cmd ) { addReplyErrorFormat ( c , ""unknown command \'%s\'"" , ( char * ) c -> argv [ 0 ] -> ptr ) ; return REDIS_OK ; } else if ( ( cmd -> arity > 0 && cmd -> arity != c -> argc ) || ( c -> argc < - cmd -> arity ) ) { addReplyErrorFormat ( c , ""wrong number of arguments for \'%s\' command"" , cmd -> name ) ; return REDIS_OK ; } if ( server . requirepass && ! c -> authenticated && cmd -> proc != authCommand ) { addReplyError ( c , ""operation not permitted"" ) ; return REDIS_OK ; } if ( server . maxmemory ) freeMemoryIfNeeded ( ) ; if ( server . maxmemory && ( cmd -> flags & REDIS_CMD_DENYOOM ) && zmalloc_used_memory ( ) > server . maxmemory ) { addReplyError ( c , ""command not allowed when used memory > \'maxmemory\'"" ) ; return REDIS_OK ; } if ( ( dictSize ( c -> pubsub_channels ) > 0 || listLength ( c -> pubsub_patterns ) > 0 ) && cmd -> proc != subscribeCommand && cmd -> proc != unsubscribeCommand && cmd -> proc != psubscribeCommand && cmd -> proc != punsubscribeCommand ) { addReplyError ( c , ""only (P)SUBSCRIBE / (P)UNSUBSCRIBE / QUIT allowed in this context"" ) ; return REDIS_OK ; } if ( server . masterhost && server . replstate != REDIS_REPL_CONNECTED && server . repl_serve_stale_data == 0 && cmd -> proc != infoCommand && cmd -> proc != slaveofCommand ) { addReplyError ( c , ""link with MASTER is down and slave-serve-stale-data is set to no"" ) ; return REDIS_OK ; } if ( server . loading && cmd -> proc != infoCommand ) { addReply ( c , shared . loadingerr ) ; return REDIS_OK ; } if ( c -> flags & REDIS_MULTI && cmd -> proc != execCommand && cmd -> proc != discardCommand && cmd -> proc != multiCommand && cmd -> proc != watchCommand ) { queueMultiCommand ( c , cmd ) ; addReply ( c , shared . queued ) ; } else { if ( server . vm_enabled && server . vm_max_threads > 0 && blockClientOnSwappedKeys ( c , cmd ) ) return REDIS_ERR ; call ( c , cmd ) ; } return REDIS_OK ; }
Fixed code:","
int processCommand ( redisClient * c ) {
  struct redisCommand * cmd ;
  if ( ! strcasecmp ( c -> argv [ 0 ] -> ptr , ""quit"" ) ) {
    addReply ( c , shared . ok ) ;
    c -> flags |= REDIS_CLOSE_AFTER_REPLY ;
    return REDIS_ERR ;
  }
  
  // Add input validation
  if ( ! c -> argv [ 0 ] -> ptr || ! c -> argv [ 0 ] ) {
    addReplyErrorFormat ( c , ""invalid input"" ) ;
    return REDIS_OK ;
  }
  
  cmd = lookupCommand ( c -> argv [ 0 ] -> ptr ) ;
  if ( ! cmd ) {
    addReplyErrorFormat ( c , ""unknown command \'%s\'"" , ( char * ) c -> argv [ 0 ] -> ptr ) ;
    return REDIS_OK ;
  } else if ( ( cmd -> arity > 0 && cmd -> arity != c -> argc ) || ( c -> argc < - cmd -> arity ) ) {
    addReplyErrorFormat ( c , ""wrong number of arguments for \'%s\' command"" , cmd -> name ) ;
    return REDIS_OK ;
  }
  if ( server . requirepass && ! c -> authenticated && cmd -> proc != authCommand ) {
    addReplyError ( c , ""operation not permitted"" ) ;
    return REDIS_OK ;
  }
  if ( server . maxmemory ) freeMemoryIfNeeded ( ) ;
  if ( server . maxmemory && ( cmd -> flags & REDIS_CMD_DENYOOM ) && zmalloc_used_memory ( ) > server . maxmemory ) {
    addReplyError ( c , ""command not allowed when used memory > \'maxmemory\'"" ) ;
    return REDIS_OK ;
  }
  if ( ( dictSize ( c -> pubsub_channels ) > 0 || listLength ( c -> pubsub_patterns ) > 0 ) && cmd -> proc != subscribeCommand && cmd -> proc != unsubscribeCommand && cmd -> proc != psubscribeCommand && cmd -> proc != punsubscribeCommand ) {
    addReplyError ( c , ""only (P)SUBSCRIBE / (P)UNSUBSCRIBE / QUIT allowed in this context"" ) ;
    return REDIS_OK ;
  }
  if ( server . masterhost && server . replstate != REDIS_REPL_CONNECTED && server . repl_serve_stale_data == 0 && cmd -> proc != infoCommand && cmd -> proc != slaveofCommand ) {
    addReplyError ( c , ""link with MASTER is down and slave-serve-stale-data is set to no"" ) ;
    return REDIS_OK ;
  }
  if ( server . loading && cmd -> proc != infoCommand ) {
    addReply ( c , shared . loadingerr ) ;
    return REDIS_OK ;
  }
  if ( c -> flags & REDIS_MULTI && cmd -> proc != execCommand && cmd -> proc != discardCommand && cmd -> proc != multiCommand && cmd -> proc != watchCommand ) {
    queueMultiCommand ( c , cmd ) ;
    addReply ( c , shared . queued ) ;
  } else {
    if ( server . vm_enabled && server . vm_max_threads > 0 && blockClientOnSwappedKeys ( c , cmd ) ) return REDIS_ERR ;
    call ( c , cmd ) ;
  }
  return REDIS_OK ;
}",826,-27.03048709808814,-0.03272456065143843
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int processCommand ( redisClient * c ) { struct redisCommand * cmd ; if ( ! strcasecmp ( c -> argv [ 0 ] -> ptr , ""quit"" ) ) { addReply ( c , shared . ok ) ; c -> flags |= REDIS_CLOSE_AFTER_REPLY ; return REDIS_ERR ; } cmd = lookupCommand ( c -> argv [ 0 ] -> ptr ) ; if ( ! cmd ) { addReplyErrorFormat ( c , ""unknown command \'%s\'"" , ( char * ) c -> argv [ 0 ] -> ptr ) ; return REDIS_OK ; } else if ( ( cmd -> arity > 0 && cmd -> arity != c -> argc ) || ( c -> argc < - cmd -> arity ) ) { addReplyErrorFormat ( c , ""wrong number of arguments for \'%s\' command"" , cmd -> name ) ; return REDIS_OK ; } if ( server . requirepass && ! c -> authenticated && cmd -> proc != authCommand ) { addReplyError ( c , ""operation not permitted"" ) ; return REDIS_OK ; } if ( server . maxmemory ) freeMemoryIfNeeded ( ) ; if ( server . maxmemory && ( cmd -> flags & REDIS_CMD_DENYOOM ) && zmalloc_used_memory ( ) > server . maxmemory ) { addReplyError ( c , ""command not allowed when used memory > \'maxmemory\'"" ) ; return REDIS_OK ; } if ( ( dictSize ( c -> pubsub_channels ) > 0 || listLength ( c -> pubsub_patterns ) > 0 ) && cmd -> proc != subscribeCommand && cmd -> proc != unsubscribeCommand && cmd -> proc != psubscribeCommand && cmd -> proc != punsubscribeCommand ) { addReplyError ( c , ""only (P)SUBSCRIBE / (P)UNSUBSCRIBE / QUIT allowed in this context"" ) ; return REDIS_OK ; } if ( server . masterhost && server . replstate != REDIS_REPL_CONNECTED && server . repl_serve_stale_data == 0 && cmd -> proc != infoCommand && cmd -> proc != slaveofCommand ) { addReplyError ( c , ""link with MASTER is down and slave-serve-stale-data is set to no"" ) ; return REDIS_OK ; } if ( server . loading && cmd -> proc != infoCommand ) { addReply ( c , shared . loadingerr ) ; return REDIS_OK ; } if ( c -> flags & REDIS_MULTI && cmd -> proc != execCommand && cmd -> proc != discardCommand && cmd -> proc != multiCommand && cmd -> proc != watchCommand ) { queueMultiCommand ( c , cmd ) ; addReply ( c , shared . queued ) ; } else { if ( server . vm_enabled && server . vm_max_threads > 0 && blockClientOnSwappedKeys ( c , cmd ) ) return REDIS_ERR ; call ( c , cmd ) ; } return REDIS_OK ; }
Fixed code:","
int processCommand ( redisClient * c ) { struct redisCommand * cmd ; 

// Check input for validity
if ( ! c || ! c -> argv || ! c -> argv [ 0 ] -> ptr || c -> argc < 0 ) { 
    addReplyError ( c , ""improper input"" ) ; 
    return REDIS_OK ; 
}

if ( ! strcasecmp ( c -> argv [ 0 ] -> ptr , ""quit"" ) ) { 
    addReply ( c , shared . ok ) ; 
    c -> flags |= REDIS_CLOSE_AFTER_REPLY ; 
    return REDIS_ERR ; 
} 

cmd = lookupCommand ( c -> argv [ 0 ] -> ptr ) ; 
if ( ! cmd ) { 
    addReplyErrorFormat ( c , ""unknown command \'%s\'"" , ( char * ) c -> argv [ 0 ] -> ptr ) ; 
    return REDIS_OK ; 
} else if ( ( cmd -> arity > 0 && cmd -> arity != c -> argc ) || ( c -> argc < - cmd -> arity ) ) { 
    addReplyErrorFormat ( c , ""wrong number of arguments for \'%s\' command"" , cmd -> name ) ; 
    return REDIS_OK ; 
} 

if ( server . requirepass && ! c -> authenticated && cmd -> proc != authCommand ) { 
    addReplyError ( c , ""operation not permitted"" ) ; 
    return REDIS_OK ; 
} 

if ( server . maxmemory ) freeMemoryIfNeeded ( ) ; 
if ( server . maxmemory && ( cmd -> flags & REDIS_CMD_DENYOOM ) && zmalloc_used_memory ( ) > server . maxmemory ) { 
    addReplyError ( c , ""command not allowed when used memory > \'maxmemory\'"" ) ; 
    return REDIS_OK ; 
} 

if ( ( dictSize ( c -> pubsub_channels ) > 0 || listLength ( c -> pubsub_patterns ) > 0 ) && cmd -> proc != subscribeCommand && cmd -> proc != unsubscribeCommand && cmd -> proc != psubscribeCommand && cmd -> proc != punsubscribeCommand ) { 
    addReplyError ( c , ""only (P)SUBSCRIBE / (P)UNSUBSCRIBE / QUIT allowed in this context"" ) ; 
    return REDIS_OK ; 
} 

if ( server . masterhost && server . replstate != REDIS_REPL_CONNECTED && server . repl_serve_stale_data == 0 && cmd -> proc != infoCommand && cmd -> proc != slaveofCommand ) { 
    addReplyError ( c , ""link with MASTER is down and slave-serve-stale-data is set to no"" ) ; 
    return REDIS_OK ; 
} 

if ( server . loading && cmd -> proc != infoCommand ) { 
    addReply ( c , shared . loadingerr ) ; 
    return REDIS_OK ; 
} 

if ( c -> flags & REDIS_MULTI && cmd -> proc != execCommand && cmd -> proc != discardCommand && cmd -> proc != multiCommand && cmd -> proc != watchCommand ) { 
    queueMultiCommand ( c , cmd ) ; 
    addReply ( c , shared . queued ) ; 
} else { 
    if ( server . vm_enabled && server . vm_max_threads > 0 && blockClientOnSwappedKeys ( c , cmd ) ) return REDIS_ERR ; 
    call ( c , cmd ) ; 
} 
return REDIS_OK ; }",856,-37.406703764837076,-0.04369942028602462
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int processCommand ( redisClient * c ) { struct redisCommand * cmd ; if ( ! strcasecmp ( c -> argv [ 0 ] -> ptr , ""quit"" ) ) { addReply ( c , shared . ok ) ; c -> flags |= REDIS_CLOSE_AFTER_REPLY ; return REDIS_ERR ; } cmd = lookupCommand ( c -> argv [ 0 ] -> ptr ) ; if ( ! cmd ) { addReplyErrorFormat ( c , ""unknown command \'%s\'"" , ( char * ) c -> argv [ 0 ] -> ptr ) ; return REDIS_OK ; } else if ( ( cmd -> arity > 0 && cmd -> arity != c -> argc ) || ( c -> argc < - cmd -> arity ) ) { addReplyErrorFormat ( c , ""wrong number of arguments for \'%s\' command"" , cmd -> name ) ; return REDIS_OK ; } if ( server . requirepass && ! c -> authenticated && cmd -> proc != authCommand ) { addReplyError ( c , ""operation not permitted"" ) ; return REDIS_OK ; } if ( server . maxmemory ) freeMemoryIfNeeded ( ) ; if ( server . maxmemory && ( cmd -> flags & REDIS_CMD_DENYOOM ) && zmalloc_used_memory ( ) > server . maxmemory ) { addReplyError ( c , ""command not allowed when used memory > \'maxmemory\'"" ) ; return REDIS_OK ; } if ( ( dictSize ( c -> pubsub_channels ) > 0 || listLength ( c -> pubsub_patterns ) > 0 ) && cmd -> proc != subscribeCommand && cmd -> proc != unsubscribeCommand && cmd -> proc != psubscribeCommand && cmd -> proc != punsubscribeCommand ) { addReplyError ( c , ""only (P)SUBSCRIBE / (P)UNSUBSCRIBE / QUIT allowed in this context"" ) ; return REDIS_OK ; } if ( server . masterhost && server . replstate != REDIS_REPL_CONNECTED && server . repl_serve_stale_data == 0 && cmd -> proc != infoCommand && cmd -> proc != slaveofCommand ) { addReplyError ( c , ""link with MASTER is down and slave-serve-stale-data is set to no"" ) ; return REDIS_OK ; } if ( server . loading && cmd -> proc != infoCommand ) { addReply ( c , shared . loadingerr ) ; return REDIS_OK ; } if ( c -> flags & REDIS_MULTI && cmd -> proc != execCommand && cmd -> proc != discardCommand && cmd -> proc != multiCommand && cmd -> proc != watchCommand ) { queueMultiCommand ( c , cmd ) ; addReply ( c , shared . queued ) ; } else { if ( server . vm_enabled && server . vm_max_threads > 0 && blockClientOnSwappedKeys ( c , cmd ) ) return REDIS_ERR ; call ( c , cmd ) ; } return REDIS_OK ; }
Fixed code:","
int processCommand ( redisClient * c ) { struct redisCommand * cmd ; // Validate input and check for malicious input if ( ! c -> argv [ 0 ] || ! c -> argv [ 0 ] -> ptr || ! validInput ( c -> argv [ 0 ] -> ptr ) ) { addReplyError ( c , ""invalid command"" ) ; return REDIS_OK ; } if ( ! strcasecmp ( c -> argv [ 0 ] -> ptr , ""quit"" ) ) { addReply ( c , shared . ok ) ; c -> flags |= REDIS_CLOSE_AFTER_REPLY ; return REDIS_ERR ; } cmd = lookupCommand ( c -> argv [ 0 ] -> ptr ) ; if ( ! cmd ) { addReplyErrorFormat ( c , ""unknown command \'%s\'"" , ( char * ) c -> argv [ 0 ] -> ptr ) ; return REDIS_OK ; } else if ( ( cmd -> arity > 0 && cmd -> arity != c -> argc ) || ( c -> argc < - cmd -> arity ) ) { addReplyErrorFormat ( c , ""wrong number of arguments for \'%s\' command"" , cmd -> name ) ; return REDIS_OK ; } if ( server . requirepass && ! c -> authenticated && cmd -> proc != authCommand ) { addReplyError ( c , ""operation not permitted"" ) ; return REDIS_OK ; } if ( server . maxmemory ) freeMemoryIfNeeded ( ) ; if ( server . maxmemory && ( cmd -> flags & REDIS_CMD_DENYOOM ) && zmalloc_used_memory ( ) > server . maxmemory ) { addReplyError ( c , ""command not allowed when used memory > \'maxmemory\'"" ) ; return REDIS_OK ; } if ( ( dictSize ( c -> pubsub_channels ) > 0 || listLength ( c -> pubsub_patterns ) > 0 ) && cmd -> proc != subscribeCommand && cmd -> proc != unsubscribeCommand && cmd -> proc != psubscribeCommand && cmd -> proc != punsubscribeCommand ) { addReplyError ( c , ""only (P)SUBSCRIBE / (P)UNSUBSCRIBE / QUIT allowed in this context"" ) ; return REDIS_OK ; } if ( server . masterhost && server . replstate != REDIS_REPL_CONNECTED && server . repl_serve_stale_data == 0 && cmd -> proc != infoCommand && cmd -> proc != slaveofCommand ) { addReplyError ( c , ""link with MASTER is down and slave-serve-stale-data is set to no"" ) ; return REDIS_OK ; } if ( server . loading && cmd -> proc != infoCommand ) { addReply ( c , shared . loadingerr ) ; return REDIS_OK ; } if ( c -> flags & REDIS_MULTI && cmd -> proc != execCommand && cmd -> proc != discardCommand && cmd -> proc != multiCommand && cmd -> proc != watchCommand ) { queueMultiCommand ( c , cmd ) ; addReply ( c , shared . queued ) ; } else { if ( server . vm_enabled && server . vm_max_threads > 0 && blockClientOnSwappedKeys ( c , cmd ) ) return REDIS_ERR ; call ( c , cmd ) ; } return REDIS_OK ; }",744,-24.52434916843501,-0.032962834903810495
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int processCommand ( redisClient * c ) { struct redisCommand * cmd ; if ( ! strcasecmp ( c -> argv [ 0 ] -> ptr , ""quit"" ) ) { addReply ( c , shared . ok ) ; c -> flags |= REDIS_CLOSE_AFTER_REPLY ; return REDIS_ERR ; } cmd = lookupCommand ( c -> argv [ 0 ] -> ptr ) ; if ( ! cmd ) { addReplyErrorFormat ( c , ""unknown command \'%s\'"" , ( char * ) c -> argv [ 0 ] -> ptr ) ; return REDIS_OK ; } else if ( ( cmd -> arity > 0 && cmd -> arity != c -> argc ) || ( c -> argc < - cmd -> arity ) ) { addReplyErrorFormat ( c , ""wrong number of arguments for \'%s\' command"" , cmd -> name ) ; return REDIS_OK ; } if ( server . requirepass && ! c -> authenticated && cmd -> proc != authCommand ) { addReplyError ( c , ""operation not permitted"" ) ; return REDIS_OK ; } if ( server . maxmemory ) freeMemoryIfNeeded ( ) ; if ( server . maxmemory && ( cmd -> flags & REDIS_CMD_DENYOOM ) && zmalloc_used_memory ( ) > server . maxmemory ) { addReplyError ( c , ""command not allowed when used memory > \'maxmemory\'"" ) ; return REDIS_OK ; } if ( ( dictSize ( c -> pubsub_channels ) > 0 || listLength ( c -> pubsub_patterns ) > 0 ) && cmd -> proc != subscribeCommand && cmd -> proc != unsubscribeCommand && cmd -> proc != psubscribeCommand && cmd -> proc != punsubscribeCommand ) { addReplyError ( c , ""only (P)SUBSCRIBE / (P)UNSUBSCRIBE / QUIT allowed in this context"" ) ; return REDIS_OK ; } if ( server . masterhost && server . replstate != REDIS_REPL_CONNECTED && server . repl_serve_stale_data == 0 && cmd -> proc != infoCommand && cmd -> proc != slaveofCommand ) { addReplyError ( c , ""link with MASTER is down and slave-serve-stale-data is set to no"" ) ; return REDIS_OK ; } if ( server . loading && cmd -> proc != infoCommand ) { addReply ( c , shared . loadingerr ) ; return REDIS_OK ; } if ( c -> flags & REDIS_MULTI && cmd -> proc != execCommand && cmd -> proc != discardCommand && cmd -> proc != multiCommand && cmd -> proc != watchCommand ) { queueMultiCommand ( c , cmd ) ; addReply ( c , shared . queued ) ; } else { if ( server . vm_enabled && server . vm_max_threads > 0 && blockClientOnSwappedKeys ( c , cmd ) ) return REDIS_ERR ; call ( c , cmd ) ; } return REDIS_OK ; }
Fixed code:","
int processCommand ( redisClient * c ) { struct redisCommand * cmd ; if ( ! strcasecmp ( c -> argv [ 0 ] -> ptr , ""quit"" ) ) { addReply ( c , shared . ok ) ; c -> flags |= REDIS_CLOSE_AFTER_REPLY ; return REDIS_ERR ; } // Added input validation to check if the command is valid. if (!c->argv[0]->ptr || strlen(c->argv[0]->ptr) == 0) { addReplyErrorFormat(c, ""Invalid command""); return REDIS_OK; } cmd = lookupCommand ( c -> argv [ 0 ] -> ptr ) ; if ( ! cmd ) { addReplyErrorFormat ( c , ""unknown command \'%s\'"" , ( char * ) c -> argv [ 0 ] -> ptr ) ; return REDIS_OK ; } else if ( ( cmd -> arity > 0 && cmd -> arity != c -> argc ) || ( c -> argc < - cmd -> arity ) ) { addReplyErrorFormat ( c , ""wrong number of arguments for \'%s\' command"" , cmd -> name ) ; return REDIS_OK ; } if ( server . requirepass && ! c -> authenticated && cmd -> proc != authCommand ) { addReplyError ( c , ""operation not permitted"" ) ; return REDIS_OK ; } if ( server . maxmemory ) freeMemoryIfNeeded ( ) ; if ( server . maxmemory && ( cmd -> flags & REDIS_CMD_DENYOOM ) && zmalloc_used_memory ( ) > server . maxmemory ) { addReplyError ( c , ""command not allowed when used memory > \'maxmemory\'"" ) ; return REDIS_OK ; } if ( ( dictSize ( c -> pubsub_channels ) > 0 || listLength ( c -> pubsub_patterns ) > 0 ) && cmd -> proc != subscribeCommand && cmd -> proc != unsubscribeCommand && cmd -> proc != psubscribeCommand && cmd -> proc != punsubscribeCommand ) { addReplyError ( c , ""only (P)SUBSCRIBE / (P)UNSUBSCRIBE / QUIT allowed in this context"" ) ; return REDIS_OK ; } if ( server . masterhost && server . replstate != REDIS_REPL_CONNECTED && server . repl_serve_stale_data == 0 && cmd -> proc != infoCommand && cmd -> proc != slaveofCommand ) { addReplyError ( c , ""link with MASTER is down and slave-serve-stale-data is set to no"" ) ; return REDIS_OK ; } if ( server . loading && cmd -> proc != infoCommand ) { addReply ( c , shared . loadingerr ) ; return REDIS_OK ; } if ( c -> flags & REDIS_MULTI && cmd -> proc != execCommand && cmd -> proc != discardCommand && cmd -> proc != multiCommand && cmd -> proc != watchCommand ) { queueMultiCommand ( c , cmd ) ; addReply ( c , shared . queued ) ; } else { if ( server . vm_enabled && server . vm_max_threads > 0 && blockClientOnSwappedKeys ( c , cmd ) ) return REDIS_ERR ; call ( c , cmd ) ; } return REDIS_OK ; }",736,-21.877299615388107,-0.02972459186873384
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int processCommand ( redisClient * c ) { struct redisCommand * cmd ; if ( ! strcasecmp ( c -> argv [ 0 ] -> ptr , ""quit"" ) ) { addReply ( c , shared . ok ) ; c -> flags |= REDIS_CLOSE_AFTER_REPLY ; return REDIS_ERR ; } cmd = lookupCommand ( c -> argv [ 0 ] -> ptr ) ; if ( ! cmd ) { addReplyErrorFormat ( c , ""unknown command \'%s\'"" , ( char * ) c -> argv [ 0 ] -> ptr ) ; return REDIS_OK ; } else if ( ( cmd -> arity > 0 && cmd -> arity != c -> argc ) || ( c -> argc < - cmd -> arity ) ) { addReplyErrorFormat ( c , ""wrong number of arguments for \'%s\' command"" , cmd -> name ) ; return REDIS_OK ; } if ( server . requirepass && ! c -> authenticated && cmd -> proc != authCommand ) { addReplyError ( c , ""operation not permitted"" ) ; return REDIS_OK ; } if ( server . maxmemory ) freeMemoryIfNeeded ( ) ; if ( server . maxmemory && ( cmd -> flags & REDIS_CMD_DENYOOM ) && zmalloc_used_memory ( ) > server . maxmemory ) { addReplyError ( c , ""command not allowed when used memory > \'maxmemory\'"" ) ; return REDIS_OK ; } if ( ( dictSize ( c -> pubsub_channels ) > 0 || listLength ( c -> pubsub_patterns ) > 0 ) && cmd -> proc != subscribeCommand && cmd -> proc != unsubscribeCommand && cmd -> proc != psubscribeCommand && cmd -> proc != punsubscribeCommand ) { addReplyError ( c , ""only (P)SUBSCRIBE / (P)UNSUBSCRIBE / QUIT allowed in this context"" ) ; return REDIS_OK ; } if ( server . masterhost && server . replstate != REDIS_REPL_CONNECTED && server . repl_serve_stale_data == 0 && cmd -> proc != infoCommand && cmd -> proc != slaveofCommand ) { addReplyError ( c , ""link with MASTER is down and slave-serve-stale-data is set to no"" ) ; return REDIS_OK ; } if ( server . loading && cmd -> proc != infoCommand ) { addReply ( c , shared . loadingerr ) ; return REDIS_OK ; } if ( c -> flags & REDIS_MULTI && cmd -> proc != execCommand && cmd -> proc != discardCommand && cmd -> proc != multiCommand && cmd -> proc != watchCommand ) { queueMultiCommand ( c , cmd ) ; addReply ( c , shared . queued ) ; } else { if ( server . vm_enabled && server . vm_max_threads > 0 && blockClientOnSwappedKeys ( c , cmd ) ) return REDIS_ERR ; call ( c , cmd ) ; } return REDIS_OK ; }
Fixed code:","
int processCommand ( redisClient * c ) { struct redisCommand * cmd ; 
// Validate input
if ( ! c || ! c-> argv || ! c-> argv[0] || ! c-> argv[0]-> ptr ) {
  addReply(c, shared.wrongtypeerr);
  return REDIS_ERR;
}

if ( ! strcasecmp ( c -> argv [ 0 ] -> ptr , ""quit"" ) ) { 
  addReply ( c , shared . ok ) ; c -> flags |= REDIS_CLOSE_AFTER_REPLY ; return REDIS_ERR ; 
} 

cmd = lookupCommand ( c -> argv [ 0 ] -> ptr ) ;
if ( ! cmd ) { 
  addReplyErrorFormat ( c , ""unknown command \'%s\'"" , ( char * ) c -> argv [ 0 ] -> ptr ) ; 
  return REDIS_OK ; 
} else if ( ( cmd -> arity > 0 && cmd -> arity != c -> argc ) || ( c -> argc < - cmd -> arity ) ) { 
  addReplyErrorFormat ( c , ""wrong number of arguments for \'%s\' command"" , cmd -> name ) ; 
  return REDIS_OK ; 
} 

if ( server . requirepass && ! c -> authenticated && cmd -> proc != authCommand ) { 
  addReplyError ( c , ""operation not permitted"" ) ; 
  return REDIS_OK ; 
} 

if ( server . maxmemory ) freeMemoryIfNeeded ( ) ; if ( server . maxmemory && ( cmd -> flags & REDIS_CMD_DENYOOM ) && zmalloc_used_memory ( ) > server . maxmemory ) { 
  addReplyError ( c , ""command not allowed when used memory > \'maxmemory\'"" ) ; 
  return REDIS_OK ; 
} 

if ( ( dictSize ( c -> pubsub_channels ) > 0 || listLength ( c -> pubsub_patterns ) > 0 ) && cmd -> proc != subscribeCommand && cmd -> proc != unsubscribeCommand && cmd -> proc != psubscribeCommand && cmd -> proc != punsubscribeCommand ) { 
  addReplyError ( c , ""only (P)SUBSCRIBE / (P)UNSUBSCRIBE / QUIT allowed in this context"" ) ; 
  return REDIS_OK ; 
} 

if ( server . masterhost && server . replstate != REDIS_REPL_CONNECTED && server . repl_serve_stale_data == 0 && cmd -> proc != infoCommand && cmd -> proc != slaveofCommand ) { 
  addReplyError ( c , ""link with MASTER is down and slave-serve-stale-data is set to no"" ) ; 
  return REDIS_OK ; 
} 

if ( server . loading && cmd -> proc != infoCommand ) { 
  addReply ( c , shared . loadingerr ) ; 
  return REDIS_OK ; 
} 

if ( c -> flags & REDIS_MULTI && cmd -> proc != execCommand && cmd -> proc != discardCommand && cmd -> proc != multiCommand && cmd -> proc != watchCommand ) { 
  queueMultiCommand ( c , cmd ) ; 
  addReply ( c , shared . queued ) ; 
} else { 
  if ( server . vm_enabled && server . vm_max_threads > 0 && blockClientOnSwappedKeys ( c , cmd ) ) return REDIS_ERR ; 
  call ( c , cmd ) ; 
} 
return REDIS_OK ; 
}",845,-45.17751655809687,-0.053464516636801025
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int processCommand ( redisClient * c ) { struct redisCommand * cmd ; if ( ! strcasecmp ( c -> argv [ 0 ] -> ptr , ""quit"" ) ) { addReply ( c , shared . ok ) ; c -> flags |= REDIS_CLOSE_AFTER_REPLY ; return REDIS_ERR ; } cmd = lookupCommand ( c -> argv [ 0 ] -> ptr ) ; if ( ! cmd ) { addReplyErrorFormat ( c , ""unknown command \'%s\'"" , ( char * ) c -> argv [ 0 ] -> ptr ) ; return REDIS_OK ; } else if ( ( cmd -> arity > 0 && cmd -> arity != c -> argc ) || ( c -> argc < - cmd -> arity ) ) { addReplyErrorFormat ( c , ""wrong number of arguments for \'%s\' command"" , cmd -> name ) ; return REDIS_OK ; } if ( server . requirepass && ! c -> authenticated && cmd -> proc != authCommand ) { addReplyError ( c , ""operation not permitted"" ) ; return REDIS_OK ; } if ( server . maxmemory ) freeMemoryIfNeeded ( ) ; if ( server . maxmemory && ( cmd -> flags & REDIS_CMD_DENYOOM ) && zmalloc_used_memory ( ) > server . maxmemory ) { addReplyError ( c , ""command not allowed when used memory > \'maxmemory\'"" ) ; return REDIS_OK ; } if ( ( dictSize ( c -> pubsub_channels ) > 0 || listLength ( c -> pubsub_patterns ) > 0 ) && cmd -> proc != subscribeCommand && cmd -> proc != unsubscribeCommand && cmd -> proc != psubscribeCommand && cmd -> proc != punsubscribeCommand ) { addReplyError ( c , ""only (P)SUBSCRIBE / (P)UNSUBSCRIBE / QUIT allowed in this context"" ) ; return REDIS_OK ; } if ( server . masterhost && server . replstate != REDIS_REPL_CONNECTED && server . repl_serve_stale_data == 0 && cmd -> proc != infoCommand && cmd -> proc != slaveofCommand ) { addReplyError ( c , ""link with MASTER is down and slave-serve-stale-data is set to no"" ) ; return REDIS_OK ; } if ( server . loading && cmd -> proc != infoCommand ) { addReply ( c , shared . loadingerr ) ; return REDIS_OK ; } if ( c -> flags & REDIS_MULTI && cmd -> proc != execCommand && cmd -> proc != discardCommand && cmd -> proc != multiCommand && cmd -> proc != watchCommand ) { queueMultiCommand ( c , cmd ) ; addReply ( c , shared . queued ) ; } else { if ( server . vm_enabled && server . vm_max_threads > 0 && blockClientOnSwappedKeys ( c , cmd ) ) return REDIS_ERR ; call ( c , cmd ) ; } return REDIS_OK ; }
Fixed code:","
int processCommand ( redisClient * c ) { struct redisCommand * cmd ; int i ; for ( i = 0 ; i < c -> argc ; i ++ ) { if ( ! isascii ( c -> argv [ i ] -> ptr ) ) { addReplyError ( c , ""Command contains non-ascii characters"" ) ; return REDIS_OK ; } } if ( ! strcasecmp ( c -> argv [ 0 ] -> ptr , ""quit"" ) ) { addReply ( c , shared . ok ) ; c -> flags |= REDIS_CLOSE_AFTER_REPLY ; return REDIS_ERR ; } cmd = lookupCommand ( c -> argv [ 0 ] -> ptr ) ; if ( ! cmd ) { addReplyErrorFormat ( c , ""unknown command \'%s\'"" , ( char * ) c -> argv [ 0 ] -> ptr ) ; return REDIS_OK ; } else if ( ( cmd -> arity > 0 && cmd -> arity != c -> argc ) || ( c -> argc < - cmd -> arity ) ) { addReplyErrorFormat ( c , ""wrong number of arguments for \'%s\' command"" , cmd -> name ) ; return REDIS_OK ; } if ( server . requirepass && ! c -> authenticated && cmd -> proc != authCommand ) { addReplyError ( c , ""operation not permitted"" ) ; return REDIS_OK ; } if ( server . maxmemory ) freeMemoryIfNeeded ( ) ; if ( server . maxmemory && ( cmd -> flags & REDIS_CMD_DENYOOM ) && zmalloc_used_memory ( ) > server . maxmemory ) { addReplyError ( c , ""command not allowed when used memory > \'maxmemory\'"" ) ; return REDIS_OK ; } if ( ( dictSize ( c -> pubsub_channels ) > 0 || listLength ( c -> pubsub_patterns ) > 0 ) && cmd -> proc != subscribeCommand && cmd -> proc != unsubscribeCommand && cmd -> proc != psubscribeCommand && cmd -> proc != punsubscribeCommand ) { addReplyError ( c , ""only (P)SUBSCRIBE / (P)UNSUBSCRIBE / QUIT allowed in this context"" ) ; return REDIS_OK ; } if ( server . masterhost && server . replstate != REDIS_REPL_CONNECTED && server . repl_serve_stale_data == 0 && cmd -> proc != infoCommand && cmd -> proc != slaveofCommand ) { addReplyError ( c , ""link with MASTER is down and slave-serve-stale-data is set to no"" ) ; return REDIS_OK ; } if ( server . loading && cmd -> proc != infoCommand ) { addReply ( c , shared . loadingerr ) ; return REDIS_OK ; } if ( c -> flags & REDIS_MULTI && cmd -> proc != execCommand && cmd -> proc != discardCommand && cmd -> proc != multiCommand && cmd -> proc != watchCommand ) { queueMultiCommand ( c , cmd ) ; addReply ( c , shared . queued ) ; } else { if ( server . vm_enabled && server . vm_max_threads > 0 && blockClientOnSwappedKeys ( c , cmd ) ) return REDIS_ERR ; call ( c , cmd ) ; } return REDIS_OK ; }",743,-19.94647837238002,-0.026845865911682396
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int processCommand ( redisClient * c ) { struct redisCommand * cmd ; if ( ! strcasecmp ( c -> argv [ 0 ] -> ptr , ""quit"" ) ) { addReply ( c , shared . ok ) ; c -> flags |= REDIS_CLOSE_AFTER_REPLY ; return REDIS_ERR ; } cmd = lookupCommand ( c -> argv [ 0 ] -> ptr ) ; if ( ! cmd ) { addReplyErrorFormat ( c , ""unknown command \'%s\'"" , ( char * ) c -> argv [ 0 ] -> ptr ) ; return REDIS_OK ; } else if ( ( cmd -> arity > 0 && cmd -> arity != c -> argc ) || ( c -> argc < - cmd -> arity ) ) { addReplyErrorFormat ( c , ""wrong number of arguments for \'%s\' command"" , cmd -> name ) ; return REDIS_OK ; } if ( server . requirepass && ! c -> authenticated && cmd -> proc != authCommand ) { addReplyError ( c , ""operation not permitted"" ) ; return REDIS_OK ; } if ( server . maxmemory ) freeMemoryIfNeeded ( ) ; if ( server . maxmemory && ( cmd -> flags & REDIS_CMD_DENYOOM ) && zmalloc_used_memory ( ) > server . maxmemory ) { addReplyError ( c , ""command not allowed when used memory > \'maxmemory\'"" ) ; return REDIS_OK ; } if ( ( dictSize ( c -> pubsub_channels ) > 0 || listLength ( c -> pubsub_patterns ) > 0 ) && cmd -> proc != subscribeCommand && cmd -> proc != unsubscribeCommand && cmd -> proc != psubscribeCommand && cmd -> proc != punsubscribeCommand ) { addReplyError ( c , ""only (P)SUBSCRIBE / (P)UNSUBSCRIBE / QUIT allowed in this context"" ) ; return REDIS_OK ; } if ( server . masterhost && server . replstate != REDIS_REPL_CONNECTED && server . repl_serve_stale_data == 0 && cmd -> proc != infoCommand && cmd -> proc != slaveofCommand ) { addReplyError ( c , ""link with MASTER is down and slave-serve-stale-data is set to no"" ) ; return REDIS_OK ; } if ( server . loading && cmd -> proc != infoCommand ) { addReply ( c , shared . loadingerr ) ; return REDIS_OK ; } if ( c -> flags & REDIS_MULTI && cmd -> proc != execCommand && cmd -> proc != discardCommand && cmd -> proc != multiCommand && cmd -> proc != watchCommand ) { queueMultiCommand ( c , cmd ) ; addReply ( c , shared . queued ) ; } else { if ( server . vm_enabled && server . vm_max_threads > 0 && blockClientOnSwappedKeys ( c , cmd ) ) return REDIS_ERR ; call ( c , cmd ) ; } return REDIS_OK ; }
Fixed code:","
int processCommand ( redisClient * c ) { struct redisCommand * cmd ; // Check for valid input before beginning processing if(c->argv[0] == NULL || !strcmp(c->argv[0]->ptr, """")) { addReplyError(c, ""Error: Invalid command""); return REDIS_ERR; } 

if ( ! strcasecmp ( c -> argv [ 0 ] -> ptr , ""quit"" ) ) { addReply ( c , shared . ok ) ; c -> flags |= REDIS_CLOSE_AFTER_REPLY ; return REDIS_ERR ; } cmd = lookupCommand ( c -> argv [ 0 ] -> ptr ) ; if ( ! cmd ) { addReplyErrorFormat ( c , ""unknown command \'%s\'"" , ( char * ) c -> argv [ 0 ] -> ptr ) ; return REDIS_OK ; } else if ( ( cmd -> arity > 0 && cmd -> arity != c -> argc ) || ( c -> argc < - cmd -> arity ) ) { addReplyErrorFormat ( c , ""wrong number of arguments for \'%s\' command"" , cmd -> name ) ; return REDIS_OK ; } if ( server . requirepass && ! c -> authenticated && cmd -> proc != authCommand ) { addReplyError ( c , ""operation not permitted"" ) ; return REDIS_OK ; } if ( server . maxmemory ) freeMemoryIfNeeded ( ) ; if ( server . maxmemory && ( cmd -> flags & REDIS_CMD_DENYOOM ) && zmalloc_used_memory ( ) > server . maxmemory ) { addReplyError ( c , ""command not allowed when used memory > \'maxmemory\'"" ) ; return REDIS_OK ; } if ( ( dictSize ( c -> pubsub_channels ) > 0 || listLength ( c -> pubsub_patterns ) > 0 ) && cmd -> proc != subscribeCommand && cmd -> proc != unsubscribeCommand && cmd -> proc != psubscribeCommand && cmd -> proc != punsubscribeCommand ) { addReplyError ( c , ""only (P)SUBSCRIBE / (P)UNSUBSCRIBE / QUIT allowed in this context"" ) ; return REDIS_OK ; } if ( server . masterhost && server . replstate != REDIS_REPL_CONNECTED && server . repl_serve_stale_data == 0 && cmd -> proc != infoCommand && cmd -> proc != slaveofCommand ) { addReplyError ( c , ""link with MASTER is down and slave-serve-stale-data is set to no"" ) ; return REDIS_OK ; } if ( server . loading && cmd -> proc != infoCommand ) { addReply ( c , shared . loadingerr ) ; return REDIS_OK ; } if ( c -> flags & REDIS_MULTI && cmd -> proc != execCommand && cmd -> proc != discardCommand && cmd -> proc != multiCommand && cmd -> proc != watchCommand ) { queueMultiCommand ( c , cmd ) ; addReply ( c , shared . queued ) ; } else { if ( server . vm_enabled && server . vm_max_threads > 0 && blockClientOnSwappedKeys ( c , cmd ) ) return REDIS_ERR ; call ( c , cmd ) ; } return REDIS_OK ; }",737,-39.650188468344126,-0.053799441612407226
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int processCommand ( redisClient * c ) { struct redisCommand * cmd ; if ( ! strcasecmp ( c -> argv [ 0 ] -> ptr , ""quit"" ) ) { addReply ( c , shared . ok ) ; c -> flags |= REDIS_CLOSE_AFTER_REPLY ; return REDIS_ERR ; } cmd = lookupCommand ( c -> argv [ 0 ] -> ptr ) ; if ( ! cmd ) { addReplyErrorFormat ( c , ""unknown command \'%s\'"" , ( char * ) c -> argv [ 0 ] -> ptr ) ; return REDIS_OK ; } else if ( ( cmd -> arity > 0 && cmd -> arity != c -> argc ) || ( c -> argc < - cmd -> arity ) ) { addReplyErrorFormat ( c , ""wrong number of arguments for \'%s\' command"" , cmd -> name ) ; return REDIS_OK ; } if ( server . requirepass && ! c -> authenticated && cmd -> proc != authCommand ) { addReplyError ( c , ""operation not permitted"" ) ; return REDIS_OK ; } if ( server . maxmemory ) freeMemoryIfNeeded ( ) ; if ( server . maxmemory && ( cmd -> flags & REDIS_CMD_DENYOOM ) && zmalloc_used_memory ( ) > server . maxmemory ) { addReplyError ( c , ""command not allowed when used memory > \'maxmemory\'"" ) ; return REDIS_OK ; } if ( ( dictSize ( c -> pubsub_channels ) > 0 || listLength ( c -> pubsub_patterns ) > 0 ) && cmd -> proc != subscribeCommand && cmd -> proc != unsubscribeCommand && cmd -> proc != psubscribeCommand && cmd -> proc != punsubscribeCommand ) { addReplyError ( c , ""only (P)SUBSCRIBE / (P)UNSUBSCRIBE / QUIT allowed in this context"" ) ; return REDIS_OK ; } if ( server . masterhost && server . replstate != REDIS_REPL_CONNECTED && server . repl_serve_stale_data == 0 && cmd -> proc != infoCommand && cmd -> proc != slaveofCommand ) { addReplyError ( c , ""link with MASTER is down and slave-serve-stale-data is set to no"" ) ; return REDIS_OK ; } if ( server . loading && cmd -> proc != infoCommand ) { addReply ( c , shared . loadingerr ) ; return REDIS_OK ; } if ( c -> flags & REDIS_MULTI && cmd -> proc != execCommand && cmd -> proc != discardCommand && cmd -> proc != multiCommand && cmd -> proc != watchCommand ) { queueMultiCommand ( c , cmd ) ; addReply ( c , shared . queued ) ; } else { if ( server . vm_enabled && server . vm_max_threads > 0 && blockClientOnSwappedKeys ( c , cmd ) ) return REDIS_ERR ; call ( c , cmd ) ; } return REDIS_OK ; }
Fixed code:","
int processCommand ( redisClient * c ) { if ( ! c || ! c -> argv ) return REDIS_ERR ; struct redisCommand * cmd ; if ( ! strcasecmp ( c -> argv [ 0 ] -> ptr , ""quit"" ) ) { addReply ( c , shared . ok ) ; c -> flags |= REDIS_CLOSE_AFTER_REPLY ; return REDIS_ERR ; } cmd = lookupCommand ( c -> argv [ 0 ] -> ptr ) ; if ( ! cmd ) { addReplyErrorFormat ( c , ""unknown command \'%s\'"" , ( char * ) c -> argv [ 0 ] -> ptr ) ; return REDIS_OK ; } else if ( ( cmd -> arity > 0 && cmd -> arity != c -> argc ) || ( c -> argc < - cmd -> arity ) ) { addReplyErrorFormat ( c , ""wrong number of arguments for \'%s\' command"" , cmd -> name ) ; return REDIS_OK ; } if ( server . requirepass && ! c -> authenticated && cmd -> proc != authCommand ) { addReplyError ( c , ""operation not permitted"" ) ; return REDIS_OK ; } if ( server . maxmemory ) freeMemoryIfNeeded ( ) ; if ( server . maxmemory && ( cmd -> flags & REDIS_CMD_DENYOOM ) && zmalloc_used_memory ( ) > server . maxmemory ) { addReplyError ( c , ""command not allowed when used memory > \'maxmemory\'"" ) ; return REDIS_OK ; } if ( ( dictSize ( c -> pubsub_channels ) > 0 || listLength ( c -> pubsub_patterns ) > 0 ) && cmd -> proc != subscribeCommand && cmd -> proc != unsubscribeCommand && cmd -> proc != psubscribeCommand && cmd -> proc != punsubscribeCommand ) { addReplyError ( c , ""only (P)SUBSCRIBE / (P)UNSUBSCRIBE / QUIT allowed in this context"" ) ; return REDIS_OK ; } if ( server . masterhost && server . replstate != REDIS_REPL_CONNECTED && server . repl_serve_stale_data == 0 && cmd -> proc != infoCommand && cmd -> proc != slaveofCommand ) { addReplyError ( c , ""link with MASTER is down and slave-serve-stale-data is set to no"" ) ; return REDIS_OK ; } if ( server . loading && cmd -> proc != infoCommand ) { addReply ( c , shared . loadingerr ) ; return REDIS_OK ; } if ( c -> flags & REDIS_MULTI && cmd -> proc != execCommand && cmd -> proc != discardCommand && cmd -> proc != multiCommand && cmd -> proc != watchCommand ) { queueMultiCommand ( c , cmd ) ; addReply ( c , shared . queued ) ; } else { if ( server . vm_enabled && server . vm_max_threads > 0 && blockClientOnSwappedKeys ( c , cmd ) ) return REDIS_ERR ; if ( ! c -> argv [ 0 ] -> ptr ) return REDIS_ERR ; call ( c , cmd ) ; } return REDIS_OK ; }",715,-15.652274273080263,-0.021891292689622744
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int processCommand ( redisClient * c ) { struct redisCommand * cmd ; if ( ! strcasecmp ( c -> argv [ 0 ] -> ptr , ""quit"" ) ) { addReply ( c , shared . ok ) ; c -> flags |= REDIS_CLOSE_AFTER_REPLY ; return REDIS_ERR ; } cmd = lookupCommand ( c -> argv [ 0 ] -> ptr ) ; if ( ! cmd ) { addReplyErrorFormat ( c , ""unknown command \'%s\'"" , ( char * ) c -> argv [ 0 ] -> ptr ) ; return REDIS_OK ; } else if ( ( cmd -> arity > 0 && cmd -> arity != c -> argc ) || ( c -> argc < - cmd -> arity ) ) { addReplyErrorFormat ( c , ""wrong number of arguments for \'%s\' command"" , cmd -> name ) ; return REDIS_OK ; } if ( server . requirepass && ! c -> authenticated && cmd -> proc != authCommand ) { addReplyError ( c , ""operation not permitted"" ) ; return REDIS_OK ; } if ( server . maxmemory ) freeMemoryIfNeeded ( ) ; if ( server . maxmemory && ( cmd -> flags & REDIS_CMD_DENYOOM ) && zmalloc_used_memory ( ) > server . maxmemory ) { addReplyError ( c , ""command not allowed when used memory > \'maxmemory\'"" ) ; return REDIS_OK ; } if ( ( dictSize ( c -> pubsub_channels ) > 0 || listLength ( c -> pubsub_patterns ) > 0 ) && cmd -> proc != subscribeCommand && cmd -> proc != unsubscribeCommand && cmd -> proc != psubscribeCommand && cmd -> proc != punsubscribeCommand ) { addReplyError ( c , ""only (P)SUBSCRIBE / (P)UNSUBSCRIBE / QUIT allowed in this context"" ) ; return REDIS_OK ; } if ( server . masterhost && server . replstate != REDIS_REPL_CONNECTED && server . repl_serve_stale_data == 0 && cmd -> proc != infoCommand && cmd -> proc != slaveofCommand ) { addReplyError ( c , ""link with MASTER is down and slave-serve-stale-data is set to no"" ) ; return REDIS_OK ; } if ( server . loading && cmd -> proc != infoCommand ) { addReply ( c , shared . loadingerr ) ; return REDIS_OK ; } if ( c -> flags & REDIS_MULTI && cmd -> proc != execCommand && cmd -> proc != discardCommand && cmd -> proc != multiCommand && cmd -> proc != watchCommand ) { queueMultiCommand ( c , cmd ) ; addReply ( c , shared . queued ) ; } else { if ( server . vm_enabled && server . vm_max_threads > 0 && blockClientOnSwappedKeys ( c , cmd ) ) return REDIS_ERR ; call ( c , cmd ) ; } return REDIS_OK ; }
Fixed code:","
int processCommand ( redisClient * c ) { 
    struct redisCommand * cmd ; 
    
    // Add input validation check
    if (c -> argv[0] == NULL || !strlen(c -> argv[0] -> ptr)) {
        addReplyError(c, ""Empty command"");
        return REDIS_OK;
    }
    
    if ( ! strcasecmp ( c -> argv [ 0 ] -> ptr , ""quit"" ) ) { 
        addReply ( c , shared . ok ) ; 
        c -> flags |= REDIS_CLOSE_AFTER_REPLY ; 
        return REDIS_ERR ; 
    } 
    cmd = lookupCommand ( c -> argv [ 0 ] -> ptr ) ; 
    if ( ! cmd ) { 
        addReplyErrorFormat ( c , ""unknown command \'%s\'"" , ( char * ) c -> argv [ 0 ] -> ptr ) ; 
        return REDIS_OK ; 
    } else if ( ( cmd -> arity > 0 && cmd -> arity != c -> argc ) || ( c -> argc < - cmd -> arity ) ) { 
        addReplyErrorFormat ( c , ""wrong number of arguments for \'%s\' command"" , cmd -> name ) ; 
        return REDIS_OK ; 
    } 
    if ( server . requirepass && ! c -> authenticated && cmd -> proc != authCommand ) { 
        addReplyError ( c , ""operation not permitted"" ) ; 
        return REDIS_OK ; 
    } 
    if ( server . maxmemory ) freeMemoryIfNeeded ( ) ; 
    if ( server . maxmemory && ( cmd -> flags & REDIS_CMD_DENYOOM ) && zmalloc_used_memory ( ) > server . maxmemory ) { 
        addReplyError ( c , ""command not allowed when used memory > \'maxmemory\'"" ) ; 
        return REDIS_OK ; 
    } 
    if ( ( dictSize ( c -> pubsub_channels ) > 0 || listLength ( c -> pubsub_patterns ) > 0 ) && cmd -> proc != subscribeCommand && cmd -> proc != unsubscribeCommand && cmd -> proc != psubscribeCommand && cmd -> proc != punsubscribeCommand ) { 
        addReplyError ( c , ""only (P)SUBSCRIBE / (P)UNSUBSCRIBE / QUIT allowed in this context"" ) ; 
        return REDIS_OK ; 
    } 
    if ( server . masterhost && server . replstate != REDIS_REPL_CONNECTED && server . repl_serve_stale_data == 0 && cmd -> proc != infoCommand && cmd -> proc != slaveofCommand ) { 
        addReplyError ( c , ""link with MASTER is down and slave-serve-stale-data is set to no"" ) ; 
        return REDIS_OK ; 
    } 
    if ( server . loading && cmd -> proc != infoCommand ) { 
        addReply ( c , shared . loadingerr ) ; 
        return REDIS_OK ; 
    } 
    if ( c -> flags & REDIS_MULTI && cmd -> proc != execCommand && cmd -> proc != discardCommand && cmd -> proc != multiCommand && cmd -> proc != watchCommand ) { 
        queueMultiCommand ( c , cmd ) ; 
        addReply ( c , shared . queued ) ; 
    } else { 
        if ( server . vm_enabled && server . vm_max_threads > 0 && blockClientOnSwappedKeys ( c , cmd ) ) return REDIS_ERR ; 
        call ( c , cmd ) ; 
    } 
    return REDIS_OK ; 
}",871,-28.996544698804755,-0.033291096095068605
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int processCommand ( redisClient * c ) { struct redisCommand * cmd ; if ( ! strcasecmp ( c -> argv [ 0 ] -> ptr , ""quit"" ) ) { addReply ( c , shared . ok ) ; c -> flags |= REDIS_CLOSE_AFTER_REPLY ; return REDIS_ERR ; } cmd = lookupCommand ( c -> argv [ 0 ] -> ptr ) ; if ( ! cmd ) { addReplyErrorFormat ( c , ""unknown command \'%s\'"" , ( char * ) c -> argv [ 0 ] -> ptr ) ; return REDIS_OK ; } else if ( ( cmd -> arity > 0 && cmd -> arity != c -> argc ) || ( c -> argc < - cmd -> arity ) ) { addReplyErrorFormat ( c , ""wrong number of arguments for \'%s\' command"" , cmd -> name ) ; return REDIS_OK ; } if ( server . requirepass && ! c -> authenticated && cmd -> proc != authCommand ) { addReplyError ( c , ""operation not permitted"" ) ; return REDIS_OK ; } if ( server . maxmemory ) freeMemoryIfNeeded ( ) ; if ( server . maxmemory && ( cmd -> flags & REDIS_CMD_DENYOOM ) && zmalloc_used_memory ( ) > server . maxmemory ) { addReplyError ( c , ""command not allowed when used memory > \'maxmemory\'"" ) ; return REDIS_OK ; } if ( ( dictSize ( c -> pubsub_channels ) > 0 || listLength ( c -> pubsub_patterns ) > 0 ) && cmd -> proc != subscribeCommand && cmd -> proc != unsubscribeCommand && cmd -> proc != psubscribeCommand && cmd -> proc != punsubscribeCommand ) { addReplyError ( c , ""only (P)SUBSCRIBE / (P)UNSUBSCRIBE / QUIT allowed in this context"" ) ; return REDIS_OK ; } if ( server . masterhost && server . replstate != REDIS_REPL_CONNECTED && server . repl_serve_stale_data == 0 && cmd -> proc != infoCommand && cmd -> proc != slaveofCommand ) { addReplyError ( c , ""link with MASTER is down and slave-serve-stale-data is set to no"" ) ; return REDIS_OK ; } if ( server . loading && cmd -> proc != infoCommand ) { addReply ( c , shared . loadingerr ) ; return REDIS_OK ; } if ( c -> flags & REDIS_MULTI && cmd -> proc != execCommand && cmd -> proc != discardCommand && cmd -> proc != multiCommand && cmd -> proc != watchCommand ) { queueMultiCommand ( c , cmd ) ; addReply ( c , shared . queued ) ; } else { if ( server . vm_enabled && server . vm_max_threads > 0 && blockClientOnSwappedKeys ( c , cmd ) ) return REDIS_ERR ; call ( c , cmd ) ; } return REDIS_OK ; }
Fixed code:"," 
int processCommand ( redisClient * c ) {
    struct redisCommand * cmd ;
    
    if (!c->argv[0] || strlen(c->argv[0]->ptr) == 0) {
        addReplyErrorFormat(c, ""invalid command"");
        return REDIS_OK;
    }

    if ( ! strcasecmp ( c -> argv [ 0 ] -> ptr , ""quit"" ) ) {
        addReply ( c , shared . ok ) ;
        c -> flags |= REDIS_CLOSE_AFTER_REPLY ;
        return REDIS_ERR ;
    }

    cmd = lookupCommand ( c -> argv [ 0 ] -> ptr ) ;
    if ( ! cmd ) {
        addReplyErrorFormat ( c , ""unknown command \'%s\'"" , ( char * ) c -> argv [ 0 ] -> ptr ) ;
        return REDIS_OK ;
    } else if ( ( cmd -> arity > 0 && cmd -> arity != c -> argc ) || ( c -> argc < - cmd -> arity ) ) {
        addReplyErrorFormat ( c , ""wrong number of arguments for \'%s\' command"" , cmd -> name ) ;
        return REDIS_OK ;
    }

    if ( server . requirepass && ! c -> authenticated && cmd -> proc != authCommand ) {
        addReplyError ( c , ""operation not permitted"" ) ;
        return REDIS_OK ;
    }

    if ( server . maxmemory ) freeMemoryIfNeeded ( ) ;
    if ( server . maxmemory && ( cmd -> flags & REDIS_CMD_DENYOOM ) && zmalloc_used_memory ( ) > server . maxmemory ) {
        addReplyError ( c , ""command not allowed when used memory > \'maxmemory\'"" ) ;
        return REDIS_OK ;
    }

    if ( ( dictSize ( c -> pubsub_channels ) > 0 || listLength ( c -> pubsub_patterns ) > 0 ) && cmd -> proc != subscribeCommand && cmd -> proc != unsubscribeCommand && cmd -> proc != psubscribeCommand && cmd -> proc != punsubscribeCommand ) {
        addReplyError ( c , ""only (P)SUBSCRIBE / (P)UNSUBSCRIBE / QUIT allowed in this context"" ) ;
        return REDIS_OK ;
    }

    if ( server . masterhost && server . replstate != REDIS_REPL_CONNECTED && server . repl_serve_stale_data == 0 && cmd -> proc != infoCommand && cmd -> proc != slaveofCommand ) {
        addReplyError ( c , ""link with MASTER is down and slave-serve-stale-data is set to no"" ) ;
        return REDIS_OK ;
    }

    if ( server . loading && cmd -> proc != infoCommand ) {
        addReply ( c , shared . loadingerr ) ;
        return REDIS_OK ;
    }

    if ( c -> flags & REDIS_MULTI && cmd -> proc != execCommand && cmd -> proc != discardCommand && cmd -> proc != multiCommand && cmd -> proc != watchCommand ) {
        queueMultiCommand ( c , cmd ) ;
        addReply ( c , shared . queued ) ;
    } else {
        if ( server . vm_enabled && server . vm_max_threads > 0 && blockClientOnSwappedKeys ( c , cmd ) ) return REDIS_ERR ;
        call ( c , cmd ) ;
    }
    return REDIS_OK ;
}",821,-27.787623712865674,-0.0338460702958169
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int processCommand ( redisClient * c ) { struct redisCommand * cmd ; if ( ! strcasecmp ( c -> argv [ 0 ] -> ptr , ""quit"" ) ) { addReply ( c , shared . ok ) ; c -> flags |= REDIS_CLOSE_AFTER_REPLY ; return REDIS_ERR ; } cmd = lookupCommand ( c -> argv [ 0 ] -> ptr ) ; if ( ! cmd ) { addReplyErrorFormat ( c , ""unknown command \'%s\'"" , ( char * ) c -> argv [ 0 ] -> ptr ) ; return REDIS_OK ; } else if ( ( cmd -> arity > 0 && cmd -> arity != c -> argc ) || ( c -> argc < - cmd -> arity ) ) { addReplyErrorFormat ( c , ""wrong number of arguments for \'%s\' command"" , cmd -> name ) ; return REDIS_OK ; } if ( server . requirepass && ! c -> authenticated && cmd -> proc != authCommand ) { addReplyError ( c , ""operation not permitted"" ) ; return REDIS_OK ; } if ( server . maxmemory ) freeMemoryIfNeeded ( ) ; if ( server . maxmemory && ( cmd -> flags & REDIS_CMD_DENYOOM ) && zmalloc_used_memory ( ) > server . maxmemory ) { addReplyError ( c , ""command not allowed when used memory > \'maxmemory\'"" ) ; return REDIS_OK ; } if ( ( dictSize ( c -> pubsub_channels ) > 0 || listLength ( c -> pubsub_patterns ) > 0 ) && cmd -> proc != subscribeCommand && cmd -> proc != unsubscribeCommand && cmd -> proc != psubscribeCommand && cmd -> proc != punsubscribeCommand ) { addReplyError ( c , ""only (P)SUBSCRIBE / (P)UNSUBSCRIBE / QUIT allowed in this context"" ) ; return REDIS_OK ; } if ( server . masterhost && server . replstate != REDIS_REPL_CONNECTED && server . repl_serve_stale_data == 0 && cmd -> proc != infoCommand && cmd -> proc != slaveofCommand ) { addReplyError ( c , ""link with MASTER is down and slave-serve-stale-data is set to no"" ) ; return REDIS_OK ; } if ( server . loading && cmd -> proc != infoCommand ) { addReply ( c , shared . loadingerr ) ; return REDIS_OK ; } if ( c -> flags & REDIS_MULTI && cmd -> proc != execCommand && cmd -> proc != discardCommand && cmd -> proc != multiCommand && cmd -> proc != watchCommand ) { queueMultiCommand ( c , cmd ) ; addReply ( c , shared . queued ) ; } else { if ( server . vm_enabled && server . vm_max_threads > 0 && blockClientOnSwappedKeys ( c , cmd ) ) return REDIS_ERR ; call ( c , cmd ) ; } return REDIS_OK ; }
Fixed code:","
int processCommand ( redisClient * c ) { 
if(c->argv[0] == NULL) {
  addReplyError(c, ""invalid number of arguments for command"");
  return REDIS_OK;
}

struct redisCommand * cmd ; 
if ( ! strcasecmp ( c -> argv [ 0 ] -> ptr , ""quit"" ) ) { 
  addReply ( c , shared . ok ) ; 
  c -> flags |= REDIS_CLOSE_AFTER_REPLY ; 
  return REDIS_ERR ; 
} 

cmd = lookupCommand ( c -> argv [ 0 ] -> ptr ) ; 
if ( ! cmd ) { 
  addReplyErrorFormat ( c , ""unknown command \'%s\'"" , ( char * ) c -> argv [ 0 ] -> ptr ) ; 
  return REDIS_OK ; 
} 
else if ( ( cmd -> arity > 0 && cmd -> arity != c -> argc ) || ( c -> argc < - cmd -> arity ) ) { 
  addReplyErrorFormat ( c , ""wrong number of arguments for \'%s\' command"" , cmd -> name ) ; 
  return REDIS_OK ; 
} 

if ( server . requirepass && ! c -> authenticated && cmd -> proc != authCommand ) { 
  addReplyError ( c , ""operation not permitted"" ) ; 
  return REDIS_OK ; 
} 

if ( server . maxmemory ) freeMemoryIfNeeded ( ) ; 

if ( server . maxmemory && ( cmd -> flags & REDIS_CMD_DENYOOM ) && zmalloc_used_memory ( ) > server . maxmemory ) { 
  addReplyError ( c , ""command not allowed when used memory > \'maxmemory\'"" ) ; 
  return REDIS_OK ; 
} 

if ( ( dictSize ( c -> pubsub_channels ) > 0 || listLength ( c -> pubsub_patterns ) > 0 ) && cmd -> proc != subscribeCommand && cmd -> proc != unsubscribeCommand && cmd -> proc != psubscribeCommand && cmd -> proc != punsubscribeCommand ) { 
  addReplyError ( c , ""only (P)SUBSCRIBE / (P)UNSUBSCRIBE / QUIT allowed in this context"" ) ; 
  return REDIS_OK ; 
} 

if ( server . masterhost && server . replstate != REDIS_REPL_CONNECTED && server . repl_serve_stale_data == 0 && cmd -> proc != infoCommand && cmd -> proc != slaveofCommand ) { 
  addReplyError ( c , ""link with MASTER is down and slave-serve-stale-data is set to no"" ) ; 
  return REDIS_OK ; 
} 

if ( server . loading && cmd -> proc != infoCommand ) { 
  addReply ( c , shared . loadingerr ) ; 
  return REDIS_OK ; 
} 

if ( c -> flags & REDIS_MULTI && cmd -> proc != execCommand && cmd -> proc != discardCommand && cmd -> proc != multiCommand && cmd -> proc != watchCommand ) { 
  queueMultiCommand ( c , cmd ) ; 
  addReply ( c , shared . queued ) ; 
} 
else { 
  if ( server . vm_enabled && server . vm_max_threads > 0 && blockClientOnSwappedKeys ( c , cmd ) ) return REDIS_ERR ; 
  call ( c , cmd ) ; 
} 

return REDIS_OK ; 
}",841,-31.09312210430442,-0.03697160773401239
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int processCommand ( redisClient * c ) { struct redisCommand * cmd ; if ( ! strcasecmp ( c -> argv [ 0 ] -> ptr , ""quit"" ) ) { addReply ( c , shared . ok ) ; c -> flags |= REDIS_CLOSE_AFTER_REPLY ; return REDIS_ERR ; } cmd = lookupCommand ( c -> argv [ 0 ] -> ptr ) ; if ( ! cmd ) { addReplyErrorFormat ( c , ""unknown command \'%s\'"" , ( char * ) c -> argv [ 0 ] -> ptr ) ; return REDIS_OK ; } else if ( ( cmd -> arity > 0 && cmd -> arity != c -> argc ) || ( c -> argc < - cmd -> arity ) ) { addReplyErrorFormat ( c , ""wrong number of arguments for \'%s\' command"" , cmd -> name ) ; return REDIS_OK ; } if ( server . requirepass && ! c -> authenticated && cmd -> proc != authCommand ) { addReplyError ( c , ""operation not permitted"" ) ; return REDIS_OK ; } if ( server . maxmemory ) freeMemoryIfNeeded ( ) ; if ( server . maxmemory && ( cmd -> flags & REDIS_CMD_DENYOOM ) && zmalloc_used_memory ( ) > server . maxmemory ) { addReplyError ( c , ""command not allowed when used memory > \'maxmemory\'"" ) ; return REDIS_OK ; } if ( ( dictSize ( c -> pubsub_channels ) > 0 || listLength ( c -> pubsub_patterns ) > 0 ) && cmd -> proc != subscribeCommand && cmd -> proc != unsubscribeCommand && cmd -> proc != psubscribeCommand && cmd -> proc != punsubscribeCommand ) { addReplyError ( c , ""only (P)SUBSCRIBE / (P)UNSUBSCRIBE / QUIT allowed in this context"" ) ; return REDIS_OK ; } if ( server . masterhost && server . replstate != REDIS_REPL_CONNECTED && server . repl_serve_stale_data == 0 && cmd -> proc != infoCommand && cmd -> proc != slaveofCommand ) { addReplyError ( c , ""link with MASTER is down and slave-serve-stale-data is set to no"" ) ; return REDIS_OK ; } if ( server . loading && cmd -> proc != infoCommand ) { addReply ( c , shared . loadingerr ) ; return REDIS_OK ; } if ( c -> flags & REDIS_MULTI && cmd -> proc != execCommand && cmd -> proc != discardCommand && cmd -> proc != multiCommand && cmd -> proc != watchCommand ) { queueMultiCommand ( c , cmd ) ; addReply ( c , shared . queued ) ; } else { if ( server . vm_enabled && server . vm_max_threads > 0 && blockClientOnSwappedKeys ( c , cmd ) ) return REDIS_ERR ; call ( c , cmd ) ; } return REDIS_OK ; }
Fixed code:","
int processCommand ( redisClient * c ) { struct redisCommand * cmd ; // check if command is valid if ( ! c -> argv [ 0 ] -> ptr ) { return REDIS_ERR ; } if ( ! strcasecmp ( c -> argv [ 0 ] -> ptr , ""quit"" ) ) { addReply ( c , shared . ok ) ; c -> flags |= REDIS_CLOSE_AFTER_REPLY ; return REDIS_ERR ; } cmd = lookupCommand ( c -> argv [ 0 ] -> ptr ) ; if ( ! cmd ) { addReplyErrorFormat ( c , ""unknown command \'%s\'"" , ( char * ) c -> argv [ 0 ] -> ptr ) ; return REDIS_OK ; } else if ( ( cmd -> arity > 0 && cmd -> arity != c -> argc ) || ( c -> argc < - cmd -> arity ) ) { addReplyErrorFormat ( c , ""wrong number of arguments for \'%s\' command"" , cmd -> name ) ; return REDIS_OK ; } if ( server . requirepass && ! c -> authenticated && cmd -> proc != authCommand ) { addReplyError ( c , ""operation not permitted"" ) ; return REDIS_OK ; } if ( server . maxmemory ) freeMemoryIfNeeded ( ) ; if ( server . maxmemory && ( cmd -> flags & REDIS_CMD_DENYOOM ) && zmalloc_used_memory ( ) > server . maxmemory ) { addReplyError ( c , ""command not allowed when used memory > \'maxmemory\'"" ) ; return REDIS_OK ; } if ( ( dictSize ( c -> pubsub_channels ) > 0 || listLength ( c -> pubsub_patterns ) > 0 ) && cmd -> proc != subscribeCommand && cmd -> proc != unsubscribeCommand && cmd -> proc != psubscribeCommand && cmd -> proc != punsubscribeCommand ) { addReplyError ( c , ""only (P)SUBSCRIBE / (P)UNSUBSCRIBE / QUIT allowed in this context"" ) ; return REDIS_OK ; } if ( server . masterhost && server . replstate != REDIS_REPL_CONNECTED && server . repl_serve_stale_data == 0 && cmd -> proc != infoCommand && cmd -> proc != slaveofCommand ) { addReplyError ( c , ""link with MASTER is down and slave-serve-stale-data is set to no"" ) ; return REDIS_OK ; } if ( server . loading && cmd -> proc != infoCommand ) { addReply ( c , shared . loadingerr ) ; return REDIS_OK ; } if ( c -> flags & REDIS_MULTI && cmd -> proc != execCommand && cmd -> proc != discardCommand && cmd -> proc != multiCommand && cmd -> proc != watchCommand ) { queueMultiCommand ( c , cmd ) ; addReply ( c , shared . queued ) ; } else { if ( server . vm_enabled && server . vm_max_threads > 0 && blockClientOnSwappedKeys ( c , cmd ) ) return REDIS_ERR ; call ( c , cmd ) ; } return REDIS_OK ; }",705,-17.381496559206347,-0.024654605048519643
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int processCommand ( redisClient * c ) { struct redisCommand * cmd ; if ( ! strcasecmp ( c -> argv [ 0 ] -> ptr , ""quit"" ) ) { addReply ( c , shared . ok ) ; c -> flags |= REDIS_CLOSE_AFTER_REPLY ; return REDIS_ERR ; } cmd = lookupCommand ( c -> argv [ 0 ] -> ptr ) ; if ( ! cmd ) { addReplyErrorFormat ( c , ""unknown command \'%s\'"" , ( char * ) c -> argv [ 0 ] -> ptr ) ; return REDIS_OK ; } else if ( ( cmd -> arity > 0 && cmd -> arity != c -> argc ) || ( c -> argc < - cmd -> arity ) ) { addReplyErrorFormat ( c , ""wrong number of arguments for \'%s\' command"" , cmd -> name ) ; return REDIS_OK ; } if ( server . requirepass && ! c -> authenticated && cmd -> proc != authCommand ) { addReplyError ( c , ""operation not permitted"" ) ; return REDIS_OK ; } if ( server . maxmemory ) freeMemoryIfNeeded ( ) ; if ( server . maxmemory && ( cmd -> flags & REDIS_CMD_DENYOOM ) && zmalloc_used_memory ( ) > server . maxmemory ) { addReplyError ( c , ""command not allowed when used memory > \'maxmemory\'"" ) ; return REDIS_OK ; } if ( ( dictSize ( c -> pubsub_channels ) > 0 || listLength ( c -> pubsub_patterns ) > 0 ) && cmd -> proc != subscribeCommand && cmd -> proc != unsubscribeCommand && cmd -> proc != psubscribeCommand && cmd -> proc != punsubscribeCommand ) { addReplyError ( c , ""only (P)SUBSCRIBE / (P)UNSUBSCRIBE / QUIT allowed in this context"" ) ; return REDIS_OK ; } if ( server . masterhost && server . replstate != REDIS_REPL_CONNECTED && server . repl_serve_stale_data == 0 && cmd -> proc != infoCommand && cmd -> proc != slaveofCommand ) { addReplyError ( c , ""link with MASTER is down and slave-serve-stale-data is set to no"" ) ; return REDIS_OK ; } if ( server . loading && cmd -> proc != infoCommand ) { addReply ( c , shared . loadingerr ) ; return REDIS_OK ; } if ( c -> flags & REDIS_MULTI && cmd -> proc != execCommand && cmd -> proc != discardCommand && cmd -> proc != multiCommand && cmd -> proc != watchCommand ) { queueMultiCommand ( c , cmd ) ; addReply ( c , shared . queued ) ; } else { if ( server . vm_enabled && server . vm_max_threads > 0 && blockClientOnSwappedKeys ( c , cmd ) ) return REDIS_ERR ; call ( c , cmd ) ; } return REDIS_OK ; }
Fixed code:","
int processCommand ( redisClient * c ) {
    struct redisCommand * cmd ;
    
    for (int i = 0; i < c->argc; i++) {
        if (!strcasecmp(c->argv[i]->ptr, ""quit"")) {
            addReply ( c , shared . ok ) ;
            c -> flags |= REDIS_CLOSE_AFTER_REPLY ;
            return REDIS_ERR ;
        }
    }
    
    cmd = lookupCommand ( c -> argv [ 0 ] -> ptr ) ;
    if ( ! cmd ) {
        addReplyErrorFormat ( c , ""unknown command \'%s\'"" , ( char * ) c -> argv [ 0 ] -> ptr ) ;
        return REDIS_OK ;
    } else if ( ( cmd -> arity > 0 && cmd -> arity != c -> argc ) || ( c -> argc < - cmd -> arity ) ) {
        addReplyErrorFormat ( c , ""wrong number of arguments for \'%s\' command"" , cmd -> name ) ;
        return REDIS_OK ;
    }
    if ( server . requirepass && ! c -> authenticated && cmd -> proc != authCommand ) {
        addReplyError ( c , ""operation not permitted"" ) ;
        return REDIS_OK ;
    }
    if ( server . maxmemory ) freeMemoryIfNeeded ( ) ;
    if ( server . maxmemory && ( cmd -> flags & REDIS_CMD_DENYOOM ) && zmalloc_used_memory ( ) > server . maxmemory ) {
        addReplyError ( c , ""command not allowed when used memory > \'maxmemory\'"" ) ;
        return REDIS_OK ;
    }
    if ( ( dictSize ( c -> pubsub_channels ) > 0 || listLength ( c -> pubsub_patterns ) > 0 ) && cmd -> proc != subscribeCommand && cmd -> proc != unsubscribeCommand && cmd -> proc != psubscribeCommand && cmd -> proc != punsubscribeCommand ) {
        addReplyError ( c , ""only (P)SUBSCRIBE / (P)UNSUBSCRIBE / QUIT allowed in this context"" ) ;
        return REDIS_OK ;
    }
    if ( server . masterhost && server . replstate != REDIS_REPL_CONNECTED && server . repl_serve_stale_data == 0 && cmd -> proc != infoCommand && cmd -> proc != slaveofCommand ) {
        addReplyError ( c , ""link with MASTER is down and slave-serve-stale-data is set to no"" ) ;
        return REDIS_OK ;
    }
    if ( server . loading && cmd -> proc != infoCommand ) {
        addReply ( c , shared . loadingerr ) ;
        return REDIS_OK ;
    }
    if ( c -> flags & REDIS_MULTI && cmd -> proc != execCommand && cmd -> proc != discardCommand && cmd -> proc != multiCommand && cmd -> proc != watchCommand ) {
        queueMultiCommand ( c , cmd ) ;
        addReply ( c , shared . queued ) ;
    } else {
        if ( server . vm_enabled && server . vm_max_threads > 0 && blockClientOnSwappedKeys ( c , cmd ) ) return REDIS_ERR ;
        call ( c , cmd ) ;
    }
    return REDIS_OK ;
}",787,-24.62151892986746,-0.03128528453604506
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int processCommand ( redisClient * c ) { struct redisCommand * cmd ; if ( ! strcasecmp ( c -> argv [ 0 ] -> ptr , ""quit"" ) ) { addReply ( c , shared . ok ) ; c -> flags |= REDIS_CLOSE_AFTER_REPLY ; return REDIS_ERR ; } cmd = lookupCommand ( c -> argv [ 0 ] -> ptr ) ; if ( ! cmd ) { addReplyErrorFormat ( c , ""unknown command \'%s\'"" , ( char * ) c -> argv [ 0 ] -> ptr ) ; return REDIS_OK ; } else if ( ( cmd -> arity > 0 && cmd -> arity != c -> argc ) || ( c -> argc < - cmd -> arity ) ) { addReplyErrorFormat ( c , ""wrong number of arguments for \'%s\' command"" , cmd -> name ) ; return REDIS_OK ; } if ( server . requirepass && ! c -> authenticated && cmd -> proc != authCommand ) { addReplyError ( c , ""operation not permitted"" ) ; return REDIS_OK ; } if ( server . maxmemory ) freeMemoryIfNeeded ( ) ; if ( server . maxmemory && ( cmd -> flags & REDIS_CMD_DENYOOM ) && zmalloc_used_memory ( ) > server . maxmemory ) { addReplyError ( c , ""command not allowed when used memory > \'maxmemory\'"" ) ; return REDIS_OK ; } if ( ( dictSize ( c -> pubsub_channels ) > 0 || listLength ( c -> pubsub_patterns ) > 0 ) && cmd -> proc != subscribeCommand && cmd -> proc != unsubscribeCommand && cmd -> proc != psubscribeCommand && cmd -> proc != punsubscribeCommand ) { addReplyError ( c , ""only (P)SUBSCRIBE / (P)UNSUBSCRIBE / QUIT allowed in this context"" ) ; return REDIS_OK ; } if ( server . masterhost && server . replstate != REDIS_REPL_CONNECTED && server . repl_serve_stale_data == 0 && cmd -> proc != infoCommand && cmd -> proc != slaveofCommand ) { addReplyError ( c , ""link with MASTER is down and slave-serve-stale-data is set to no"" ) ; return REDIS_OK ; } if ( server . loading && cmd -> proc != infoCommand ) { addReply ( c , shared . loadingerr ) ; return REDIS_OK ; } if ( c -> flags & REDIS_MULTI && cmd -> proc != execCommand && cmd -> proc != discardCommand && cmd -> proc != multiCommand && cmd -> proc != watchCommand ) { queueMultiCommand ( c , cmd ) ; addReply ( c , shared . queued ) ; } else { if ( server . vm_enabled && server . vm_max_threads > 0 && blockClientOnSwappedKeys ( c , cmd ) ) return REDIS_ERR ; call ( c , cmd ) ; } return REDIS_OK ; }
Fixed code:","
int processCommand ( redisClient * c ) { 
    struct redisCommand * cmd ; 
    int arity;

    //verify command is in valid range
    if ( ! strcasecmp ( c -> argv [ 0 ] -> ptr , ""quit"" ) ) {
        addReply ( c , shared . ok ) ; 
        c -> flags |= REDIS_CLOSE_AFTER_REPLY ; 
        return REDIS_ERR ; 
    } 
    
    //verify command is in valid range
    cmd = lookupCommand ( c -> argv [ 0 ] -> ptr ) ; 
    if ( ! cmd ) {
        addReplyErrorFormat ( c , ""unknown command \'%s\'"" , ( char * ) c -> argv [ 0 ] -> ptr ) ; 
        return REDIS_OK ; 
    } 
    //verify number of arguments is in valid range
    arity = cmd->arity;
    if ( arity > 0 && arity != c -> argc ){
        addReplyErrorFormat ( c , ""wrong number of arguments for \'%s\' command"" , cmd -> name ) ; 
        return REDIS_OK ; 
    }
    if ( server . requirepass && ! c -> authenticated && cmd -> proc != authCommand ) {
        addReplyError ( c , ""operation not permitted"" ) ; 
        return REDIS_OK ; 
    } 

    if ( server . maxmemory ) freeMemoryIfNeeded ( ) ; 
    if ( server . maxmemory && ( cmd -> flags & REDIS_CMD_DENYOOM ) && zmalloc_used_memory ( ) > server . maxmemory ) {
        addReplyError ( c , ""command not allowed when used memory > \'maxmemory\'"" ) ; 
        return REDIS_OK ; 
    } 
    
    if ( ( dictSize ( c -> pubsub_channels ) > 0 || listLength ( c -> pubsub_patterns ) > 0 ) && cmd -> proc != subscribeCommand && cmd -> proc != unsubscribeCommand && cmd -> proc != psubscribeCommand && cmd -> proc != punsubscribeCommand ) {
        addReplyError ( c , ""only (P)SUBSCRIBE / (P)UNSUBSCRIBE / QUIT allowed in this context"" ) ; 
        return REDIS_OK ; 
    } 
    if ( server . masterhost && server . replstate != REDIS_REPL_CONNECTED && server . repl_serve_stale_data == 0 && cmd -> proc != infoCommand && cmd -> proc != slaveofCommand ) {
        addReplyError ( c , ""link with MASTER is down and slave-serve-stale-data is set to no"" ) ; 
        return REDIS_OK ; 
    } 
    if ( server . loading && cmd -> proc != infoCommand ) {
        addReply ( c , shared . loadingerr ) ; 
        return REDIS_OK ; 
    } 
    if ( c -> flags & REDIS_MULTI && cmd -> proc != execCommand && cmd -> proc != discardCommand && cmd -> proc != multiCommand && cmd -> proc != watchCommand ) {
        queueMultiCommand ( c , cmd ) ; 
        addReply ( c , shared . queued ) ; 
    } else {
        if ( server . vm_enabled && server . vm_max_threads > 0 && blockClientOnSwappedKeys ( c , cmd ) ) return REDIS_ERR ; 
        call ( c , cmd ) ; 
    } 
    return REDIS_OK ; 
}",831,-70.9591797745795,-0.08539010803198495
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int processCommand ( redisClient * c ) { struct redisCommand * cmd ; if ( ! strcasecmp ( c -> argv [ 0 ] -> ptr , ""quit"" ) ) { addReply ( c , shared . ok ) ; c -> flags |= REDIS_CLOSE_AFTER_REPLY ; return REDIS_ERR ; } cmd = lookupCommand ( c -> argv [ 0 ] -> ptr ) ; if ( ! cmd ) { addReplyErrorFormat ( c , ""unknown command \'%s\'"" , ( char * ) c -> argv [ 0 ] -> ptr ) ; return REDIS_OK ; } else if ( ( cmd -> arity > 0 && cmd -> arity != c -> argc ) || ( c -> argc < - cmd -> arity ) ) { addReplyErrorFormat ( c , ""wrong number of arguments for \'%s\' command"" , cmd -> name ) ; return REDIS_OK ; } if ( server . requirepass && ! c -> authenticated && cmd -> proc != authCommand ) { addReplyError ( c , ""operation not permitted"" ) ; return REDIS_OK ; } if ( server . maxmemory ) freeMemoryIfNeeded ( ) ; if ( server . maxmemory && ( cmd -> flags & REDIS_CMD_DENYOOM ) && zmalloc_used_memory ( ) > server . maxmemory ) { addReplyError ( c , ""command not allowed when used memory > \'maxmemory\'"" ) ; return REDIS_OK ; } if ( ( dictSize ( c -> pubsub_channels ) > 0 || listLength ( c -> pubsub_patterns ) > 0 ) && cmd -> proc != subscribeCommand && cmd -> proc != unsubscribeCommand && cmd -> proc != psubscribeCommand && cmd -> proc != punsubscribeCommand ) { addReplyError ( c , ""only (P)SUBSCRIBE / (P)UNSUBSCRIBE / QUIT allowed in this context"" ) ; return REDIS_OK ; } if ( server . masterhost && server . replstate != REDIS_REPL_CONNECTED && server . repl_serve_stale_data == 0 && cmd -> proc != infoCommand && cmd -> proc != slaveofCommand ) { addReplyError ( c , ""link with MASTER is down and slave-serve-stale-data is set to no"" ) ; return REDIS_OK ; } if ( server . loading && cmd -> proc != infoCommand ) { addReply ( c , shared . loadingerr ) ; return REDIS_OK ; } if ( c -> flags & REDIS_MULTI && cmd -> proc != execCommand && cmd -> proc != discardCommand && cmd -> proc != multiCommand && cmd -> proc != watchCommand ) { queueMultiCommand ( c , cmd ) ; addReply ( c , shared . queued ) ; } else { if ( server . vm_enabled && server . vm_max_threads > 0 && blockClientOnSwappedKeys ( c , cmd ) ) return REDIS_ERR ; call ( c , cmd ) ; } return REDIS_OK ; }
Fixed code:","
int processCommand ( redisClient * c ) { 
  // Add command validation 
  if(!c->argv[0]->ptr) { 
    addReplyError(c, ""Invalid command""); 
    return REDIS_OK;
  }
  
  struct redisCommand * cmd ; 
  if ( ! strcasecmp ( c -> argv [ 0 ] -> ptr , ""quit"" ) ) { 
    addReply ( c , shared . ok ) ; 
    c -> flags |= REDIS_CLOSE_AFTER_REPLY ; 
    return REDIS_ERR ; 
  } 
  cmd = lookupCommand ( c -> argv [ 0 ] -> ptr ) ; 
  if ( ! cmd ) { 
    addReplyErrorFormat ( c , ""unknown command \'%s\'"" , ( char * ) c -> argv [ 0 ] -> ptr ) ; 
    return REDIS_OK ; 
  } else if ( ( cmd -> arity > 0 && cmd -> arity != c -> argc ) || ( c -> argc < - cmd -> arity ) ) { 
    addReplyErrorFormat ( c , ""wrong number of arguments for \'%s\' command"" , cmd -> name ) ; 
    return REDIS_OK ; 
  } 
  if ( server . requirepass && ! c -> authenticated && cmd -> proc != authCommand ) { 
    addReplyError ( c , ""operation not permitted"" ) ; 
    return REDIS_OK ; 
  } 
  if ( server . maxmemory ) freeMemoryIfNeeded ( ) ; 
  if ( server . maxmemory && ( cmd -> flags & REDIS_CMD_DENYOOM ) && zmalloc_used_memory ( ) > server . maxmemory ) { 
    addReplyError ( c , ""command not allowed when used memory > \'maxmemory\'"" ) ; 
    return REDIS_OK ; 
  } 
  if ( ( dictSize ( c -> pubsub_channels ) > 0 || listLength ( c -> pubsub_patterns ) > 0 ) && cmd -> proc != subscribeCommand && cmd -> proc != unsubscribeCommand && cmd -> proc != psubscribeCommand && cmd -> proc != punsubscribeCommand ) { 
    addReplyError ( c , ""only (P)SUBSCRIBE / (P)UNSUBSCRIBE / QUIT allowed in this context"" ) ; 
    return REDIS_OK ; 
  } 
  if ( server . masterhost && server . replstate != REDIS_REPL_CONNECTED && server . repl_serve_stale_data == 0 && cmd -> proc != infoCommand && cmd -> proc != slaveofCommand ) { 
    addReplyError ( c , ""link with MASTER is down and slave-serve-stale-data is set to no"" ) ; 
    return REDIS_OK ; 
  } 
  if ( server . loading && cmd -> proc != infoCommand ) { 
    addReply ( c , shared . loadingerr ) ; 
    return REDIS_OK ; 
  } 
  if ( c -> flags & REDIS_MULTI && cmd -> proc != execCommand && cmd -> proc != discardCommand && cmd -> proc != multiCommand && cmd -> proc != watchCommand ) { 
    queueMultiCommand ( c , cmd ) ; 
    addReply ( c , shared . queued ) ; 
  } else { 
    if ( server . vm_enabled && server . vm_max_threads > 0 && blockClientOnSwappedKeys ( c , cmd ) ) return REDIS_ERR ; 
    call ( c , cmd ) ; 
  } 
  return REDIS_OK ; 
}",858,-31.358419535730004,-0.036548274517167835
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int processCommand ( redisClient * c ) { struct redisCommand * cmd ; if ( ! strcasecmp ( c -> argv [ 0 ] -> ptr , ""quit"" ) ) { addReply ( c , shared . ok ) ; c -> flags |= REDIS_CLOSE_AFTER_REPLY ; return REDIS_ERR ; } cmd = lookupCommand ( c -> argv [ 0 ] -> ptr ) ; if ( ! cmd ) { addReplyErrorFormat ( c , ""unknown command \'%s\'"" , ( char * ) c -> argv [ 0 ] -> ptr ) ; return REDIS_OK ; } else if ( ( cmd -> arity > 0 && cmd -> arity != c -> argc ) || ( c -> argc < - cmd -> arity ) ) { addReplyErrorFormat ( c , ""wrong number of arguments for \'%s\' command"" , cmd -> name ) ; return REDIS_OK ; } if ( server . requirepass && ! c -> authenticated && cmd -> proc != authCommand ) { addReplyError ( c , ""operation not permitted"" ) ; return REDIS_OK ; } if ( server . maxmemory ) freeMemoryIfNeeded ( ) ; if ( server . maxmemory && ( cmd -> flags & REDIS_CMD_DENYOOM ) && zmalloc_used_memory ( ) > server . maxmemory ) { addReplyError ( c , ""command not allowed when used memory > \'maxmemory\'"" ) ; return REDIS_OK ; } if ( ( dictSize ( c -> pubsub_channels ) > 0 || listLength ( c -> pubsub_patterns ) > 0 ) && cmd -> proc != subscribeCommand && cmd -> proc != unsubscribeCommand && cmd -> proc != psubscribeCommand && cmd -> proc != punsubscribeCommand ) { addReplyError ( c , ""only (P)SUBSCRIBE / (P)UNSUBSCRIBE / QUIT allowed in this context"" ) ; return REDIS_OK ; } if ( server . masterhost && server . replstate != REDIS_REPL_CONNECTED && server . repl_serve_stale_data == 0 && cmd -> proc != infoCommand && cmd -> proc != slaveofCommand ) { addReplyError ( c , ""link with MASTER is down and slave-serve-stale-data is set to no"" ) ; return REDIS_OK ; } if ( server . loading && cmd -> proc != infoCommand ) { addReply ( c , shared . loadingerr ) ; return REDIS_OK ; } if ( c -> flags & REDIS_MULTI && cmd -> proc != execCommand && cmd -> proc != discardCommand && cmd -> proc != multiCommand && cmd -> proc != watchCommand ) { queueMultiCommand ( c , cmd ) ; addReply ( c , shared . queued ) ; } else { if ( server . vm_enabled && server . vm_max_threads > 0 && blockClientOnSwappedKeys ( c , cmd ) ) return REDIS_ERR ; call ( c , cmd ) ; } return REDIS_OK ; }
Fixed code:","
int processCommand ( redisClient * c ) { struct redisCommand * cmd ; 

// Validate command input 
if (c->argv[0] == NULL || c->argv[0]->ptr == NULL || strlen(c->argv[0]->ptr) == 0) {
    addReplyError(c, ""invalid command"");
    return REDIS_ERR;
}

if ( ! strcasecmp ( c -> argv [ 0 ] -> ptr , ""quit"" ) ) { addReply ( c , shared . ok ) ; c -> flags |= REDIS_CLOSE_AFTER_REPLY ; return REDIS_ERR ; } cmd = lookupCommand ( c -> argv [ 0 ] -> ptr ) ; if ( ! cmd ) { addReplyErrorFormat ( c , ""unknown command \'%s\'"" , ( char * ) c -> argv [ 0 ] -> ptr ) ; return REDIS_OK ; } else if ( ( cmd -> arity > 0 && cmd -> arity != c -> argc ) || ( c -> argc < - cmd -> arity ) ) { addReplyErrorFormat ( c , ""wrong number of arguments for \'%s\' command"" , cmd -> name ) ; return REDIS_OK ; } if ( server . requirepass && ! c -> authenticated && cmd -> proc != authCommand ) { addReplyError ( c , ""operation not permitted"" ) ; return REDIS_OK ; } if ( server . maxmemory ) freeMemoryIfNeeded ( ) ; if ( server . maxmemory && ( cmd -> flags & REDIS_CMD_DENYOOM ) && zmalloc_used_memory ( ) > server . maxmemory ) { addReplyError ( c , ""command not allowed when used memory > \'maxmemory\'"" ) ; return REDIS_OK ; } if ( ( dictSize ( c -> pubsub_channels ) > 0 || listLength ( c -> pubsub_patterns ) > 0 ) && cmd -> proc != subscribeCommand && cmd -> proc != unsubscribeCommand && cmd -> proc != psubscribeCommand && cmd -> proc != punsubscribeCommand ) { addReplyError ( c , ""only (P)SUBSCRIBE / (P)UNSUBSCRIBE / QUIT allowed in this context"" ) ; return REDIS_OK ; } if ( server . masterhost && server . replstate != REDIS_REPL_CONNECTED && server . repl_serve_stale_data == 0 && cmd -> proc != infoCommand && cmd -> proc != slaveofCommand ) { addReplyError ( c , ""link with MASTER is down and slave-serve-stale-data is set to no"" ) ; return REDIS_OK ; } if ( server . loading && cmd -> proc != infoCommand ) { addReply ( c , shared . loadingerr ) ; return REDIS_OK ; } if ( c -> flags & REDIS_MULTI && cmd -> proc != execCommand && cmd -> proc != discardCommand && cmd -> proc != multiCommand && cmd -> proc != watchCommand ) { queueMultiCommand ( c , cmd ) ; addReply ( c , shared . queued ) ; } else { if ( server . vm_enabled && server . vm_max_threads > 0 && blockClientOnSwappedKeys ( c , cmd ) ) return REDIS_ERR ; call ( c , cmd ) ; } return REDIS_OK ; }",754,-22.856055057520756,-0.030313070368064663
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int processCommand ( redisClient * c ) { struct redisCommand * cmd ; if ( ! strcasecmp ( c -> argv [ 0 ] -> ptr , ""quit"" ) ) { addReply ( c , shared . ok ) ; c -> flags |= REDIS_CLOSE_AFTER_REPLY ; return REDIS_ERR ; } cmd = lookupCommand ( c -> argv [ 0 ] -> ptr ) ; if ( ! cmd ) { addReplyErrorFormat ( c , ""unknown command \'%s\'"" , ( char * ) c -> argv [ 0 ] -> ptr ) ; return REDIS_OK ; } else if ( ( cmd -> arity > 0 && cmd -> arity != c -> argc ) || ( c -> argc < - cmd -> arity ) ) { addReplyErrorFormat ( c , ""wrong number of arguments for \'%s\' command"" , cmd -> name ) ; return REDIS_OK ; } if ( server . requirepass && ! c -> authenticated && cmd -> proc != authCommand ) { addReplyError ( c , ""operation not permitted"" ) ; return REDIS_OK ; } if ( server . maxmemory ) freeMemoryIfNeeded ( ) ; if ( server . maxmemory && ( cmd -> flags & REDIS_CMD_DENYOOM ) && zmalloc_used_memory ( ) > server . maxmemory ) { addReplyError ( c , ""command not allowed when used memory > \'maxmemory\'"" ) ; return REDIS_OK ; } if ( ( dictSize ( c -> pubsub_channels ) > 0 || listLength ( c -> pubsub_patterns ) > 0 ) && cmd -> proc != subscribeCommand && cmd -> proc != unsubscribeCommand && cmd -> proc != psubscribeCommand && cmd -> proc != punsubscribeCommand ) { addReplyError ( c , ""only (P)SUBSCRIBE / (P)UNSUBSCRIBE / QUIT allowed in this context"" ) ; return REDIS_OK ; } if ( server . masterhost && server . replstate != REDIS_REPL_CONNECTED && server . repl_serve_stale_data == 0 && cmd -> proc != infoCommand && cmd -> proc != slaveofCommand ) { addReplyError ( c , ""link with MASTER is down and slave-serve-stale-data is set to no"" ) ; return REDIS_OK ; } if ( server . loading && cmd -> proc != infoCommand ) { addReply ( c , shared . loadingerr ) ; return REDIS_OK ; } if ( c -> flags & REDIS_MULTI && cmd -> proc != execCommand && cmd -> proc != discardCommand && cmd -> proc != multiCommand && cmd -> proc != watchCommand ) { queueMultiCommand ( c , cmd ) ; addReply ( c , shared . queued ) ; } else { if ( server . vm_enabled && server . vm_max_threads > 0 && blockClientOnSwappedKeys ( c , cmd ) ) return REDIS_ERR ; call ( c , cmd ) ; } return REDIS_OK ; }
Fixed code:","
int processCommand ( redisClient * c ) { struct redisCommand * cmd ; 
//Validate input to prevent bad commands 
if ( ! c -> argv || ! c -> argv [ 0 ] -> ptr ) { addReplyError ( c , ""bad arguments"" ) ; return REDIS_OK ; }
if ( ! strcasecmp ( c -> argv [ 0 ] -> ptr , ""quit"" ) ) { addReply ( c , shared . ok ) ; c -> flags |= REDIS_CLOSE_AFTER_REPLY ; return REDIS_ERR ; } cmd = lookupCommand ( c -> argv [ 0 ] -> ptr ) ; if ( ! cmd ) { addReplyErrorFormat ( c , ""unknown command \'%s\'"" , ( char * ) c -> argv [ 0 ] -> ptr ) ; return REDIS_OK ; } else if ( ( cmd -> arity > 0 && cmd -> arity != c -> argc ) || ( c -> argc < - cmd -> arity ) ) { addReplyErrorFormat ( c , ""wrong number of arguments for \'%s\' command"" , cmd -> name ) ; return REDIS_OK ; } if ( server . requirepass && ! c -> authenticated && cmd -> proc != authCommand ) { addReplyError ( c , ""operation not permitted"" ) ; return REDIS_OK ; } if ( server . maxmemory ) freeMemoryIfNeeded ( ) ; if ( server . maxmemory && ( cmd -> flags & REDIS_CMD_DENYOOM ) && zmalloc_used_memory ( ) > server . maxmemory ) { addReplyError ( c , ""command not allowed when used memory > \'maxmemory\'"" ) ; return REDIS_OK ; } if ( ( dictSize ( c -> pubsub_channels ) > 0 || listLength ( c -> pubsub_patterns ) > 0 ) && cmd -> proc != subscribeCommand && cmd -> proc != unsubscribeCommand && cmd -> proc != psubscribeCommand && cmd -> proc != punsubscribeCommand ) { addReplyError ( c , ""only (P)SUBSCRIBE / (P)UNSUBSCRIBE / QUIT allowed in this context"" ) ; return REDIS_OK ; } if ( server . masterhost && server . replstate != REDIS_REPL_CONNECTED && server . repl_serve_stale_data == 0 && cmd -> proc != infoCommand && cmd -> proc != slaveofCommand ) { addReplyError ( c , ""link with MASTER is down and slave-serve-stale-data is set to no"" ) ; return REDIS_OK ; } if ( server . loading && cmd -> proc != infoCommand ) { addReply ( c , shared . loadingerr ) ; return REDIS_OK ; } if ( c -> flags & REDIS_MULTI && cmd -> proc != execCommand && cmd -> proc != discardCommand && cmd -> proc != multiCommand && cmd -> proc != watchCommand ) { queueMultiCommand ( c , cmd ) ; addReply ( c , shared . queued ) ; } else { if ( server . vm_enabled && server . vm_max_threads > 0 && blockClientOnSwappedKeys ( c , cmd ) ) return REDIS_ERR ; call ( c , cmd ) ; } return REDIS_OK ; }",729,-36.63830998460451,-0.050258312736083006
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int processCommand ( redisClient * c ) { struct redisCommand * cmd ; if ( ! strcasecmp ( c -> argv [ 0 ] -> ptr , ""quit"" ) ) { addReply ( c , shared . ok ) ; c -> flags |= REDIS_CLOSE_AFTER_REPLY ; return REDIS_ERR ; } cmd = lookupCommand ( c -> argv [ 0 ] -> ptr ) ; if ( ! cmd ) { addReplyErrorFormat ( c , ""unknown command \'%s\'"" , ( char * ) c -> argv [ 0 ] -> ptr ) ; return REDIS_OK ; } else if ( ( cmd -> arity > 0 && cmd -> arity != c -> argc ) || ( c -> argc < - cmd -> arity ) ) { addReplyErrorFormat ( c , ""wrong number of arguments for \'%s\' command"" , cmd -> name ) ; return REDIS_OK ; } if ( server . requirepass && ! c -> authenticated && cmd -> proc != authCommand ) { addReplyError ( c , ""operation not permitted"" ) ; return REDIS_OK ; } if ( server . maxmemory ) freeMemoryIfNeeded ( ) ; if ( server . maxmemory && ( cmd -> flags & REDIS_CMD_DENYOOM ) && zmalloc_used_memory ( ) > server . maxmemory ) { addReplyError ( c , ""command not allowed when used memory > \'maxmemory\'"" ) ; return REDIS_OK ; } if ( ( dictSize ( c -> pubsub_channels ) > 0 || listLength ( c -> pubsub_patterns ) > 0 ) && cmd -> proc != subscribeCommand && cmd -> proc != unsubscribeCommand && cmd -> proc != psubscribeCommand && cmd -> proc != punsubscribeCommand ) { addReplyError ( c , ""only (P)SUBSCRIBE / (P)UNSUBSCRIBE / QUIT allowed in this context"" ) ; return REDIS_OK ; } if ( server . masterhost && server . replstate != REDIS_REPL_CONNECTED && server . repl_serve_stale_data == 0 && cmd -> proc != infoCommand && cmd -> proc != slaveofCommand ) { addReplyError ( c , ""link with MASTER is down and slave-serve-stale-data is set to no"" ) ; return REDIS_OK ; } if ( server . loading && cmd -> proc != infoCommand ) { addReply ( c , shared . loadingerr ) ; return REDIS_OK ; } if ( c -> flags & REDIS_MULTI && cmd -> proc != execCommand && cmd -> proc != discardCommand && cmd -> proc != multiCommand && cmd -> proc != watchCommand ) { queueMultiCommand ( c , cmd ) ; addReply ( c , shared . queued ) ; } else { if ( server . vm_enabled && server . vm_max_threads > 0 && blockClientOnSwappedKeys ( c , cmd ) ) return REDIS_ERR ; call ( c , cmd ) ; } return REDIS_OK ; }
Fixed code:","
int processCommand ( redisClient * c ) { struct redisCommand * cmd ; 

//Validate input to ensure it is a valid command
if ( ! isValidCommand ( c -> argv [ 0 ] -> ptr ) ) { addReplyErrorFormat ( c , ""unknown command \'%s\'"" , ( char * ) c -> argv [ 0 ] -> ptr ) ; return REDIS_OK ; }

if ( ! strcasecmp ( c -> argv [ 0 ] -> ptr , ""quit"" ) ) { addReply ( c , shared . ok ) ; c -> flags |= REDIS_CLOSE_AFTER_REPLY ; return REDIS_ERR ; } cmd = lookupCommand ( c -> argv [ 0 ] -> ptr ) ; 

if ( ( cmd -> arity > 0 && cmd -> arity != c -> argc ) || ( c -> argc < - cmd -> arity ) ) { addReplyErrorFormat ( c , ""wrong number of arguments for \'%s\' command"" , cmd -> name ) ; return REDIS_OK ; } if ( server . requirepass && ! c -> authenticated && cmd -> proc != authCommand ) { addReplyError ( c , ""operation not permitted"" ) ; return REDIS_OK ; } if ( server . maxmemory ) freeMemoryIfNeeded ( ) ; if ( server . maxmemory && ( cmd -> flags & REDIS_CMD_DENYOOM ) && zmalloc_used_memory ( ) > server . maxmemory ) { addReplyError ( c , ""command not allowed when used memory > \'maxmemory\'"" ) ; return REDIS_OK ; } if ( ( dictSize ( c -> pubsub_channels ) > 0 || listLength ( c -> pubsub_patterns ) > 0 ) && cmd -> proc != subscribeCommand && cmd -> proc != unsubscribeCommand && cmd -> proc != psubscribeCommand && cmd -> proc != punsubscribeCommand ) { addReplyError ( c , ""only (P)SUBSCRIBE / (P)UNSUBSCRIBE / QUIT allowed in this context"" ) ; return REDIS_OK ; } if ( server . masterhost && server . replstate != REDIS_REPL_CONNECTED && server . repl_serve_stale_data == 0 && cmd -> proc != infoCommand && cmd -> proc != slaveofCommand ) { addReplyError ( c , ""link with MASTER is down and slave-serve-stale-data is set to no"" ) ; return REDIS_OK ; } if ( server . loading && cmd -> proc != infoCommand ) { addReply ( c , shared . loadingerr ) ; return REDIS_OK ; } if ( c -> flags & REDIS_MULTI && cmd -> proc != execCommand && cmd -> proc != discardCommand && cmd -> proc != multiCommand && cmd -> proc != watchCommand ) { queueMultiCommand ( c , cmd ) ; addReply ( c , shared . queued ) ; } else { if ( server . vm_enabled && server . vm_max_threads > 0 && blockClientOnSwappedKeys ( c , cmd ) ) return REDIS_ERR ; call ( c , cmd ) ; } return REDIS_OK ; }",709,-20.386907237793732,-0.028754453085745743
