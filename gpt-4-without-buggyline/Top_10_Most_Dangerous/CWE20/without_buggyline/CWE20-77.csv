Original code,Plausible Program,Total Tokens,Sum Entropy,Mean Entropy
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int ff_amf_get_field_value ( const uint8_t * data , const uint8_t * data_end , const uint8_t * name , uint8_t * dst , int dst_size ) { int namelen = strlen ( name ) ; int len ; while ( * data != AMF_DATA_TYPE_OBJECT && data < data_end ) { len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 ) len = data_end - data ; data += len ; } if ( data_end - data < 3 ) return - 1 ; data ++ ; for ( ; ; ) { int size = bytestream_get_be16 ( & data ) ; if ( ! size ) break ; if ( size < 0 || size >= data_end - data ) return - 1 ; data += size ; if ( size == namelen && ! memcmp ( data - size , name , namelen ) ) { switch ( * data ++ ) { case AMF_DATA_TYPE_NUMBER : snprintf ( dst , dst_size , ""%g"" , av_int2double ( AV_RB64 ( data ) ) ) ; break ; case AMF_DATA_TYPE_BOOL : snprintf ( dst , dst_size , ""%s"" , * data ? ""true"" : ""false"" ) ; break ; case AMF_DATA_TYPE_STRING : len = bytestream_get_be16 ( & data ) ; av_strlcpy ( dst , data , FFMIN ( len + 1 , dst_size ) ) ; break ; default : return - 1 ; } return 0 ; } len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 || len >= data_end - data ) return - 1 ; data += len ; } return - 1 ; }
Fixed code:","
int ff_amf_get_field_value ( const uint8_t * data , const uint8_t * data_end , const uint8_t * name , uint8_t * dst , int dst_size ) { int namelen = strlen ( name ) ; int len ; while ( * data != AMF_DATA_TYPE_OBJECT && data < data_end ) { len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 ) len = data_end - data ; data += len ; } if ( data_end - data < 3 ) return - 1 ; data ++ ; for ( ; ; ) { int size = bytestream_get_be16 ( & data ) ; if ( ! size ) break ; if ( size < 0 || size > namelen || size >= data_end - data ) return - 1 ; data += size ; if ( size == namelen && ! memcmp ( data - size , name , namelen ) ) { switch ( * data ++ ) { case AMF_DATA_TYPE_NUMBER : snprintf ( dst , dst_size , ""%g"" , av_int2double ( AV_RB64 ( data ) ) ) ; break ; case AMF_DATA_TYPE_BOOL : snprintf ( dst , dst_size , ""%s"" , * data ? ""true"" : ""false"" ) ; break ; case AMF_DATA_TYPE_STRING : len = bytestream_get_be16 ( & data ) ; if (len >= dst_size) return -1; av_strlcpy ( dst , data , FFMIN ( len + 1 , dst_size ) ) ; break ; default : return - 1 ; } return 0 ; } len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 || len >= data_end - data ) return - 1 ; data += len ; } return - 1 ; }",430,-10.22388325800244,-0.02377647269302893
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int ff_amf_get_field_value ( const uint8_t * data , const uint8_t * data_end , const uint8_t * name , uint8_t * dst , int dst_size ) { int namelen = strlen ( name ) ; int len ; while ( * data != AMF_DATA_TYPE_OBJECT && data < data_end ) { len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 ) len = data_end - data ; data += len ; } if ( data_end - data < 3 ) return - 1 ; data ++ ; for ( ; ; ) { int size = bytestream_get_be16 ( & data ) ; if ( ! size ) break ; if ( size < 0 || size >= data_end - data ) return - 1 ; data += size ; if ( size == namelen && ! memcmp ( data - size , name , namelen ) ) { switch ( * data ++ ) { case AMF_DATA_TYPE_NUMBER : snprintf ( dst , dst_size , ""%g"" , av_int2double ( AV_RB64 ( data ) ) ) ; break ; case AMF_DATA_TYPE_BOOL : snprintf ( dst , dst_size , ""%s"" , * data ? ""true"" : ""false"" ) ; break ; case AMF_DATA_TYPE_STRING : len = bytestream_get_be16 ( & data ) ; av_strlcpy ( dst , data , FFMIN ( len + 1 , dst_size ) ) ; break ; default : return - 1 ; } return 0 ; } len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 || len >= data_end - data ) return - 1 ; data += len ; } return - 1 ; }
Fixed code:","
int ff_amf_get_field_value ( const uint8_t * data , const uint8_t * data_end , const uint8_t * name , uint8_t * dst , int dst_size ) { int namelen = strlen ( name ) ; int len ; while ( * data != AMF_DATA_TYPE_OBJECT && data < data_end ) { len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 || len > data_end - data ) return -1; data += len ; } if ( data_end - data < 3 ) return - 1 ; data ++ ; for ( ; ; ) { int size = bytestream_get_be16 ( & data ) ; if ( ! size ) break ; if ( size < 0 || size >= data_end - data ) return - 1 ; data += size ; if ( size == namelen && ! memcmp ( data - size , name , namelen ) ) { switch ( * data ++ ) { case AMF_DATA_TYPE_NUMBER : snprintf ( dst , dst_size , ""%g"" , av_int2double ( AV_RB64 ( data ) ) ) ; break ; case AMF_DATA_TYPE_BOOL : snprintf ( dst , dst_size , ""%s"" , * data ? ""true"" : ""false"" ) ; break ; case AMF_DATA_TYPE_STRING : len = bytestream_get_be16 ( & data ) ; if ( len < 0 || len > dst_size ) return -1; av_strlcpy ( dst , data , FFMIN ( len + 1 , dst_size ) ) ; break ; default : return - 1 ; } return 0 ; } len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 || len > data_end - data ) return - 1 ; data += len ; } return - 1 ; }",432,-10.894244451444443,-0.02521815845241769
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int ff_amf_get_field_value ( const uint8_t * data , const uint8_t * data_end , const uint8_t * name , uint8_t * dst , int dst_size ) { int namelen = strlen ( name ) ; int len ; while ( * data != AMF_DATA_TYPE_OBJECT && data < data_end ) { len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 ) len = data_end - data ; data += len ; } if ( data_end - data < 3 ) return - 1 ; data ++ ; for ( ; ; ) { int size = bytestream_get_be16 ( & data ) ; if ( ! size ) break ; if ( size < 0 || size >= data_end - data ) return - 1 ; data += size ; if ( size == namelen && ! memcmp ( data - size , name , namelen ) ) { switch ( * data ++ ) { case AMF_DATA_TYPE_NUMBER : snprintf ( dst , dst_size , ""%g"" , av_int2double ( AV_RB64 ( data ) ) ) ; break ; case AMF_DATA_TYPE_BOOL : snprintf ( dst , dst_size , ""%s"" , * data ? ""true"" : ""false"" ) ; break ; case AMF_DATA_TYPE_STRING : len = bytestream_get_be16 ( & data ) ; av_strlcpy ( dst , data , FFMIN ( len + 1 , dst_size ) ) ; break ; default : return - 1 ; } return 0 ; } len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 || len >= data_end - data ) return - 1 ; data += len ; } return - 1 ; }
Fixed code:","
int ff_amf_get_field_value ( const uint8_t * data , const uint8_t * data_end , const uint8_t * name , uint8_t * dst , int dst_size ) { 
    int namelen = strlen ( name ) ; 
    int len ; 
    while ( * data != AMF_DATA_TYPE_OBJECT && data < data_end ) { 
        len = ff_amf_tag_size ( data , data_end ) ; 
        if ( len < 0 ) len = data_end - data ; 
        data += len ; 
    } 
    if ( data_end - data < 3 ) return - 1 ; 
    data ++ ; 
    for ( ; ; ) { 
        int size = bytestream_get_be16 ( & data ) ; 
        if ( ! size ) break ; 
        if ( size < 0 || size >= data_end - data ) return - 1 ; 
        data += size ; 
        if ( size == namelen && ! memcmp ( data - size , name , namelen ) ) { 
            switch ( * data ++ ) { 
                case AMF_DATA_TYPE_NUMBER : 
                    if (dst_size >= sizeof(double)) {
                        snprintf ( dst , dst_size , ""%g"" , av_int2double ( AV_RB64 ( data ) ) ) ; 
                    }
                    break ; 
                case AMF_DATA_TYPE_BOOL : 
                    if (dst_size > 0) {
                        snprintf ( dst , dst_size , ""%s"" , * data ? ""true"" : ""false"" ) ; 
                    }
                    break ; 
                case AMF_DATA_TYPE_STRING : 
                    len = bytestream_get_be16 ( & data ) ; 
                    if (dst_size > 0) {
                        av_strlcpy ( dst , data , FFMIN ( len + 1 , dst_size ) ) ; 
                    }
                    break ; 
                default : 
                    return - 1 ; 
            } 
            return 0 ; 
        } 
        len = ff_amf_tag_size ( data , data_end ) ; 
        if ( len < 0 || len >= data_end - data ) return - 1 ; 
        data += len ; 
    } 
    return - 1 ; 
}",569,-20.80466439597314,-0.03656355781366106
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int ff_amf_get_field_value ( const uint8_t * data , const uint8_t * data_end , const uint8_t * name , uint8_t * dst , int dst_size ) { int namelen = strlen ( name ) ; int len ; while ( * data != AMF_DATA_TYPE_OBJECT && data < data_end ) { len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 ) len = data_end - data ; data += len ; } if ( data_end - data < 3 ) return - 1 ; data ++ ; for ( ; ; ) { int size = bytestream_get_be16 ( & data ) ; if ( ! size ) break ; if ( size < 0 || size >= data_end - data ) return - 1 ; data += size ; if ( size == namelen && ! memcmp ( data - size , name , namelen ) ) { switch ( * data ++ ) { case AMF_DATA_TYPE_NUMBER : snprintf ( dst , dst_size , ""%g"" , av_int2double ( AV_RB64 ( data ) ) ) ; break ; case AMF_DATA_TYPE_BOOL : snprintf ( dst , dst_size , ""%s"" , * data ? ""true"" : ""false"" ) ; break ; case AMF_DATA_TYPE_STRING : len = bytestream_get_be16 ( & data ) ; av_strlcpy ( dst , data , FFMIN ( len + 1 , dst_size ) ) ; break ; default : return - 1 ; } return 0 ; } len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 || len >= data_end - data ) return - 1 ; data += len ; } return - 1 ; }
Fixed code:","
int ff_amf_get_field_value ( const uint8_t * data , const uint8_t * data_end , const uint8_t * name , uint8_t * dst , int dst_size ) { int namelen = strlen ( name ) ; int len ; 

// validate input
if (data == NULL || data_end == NULL || name == NULL || dst == NULL || dst_size <= 0) {
	return -1;
}

while ( * data != AMF_DATA_TYPE_OBJECT && data < data_end ) { len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 ) len = data_end - data ; data += len ; } if ( data_end - data < 3 ) return - 1 ; data ++ ; for ( ; ; ) { int size = bytestream_get_be16 ( & data ) ; if ( ! size ) break ; if ( size < 0 || size >= data_end - data ) return - 1 ; data += size ; if ( size == namelen && ! memcmp ( data - size , name , namelen ) ) { switch ( * data ++ ) { case AMF_DATA_TYPE_NUMBER : snprintf ( dst , dst_size , ""%g"" , av_int2double ( AV_RB64 ( data ) ) ) ; break ; case AMF_DATA_TYPE_BOOL : snprintf ( dst , dst_size , ""%s"" , * data ? ""true"" : ""false"" ) ; break ; case AMF_DATA_TYPE_STRING : len = bytestream_get_be16 ( & data ) ; av_strlcpy ( dst , data , FFMIN ( len + 1 , dst_size ) ) ; break ; default : return - 1 ; } return 0 ; } len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 || len >= data_end - data ) return - 1 ; data += len ; } return - 1 ; }",456,-15.960206271267566,-0.03500045234927098
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int ff_amf_get_field_value ( const uint8_t * data , const uint8_t * data_end , const uint8_t * name , uint8_t * dst , int dst_size ) { int namelen = strlen ( name ) ; int len ; while ( * data != AMF_DATA_TYPE_OBJECT && data < data_end ) { len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 ) len = data_end - data ; data += len ; } if ( data_end - data < 3 ) return - 1 ; data ++ ; for ( ; ; ) { int size = bytestream_get_be16 ( & data ) ; if ( ! size ) break ; if ( size < 0 || size >= data_end - data ) return - 1 ; data += size ; if ( size == namelen && ! memcmp ( data - size , name , namelen ) ) { switch ( * data ++ ) { case AMF_DATA_TYPE_NUMBER : snprintf ( dst , dst_size , ""%g"" , av_int2double ( AV_RB64 ( data ) ) ) ; break ; case AMF_DATA_TYPE_BOOL : snprintf ( dst , dst_size , ""%s"" , * data ? ""true"" : ""false"" ) ; break ; case AMF_DATA_TYPE_STRING : len = bytestream_get_be16 ( & data ) ; av_strlcpy ( dst , data , FFMIN ( len + 1 , dst_size ) ) ; break ; default : return - 1 ; } return 0 ; } len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 || len >= data_end - data ) return - 1 ; data += len ; } return - 1 ; }
Fixed code:","
int ff_amf_get_field_value ( const uint8_t * data , const uint8_t * data_end , const uint8_t * name , uint8_t * dst , int dst_size ) { int namelen = strlen ( name ) ; int len ; while ( * data != AMF_DATA_TYPE_OBJECT && data < data_end ) { len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 ) len = data_end - data ; data += len ; } if ( data_end - data < 3 ) return - 1 ; data ++ ; for ( ; ; ) { int size = bytestream_get_be16 ( & data ) ; if ( ! size ) break ; if ( size < 0 || size >= data_end - data ) return - 1 ; // Validate the name is not too long if ( size > namelen ) return -1; data += size ; if ( size == namelen && ! memcmp ( data - size , name , namelen ) ) { switch ( * data ++ ) { case AMF_DATA_TYPE_NUMBER : snprintf ( dst , dst_size , ""%g"" , av_int2double ( AV_RB64 ( data ) ) ) ; break ; case AMF_DATA_TYPE_BOOL : snprintf ( dst , dst_size , ""%s"" , * data ? ""true"" : ""false"" ) ; break ; case AMF_DATA_TYPE_STRING : len = bytestream_get_be16 ( & data ) ; // Validate the string length is not too long if ( len > dst_size ) return -1; av_strlcpy ( dst , data , FFMIN ( len + 1 , dst_size ) ) ; break ; default : return - 1 ; } return 0 ; } len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 || len >= data_end - data ) return - 1 ; data += len ; } return - 1 ; }",455,-24.975004462905122,-0.05489011969869258
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int ff_amf_get_field_value ( const uint8_t * data , const uint8_t * data_end , const uint8_t * name , uint8_t * dst , int dst_size ) { int namelen = strlen ( name ) ; int len ; while ( * data != AMF_DATA_TYPE_OBJECT && data < data_end ) { len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 ) len = data_end - data ; data += len ; } if ( data_end - data < 3 ) return - 1 ; data ++ ; for ( ; ; ) { int size = bytestream_get_be16 ( & data ) ; if ( ! size ) break ; if ( size < 0 || size >= data_end - data ) return - 1 ; data += size ; if ( size == namelen && ! memcmp ( data - size , name , namelen ) ) { switch ( * data ++ ) { case AMF_DATA_TYPE_NUMBER : snprintf ( dst , dst_size , ""%g"" , av_int2double ( AV_RB64 ( data ) ) ) ; break ; case AMF_DATA_TYPE_BOOL : snprintf ( dst , dst_size , ""%s"" , * data ? ""true"" : ""false"" ) ; break ; case AMF_DATA_TYPE_STRING : len = bytestream_get_be16 ( & data ) ; av_strlcpy ( dst , data , FFMIN ( len + 1 , dst_size ) ) ; break ; default : return - 1 ; } return 0 ; } len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 || len >= data_end - data ) return - 1 ; data += len ; } return - 1 ; }
Fixed code:","
int ff_amf_get_field_value ( const uint8_t * data , const uint8_t * data_end , const uint8_t * name , uint8_t * dst , int dst_size ) { int namelen = strlen ( name ) ; int len ; while ( * data != AMF_DATA_TYPE_OBJECT && data < data_end ) { len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 ) len = data_end - data ; data += len ; } if ( data_end - data < 3 ) return - 1 ; data ++ ; for ( ; ; ) { int size = bytestream_get_be16 ( & data ) ; if ( ! size ) break ; if ( size < 0 || size >= data_end - data ) return - 1 ; data += size ; if ( size == namelen && ! memcmp ( data - size , name , namelen ) ) { switch ( * data ++ ) { case AMF_DATA_TYPE_NUMBER : if ( data_end - data < 8 ) return - 1 ; snprintf ( dst , dst_size , ""%g"" , av_int2double ( AV_RB64 ( data ) ) ) ; break ; case AMF_DATA_TYPE_BOOL : if ( data_end - data < 1 ) return - 1 ; snprintf ( dst , dst_size , ""%s"" , * data ? ""true"" : ""false"" ) ; break ; case AMF_DATA_TYPE_STRING : len = bytestream_get_be16 ( & data ) ; if ( len < 0 || len >= data_end - data ) return - 1 ; av_strlcpy ( dst , data , FFMIN ( len + 1 , dst_size ) ) ; break ; default : return - 1 ; } return 0 ; } len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 || len >= data_end - data ) return - 1 ; data += len ; } return - 1 ; }",458,-11.963974140852995,-0.02612221428133842
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int ff_amf_get_field_value ( const uint8_t * data , const uint8_t * data_end , const uint8_t * name , uint8_t * dst , int dst_size ) { int namelen = strlen ( name ) ; int len ; while ( * data != AMF_DATA_TYPE_OBJECT && data < data_end ) { len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 ) len = data_end - data ; data += len ; } if ( data_end - data < 3 ) return - 1 ; data ++ ; for ( ; ; ) { int size = bytestream_get_be16 ( & data ) ; if ( ! size ) break ; if ( size < 0 || size >= data_end - data ) return - 1 ; data += size ; if ( size == namelen && ! memcmp ( data - size , name , namelen ) ) { switch ( * data ++ ) { case AMF_DATA_TYPE_NUMBER : snprintf ( dst , dst_size , ""%g"" , av_int2double ( AV_RB64 ( data ) ) ) ; break ; case AMF_DATA_TYPE_BOOL : snprintf ( dst , dst_size , ""%s"" , * data ? ""true"" : ""false"" ) ; break ; case AMF_DATA_TYPE_STRING : len = bytestream_get_be16 ( & data ) ; av_strlcpy ( dst , data , FFMIN ( len + 1 , dst_size ) ) ; break ; default : return - 1 ; } return 0 ; } len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 || len >= data_end - data ) return - 1 ; data += len ; } return - 1 ; }
Fixed code:"," 
int ff_amf_get_field_value ( const uint8_t * data , const uint8_t * data_end , const uint8_t * name , uint8_t * dst , int dst_size ) { 
//Validate the name input before processing it 
if (!name || !strlen(name)) { 
    return -1; 
} 

int namelen = strlen ( name ) ; 
int len ; 
while ( * data != AMF_DATA_TYPE_OBJECT && data < data_end ) { 
len = ff_amf_tag_size ( data , data_end ) ; 
if ( len < 0 ) len = data_end - data ; 
data += len ; 
} 
if ( data_end - data < 3 ) return - 1 ; 
data ++ ; 
for ( ; ; ) { 
int size = bytestream_get_be16 ( & data ) ; 
if ( ! size ) break ; 
if ( size < 0 || size >= data_end - data ) return - 1 ; 
data += size ; 
if ( size == namelen && ! memcmp ( data - size , name , namelen ) ) { 
switch ( * data ++ ) { 
case AMF_DATA_TYPE_NUMBER : 
snprintf ( dst , dst_size , ""%g"" , av_int2double ( AV_RB64 ( data ) ) ) ; 
break ; 
case AMF_DATA_TYPE_BOOL : 
snprintf ( dst , dst_size , ""%s"" , * data ? ""true"" : ""false"" ) ; 
break ; 
case AMF_DATA_TYPE_STRING : 
len = bytestream_get_be16 ( & data ) ;
//Validate the length of the string before copying it to the destination 
if (len >= 0 && len <= dst_size) { 
    av_strlcpy ( dst , data , FFMIN ( len + 1 , dst_size ) ) ; 
} else { 
    return -1; 
} 
break ; 
default : 
return - 1 ; 
} 
return 0 ; 
} 
len = ff_amf_tag_size ( data , data_end ) ; 
if ( len < 0 || len >= data_end - data ) return - 1 ; 
data += len ; 
} 
return - 1 ; 
}",568,-57.32076256461439,-0.10091683550108167
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int ff_amf_get_field_value ( const uint8_t * data , const uint8_t * data_end , const uint8_t * name , uint8_t * dst , int dst_size ) { int namelen = strlen ( name ) ; int len ; while ( * data != AMF_DATA_TYPE_OBJECT && data < data_end ) { len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 ) len = data_end - data ; data += len ; } if ( data_end - data < 3 ) return - 1 ; data ++ ; for ( ; ; ) { int size = bytestream_get_be16 ( & data ) ; if ( ! size ) break ; if ( size < 0 || size >= data_end - data ) return - 1 ; data += size ; if ( size == namelen && ! memcmp ( data - size , name , namelen ) ) { switch ( * data ++ ) { case AMF_DATA_TYPE_NUMBER : snprintf ( dst , dst_size , ""%g"" , av_int2double ( AV_RB64 ( data ) ) ) ; break ; case AMF_DATA_TYPE_BOOL : snprintf ( dst , dst_size , ""%s"" , * data ? ""true"" : ""false"" ) ; break ; case AMF_DATA_TYPE_STRING : len = bytestream_get_be16 ( & data ) ; av_strlcpy ( dst , data , FFMIN ( len + 1 , dst_size ) ) ; break ; default : return - 1 ; } return 0 ; } len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 || len >= data_end - data ) return - 1 ; data += len ; } return - 1 ; }
Fixed code:","
int ff_amf_get_field_value ( const uint8_t * data , const uint8_t * data_end , const uint8_t * name , uint8_t * dst , int dst_size ) { int namelen = strlen ( name ) ; int len ; // Check for buffer overflow and null characters if ( data_end - data <= 0 || data == NULL || name == NULL ) return - 1 ; while ( * data != AMF_DATA_TYPE_OBJECT && data < data_end ) { len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 ) len = data_end - data ; data += len ; } if ( data_end - data < 3 ) return - 1 ; data ++ ; for ( ; ; ) { int size = bytestream_get_be16 ( & data ) ; if ( ! size ) break ; if ( size < 0 || size >= data_end - data ) return - 1 ; data += size ; if ( size == namelen && ! memcmp ( data - size , name , namelen ) ) { switch ( * data ++ ) { case AMF_DATA_TYPE_NUMBER : snprintf ( dst , dst_size , ""%g"" , av_int2double ( AV_RB64 ( data ) ) ) ; break ; case AMF_DATA_TYPE_BOOL : snprintf ( dst , dst_size , ""%s"" , * data ? ""true"" : ""false"" ) ; break ; case AMF_DATA_TYPE_STRING : len = bytestream_get_be16 ( & data ) ; // Check for buffer overflow before copying data if ( len > dst_size - 1 ) return - 1 ; av_strlcpy ( dst , data , FFMIN ( len + 1 , dst_size ) ) ; break ; default : return - 1 ; } return 0 ; } len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 || len >= data_end - data ) return - 1 ; data += len ; } return - 1 ; }",464,-38.37312234086356,-0.08270069470013698
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int ff_amf_get_field_value ( const uint8_t * data , const uint8_t * data_end , const uint8_t * name , uint8_t * dst , int dst_size ) { int namelen = strlen ( name ) ; int len ; while ( * data != AMF_DATA_TYPE_OBJECT && data < data_end ) { len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 ) len = data_end - data ; data += len ; } if ( data_end - data < 3 ) return - 1 ; data ++ ; for ( ; ; ) { int size = bytestream_get_be16 ( & data ) ; if ( ! size ) break ; if ( size < 0 || size >= data_end - data ) return - 1 ; data += size ; if ( size == namelen && ! memcmp ( data - size , name , namelen ) ) { switch ( * data ++ ) { case AMF_DATA_TYPE_NUMBER : snprintf ( dst , dst_size , ""%g"" , av_int2double ( AV_RB64 ( data ) ) ) ; break ; case AMF_DATA_TYPE_BOOL : snprintf ( dst , dst_size , ""%s"" , * data ? ""true"" : ""false"" ) ; break ; case AMF_DATA_TYPE_STRING : len = bytestream_get_be16 ( & data ) ; av_strlcpy ( dst , data , FFMIN ( len + 1 , dst_size ) ) ; break ; default : return - 1 ; } return 0 ; } len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 || len >= data_end - data ) return - 1 ; data += len ; } return - 1 ; }
Fixed code:","
int ff_amf_get_field_value ( const uint8_t * data , const uint8_t * data_end , const uint8_t * name , uint8_t * dst , int dst_size ) { int namelen = strlen ( name ) ; int len ; while ( * data != AMF_DATA_TYPE_OBJECT && data < data_end ) { len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 ) len = data_end - data ; data += len ; } if ( data_end - data < 3 ) return - 1 ; data ++ ; for ( ; ; ) { int size = bytestream_get_be16 ( & data ) ; if ( ! size ) break ; if ( size < 0 || size > namelen || size >= data_end - data ) return - 1 ; data += size ; if ( size == namelen && ! memcmp ( data - size , name , namelen ) ) { switch ( * data ++ ) { case AMF_DATA_TYPE_NUMBER : snprintf ( dst , dst_size , ""%g"" , av_int2double ( AV_RB64 ( data ) ) ) ; break ; case AMF_DATA_TYPE_BOOL : snprintf ( dst , dst_size , ""%s"" , * data ? ""true"" : ""false"" ) ; break ; case AMF_DATA_TYPE_STRING : len = bytestream_get_be16 ( & data ) ; if ( len <= 0 || len >= dst_size ) { return - 1 ; } av_strlcpy ( dst , data , FFMIN ( len + 1 , dst_size ) ) ; break ; default : return - 1 ; } return 0 ; } len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 || len >= data_end - data ) return - 1 ; data += len ; } return - 1 ; }",436,-13.131772156305408,-0.030118743477764696
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int ff_amf_get_field_value ( const uint8_t * data , const uint8_t * data_end , const uint8_t * name , uint8_t * dst , int dst_size ) { int namelen = strlen ( name ) ; int len ; while ( * data != AMF_DATA_TYPE_OBJECT && data < data_end ) { len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 ) len = data_end - data ; data += len ; } if ( data_end - data < 3 ) return - 1 ; data ++ ; for ( ; ; ) { int size = bytestream_get_be16 ( & data ) ; if ( ! size ) break ; if ( size < 0 || size >= data_end - data ) return - 1 ; data += size ; if ( size == namelen && ! memcmp ( data - size , name , namelen ) ) { switch ( * data ++ ) { case AMF_DATA_TYPE_NUMBER : snprintf ( dst , dst_size , ""%g"" , av_int2double ( AV_RB64 ( data ) ) ) ; break ; case AMF_DATA_TYPE_BOOL : snprintf ( dst , dst_size , ""%s"" , * data ? ""true"" : ""false"" ) ; break ; case AMF_DATA_TYPE_STRING : len = bytestream_get_be16 ( & data ) ; av_strlcpy ( dst , data , FFMIN ( len + 1 , dst_size ) ) ; break ; default : return - 1 ; } return 0 ; } len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 || len >= data_end - data ) return - 1 ; data += len ; } return - 1 ; }
Fixed code:","
int ff_amf_get_field_value ( const uint8_t * data , const uint8_t * data_end , const uint8_t * name , uint8_t * dst , int dst_size ) { int namelen = strlen ( name ) ; int len ; if ( name == NULL || namelen == 0 ) return -1 ; while ( * data != AMF_DATA_TYPE_OBJECT && data < data_end ) { len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 ) len = data_end - data ; data += len ; } if ( data_end - data < 3 ) return - 1 ; data ++ ; for ( ; ; ) { int size = bytestream_get_be16 ( & data ) ; if ( ! size ) break ; if ( size < 0 || size >= data_end - data ) return - 1 ; data += size ; if ( size == namelen && ! memcmp ( data - size , name , namelen ) ) { switch ( * data ++ ) { case AMF_DATA_TYPE_NUMBER : snprintf ( dst , dst_size , ""%g"" , av_int2double ( AV_RB64 ( data ) ) ) ; break ; case AMF_DATA_TYPE_BOOL : snprintf ( dst , dst_size , ""%s"" , * data ? ""true"" : ""false"" ) ; break ; case AMF_DATA_TYPE_STRING : len = bytestream_get_be16 ( & data ) ; av_strlcpy ( dst , data , FFMIN ( len + 1 , dst_size ) ) ; break ; default : return - 1 ; } return 0 ; } len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 || len >= data_end - data ) return - 1 ; data += len ; } return - 1 ; }",428,-18.333716316842597,-0.04283578578701541
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int ff_amf_get_field_value ( const uint8_t * data , const uint8_t * data_end , const uint8_t * name , uint8_t * dst , int dst_size ) { int namelen = strlen ( name ) ; int len ; while ( * data != AMF_DATA_TYPE_OBJECT && data < data_end ) { len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 ) len = data_end - data ; data += len ; } if ( data_end - data < 3 ) return - 1 ; data ++ ; for ( ; ; ) { int size = bytestream_get_be16 ( & data ) ; if ( ! size ) break ; if ( size < 0 || size >= data_end - data ) return - 1 ; data += size ; if ( size == namelen && ! memcmp ( data - size , name , namelen ) ) { switch ( * data ++ ) { case AMF_DATA_TYPE_NUMBER : snprintf ( dst , dst_size , ""%g"" , av_int2double ( AV_RB64 ( data ) ) ) ; break ; case AMF_DATA_TYPE_BOOL : snprintf ( dst , dst_size , ""%s"" , * data ? ""true"" : ""false"" ) ; break ; case AMF_DATA_TYPE_STRING : len = bytestream_get_be16 ( & data ) ; av_strlcpy ( dst , data , FFMIN ( len + 1 , dst_size ) ) ; break ; default : return - 1 ; } return 0 ; } len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 || len >= data_end - data ) return - 1 ; data += len ; } return - 1 ; }
Fixed code:","
int ff_amf_get_field_value ( const uint8_t * data , const uint8_t * data_end , const uint8_t * name , uint8_t * dst , int dst_size ) { int namelen = strlen ( name ) ; int len , size ; while ( * data != AMF_DATA_TYPE_OBJECT && data < data_end ) { len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 ) len = data_end - data ; data += len ; } if ( data_end - data < 3 ) return - 1 ; data ++ ; for ( ; ; ) { size = bytestream_get_be16 ( & data ) ; if ( ! size ) break ; if ( size < 0 || size >= data_end - data ) return - 1 ; if ( size == namelen && ! memcmp ( data - size , name , namelen ) ) { switch ( * data ++ ) { case AMF_DATA_TYPE_NUMBER : snprintf ( dst , dst_size , ""%g"" , av_int2double ( AV_RB64 ( data ) ) ) ; break ; case AMF_DATA_TYPE_BOOL : snprintf ( dst , dst_size , ""%s"" , * data ? ""true"" : ""false"" ) ; break ; case AMF_DATA_TYPE_STRING : len = bytestream_get_be16 ( & data ) ; if ( len <= 0 || len > dst_size ) return - 1 ; //Added input validation av_strlcpy ( dst , data , FFMIN ( len + 1 , dst_size ) ) ; break ; default : return - 1 ; } return 0 ; } data += size ; //Moved increment from above if loop len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 || len >= data_end - data ) return - 1 ; data += len ; } return - 1 ; }",441,-42.53712512175002,-0.09645606603571434
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int ff_amf_get_field_value ( const uint8_t * data , const uint8_t * data_end , const uint8_t * name , uint8_t * dst , int dst_size ) { int namelen = strlen ( name ) ; int len ; while ( * data != AMF_DATA_TYPE_OBJECT && data < data_end ) { len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 ) len = data_end - data ; data += len ; } if ( data_end - data < 3 ) return - 1 ; data ++ ; for ( ; ; ) { int size = bytestream_get_be16 ( & data ) ; if ( ! size ) break ; if ( size < 0 || size >= data_end - data ) return - 1 ; data += size ; if ( size == namelen && ! memcmp ( data - size , name , namelen ) ) { switch ( * data ++ ) { case AMF_DATA_TYPE_NUMBER : snprintf ( dst , dst_size , ""%g"" , av_int2double ( AV_RB64 ( data ) ) ) ; break ; case AMF_DATA_TYPE_BOOL : snprintf ( dst , dst_size , ""%s"" , * data ? ""true"" : ""false"" ) ; break ; case AMF_DATA_TYPE_STRING : len = bytestream_get_be16 ( & data ) ; av_strlcpy ( dst , data , FFMIN ( len + 1 , dst_size ) ) ; break ; default : return - 1 ; } return 0 ; } len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 || len >= data_end - data ) return - 1 ; data += len ; } return - 1 ; }
Fixed code:","
int ff_amf_get_field_value ( const uint8_t * data , const uint8_t * data_end , const uint8_t * name , uint8_t * dst , int dst_size ) { int namelen = strlen ( name ) ; int len ; while ( * data != AMF_DATA_TYPE_OBJECT && data < data_end ) { len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 ) len = data_end - data ; data += len ; } if ( data_end - data < 3 ) return - 1 ; data ++ ; for ( ; ; ) { int size = bytestream_get_be16 ( & data ) ; if ( ! size ) break ; if ( size < 0 || size >= data_end - data || size > namelen || ! memcmp ( data - size , name , size ) ) { return - 1 ; } if ( size == namelen && ! memcmp ( data - size , name , namelen ) ) { switch ( * data ++ ) { case AMF_DATA_TYPE_NUMBER : snprintf ( dst , dst_size , ""%g"" , av_int2double ( AV_RB64 ( data ) ) ) ; break ; case AMF_DATA_TYPE_BOOL : snprintf ( dst , dst_size , ""%s"" , * data ? ""true"" : ""false"" ) ; break ; case AMF_DATA_TYPE_STRING : len = bytestream_get_be16 ( & data ) ; av_strlcpy ( dst , data , FFMIN ( len + 1 , dst_size ) ) ; break ; default : return - 1 ; } return 0 ; } len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 || len >= data_end - data ) return - 1 ; data += len ; } return - 1 ; }",429,-13.000704645148943,-0.03030467283251502
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int ff_amf_get_field_value ( const uint8_t * data , const uint8_t * data_end , const uint8_t * name , uint8_t * dst , int dst_size ) { int namelen = strlen ( name ) ; int len ; while ( * data != AMF_DATA_TYPE_OBJECT && data < data_end ) { len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 ) len = data_end - data ; data += len ; } if ( data_end - data < 3 ) return - 1 ; data ++ ; for ( ; ; ) { int size = bytestream_get_be16 ( & data ) ; if ( ! size ) break ; if ( size < 0 || size >= data_end - data ) return - 1 ; data += size ; if ( size == namelen && ! memcmp ( data - size , name , namelen ) ) { switch ( * data ++ ) { case AMF_DATA_TYPE_NUMBER : snprintf ( dst , dst_size , ""%g"" , av_int2double ( AV_RB64 ( data ) ) ) ; break ; case AMF_DATA_TYPE_BOOL : snprintf ( dst , dst_size , ""%s"" , * data ? ""true"" : ""false"" ) ; break ; case AMF_DATA_TYPE_STRING : len = bytestream_get_be16 ( & data ) ; av_strlcpy ( dst , data , FFMIN ( len + 1 , dst_size ) ) ; break ; default : return - 1 ; } return 0 ; } len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 || len >= data_end - data ) return - 1 ; data += len ; } return - 1 ; }
Fixed code:","
int ff_amf_get_field_value ( const uint8_t * data , const uint8_t * data_end , const uint8_t * name , uint8_t * dst , int dst_size ) { int namelen = strlen ( name ) ; int len ; while ( * data != AMF_DATA_TYPE_OBJECT && data < data_end ) { len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 ) len = data_end - data ; data += len ; } if ( data_end - data < 3 ) return - 1 ; data ++ ; for ( ; ; ) { int size = bytestream_get_be16 ( & data ) ; if ( ! size ) break ; if ( size < 0 || size >= data_end - data ) return - 1 ; data += size ; if ( size == namelen && ! memcmp ( data - size , name , namelen ) ) { switch ( * data ++ ) { case AMF_DATA_TYPE_NUMBER : if (data + 7 > data_end) {return -1; } snprintf ( dst , dst_size , ""%g"" , av_int2double ( AV_RB64 ( data ) ) ) ; break ; case AMF_DATA_TYPE_BOOL : if (data  + 1 > data_end) {return -1; } snprintf ( dst , dst_size , ""%s"" , * data ? ""true"" : ""false"" ) ; break ; case AMF_DATA_TYPE_STRING : len = bytestream_get_be16 ( & data ) ; if (data + len > data_end) {return -1; } av_strlcpy ( dst , data , FFMIN ( len + 1 , dst_size ) ) ; break ; default : return - 1 ; } return 0 ; } len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 || len >= data_end - data ) return - 1 ; data += len ; } return - 1 ; }",461,-30.30479679717799,-0.0657370863279349
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int ff_amf_get_field_value ( const uint8_t * data , const uint8_t * data_end , const uint8_t * name , uint8_t * dst , int dst_size ) { int namelen = strlen ( name ) ; int len ; while ( * data != AMF_DATA_TYPE_OBJECT && data < data_end ) { len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 ) len = data_end - data ; data += len ; } if ( data_end - data < 3 ) return - 1 ; data ++ ; for ( ; ; ) { int size = bytestream_get_be16 ( & data ) ; if ( ! size ) break ; if ( size < 0 || size >= data_end - data ) return - 1 ; data += size ; if ( size == namelen && ! memcmp ( data - size , name , namelen ) ) { switch ( * data ++ ) { case AMF_DATA_TYPE_NUMBER : snprintf ( dst , dst_size , ""%g"" , av_int2double ( AV_RB64 ( data ) ) ) ; break ; case AMF_DATA_TYPE_BOOL : snprintf ( dst , dst_size , ""%s"" , * data ? ""true"" : ""false"" ) ; break ; case AMF_DATA_TYPE_STRING : len = bytestream_get_be16 ( & data ) ; av_strlcpy ( dst , data , FFMIN ( len + 1 , dst_size ) ) ; break ; default : return - 1 ; } return 0 ; } len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 || len >= data_end - data ) return - 1 ; data += len ; } return - 1 ; }
Fixed code:","
int ff_amf_get_field_value ( const uint8_t * data , const uint8_t * data_end , const uint8_t * name , uint8_t * dst , int dst_size ) { int namelen = strlen ( name ) ; int len ; while ( * data != AMF_DATA_TYPE_OBJECT && data < data_end ) { len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 ) len = data_end - data ; data += len ; } if ( data_end - data < 3 ) return - 1 ; data ++ ; for ( ; ; ) { int size = bytestream_get_be16 ( & data ) ; if ( ! size ) break ; if ( size < 0 || size >= data_end - data ) return - 1 ; data += size ; if ( size == namelen && ! memcmp ( data - size , name , namelen ) ) { switch ( * data ++ ) { case AMF_DATA_TYPE_NUMBER : if (dst_size > 0 && dst != NULL) { snprintf ( dst , dst_size , ""%g"" , av_int2double ( AV_RB64 ( data ) ) ) ; } else { return - 1 ; } break ; case AMF_DATA_TYPE_BOOL : if (dst_size > 0 && dst != NULL){  snprintf ( dst , dst_size , ""%s"" , * data ? ""true"" : ""false"" ) ; } else { return - 1 ; } break ; case AMF_DATA_TYPE_STRING : len = bytestream_get_be16 ( & data ) ; if (dst_size > 0 && dst != NULL) { av_strlcpy ( dst , data , FFMIN ( len + 1 , dst_size ) ) ; } else { return - 1 ; } break ; default : return - 1 ; } return 0 ; } len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 || len >= data_end - data ) return - 1 ; data += len ; } return - 1 ; }",478,-26.32195022456692,-0.05506684147398937
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int ff_amf_get_field_value ( const uint8_t * data , const uint8_t * data_end , const uint8_t * name , uint8_t * dst , int dst_size ) { int namelen = strlen ( name ) ; int len ; while ( * data != AMF_DATA_TYPE_OBJECT && data < data_end ) { len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 ) len = data_end - data ; data += len ; } if ( data_end - data < 3 ) return - 1 ; data ++ ; for ( ; ; ) { int size = bytestream_get_be16 ( & data ) ; if ( ! size ) break ; if ( size < 0 || size >= data_end - data ) return - 1 ; data += size ; if ( size == namelen && ! memcmp ( data - size , name , namelen ) ) { switch ( * data ++ ) { case AMF_DATA_TYPE_NUMBER : snprintf ( dst , dst_size , ""%g"" , av_int2double ( AV_RB64 ( data ) ) ) ; break ; case AMF_DATA_TYPE_BOOL : snprintf ( dst , dst_size , ""%s"" , * data ? ""true"" : ""false"" ) ; break ; case AMF_DATA_TYPE_STRING : len = bytestream_get_be16 ( & data ) ; av_strlcpy ( dst , data , FFMIN ( len + 1 , dst_size ) ) ; break ; default : return - 1 ; } return 0 ; } len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 || len >= data_end - data ) return - 1 ; data += len ; } return - 1 ; }
Fixed code:","
int ff_amf_get_field_value ( const uint8_t * data , const uint8_t * data_end , const uint8_t * name , uint8_t * dst , int dst_size ) { int namelen = strlen ( name ) ; int len ; while ( * data != AMF_DATA_TYPE_OBJECT && data < data_end ) { len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 || len >= data_end - data ) return - 1; data += len ; } 
if ( data_end - data < 3 ) return - 1 ; data ++ ; for ( ; ; ) { int size = bytestream_get_be16 ( & data ) ; if ( ! size ) break ; if ( size < 0 || size >= data_end - data ) return - 1 ; data += size ; if ( size == namelen && ! memcmp ( data - size , name , namelen ) ) { switch ( * data ++ ) { case AMF_DATA_TYPE_NUMBER : snprintf ( dst , dst_size , ""%g"" , av_int2double ( AV_RB64 ( data ) ) ) ; break ; case AMF_DATA_TYPE_BOOL : snprintf ( dst , dst_size , ""%s"" , * data ? ""true"" : ""false"" ) ; break ; case AMF_DATA_TYPE_STRING : len = bytestream_get_be16 ( & data ) ; if ( len < 0 || len >= data_end - data ) return - 1; av_strlcpy ( dst , data , FFMIN ( len + 1 , dst_size ) ) ; break ; default : return - 1 ; } return 0 ; } len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 || len >= data_end - data ) return - 1 ; data += len ; } return - 1 ; }",436,-13.42244719640429,-0.030785429349551124
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int ff_amf_get_field_value ( const uint8_t * data , const uint8_t * data_end , const uint8_t * name , uint8_t * dst , int dst_size ) { int namelen = strlen ( name ) ; int len ; while ( * data != AMF_DATA_TYPE_OBJECT && data < data_end ) { len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 ) len = data_end - data ; data += len ; } if ( data_end - data < 3 ) return - 1 ; data ++ ; for ( ; ; ) { int size = bytestream_get_be16 ( & data ) ; if ( ! size ) break ; if ( size < 0 || size >= data_end - data ) return - 1 ; data += size ; if ( size == namelen && ! memcmp ( data - size , name , namelen ) ) { switch ( * data ++ ) { case AMF_DATA_TYPE_NUMBER : snprintf ( dst , dst_size , ""%g"" , av_int2double ( AV_RB64 ( data ) ) ) ; break ; case AMF_DATA_TYPE_BOOL : snprintf ( dst , dst_size , ""%s"" , * data ? ""true"" : ""false"" ) ; break ; case AMF_DATA_TYPE_STRING : len = bytestream_get_be16 ( & data ) ; av_strlcpy ( dst , data , FFMIN ( len + 1 , dst_size ) ) ; break ; default : return - 1 ; } return 0 ; } len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 || len >= data_end - data ) return - 1 ; data += len ; } return - 1 ; }
Fixed code:","
int ff_amf_get_field_value ( const uint8_t * data , const uint8_t * data_end , const uint8_t * name , uint8_t * dst , int dst_size ) { int namelen = strlen ( name ) ; int len ; while ( * data != AMF_DATA_TYPE_OBJECT && data < data_end ) { len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 ) len = data_end - data ; data += len ; } if ( data_end - data < 3 ) return - 1 ; data ++ ; for ( ; ; ) { int size = bytestream_get_be16 ( & data ) ; if ( ! size ) break ; if ( size < 0 || size >= data_end - data ) return - 1 ; data += size ; if ( size == namelen && ! memcmp ( data - size , name , namelen ) ) { switch ( * data ++ ) { case AMF_DATA_TYPE_NUMBER : if ( dst_size < 64 ) { return - 1 ; } snprintf ( dst , dst_size , ""%g"" , av_int2double ( AV_RB64 ( data ) ) ) ; break ; case AMF_DATA_TYPE_BOOL : snprintf ( dst , dst_size , ""%s"" , * data ? ""true"" : ""false"" ) ; break ; case AMF_DATA_TYPE_STRING : len = bytestream_get_be16 ( & data ) ; if ( len > dst_size ) { return - 1 ; } av_strlcpy ( dst , data , FFMIN ( len + 1 , dst_size ) ) ; break ; default : return - 1 ; } return 0 ; } len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 || len >= data_end - data ) return - 1 ; data += len ; } return - 1 ; }",440,-14.236343790036397,-0.032355326795537265
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int ff_amf_get_field_value ( const uint8_t * data , const uint8_t * data_end , const uint8_t * name , uint8_t * dst , int dst_size ) { int namelen = strlen ( name ) ; int len ; while ( * data != AMF_DATA_TYPE_OBJECT && data < data_end ) { len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 ) len = data_end - data ; data += len ; } if ( data_end - data < 3 ) return - 1 ; data ++ ; for ( ; ; ) { int size = bytestream_get_be16 ( & data ) ; if ( ! size ) break ; if ( size < 0 || size >= data_end - data ) return - 1 ; data += size ; if ( size == namelen && ! memcmp ( data - size , name , namelen ) ) { switch ( * data ++ ) { case AMF_DATA_TYPE_NUMBER : snprintf ( dst , dst_size , ""%g"" , av_int2double ( AV_RB64 ( data ) ) ) ; break ; case AMF_DATA_TYPE_BOOL : snprintf ( dst , dst_size , ""%s"" , * data ? ""true"" : ""false"" ) ; break ; case AMF_DATA_TYPE_STRING : len = bytestream_get_be16 ( & data ) ; av_strlcpy ( dst , data , FFMIN ( len + 1 , dst_size ) ) ; break ; default : return - 1 ; } return 0 ; } len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 || len >= data_end - data ) return - 1 ; data += len ; } return - 1 ; }
Fixed code:","
int ff_amf_get_field_value ( const uint8_t * data , const uint8_t * data_end , const uint8_t * name , uint8_t * dst , int dst_size ) { int namelen = strlen ( name ) ; int len ; while ( * data != AMF_DATA_TYPE_OBJECT && data < data_end ) { len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 ) len = data_end - data ; data += len ; } if ( data_end - data < 3 ) return - 1 ; data ++ ; for ( ; ; ) { int size = bytestream_get_be16 ( & data ) ; if ( ! size ) break ; if ( size < 0 || size > namelen || size >= data_end - data ) return - 1 ; if ( ! memcmp ( data - size , name , size ) ) { switch ( * data ++ ) { case AMF_DATA_TYPE_NUMBER : snprintf ( dst , dst_size , ""%g"" , av_int2double ( AV_RB64 ( data ) ) ) ; break ; case AMF_DATA_TYPE_BOOL : snprintf ( dst , dst_size , ""%s"" , * data ? ""true"" : ""false"" ) ; break ; case AMF_DATA_TYPE_STRING : len = bytestream_get_be16 ( & data ) ; av_strlcpy ( dst , data , FFMIN ( len + 1 , dst_size ) ) ; break ; default : return - 1 ; } return 0 ; } len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 || len >= data_end - data ) return - 1 ; data += len ; } return - 1 ; }

The vulnerability was fixed by adding the check that the size of the data should not be greater than the length of the name. This ensures that the data is valid before being processed.",444,-34.53676761907081,-0.07778551265556488
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int ff_amf_get_field_value ( const uint8_t * data , const uint8_t * data_end , const uint8_t * name , uint8_t * dst , int dst_size ) { int namelen = strlen ( name ) ; int len ; while ( * data != AMF_DATA_TYPE_OBJECT && data < data_end ) { len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 ) len = data_end - data ; data += len ; } if ( data_end - data < 3 ) return - 1 ; data ++ ; for ( ; ; ) { int size = bytestream_get_be16 ( & data ) ; if ( ! size ) break ; if ( size < 0 || size >= data_end - data ) return - 1 ; data += size ; if ( size == namelen && ! memcmp ( data - size , name , namelen ) ) { switch ( * data ++ ) { case AMF_DATA_TYPE_NUMBER : snprintf ( dst , dst_size , ""%g"" , av_int2double ( AV_RB64 ( data ) ) ) ; break ; case AMF_DATA_TYPE_BOOL : snprintf ( dst , dst_size , ""%s"" , * data ? ""true"" : ""false"" ) ; break ; case AMF_DATA_TYPE_STRING : len = bytestream_get_be16 ( & data ) ; av_strlcpy ( dst , data , FFMIN ( len + 1 , dst_size ) ) ; break ; default : return - 1 ; } return 0 ; } len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 || len >= data_end - data ) return - 1 ; data += len ; } return - 1 ; }
Fixed code:","
int ff_amf_get_field_value ( const uint8_t * data , const uint8_t * data_end , const uint8_t * name , uint8_t * dst , int dst_size ) { int namelen = strlen ( name ) ; int len ; while ( * data != AMF_DATA_TYPE_OBJECT && data < data_end ) { len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 ) len = data_end - data ; data += len ; } if ( data_end - data < 3 ) return - 1 ; data ++ ; for ( ; ; ) { int size = bytestream_get_be16 ( & data ) ; if ( ! size ) break ; if ( size < 0 || size >= data_end - data ) return - 1 ; data += size ; if ( size == namelen && ! memcmp ( data - size , name , namelen ) ) { switch ( * data ++ ) { case AMF_DATA_TYPE_NUMBER : if (is_valid_number(data)) { snprintf ( dst , dst_size , ""%g"" , av_int2double ( AV_RB64 ( data ) ) ) ; } break ; case AMF_DATA_TYPE_BOOL : if (is_valid_boolean(data)) { snprintf ( dst , dst_size , ""%s"" , * data ? ""true"" : ""false"" ) ; } break ; case AMF_DATA_TYPE_STRING : len = bytestream_get_be16 ( & data ) ; if (is_valid_string(data, len)) { av_strlcpy ( dst , data , FFMIN ( len + 1 , dst_size ) ) ; } break ; default : return - 1 ; } return 0 ; } len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 || len >= data_end - data ) return - 1 ; data += len ; } return - 1 ; }

//Validation functions
bool is_valid_number(uint8_t *data) {
    if (data == NULL)
        return false;
    //Check if the data is a valid numeric value
    return true;
}

bool is_valid_boolean(uint8_t *data) {
    if (data == NULL) 
        return false;
    //Check if the data is a valid boolean value
    return true;
}

bool is_valid_string(uint8_t *data, int len) {
    if (data == NULL || len < 0) 
        return false;
    //Check if the data is a valid string
    return true;
}",612,-50.01055701876376,-0.0817165964358885
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int ff_amf_get_field_value ( const uint8_t * data , const uint8_t * data_end , const uint8_t * name , uint8_t * dst , int dst_size ) { int namelen = strlen ( name ) ; int len ; while ( * data != AMF_DATA_TYPE_OBJECT && data < data_end ) { len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 ) len = data_end - data ; data += len ; } if ( data_end - data < 3 ) return - 1 ; data ++ ; for ( ; ; ) { int size = bytestream_get_be16 ( & data ) ; if ( ! size ) break ; if ( size < 0 || size >= data_end - data ) return - 1 ; data += size ; if ( size == namelen && ! memcmp ( data - size , name , namelen ) ) { switch ( * data ++ ) { case AMF_DATA_TYPE_NUMBER : snprintf ( dst , dst_size , ""%g"" , av_int2double ( AV_RB64 ( data ) ) ) ; break ; case AMF_DATA_TYPE_BOOL : snprintf ( dst , dst_size , ""%s"" , * data ? ""true"" : ""false"" ) ; break ; case AMF_DATA_TYPE_STRING : len = bytestream_get_be16 ( & data ) ; av_strlcpy ( dst , data , FFMIN ( len + 1 , dst_size ) ) ; break ; default : return - 1 ; } return 0 ; } len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 || len >= data_end - data ) return - 1 ; data += len ; } return - 1 ; }
Fixed code:","
int ff_amf_get_field_value ( const uint8_t * data , const uint8_t * data_end , const uint8_t * name , uint8_t * dst , int dst_size ) { int namelen = strlen ( name ) ; int len ;

//Added input validation code to check if the data pointer is within valid bounds
if (data > data_end) {
  return -1;
}

while ( * data != AMF_DATA_TYPE_OBJECT && data < data_end ) { len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 ) len = data_end - data ; data += len ; } if ( data_end - data < 3 ) return - 1 ; data ++ ; for ( ; ; ) { int size = bytestream_get_be16 ( & data ) ; 

//Added input validation code to make sure the size is valid
if (size < 0 || size >= data_end - data) {
  return -1;
}

if ( ! size ) break ; data += size ; if ( size == namelen && ! memcmp ( data - size , name , namelen ) ) { switch ( * data ++ ) { case AMF_DATA_TYPE_NUMBER : snprintf ( dst , dst_size , ""%g"" , av_int2double ( AV_RB64 ( data ) ) ) ; break ; case AMF_DATA_TYPE_BOOL : snprintf ( dst , dst_size , ""%s"" , * data ? ""true"" : ""false"" ) ; break ; case AMF_DATA_TYPE_STRING : len = bytestream_get_be16 ( & data ) ;

//Added input validation code to make sure the length is valid
if (len < 0 || len >= dst_size) {
  return -1;
}

av_strlcpy ( dst , data , FFMIN ( len + 1 , dst_size ) ) ; break ; default : return - 1 ; } return 0 ; } len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 || len >= data_end - data ) return - 1 ; data += len ; } return - 1 ; }",510,-52.13402747269266,-0.10222358327978953
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int ff_amf_get_field_value ( const uint8_t * data , const uint8_t * data_end , const uint8_t * name , uint8_t * dst , int dst_size ) { int namelen = strlen ( name ) ; int len ; while ( * data != AMF_DATA_TYPE_OBJECT && data < data_end ) { len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 ) len = data_end - data ; data += len ; } if ( data_end - data < 3 ) return - 1 ; data ++ ; for ( ; ; ) { int size = bytestream_get_be16 ( & data ) ; if ( ! size ) break ; if ( size < 0 || size >= data_end - data ) return - 1 ; data += size ; if ( size == namelen && ! memcmp ( data - size , name , namelen ) ) { switch ( * data ++ ) { case AMF_DATA_TYPE_NUMBER : snprintf ( dst , dst_size , ""%g"" , av_int2double ( AV_RB64 ( data ) ) ) ; break ; case AMF_DATA_TYPE_BOOL : snprintf ( dst , dst_size , ""%s"" , * data ? ""true"" : ""false"" ) ; break ; case AMF_DATA_TYPE_STRING : len = bytestream_get_be16 ( & data ) ; av_strlcpy ( dst , data , FFMIN ( len + 1 , dst_size ) ) ; break ; default : return - 1 ; } return 0 ; } len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 || len >= data_end - data ) return - 1 ; data += len ; } return - 1 ; }
Fixed code:","
int ff_amf_get_field_value ( const uint8_t * data , const uint8_t * data_end , const uint8_t * name , uint8_t * dst , int dst_size ) { int namelen = strlen ( name ) ; int len ; while ( * data != AMF_DATA_TYPE_OBJECT && data < data_end ) { len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 ) len = data_end - data ; data += len ; } if ( data_end - data < 3 ) return - 1 ; data ++ ; for ( ; ; ) { int size = bytestream_get_be16 ( & data ) ; if ( ! size ) break ; if ( size < 0 || size >= data_end - data || size != namelen || memcmp ( data - size , name , namelen ) ) { len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 || len >= data_end - data ) return - 1 ; data += len ; continue; } switch ( * data ++ ) { case AMF_DATA_TYPE_NUMBER : snprintf ( dst , dst_size , ""%g"" , av_int2double ( AV_RB64 ( data ) ) ) ; break ; case AMF_DATA_TYPE_BOOL : snprintf ( dst , dst_size , ""%s"" , * data ? ""true"" : ""false"" ) ; break ; case AMF_DATA_TYPE_STRING : len = bytestream_get_be16 ( & data ) ; av_strlcpy ( dst , data , FFMIN ( len + 1 , dst_size ) ) ; break ; default : return - 1 ; } return 0 ; } return - 1 ; }",403,-6.6619261191447,-0.01653083404254268
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int ff_amf_get_field_value ( const uint8_t * data , const uint8_t * data_end , const uint8_t * name , uint8_t * dst , int dst_size ) { int namelen = strlen ( name ) ; int len ; while ( * data != AMF_DATA_TYPE_OBJECT && data < data_end ) { len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 ) len = data_end - data ; data += len ; } if ( data_end - data < 3 ) return - 1 ; data ++ ; for ( ; ; ) { int size = bytestream_get_be16 ( & data ) ; if ( ! size ) break ; if ( size < 0 || size >= data_end - data ) return - 1 ; data += size ; if ( size == namelen && ! memcmp ( data - size , name , namelen ) ) { switch ( * data ++ ) { case AMF_DATA_TYPE_NUMBER : snprintf ( dst , dst_size , ""%g"" , av_int2double ( AV_RB64 ( data ) ) ) ; break ; case AMF_DATA_TYPE_BOOL : snprintf ( dst , dst_size , ""%s"" , * data ? ""true"" : ""false"" ) ; break ; case AMF_DATA_TYPE_STRING : len = bytestream_get_be16 ( & data ) ; av_strlcpy ( dst , data , FFMIN ( len + 1 , dst_size ) ) ; break ; default : return - 1 ; } return 0 ; } len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 || len >= data_end - data ) return - 1 ; data += len ; } return - 1 ; }
Fixed code:","
int ff_amf_get_field_value ( const uint8_t * data , const uint8_t * data_end , const uint8_t * name , uint8_t * dst , int dst_size ) { int namelen = strlen ( name ) ; int len ; while ( * data != AMF_DATA_TYPE_OBJECT && data < data_end ) { len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 ) len = data_end - data ; data += len ; } if ( data_end - data < 3 ) return - 1 ; data ++ ; for ( ; ; ) { int size = bytestream_get_be16 ( & data ) ; if ( ! size ) break ; if ( size < 0 || size >= data_end - data ) return - 1 ; data += size ; if ( size == namelen && ! memcmp ( data - size , name , namelen ) ) { switch ( * data ++ ) { case AMF_DATA_TYPE_NUMBER : if(!is_valid_double(av_int2double(AV_RB64(data)))) return -1; snprintf ( dst , dst_size , ""%g"" , av_int2double ( AV_RB64 ( data ) ) ) ; break ; case AMF_DATA_TYPE_BOOL : snprintf ( dst , dst_size , ""%s"" , * data ? ""true"" : ""false"" ) ; break ; case AMF_DATA_TYPE_STRING : len = bytestream_get_be16 ( & data ) ; if(len >= dst_size) return -1; av_strlcpy ( dst , data , FFMIN ( len + 1 , dst_size ) ) ; break ; default : return - 1 ; } return 0 ; } len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 || len >= data_end - data ) return - 1 ; data += len ; } return - 1 ; }

bool is_valid_double(double d) {
  return !std::isnan(d) && !std::isinf(d);
}",485,-23.616318414867305,-0.048693440030654234
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int ff_amf_get_field_value ( const uint8_t * data , const uint8_t * data_end , const uint8_t * name , uint8_t * dst , int dst_size ) { int namelen = strlen ( name ) ; int len ; while ( * data != AMF_DATA_TYPE_OBJECT && data < data_end ) { len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 ) len = data_end - data ; data += len ; } if ( data_end - data < 3 ) return - 1 ; data ++ ; for ( ; ; ) { int size = bytestream_get_be16 ( & data ) ; if ( ! size ) break ; if ( size < 0 || size >= data_end - data ) return - 1 ; data += size ; if ( size == namelen && ! memcmp ( data - size , name , namelen ) ) { switch ( * data ++ ) { case AMF_DATA_TYPE_NUMBER : snprintf ( dst , dst_size , ""%g"" , av_int2double ( AV_RB64 ( data ) ) ) ; break ; case AMF_DATA_TYPE_BOOL : snprintf ( dst , dst_size , ""%s"" , * data ? ""true"" : ""false"" ) ; break ; case AMF_DATA_TYPE_STRING : len = bytestream_get_be16 ( & data ) ; av_strlcpy ( dst , data , FFMIN ( len + 1 , dst_size ) ) ; break ; default : return - 1 ; } return 0 ; } len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 || len >= data_end - data ) return - 1 ; data += len ; } return - 1 ; }
Fixed code:","
int ff_amf_get_field_value ( const uint8_t * data , const uint8_t * data_end , const uint8_t * name , uint8_t * dst , int dst_size ) { int namelen = strlen ( name ) ; int len ; while ( * data != AMF_DATA_TYPE_OBJECT && data < data_end ) { len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 ) len = data_end - data ; data += len ; } if ( data_end - data < 3 ) return - 1 ; data ++ ; for ( ; ; ) { int size = bytestream_get_be16 ( & data ) ; if ( ! size ) break ; if ( size < 0 || size >= data_end - data ) return - 1 ; // Input validation if ( size < 0 || size > namelen ) return - 1 ; // Added input validation to limit size data += size ; if ( size == namelen && ! memcmp ( data - size , name , namelen ) ) { switch ( * data ++ ) { case AMF_DATA_TYPE_NUMBER : snprintf ( dst , dst_size , ""%g"" , av_int2double ( AV_RB64 ( data ) ) ) ; break ; case AMF_DATA_TYPE_BOOL : snprintf ( dst , dst_size , ""%s"" , * data ? ""true"" : ""false"" ) ; break ; case AMF_DATA_TYPE_STRING : len = bytestream_get_be16 ( & data ) ; av_strlcpy ( dst , data , FFMIN ( len + 1 , dst_size ) ) ; break ; default : return - 1 ; } return 0 ; } len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 || len >= data_end - data ) return - 1 ; data += len ; } return - 1 ; }",438,-31.807334241605734,-0.0726194845698761
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int ff_amf_get_field_value ( const uint8_t * data , const uint8_t * data_end , const uint8_t * name , uint8_t * dst , int dst_size ) { int namelen = strlen ( name ) ; int len ; while ( * data != AMF_DATA_TYPE_OBJECT && data < data_end ) { len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 ) len = data_end - data ; data += len ; } if ( data_end - data < 3 ) return - 1 ; data ++ ; for ( ; ; ) { int size = bytestream_get_be16 ( & data ) ; if ( ! size ) break ; if ( size < 0 || size >= data_end - data ) return - 1 ; data += size ; if ( size == namelen && ! memcmp ( data - size , name , namelen ) ) { switch ( * data ++ ) { case AMF_DATA_TYPE_NUMBER : snprintf ( dst , dst_size , ""%g"" , av_int2double ( AV_RB64 ( data ) ) ) ; break ; case AMF_DATA_TYPE_BOOL : snprintf ( dst , dst_size , ""%s"" , * data ? ""true"" : ""false"" ) ; break ; case AMF_DATA_TYPE_STRING : len = bytestream_get_be16 ( & data ) ; av_strlcpy ( dst , data , FFMIN ( len + 1 , dst_size ) ) ; break ; default : return - 1 ; } return 0 ; } len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 || len >= data_end - data ) return - 1 ; data += len ; } return - 1 ; }
Fixed code:","
int ff_amf_get_field_value ( const uint8_t * data , const uint8_t * data_end , const uint8_t * name , uint8_t * dst , int dst_size ) { int namelen = strlen ( name ) ; int len ; while ( * data != AMF_DATA_TYPE_OBJECT && data < data_end ) { len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 ) len = data_end - data ; data += len ; } if ( data_end - data < 3 ) return - 1 ; data ++ ; for ( ; ; ) { int size = bytestream_get_be16 ( & data ) ; if ( ! size ) break ; if ( size < 0 || size >= data_end - data ) return - 1 ; data += size ; if ( size == namelen && ! memcmp ( data - size , name , namelen ) ) { switch ( * data ++ ) { case AMF_DATA_TYPE_NUMBER : if (dst_size > 0) { snprintf ( dst , dst_size , ""%g"" , av_int2double ( AV_RB64 ( data ) ) ) ; } break ; case AMF_DATA_TYPE_BOOL : if (dst_size > 0) { snprintf ( dst , dst_size , ""%s"" , * data ? ""true"" : ""false"" ) ; } break ; case AMF_DATA_TYPE_STRING : len = bytestream_get_be16 ( & data ) ; if (dst_size > 0) { av_strlcpy ( dst , data , FFMIN ( len + 1 , dst_size ) ) ; } break ; default : return - 1 ; } return 0 ; } len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 || len >= data_end - data ) return - 1 ; data += len ; } return - 1 ; }",445,-8.49409077861241,-0.019087844446320022
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int ff_amf_get_field_value ( const uint8_t * data , const uint8_t * data_end , const uint8_t * name , uint8_t * dst , int dst_size ) { int namelen = strlen ( name ) ; int len ; while ( * data != AMF_DATA_TYPE_OBJECT && data < data_end ) { len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 ) len = data_end - data ; data += len ; } if ( data_end - data < 3 ) return - 1 ; data ++ ; for ( ; ; ) { int size = bytestream_get_be16 ( & data ) ; if ( ! size ) break ; if ( size < 0 || size >= data_end - data ) return - 1 ; data += size ; if ( size == namelen && ! memcmp ( data - size , name , namelen ) ) { switch ( * data ++ ) { case AMF_DATA_TYPE_NUMBER : snprintf ( dst , dst_size , ""%g"" , av_int2double ( AV_RB64 ( data ) ) ) ; break ; case AMF_DATA_TYPE_BOOL : snprintf ( dst , dst_size , ""%s"" , * data ? ""true"" : ""false"" ) ; break ; case AMF_DATA_TYPE_STRING : len = bytestream_get_be16 ( & data ) ; av_strlcpy ( dst , data , FFMIN ( len + 1 , dst_size ) ) ; break ; default : return - 1 ; } return 0 ; } len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 || len >= data_end - data ) return - 1 ; data += len ; } return - 1 ; }
Fixed code:","
int ff_amf_get_field_value ( const uint8_t * data , const uint8_t * data_end , const uint8_t * name , uint8_t * dst , int dst_size ) {
// Add input validation
if(data == NULL || data_end == NULL || name == NULL || dst == NULL || dst_size < 0) {
    return -1;
}

int namelen = strlen ( name ) ; int len ; while ( * data != AMF_DATA_TYPE_OBJECT && data < data_end ) { len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 ) len = data_end - data ; data += len ; } if ( data_end - data < 3 ) return - 1 ; data ++ ; for ( ; ; ) { int size = bytestream_get_be16 ( & data ) ; if ( ! size ) break ; if ( size < 0 || size >= data_end - data ) return - 1 ; data += size ; if ( size == namelen && ! memcmp ( data - size , name , namelen ) ) { switch ( * data ++ ) { case AMF_DATA_TYPE_NUMBER : snprintf ( dst , dst_size , ""%g"" , av_int2double ( AV_RB64 ( data ) ) ) ; break ; case AMF_DATA_TYPE_BOOL : snprintf ( dst , dst_size , ""%s"" , * data ? ""true"" : ""false"" ) ; break ; case AMF_DATA_TYPE_STRING : len = bytestream_get_be16 ( & data ) ;
// Add input validation
if(len < 0 || len >= dst_size) {
    return -1;
}
av_strlcpy ( dst , data , FFMIN ( len + 1 , dst_size ) ) ; break ; default : return - 1 ; } return 0 ; } len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 || len >= data_end - data ) return - 1 ; data += len ; } return - 1 ; }",483,-25.955949073966217,-0.05373902499785966
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int ff_amf_get_field_value ( const uint8_t * data , const uint8_t * data_end , const uint8_t * name , uint8_t * dst , int dst_size ) { int namelen = strlen ( name ) ; int len ; while ( * data != AMF_DATA_TYPE_OBJECT && data < data_end ) { len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 ) len = data_end - data ; data += len ; } if ( data_end - data < 3 ) return - 1 ; data ++ ; for ( ; ; ) { int size = bytestream_get_be16 ( & data ) ; if ( ! size ) break ; if ( size < 0 || size >= data_end - data ) return - 1 ; data += size ; if ( size == namelen && ! memcmp ( data - size , name , namelen ) ) { switch ( * data ++ ) { case AMF_DATA_TYPE_NUMBER : snprintf ( dst , dst_size , ""%g"" , av_int2double ( AV_RB64 ( data ) ) ) ; break ; case AMF_DATA_TYPE_BOOL : snprintf ( dst , dst_size , ""%s"" , * data ? ""true"" : ""false"" ) ; break ; case AMF_DATA_TYPE_STRING : len = bytestream_get_be16 ( & data ) ; av_strlcpy ( dst , data , FFMIN ( len + 1 , dst_size ) ) ; break ; default : return - 1 ; } return 0 ; } len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 || len >= data_end - data ) return - 1 ; data += len ; } return - 1 ; }
Fixed code:","
int ff_amf_get_field_value ( const uint8_t * data , const uint8_t * data_end , const uint8_t * name , uint8_t * dst , int dst_size ) { 
	int namelen = strlen ( name ) ; 
	int len ;
	
	if ( data > data_end ) { 
		return - 1 ; 
	}
	
	while ( * data != AMF_DATA_TYPE_OBJECT && data < data_end ) { 
		len = ff_amf_tag_size ( data , data_end ) ; 
		if ( len < 0 ) { 
			len = data_end - data ; 
		}
		
		data += len ;
	}
	
	if ( data_end - data < 3 ) { 
		return - 1 ; 
	}
	
	data ++ ; 
	
	for ( ; ; ) { 
		int size = bytestream_get_be16 ( & data ) ; 
		if ( ! size ) { 
			break ; 
		}
		
		if ( size < 0 || size >= data_end - data ) { 
			return - 1 ; 
		}
		
		data += size ; 
		if ( size == namelen && ! memcmp ( data - size , name , namelen ) ) { 
			switch ( * data ++ ) { 
				case AMF_DATA_TYPE_NUMBER : 
					snprintf ( dst , dst_size , ""%g"" , av_int2double ( AV_RB64 ( data ) ) ) ; 
					break ; 
				case AMF_DATA_TYPE_BOOL : 
					snprintf ( dst , dst_size , ""%s"" , * data ? ""true"" : ""false"" ) ; 
					break ; 
				case AMF_DATA_TYPE_STRING : 
					len = bytestream_get_be16 ( & data ) ; 
					if ( len >= 0 && len < dst_size ) { 
						av_strlcpy ( dst , data , FFMIN ( len + 1 , dst_size ) ) ; 
					}
					break ; 
				default : 
					return - 1 ; 
			}
			return 0 ;
		}
		
		len = ff_amf_tag_size ( data , data_end ) ; 
		if ( len < 0 || len >= data_end - data ) { 
			return - 1 ; 
		}
		
		data += len ;
	}
	
	return - 1 ; 
}",702,-45.53227777372781,-0.06486079454946982
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int ff_amf_get_field_value ( const uint8_t * data , const uint8_t * data_end , const uint8_t * name , uint8_t * dst , int dst_size ) { int namelen = strlen ( name ) ; int len ; while ( * data != AMF_DATA_TYPE_OBJECT && data < data_end ) { len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 ) len = data_end - data ; data += len ; } if ( data_end - data < 3 ) return - 1 ; data ++ ; for ( ; ; ) { int size = bytestream_get_be16 ( & data ) ; if ( ! size ) break ; if ( size < 0 || size >= data_end - data ) return - 1 ; data += size ; if ( size == namelen && ! memcmp ( data - size , name , namelen ) ) { switch ( * data ++ ) { case AMF_DATA_TYPE_NUMBER : snprintf ( dst , dst_size , ""%g"" , av_int2double ( AV_RB64 ( data ) ) ) ; break ; case AMF_DATA_TYPE_BOOL : snprintf ( dst , dst_size , ""%s"" , * data ? ""true"" : ""false"" ) ; break ; case AMF_DATA_TYPE_STRING : len = bytestream_get_be16 ( & data ) ; av_strlcpy ( dst , data , FFMIN ( len + 1 , dst_size ) ) ; break ; default : return - 1 ; } return 0 ; } len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 || len >= data_end - data ) return - 1 ; data += len ; } return - 1 ; }
Fixed code:","
int ff_amf_get_field_value ( const uint8_t * data , const uint8_t * data_end , const uint8_t * name , uint8_t * dst , int dst_size ) { int namelen = strlen ( name ) ; int len ; while ( * data != AMF_DATA_TYPE_OBJECT && data < data_end ) { len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 || len > data_end - data ) return - 1 ; data += len ; } if ( data_end - data < 3 ) return - 1 ; data ++ ; for ( ; ; ) { int size = bytestream_get_be16 ( & data ) ; if ( ! size ) break ; if ( size < 0 || size > data_end - data ) return - 1 ; data += size ; if ( size == namelen && ! memcmp ( data - size , name , namelen ) ) { switch ( * data ++ ) { case AMF_DATA_TYPE_NUMBER : snprintf ( dst , dst_size , ""%g"" , av_int2double ( AV_RB64 ( data ) ) ) ; break ; case AMF_DATA_TYPE_BOOL : snprintf ( dst , dst_size , ""%s"" , * data ? ""true"" : ""false"" ) ; break ; case AMF_DATA_TYPE_STRING : len = bytestream_get_be16 ( & data ) ; if ( len > data_end - data ) return - 1 ; av_strlcpy ( dst , data , FFMIN ( len + 1 , dst_size ) ) ; break ; default : return - 1 ; } return 0 ; } len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 || len > data_end - data ) return - 1 ; data += len ; } return - 1 ; }",430,-7.8720770995893,-0.01830715604555651
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int ff_amf_get_field_value ( const uint8_t * data , const uint8_t * data_end , const uint8_t * name , uint8_t * dst , int dst_size ) { int namelen = strlen ( name ) ; int len ; while ( * data != AMF_DATA_TYPE_OBJECT && data < data_end ) { len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 ) len = data_end - data ; data += len ; } if ( data_end - data < 3 ) return - 1 ; data ++ ; for ( ; ; ) { int size = bytestream_get_be16 ( & data ) ; if ( ! size ) break ; if ( size < 0 || size >= data_end - data ) return - 1 ; data += size ; if ( size == namelen && ! memcmp ( data - size , name , namelen ) ) { switch ( * data ++ ) { case AMF_DATA_TYPE_NUMBER : snprintf ( dst , dst_size , ""%g"" , av_int2double ( AV_RB64 ( data ) ) ) ; break ; case AMF_DATA_TYPE_BOOL : snprintf ( dst , dst_size , ""%s"" , * data ? ""true"" : ""false"" ) ; break ; case AMF_DATA_TYPE_STRING : len = bytestream_get_be16 ( & data ) ; av_strlcpy ( dst , data , FFMIN ( len + 1 , dst_size ) ) ; break ; default : return - 1 ; } return 0 ; } len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 || len >= data_end - data ) return - 1 ; data += len ; } return - 1 ; }
Fixed code:","
int ff_amf_get_field_value ( const uint8_t * data , const uint8_t * data_end , const uint8_t * name , uint8_t * dst , int dst_size ) { int namelen = strlen ( name ) ; int len ; while ( * data != AMF_DATA_TYPE_OBJECT && data < data_end ) { len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 ) len = data_end - data ; data += len ; } if ( data_end - data < 3 ) return - 1 ; data ++ ; for ( ; ; ) { int size = bytestream_get_be16 ( & data ) ; if ( ! size ) break ; if ( size < 0 || size >= data_end - data ) return - 1 ; data += size ; if ( size == namelen && ! memcmp ( data - size , name , namelen ) ) { switch ( * data ++ ) { case AMF_DATA_TYPE_NUMBER : // Add input validation if (data + 8 > data_end) return -1; snprintf ( dst , dst_size , ""%g"" , av_int2double ( AV_RB64 ( data ) ) ) ; break ; case AMF_DATA_TYPE_BOOL : // Add input validation if (data + 1 > data_end) return -1; snprintf ( dst , dst_size , ""%s"" , * data ? ""true"" : ""false"" ) ; break ; case AMF_DATA_TYPE_STRING : // Add input validation if (data + 2 > data_end) return -1; len = bytestream_get_be16 ( & data ) ; if (data + len > data_end) return -1; av_strlcpy ( dst , data , FFMIN ( len + 1 , dst_size ) ) ; break ; default : return - 1 ; } return 0 ; } len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 || len >= data_end - data ) return - 1 ; data += len ; } return - 1 ; }",480,-17.058319721895888,-0.0355381660872831
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int ff_amf_get_field_value ( const uint8_t * data , const uint8_t * data_end , const uint8_t * name , uint8_t * dst , int dst_size ) { int namelen = strlen ( name ) ; int len ; while ( * data != AMF_DATA_TYPE_OBJECT && data < data_end ) { len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 ) len = data_end - data ; data += len ; } if ( data_end - data < 3 ) return - 1 ; data ++ ; for ( ; ; ) { int size = bytestream_get_be16 ( & data ) ; if ( ! size ) break ; if ( size < 0 || size >= data_end - data ) return - 1 ; data += size ; if ( size == namelen && ! memcmp ( data - size , name , namelen ) ) { switch ( * data ++ ) { case AMF_DATA_TYPE_NUMBER : snprintf ( dst , dst_size , ""%g"" , av_int2double ( AV_RB64 ( data ) ) ) ; break ; case AMF_DATA_TYPE_BOOL : snprintf ( dst , dst_size , ""%s"" , * data ? ""true"" : ""false"" ) ; break ; case AMF_DATA_TYPE_STRING : len = bytestream_get_be16 ( & data ) ; av_strlcpy ( dst , data , FFMIN ( len + 1 , dst_size ) ) ; break ; default : return - 1 ; } return 0 ; } len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 || len >= data_end - data ) return - 1 ; data += len ; } return - 1 ; }
Fixed code:","
int ff_amf_get_field_value ( const uint8_t * data , const uint8_t * data_end , const uint8_t * name , uint8_t * dst , int dst_size ) { int namelen = strlen ( name ) ; int len ; while ( * data != AMF_DATA_TYPE_OBJECT && data < data_end ) { len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 ) len = data_end - data ; data += len ; } if ( data_end - data < 3 ) return - 1 ; data ++ ; for ( ; ; ) { int size = bytestream_get_be16 ( & data ) ; if ( ! size ) break ; if ( size < 0 || size >= data_end - data ) return - 1 ; data += size ; if ( size == namelen && ! memcmp ( data - size , name , namelen ) ) { switch ( * data ++ ) { case AMF_DATA_TYPE_NUMBER : if (dst_size < sizeof(double)) { return -1; } snprintf ( dst , dst_size , ""%g"" , av_int2double ( AV_RB64 ( data ) ) ) ; break ; case AMF_DATA_TYPE_BOOL : if (dst_size < strlen(""true"") + 1 || dst_size < strlen(""false"") + 1) { return -1; } snprintf ( dst , dst_size , ""%s"" , * data ? ""true"" : ""false"" ) ; break ; case AMF_DATA_TYPE_STRING : len = bytestream_get_be16 ( & data ) ; if (len > dst_size - 1) { return -1; } av_strlcpy ( dst , data , FFMIN ( len + 1 , dst_size ) ) ; break ; default : return - 1 ; } return 0 ; } len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 || len >= data_end - data ) return - 1 ; data += len ; } return - 1 ; }",478,-17.66210658264124,-0.036950013771215984
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int ff_amf_get_field_value ( const uint8_t * data , const uint8_t * data_end , const uint8_t * name , uint8_t * dst , int dst_size ) { int namelen = strlen ( name ) ; int len ; while ( * data != AMF_DATA_TYPE_OBJECT && data < data_end ) { len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 ) len = data_end - data ; data += len ; } if ( data_end - data < 3 ) return - 1 ; data ++ ; for ( ; ; ) { int size = bytestream_get_be16 ( & data ) ; if ( ! size ) break ; if ( size < 0 || size >= data_end - data ) return - 1 ; data += size ; if ( size == namelen && ! memcmp ( data - size , name , namelen ) ) { switch ( * data ++ ) { case AMF_DATA_TYPE_NUMBER : snprintf ( dst , dst_size , ""%g"" , av_int2double ( AV_RB64 ( data ) ) ) ; break ; case AMF_DATA_TYPE_BOOL : snprintf ( dst , dst_size , ""%s"" , * data ? ""true"" : ""false"" ) ; break ; case AMF_DATA_TYPE_STRING : len = bytestream_get_be16 ( & data ) ; av_strlcpy ( dst , data , FFMIN ( len + 1 , dst_size ) ) ; break ; default : return - 1 ; } return 0 ; } len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 || len >= data_end - data ) return - 1 ; data += len ; } return - 1 ; }
Fixed code:","
int ff_amf_get_field_value ( const uint8_t * data , const uint8_t * data_end , const uint8_t * name , uint8_t * dst , int dst_size ) { int namelen = strlen ( name ) ; int len ; while ( * data != AMF_DATA_TYPE_OBJECT && data < data_end ) { len = ff_amf_tag_size ( data , data_end ) ; // Check for invalid length if ( len < 0 ) len = data_end - data ; data += len ; } if ( data_end - data < 3 ) return - 1 ; data ++ ; for ( ; ; ) { int size = bytestream_get_be16 ( & data ) ; // Check for invalid size if ( size <= 0 || size >= data_end - data ) return - 1 ; data += size ; if ( size == namelen && ! memcmp ( data - size , name , namelen ) ) { switch ( * data ++ ) { // Check for invalid length case AMF_DATA_TYPE_NUMBER : len = bytestream_get_be16 ( & data ) ; if ( len < 0 ) return -1; snprintf ( dst , dst_size , ""%g"" , av_int2double ( AV_RB64 ( data ) ) ) ; break ; case AMF_DATA_TYPE_BOOL : snprintf ( dst , dst_size , ""%s"" , * data ? ""true"" : ""false"" ) ; break ; case AMF_DATA_TYPE_STRING : len = bytestream_get_be16 ( & data ) ; // Check for invalid length if ( len < 0 ) return -1; av_strlcpy ( dst , data , FFMIN ( len + 1 , dst_size ) ) ; break ; default : return - 1 ; } return 0 ; } len = ff_amf_tag_size ( data , data_end ) ; // Check for invalid length if ( len < 0 || len >= data_end - data ) return - 1 ; data += len ; } return - 1 ; }",465,-40.49271698716773,-0.08708111180036071
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int ff_amf_get_field_value ( const uint8_t * data , const uint8_t * data_end , const uint8_t * name , uint8_t * dst , int dst_size ) { int namelen = strlen ( name ) ; int len ; while ( * data != AMF_DATA_TYPE_OBJECT && data < data_end ) { len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 ) len = data_end - data ; data += len ; } if ( data_end - data < 3 ) return - 1 ; data ++ ; for ( ; ; ) { int size = bytestream_get_be16 ( & data ) ; if ( ! size ) break ; if ( size < 0 || size >= data_end - data ) return - 1 ; data += size ; if ( size == namelen && ! memcmp ( data - size , name , namelen ) ) { switch ( * data ++ ) { case AMF_DATA_TYPE_NUMBER : snprintf ( dst , dst_size , ""%g"" , av_int2double ( AV_RB64 ( data ) ) ) ; break ; case AMF_DATA_TYPE_BOOL : snprintf ( dst , dst_size , ""%s"" , * data ? ""true"" : ""false"" ) ; break ; case AMF_DATA_TYPE_STRING : len = bytestream_get_be16 ( & data ) ; av_strlcpy ( dst , data , FFMIN ( len + 1 , dst_size ) ) ; break ; default : return - 1 ; } return 0 ; } len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 || len >= data_end - data ) return - 1 ; data += len ; } return - 1 ; }
Fixed code:","
int ff_amf_get_field_value ( const uint8_t * data , const uint8_t * data_end , const uint8_t * name , uint8_t * dst , int dst_size ) { int namelen = strlen ( name ) ; int len ; 
	if(data == NULL || data_end == NULL || name == NULL || dst == NULL || dst_size <= 0) {
		return -1;
	}
	
	while ( * data != AMF_DATA_TYPE_OBJECT && data < data_end ) { len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 ) len = data_end - data ; data += len ; } if ( data_end - data < 3 ) return - 1 ; data ++ ; for ( ; ; ) { int size = bytestream_get_be16 ( & data ) ; if ( ! size ) break ; if ( size < 0 || size >= data_end - data ) return - 1 ; data += size ; if ( size == namelen && ! memcmp ( data - size , name , namelen ) ) { switch ( * data ++ ) { case AMF_DATA_TYPE_NUMBER : snprintf ( dst , dst_size , ""%g"" , av_int2double ( AV_RB64 ( data ) ) ) ; break ; case AMF_DATA_TYPE_BOOL : snprintf ( dst , dst_size , ""%s"" , * data ? ""true"" : ""false"" ) ; break ; case AMF_DATA_TYPE_STRING : len = bytestream_get_be16 ( & data ) ; if(len >= dst_size) {
			return -1;
		}
		av_strlcpy ( dst , data , FFMIN ( len + 1 , dst_size ) ) ; break ; default : return - 1 ; } return 0 ; } len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 || len >= data_end - data ) return - 1 ; data += len ; } return - 1 ; }",480,-24.096439523056386,-0.050200915673034134
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int ff_amf_get_field_value ( const uint8_t * data , const uint8_t * data_end , const uint8_t * name , uint8_t * dst , int dst_size ) { int namelen = strlen ( name ) ; int len ; while ( * data != AMF_DATA_TYPE_OBJECT && data < data_end ) { len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 ) len = data_end - data ; data += len ; } if ( data_end - data < 3 ) return - 1 ; data ++ ; for ( ; ; ) { int size = bytestream_get_be16 ( & data ) ; if ( ! size ) break ; if ( size < 0 || size >= data_end - data ) return - 1 ; data += size ; if ( size == namelen && ! memcmp ( data - size , name , namelen ) ) { switch ( * data ++ ) { case AMF_DATA_TYPE_NUMBER : snprintf ( dst , dst_size , ""%g"" , av_int2double ( AV_RB64 ( data ) ) ) ; break ; case AMF_DATA_TYPE_BOOL : snprintf ( dst , dst_size , ""%s"" , * data ? ""true"" : ""false"" ) ; break ; case AMF_DATA_TYPE_STRING : len = bytestream_get_be16 ( & data ) ; av_strlcpy ( dst , data , FFMIN ( len + 1 , dst_size ) ) ; break ; default : return - 1 ; } return 0 ; } len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 || len >= data_end - data ) return - 1 ; data += len ; } return - 1 ; }
Fixed code:","
int ff_amf_get_field_value ( const uint8_t * data , const uint8_t * data_end , const uint8_t * name , uint8_t * dst , int dst_size ) { int namelen = strlen ( name ) ; int len ; while ( * data != AMF_DATA_TYPE_OBJECT && data < data_end ) { len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 || len >= data_end - data ) { return -1; } data += len ; } if ( data_end - data < 3 ) return - 1 ; data ++ ; for ( ; ; ) { int size = bytestream_get_be16 ( & data ) ; if ( ! size ) break ; if ( size < 0 || size >= data_end - data ) return - 1 ; data += size ; if ( size == namelen && ! memcmp ( data - size , name , namelen ) ) { switch ( * data ++ ) { case AMF_DATA_TYPE_NUMBER : snprintf ( dst , dst_size , ""%g"" , av_int2double ( AV_RB64 ( data ) ) ) ; break ; case AMF_DATA_TYPE_BOOL : snprintf ( dst , dst_size , ""%s"" , * data ? ""true"" : ""false"" ) ; break ; case AMF_DATA_TYPE_STRING : len = bytestream_get_be16 ( & data ) ; if (len < 0 || len >= data_end - data) { return -1; } av_strlcpy ( dst , data , FFMIN ( len + 1 , dst_size ) ) ; break ; default : return - 1 ; } return 0 ; } len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 || len >= data_end - data ) return - 1 ; data += len ; } return - 1 ; }",438,-10.537190763658502,-0.024057513159037678
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int ff_amf_get_field_value ( const uint8_t * data , const uint8_t * data_end , const uint8_t * name , uint8_t * dst , int dst_size ) { int namelen = strlen ( name ) ; int len ; while ( * data != AMF_DATA_TYPE_OBJECT && data < data_end ) { len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 ) len = data_end - data ; data += len ; } if ( data_end - data < 3 ) return - 1 ; data ++ ; for ( ; ; ) { int size = bytestream_get_be16 ( & data ) ; if ( ! size ) break ; if ( size < 0 || size >= data_end - data ) return - 1 ; data += size ; if ( size == namelen && ! memcmp ( data - size , name , namelen ) ) { switch ( * data ++ ) { case AMF_DATA_TYPE_NUMBER : snprintf ( dst , dst_size , ""%g"" , av_int2double ( AV_RB64 ( data ) ) ) ; break ; case AMF_DATA_TYPE_BOOL : snprintf ( dst , dst_size , ""%s"" , * data ? ""true"" : ""false"" ) ; break ; case AMF_DATA_TYPE_STRING : len = bytestream_get_be16 ( & data ) ; av_strlcpy ( dst , data , FFMIN ( len + 1 , dst_size ) ) ; break ; default : return - 1 ; } return 0 ; } len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 || len >= data_end - data ) return - 1 ; data += len ; } return - 1 ; }
Fixed code:","
int ff_amf_get_field_value ( const uint8_t * data , const uint8_t * data_end , const uint8_t * name , uint8_t * dst , int dst_size ) { int namelen = strlen ( name ) ; int len ; while ( * data != AMF_DATA_TYPE_OBJECT && data < data_end ) { len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 ) len = data_end - data ; data += len ; } if ( data_end - data < 3 ) return - 1 ; data ++ ; 

for ( ; ; ) { int size = bytestream_get_be16 ( & data ) ; if ( ! size ) break ; if ( size < 0 || size >= data_end - data || size < namelen ) return - 1 ; // Validate size 
if ( ! memcmp ( data - size , name , namelen ) ) { switch ( * data ++ ) { case AMF_DATA_TYPE_NUMBER : snprintf ( dst , dst_size , ""%g"" , av_int2double ( AV_RB64 ( data ) ) ) ; break ; case AMF_DATA_TYPE_BOOL : snprintf ( dst , dst_size , ""%s"" , * data ? ""true"" : ""false"" ) ; break ; case AMF_DATA_TYPE_STRING : len = bytestream_get_be16 ( & data ) ; // Validate len if ( len < 0 || len >= dst_size ) return - 1 ; av_strlcpy ( dst , data , FFMIN ( len + 1 , dst_size ) ) ; break ; default : return - 1 ; } return 0 ; } 
len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 || len >= data_end - data ) return - 1 ; data += len ; } return - 1 ; }",439,-35.73990125509842,-0.08141207575193261
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int ff_amf_get_field_value ( const uint8_t * data , const uint8_t * data_end , const uint8_t * name , uint8_t * dst , int dst_size ) { int namelen = strlen ( name ) ; int len ; while ( * data != AMF_DATA_TYPE_OBJECT && data < data_end ) { len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 ) len = data_end - data ; data += len ; } if ( data_end - data < 3 ) return - 1 ; data ++ ; for ( ; ; ) { int size = bytestream_get_be16 ( & data ) ; if ( ! size ) break ; if ( size < 0 || size >= data_end - data ) return - 1 ; data += size ; if ( size == namelen && ! memcmp ( data - size , name , namelen ) ) { switch ( * data ++ ) { case AMF_DATA_TYPE_NUMBER : snprintf ( dst , dst_size , ""%g"" , av_int2double ( AV_RB64 ( data ) ) ) ; break ; case AMF_DATA_TYPE_BOOL : snprintf ( dst , dst_size , ""%s"" , * data ? ""true"" : ""false"" ) ; break ; case AMF_DATA_TYPE_STRING : len = bytestream_get_be16 ( & data ) ; av_strlcpy ( dst , data , FFMIN ( len + 1 , dst_size ) ) ; break ; default : return - 1 ; } return 0 ; } len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 || len >= data_end - data ) return - 1 ; data += len ; } return - 1 ; }
Fixed code:","
int ff_amf_get_field_value ( const uint8_t * data , const uint8_t * data_end , const uint8_t * name , uint8_t * dst , int dst_size ) { int namelen = strlen ( name ) ; int len ; while ( * data != AMF_DATA_TYPE_OBJECT && data < data_end ) { len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 ) len = data_end - data ; data += len ; } if ( data_end - data < 3 ) return - 1 ; data ++ ; for ( ; ; ) { int size = bytestream_get_be16 ( & data ) ; if ( ! size ) break ; if ( size < 0 || size >= data_end - data ) return - 1 ; data += size ; if ( size == namelen && ! memcmp ( data - size , name , namelen ) ) { switch ( * data ++ ) { case AMF_DATA_TYPE_NUMBER : if (dst_size > 0 && dst != NULL) { snprintf ( dst , dst_size , ""%g"" , av_int2double ( AV_RB64 ( data ) ) ) ; } break ; case AMF_DATA_TYPE_BOOL : if (dst_size > 0 && dst != NULL) { snprintf ( dst , dst_size , ""%s"" , * data ? ""true"" : ""false"" ) ; } break ; case AMF_DATA_TYPE_STRING : len = bytestream_get_be16 ( & data ) ; if (dst_size > 0 && dst != NULL) { av_strlcpy ( dst , data , FFMIN ( len + 1 , dst_size ) ) ; } break ; default : return - 1 ; } return 0 ; } len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 || len >= data_end - data ) return - 1 ; data += len ; } return - 1 ; }",457,-10.826694758062047,-0.023690798157685003
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int ff_amf_get_field_value ( const uint8_t * data , const uint8_t * data_end , const uint8_t * name , uint8_t * dst , int dst_size ) { int namelen = strlen ( name ) ; int len ; while ( * data != AMF_DATA_TYPE_OBJECT && data < data_end ) { len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 ) len = data_end - data ; data += len ; } if ( data_end - data < 3 ) return - 1 ; data ++ ; for ( ; ; ) { int size = bytestream_get_be16 ( & data ) ; if ( ! size ) break ; if ( size < 0 || size >= data_end - data ) return - 1 ; data += size ; if ( size == namelen && ! memcmp ( data - size , name , namelen ) ) { switch ( * data ++ ) { case AMF_DATA_TYPE_NUMBER : snprintf ( dst , dst_size , ""%g"" , av_int2double ( AV_RB64 ( data ) ) ) ; break ; case AMF_DATA_TYPE_BOOL : snprintf ( dst , dst_size , ""%s"" , * data ? ""true"" : ""false"" ) ; break ; case AMF_DATA_TYPE_STRING : len = bytestream_get_be16 ( & data ) ; av_strlcpy ( dst , data , FFMIN ( len + 1 , dst_size ) ) ; break ; default : return - 1 ; } return 0 ; } len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 || len >= data_end - data ) return - 1 ; data += len ; } return - 1 ; }
Fixed code:","
int ff_amf_get_field_value ( const uint8_t * data , const uint8_t * data_end , const uint8_t * name , uint8_t * dst , int dst_size ) { int namelen = strlen ( name ) ; int len ; while ( * data != AMF_DATA_TYPE_OBJECT && data < data_end ) { len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 ) len = data_end - data ; data += len ; } if ( data_end - data < 3 ) return - 1 ; data ++ ; for ( ; ; ) { int size = bytestream_get_be16 ( & data ) ; if ( ! size ) break ; if ( size < 0 || size >= data_end - data ) return - 1 ; data += size ; if ( size == namelen && ! memcmp ( data - size , name , namelen ) ) { switch ( * data ++ ) { case AMF_DATA_TYPE_NUMBER : if (dst_size < sizeof(double)) return -1; snprintf ( dst , dst_size , ""%g"" , av_int2double ( AV_RB64 ( data ) ) ) ; break ; case AMF_DATA_TYPE_BOOL : if (dst_size < 5) return -1; snprintf ( dst , dst_size , ""%s"" , * data ? ""true"" : ""false"" ) ; break ; case AMF_DATA_TYPE_STRING : len = bytestream_get_be16 ( & data ) ; if (dst_size < len+1) return -1; av_strlcpy ( dst , data , FFMIN ( len + 1 , dst_size ) ) ; break ; default : return - 1 ; } return 0 ; } len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 || len >= data_end - data ) return - 1 ; data += len ; } return - 1 ; }",455,-11.166770950961908,-0.02454235373837782
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int ff_amf_get_field_value ( const uint8_t * data , const uint8_t * data_end , const uint8_t * name , uint8_t * dst , int dst_size ) { int namelen = strlen ( name ) ; int len ; while ( * data != AMF_DATA_TYPE_OBJECT && data < data_end ) { len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 ) len = data_end - data ; data += len ; } if ( data_end - data < 3 ) return - 1 ; data ++ ; for ( ; ; ) { int size = bytestream_get_be16 ( & data ) ; if ( ! size ) break ; if ( size < 0 || size >= data_end - data ) return - 1 ; data += size ; if ( size == namelen && ! memcmp ( data - size , name , namelen ) ) { switch ( * data ++ ) { case AMF_DATA_TYPE_NUMBER : snprintf ( dst , dst_size , ""%g"" , av_int2double ( AV_RB64 ( data ) ) ) ; break ; case AMF_DATA_TYPE_BOOL : snprintf ( dst , dst_size , ""%s"" , * data ? ""true"" : ""false"" ) ; break ; case AMF_DATA_TYPE_STRING : len = bytestream_get_be16 ( & data ) ; av_strlcpy ( dst , data , FFMIN ( len + 1 , dst_size ) ) ; break ; default : return - 1 ; } return 0 ; } len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 || len >= data_end - data ) return - 1 ; data += len ; } return - 1 ; }
Fixed code:","
int ff_amf_get_field_value ( const uint8_t * data , const uint8_t * data_end , const uint8_t * name , uint8_t * dst , int dst_size ) { int namelen = strlen ( name ) ; int len ; while ( * data != AMF_DATA_TYPE_OBJECT && data < data_end ) { len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 ) len = data_end - data ; data += len ; } if ( data_end - data < 3 ) return - 1 ; data ++ ; for ( ; ; ) { int size = bytestream_get_be16 ( & data ) ; // verify size is within bounds if ( size < 0 || size > data_end - data ) return - 1 ; if ( ! size ) break ; data += size ; if ( size == namelen && ! memcmp ( data - size , name , namelen ) ) { switch ( * data ++ ) { case AMF_DATA_TYPE_NUMBER : snprintf ( dst , dst_size , ""%g"" , av_int2double ( AV_RB64 ( data ) ) ) ; break ; case AMF_DATA_TYPE_BOOL : snprintf ( dst , dst_size , ""%s"" , * data ? ""true"" : ""false"" ) ; break ; case AMF_DATA_TYPE_STRING : len = bytestream_get_be16 ( & data ) ; // verify string length is within bounds if ( len < 0 || len > data_end - data ) return - 1 ; av_strlcpy ( dst , data , FFMIN ( len + 1 , dst_size ) ) ; break ; default : return - 1 ; } return 0 ; } len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 || len >= data_end - data ) return - 1 ; data += len ; } return - 1 ; }",443,-21.64802346906084,-0.048866870133320174
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int ff_amf_get_field_value ( const uint8_t * data , const uint8_t * data_end , const uint8_t * name , uint8_t * dst , int dst_size ) { int namelen = strlen ( name ) ; int len ; while ( * data != AMF_DATA_TYPE_OBJECT && data < data_end ) { len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 ) len = data_end - data ; data += len ; } if ( data_end - data < 3 ) return - 1 ; data ++ ; for ( ; ; ) { int size = bytestream_get_be16 ( & data ) ; if ( ! size ) break ; if ( size < 0 || size >= data_end - data ) return - 1 ; data += size ; if ( size == namelen && ! memcmp ( data - size , name , namelen ) ) { switch ( * data ++ ) { case AMF_DATA_TYPE_NUMBER : snprintf ( dst , dst_size , ""%g"" , av_int2double ( AV_RB64 ( data ) ) ) ; break ; case AMF_DATA_TYPE_BOOL : snprintf ( dst , dst_size , ""%s"" , * data ? ""true"" : ""false"" ) ; break ; case AMF_DATA_TYPE_STRING : len = bytestream_get_be16 ( & data ) ; av_strlcpy ( dst , data , FFMIN ( len + 1 , dst_size ) ) ; break ; default : return - 1 ; } return 0 ; } len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 || len >= data_end - data ) return - 1 ; data += len ; } return - 1 ; }
Fixed code:","
int ff_amf_get_field_value ( const uint8_t * data , const uint8_t * data_end , const uint8_t * name , uint8_t * dst , int dst_size ) { int namelen = strlen ( name ) ; int len ; while ( * data != AMF_DATA_TYPE_OBJECT && data < data_end ) { len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 ) len = data_end - data ; data += len ; } if ( data_end - data < 3 ) return - 1 ; data ++ ; for ( ; ; ) { int size = bytestream_get_be16 ( & data ) ; if ( ! size ) break ; if ( size < 0 || size >= data_end - data || size > namelen ) return - 1 ; if ( size == namelen && ! memcmp ( data - size , name , namelen ) ) { switch ( * data ++ ) { case AMF_DATA_TYPE_NUMBER : snprintf ( dst , dst_size , ""%g"" , av_int2double ( AV_RB64 ( data ) ) ) ; break ; case AMF_DATA_TYPE_BOOL : snprintf ( dst , dst_size , ""%s"" , * data ? ""true"" : ""false"" ) ; break ; case AMF_DATA_TYPE_STRING : len = bytestream_get_be16 ( & data ) ; av_strlcpy ( dst , data , FFMIN ( len + 1 , dst_size ) ) ; break ; default : return - 1 ; } return 0 ; } len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 || len >= data_end - data ) return - 1 ; data += len ; } return - 1 ; } 
The vulnerability has been fixed by adding a check for the size of the name before comparing it to the given data. This ensures that the data is not overrun, which could lead to a buffer overflow.",456,-39.65477515139989,-0.08696222620921028
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int ff_amf_get_field_value ( const uint8_t * data , const uint8_t * data_end , const uint8_t * name , uint8_t * dst , int dst_size ) { int namelen = strlen ( name ) ; int len ; while ( * data != AMF_DATA_TYPE_OBJECT && data < data_end ) { len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 ) len = data_end - data ; data += len ; } if ( data_end - data < 3 ) return - 1 ; data ++ ; for ( ; ; ) { int size = bytestream_get_be16 ( & data ) ; if ( ! size ) break ; if ( size < 0 || size >= data_end - data ) return - 1 ; data += size ; if ( size == namelen && ! memcmp ( data - size , name , namelen ) ) { switch ( * data ++ ) { case AMF_DATA_TYPE_NUMBER : snprintf ( dst , dst_size , ""%g"" , av_int2double ( AV_RB64 ( data ) ) ) ; break ; case AMF_DATA_TYPE_BOOL : snprintf ( dst , dst_size , ""%s"" , * data ? ""true"" : ""false"" ) ; break ; case AMF_DATA_TYPE_STRING : len = bytestream_get_be16 ( & data ) ; av_strlcpy ( dst , data , FFMIN ( len + 1 , dst_size ) ) ; break ; default : return - 1 ; } return 0 ; } len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 || len >= data_end - data ) return - 1 ; data += len ; } return - 1 ; }
Fixed code:","
int ff_amf_get_field_value ( const uint8_t * data , const uint8_t * data_end , const uint8_t * name , uint8_t * dst , int dst_size ) { int namelen = strlen ( name ) ; int len ; while ( * data != AMF_DATA_TYPE_OBJECT && data < data_end ) { len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 ) len = data_end - data ; data += len ; } if ( data_end - data < 3 ) return - 1 ; data ++ ; for ( ; ; ) { int size = bytestream_get_be16 ( & data ) ; if ( ! size ) break ; if ( size < 0 || size >= data_end - data ) return - 1 ; data += size ; if ( size == namelen && ! memcmp ( data - size , name , namelen ) ) { switch ( * data ++ ) { case AMF_DATA_TYPE_NUMBER : 
																																																																																if (!dst_size) {
																																																																																	return -1;
																																																																																	}
																																																																																snprintf ( dst , dst_size , ""%g"" , av_int2double ( AV_RB64 ( data ) ) ) ; break ; case AMF_DATA_TYPE_BOOL : 
																																																																																if (!dst_size) {
																																																																																		return -1;
																																																																																	}
																																																																																snprintf ( dst , dst_size , ""%s"" , * data ? ""true"" : ""false"" ) ; break ; case AMF_DATA_TYPE_STRING : len = bytest",1000,-25.45799582242319,-0.02545799582242319
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int ff_amf_get_field_value ( const uint8_t * data , const uint8_t * data_end , const uint8_t * name , uint8_t * dst , int dst_size ) { int namelen = strlen ( name ) ; int len ; while ( * data != AMF_DATA_TYPE_OBJECT && data < data_end ) { len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 ) len = data_end - data ; data += len ; } if ( data_end - data < 3 ) return - 1 ; data ++ ; for ( ; ; ) { int size = bytestream_get_be16 ( & data ) ; if ( ! size ) break ; if ( size < 0 || size >= data_end - data ) return - 1 ; data += size ; if ( size == namelen && ! memcmp ( data - size , name , namelen ) ) { switch ( * data ++ ) { case AMF_DATA_TYPE_NUMBER : snprintf ( dst , dst_size , ""%g"" , av_int2double ( AV_RB64 ( data ) ) ) ; break ; case AMF_DATA_TYPE_BOOL : snprintf ( dst , dst_size , ""%s"" , * data ? ""true"" : ""false"" ) ; break ; case AMF_DATA_TYPE_STRING : len = bytestream_get_be16 ( & data ) ; av_strlcpy ( dst , data , FFMIN ( len + 1 , dst_size ) ) ; break ; default : return - 1 ; } return 0 ; } len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 || len >= data_end - data ) return - 1 ; data += len ; } return - 1 ; }
Fixed code:"," 
int ff_amf_get_field_value ( const uint8_t * data , const uint8_t * data_end , const uint8_t * name , uint8_t * dst , int dst_size ) { //Add input validation if (data == NULL || data_end == NULL || name == NULL || dst == NULL || dst_size <= 0) { return -1; } int namelen = strlen ( name ) ; int len ; while ( * data != AMF_DATA_TYPE_OBJECT && data < data_end ) { len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 ) len = data_end - data ; data += len ; } if ( data_end - data < 3 ) return - 1 ; data ++ ; for ( ; ; ) { int size = bytestream_get_be16 ( & data ) ; if ( ! size ) break ; if ( size < 0 || size >= data_end - data ) return - 1 ; data += size ; if ( size == namelen && ! memcmp ( data - size , name , namelen ) ) { switch ( * data ++ ) { case AMF_DATA_TYPE_NUMBER : snprintf ( dst , dst_size , ""%g"" , av_int2double ( AV_RB64 ( data ) ) ) ; break ; case AMF_DATA_TYPE_BOOL : snprintf ( dst , dst_size , ""%s"" , * data ? ""true"" : ""false"" ) ; break ; case AMF_DATA_TYPE_STRING : len = bytestream_get_be16 ( & data ) ; //Add input validation if (len <= 0 || len > dst_size) { return -1; } av_strlcpy ( dst , data , FFMIN ( len + 1 , dst_size ) ) ; break ; default : return - 1 ; } return 0 ; } len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 || len >= data_end - data ) return - 1 ; data += len ; } return - 1 ; }",471,-21.436402814401962,-0.04551253251465385
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int ff_amf_get_field_value ( const uint8_t * data , const uint8_t * data_end , const uint8_t * name , uint8_t * dst , int dst_size ) { int namelen = strlen ( name ) ; int len ; while ( * data != AMF_DATA_TYPE_OBJECT && data < data_end ) { len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 ) len = data_end - data ; data += len ; } if ( data_end - data < 3 ) return - 1 ; data ++ ; for ( ; ; ) { int size = bytestream_get_be16 ( & data ) ; if ( ! size ) break ; if ( size < 0 || size >= data_end - data ) return - 1 ; data += size ; if ( size == namelen && ! memcmp ( data - size , name , namelen ) ) { switch ( * data ++ ) { case AMF_DATA_TYPE_NUMBER : snprintf ( dst , dst_size , ""%g"" , av_int2double ( AV_RB64 ( data ) ) ) ; break ; case AMF_DATA_TYPE_BOOL : snprintf ( dst , dst_size , ""%s"" , * data ? ""true"" : ""false"" ) ; break ; case AMF_DATA_TYPE_STRING : len = bytestream_get_be16 ( & data ) ; av_strlcpy ( dst , data , FFMIN ( len + 1 , dst_size ) ) ; break ; default : return - 1 ; } return 0 ; } len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 || len >= data_end - data ) return - 1 ; data += len ; } return - 1 ; }
Fixed code:","
int ff_amf_get_field_value ( const uint8_t * data , const uint8_t * data_end , const uint8_t * name , uint8_t * dst , int dst_size ) { int namelen = strlen ( name ) ; int len ; while ( * data != AMF_DATA_TYPE_OBJECT && data < data_end ) { len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 ) len = data_end - data ; data += len ; } if ( data_end - data < 3 ) return - 1 ; data ++ ; for ( ; ; ) { int size = bytestream_get_be16 ( & data ) ; if ( ! size ) break ; if ( size < 0 || size >= data_end - data ) return - 1 ; data += size ; if ( size == namelen && ! memcmp ( data - size , name , namelen ) ) { switch ( * data ++ ) { case AMF_DATA_TYPE_NUMBER : if (!snprintf ( dst , dst_size , ""%g"" , av_int2double ( AV_RB64 ( data ) ))) return -1; break ; case AMF_DATA_TYPE_BOOL : if (!snprintf ( dst , dst_size , ""%s"" , * data ? ""true"" : ""false"" )) return -1; break ; case AMF_DATA_TYPE_STRING : len = bytestream_get_be16 ( & data ) ; if (!av_strlcpy ( dst , data , FFMIN ( len + 1 , dst_size ))) return -1; break ; default : return - 1 ; } return 0 ; } len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 || len >= data_end - data ) return - 1 ; data += len ; } return - 1 ; }",425,-14.667366273856803,-0.03451145005613365
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int ff_amf_get_field_value ( const uint8_t * data , const uint8_t * data_end , const uint8_t * name , uint8_t * dst , int dst_size ) { int namelen = strlen ( name ) ; int len ; while ( * data != AMF_DATA_TYPE_OBJECT && data < data_end ) { len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 ) len = data_end - data ; data += len ; } if ( data_end - data < 3 ) return - 1 ; data ++ ; for ( ; ; ) { int size = bytestream_get_be16 ( & data ) ; if ( ! size ) break ; if ( size < 0 || size >= data_end - data ) return - 1 ; data += size ; if ( size == namelen && ! memcmp ( data - size , name , namelen ) ) { switch ( * data ++ ) { case AMF_DATA_TYPE_NUMBER : snprintf ( dst , dst_size , ""%g"" , av_int2double ( AV_RB64 ( data ) ) ) ; break ; case AMF_DATA_TYPE_BOOL : snprintf ( dst , dst_size , ""%s"" , * data ? ""true"" : ""false"" ) ; break ; case AMF_DATA_TYPE_STRING : len = bytestream_get_be16 ( & data ) ; av_strlcpy ( dst , data , FFMIN ( len + 1 , dst_size ) ) ; break ; default : return - 1 ; } return 0 ; } len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 || len >= data_end - data ) return - 1 ; data += len ; } return - 1 ; }
Fixed code:","
int ff_amf_get_field_value ( const uint8_t * data , const uint8_t * data_end , const uint8_t * name , uint8_t * dst , int dst_size ) { int namelen = strlen ( name ) ; int len ; while ( * data != AMF_DATA_TYPE_OBJECT && data < data_end ) { len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 ) len = data_end - data ; data += len ; } if ( data_end - data < 3 ) return - 1 ; data ++ ; for ( ; ; ) { int size = bytestream_get_be16 ( & data ) ; if ( size < 0 || size > data_end - data ) return -1; if ( ! size ) break ; if ( size == namelen && ! memcmp ( data - size , name , namelen ) ) { switch ( * data ++ ) { case AMF_DATA_TYPE_NUMBER : snprintf ( dst , dst_size , ""%g"" , av_int2double ( AV_RB64 ( data ) ) ) ; break ; case AMF_DATA_TYPE_BOOL : snprintf ( dst , dst_size , ""%s"" , * data ? ""true"" : ""false"" ) ; break ; case AMF_DATA_TYPE_STRING : len = bytestream_get_be16 ( & data ) ; if ( len > 0 && len < FFMIN ( len + 1 , dst_size ) ) // Check for proper length av_strlcpy ( dst , data , FFMIN ( len + 1 , dst_size ) ) ; break ; default : return - 1 ; } return 0 ; } len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 || len >= data_end - data ) return - 1 ; data += len ; } return - 1 ; }",433,-32.94628822748355,-0.07608842546762945
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int ff_amf_get_field_value ( const uint8_t * data , const uint8_t * data_end , const uint8_t * name , uint8_t * dst , int dst_size ) { int namelen = strlen ( name ) ; int len ; while ( * data != AMF_DATA_TYPE_OBJECT && data < data_end ) { len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 ) len = data_end - data ; data += len ; } if ( data_end - data < 3 ) return - 1 ; data ++ ; for ( ; ; ) { int size = bytestream_get_be16 ( & data ) ; if ( ! size ) break ; if ( size < 0 || size >= data_end - data ) return - 1 ; data += size ; if ( size == namelen && ! memcmp ( data - size , name , namelen ) ) { switch ( * data ++ ) { case AMF_DATA_TYPE_NUMBER : snprintf ( dst , dst_size , ""%g"" , av_int2double ( AV_RB64 ( data ) ) ) ; break ; case AMF_DATA_TYPE_BOOL : snprintf ( dst , dst_size , ""%s"" , * data ? ""true"" : ""false"" ) ; break ; case AMF_DATA_TYPE_STRING : len = bytestream_get_be16 ( & data ) ; av_strlcpy ( dst , data , FFMIN ( len + 1 , dst_size ) ) ; break ; default : return - 1 ; } return 0 ; } len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 || len >= data_end - data ) return - 1 ; data += len ; } return - 1 ; }
Fixed code:","
int ff_amf_get_field_value ( const uint8_t * data , const uint8_t * data_end , const uint8_t * name , uint8_t * dst , int dst_size ) { int namelen = strlen ( name ) ; int len ; while ( * data != AMF_DATA_TYPE_OBJECT && data < data_end ) { len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 ) len = data_end - data ; data += len ; } if ( data_end - data < 3 ) return - 1 ; data ++ ; for ( ; ; ) { int size = bytestream_get_be16 ( & data ) ; if ( ! size ) break ; if ( size < 0 || size >= data_end - data ) return - 1 ; data += size ; if ( size == namelen && ! memcmp ( data - size , name , namelen ) ) { switch ( * data ++ ) { case AMF_DATA_TYPE_NUMBER : if (isnan(av_int2double(AV_RB64(data))) || isinf(av_int2double(AV_RB64(data)))) { return -1; } snprintf ( dst , dst_size , ""%g"" , av_int2double ( AV_RB64 ( data ) ) ) ; break ; case AMF_DATA_TYPE_BOOL : snprintf ( dst , dst_size , ""%s"" , * data ? ""true"" : ""false"" ) ; break ; case AMF_DATA_TYPE_STRING : len = bytestream_get_be16 ( & data ) ; av_strlcpy ( dst , data , FFMIN ( len + 1 , dst_size ) ) ; break ; default : return - 1 ; } return 0 ; } len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 || len >= data_end - data ) return - 1 ; data += len ; } return - 1 ; }",453,-18.205510224011082,-0.04018876429141519
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int ff_amf_get_field_value ( const uint8_t * data , const uint8_t * data_end , const uint8_t * name , uint8_t * dst , int dst_size ) { int namelen = strlen ( name ) ; int len ; while ( * data != AMF_DATA_TYPE_OBJECT && data < data_end ) { len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 ) len = data_end - data ; data += len ; } if ( data_end - data < 3 ) return - 1 ; data ++ ; for ( ; ; ) { int size = bytestream_get_be16 ( & data ) ; if ( ! size ) break ; if ( size < 0 || size >= data_end - data ) return - 1 ; data += size ; if ( size == namelen && ! memcmp ( data - size , name , namelen ) ) { switch ( * data ++ ) { case AMF_DATA_TYPE_NUMBER : snprintf ( dst , dst_size , ""%g"" , av_int2double ( AV_RB64 ( data ) ) ) ; break ; case AMF_DATA_TYPE_BOOL : snprintf ( dst , dst_size , ""%s"" , * data ? ""true"" : ""false"" ) ; break ; case AMF_DATA_TYPE_STRING : len = bytestream_get_be16 ( & data ) ; av_strlcpy ( dst , data , FFMIN ( len + 1 , dst_size ) ) ; break ; default : return - 1 ; } return 0 ; } len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 || len >= data_end - data ) return - 1 ; data += len ; } return - 1 ; }
Fixed code:","
int ff_amf_get_field_value ( const uint8_t * data , const uint8_t * data_end , const uint8_t * name , uint8_t * dst , int dst_size ) { int namelen = strlen ( name ) ; int len ; while ( * data != AMF_DATA_TYPE_OBJECT && data < data_end ) { len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 ) len = data_end - data ; data += len ; } if ( data_end - data < 3 ) return - 1 ; data ++ ; for ( ; ; ) { int size = bytestream_get_be16 ( & data ) ; if ( ! size ) break ; if ( size < 0 || size >= data_end - data ) return - 1 ; data += size ; if ( size == namelen && ! memcmp ( data - size , name , namelen ) ) { switch ( * data ++ ) { case AMF_DATA_TYPE_NUMBER : if (dst_size<=0) { return - 1; } snprintf ( dst , dst_size , ""%g"" , av_int2double ( AV_RB64 ( data ) ) ) ; break ; case AMF_DATA_TYPE_BOOL : if (dst_size<=0) { return - 1; } snprintf ( dst , dst_size , ""%s"" , * data ? ""true"" : ""false"" ) ; break ; case AMF_DATA_TYPE_STRING : len = bytestream_get_be16 ( & data ) ; if (dst_size<=0) { return - 1; } av_strlcpy ( dst , data , FFMIN ( len + 1 , dst_size ) ) ; break ; default : return - 1 ; } return 0 ; } len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 || len >= data_end - data ) return - 1 ; data += len ; } return - 1 ; }",460,-19.940937091493467,-0.0433498632423771
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int ff_amf_get_field_value ( const uint8_t * data , const uint8_t * data_end , const uint8_t * name , uint8_t * dst , int dst_size ) { int namelen = strlen ( name ) ; int len ; while ( * data != AMF_DATA_TYPE_OBJECT && data < data_end ) { len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 ) len = data_end - data ; data += len ; } if ( data_end - data < 3 ) return - 1 ; data ++ ; for ( ; ; ) { int size = bytestream_get_be16 ( & data ) ; if ( ! size ) break ; if ( size < 0 || size >= data_end - data ) return - 1 ; data += size ; if ( size == namelen && ! memcmp ( data - size , name , namelen ) ) { switch ( * data ++ ) { case AMF_DATA_TYPE_NUMBER : snprintf ( dst , dst_size , ""%g"" , av_int2double ( AV_RB64 ( data ) ) ) ; break ; case AMF_DATA_TYPE_BOOL : snprintf ( dst , dst_size , ""%s"" , * data ? ""true"" : ""false"" ) ; break ; case AMF_DATA_TYPE_STRING : len = bytestream_get_be16 ( & data ) ; av_strlcpy ( dst , data , FFMIN ( len + 1 , dst_size ) ) ; break ; default : return - 1 ; } return 0 ; } len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 || len >= data_end - data ) return - 1 ; data += len ; } return - 1 ; }
Fixed code:","
int ff_amf_get_field_value ( const uint8_t * data , const uint8_t * data_end , const uint8_t * name , uint8_t * dst , int dst_size ) { 
int namelen = strlen ( name ) ; 
int len ; 

if (data_end - data < 3 || namelen > dst_size)
    return -1;

while ( * data != AMF_DATA_TYPE_OBJECT && data < data_end ) { 
    len = ff_amf_tag_size ( data , data_end ) ; 
    if ( len < 0 ) len = data_end - data ; 
    data += len ; 
} 

data ++ ; 
for ( ; ; ) { 
    int size = bytestream_get_be16 ( & data ) ; 
    if ( ! size ) break ; 
    if ( size < 0 || size >= data_end - data ) return - 1 ; 
    data += size ; 
    if ( size == namelen && ! memcmp ( data - size , name , namelen ) ) { 
        switch ( * data ++ ) { 
            case AMF_DATA_TYPE_NUMBER : 
                snprintf ( dst , dst_size , ""%g"" , av_int2double ( AV_RB64 ( data ) ) ) ; 
            break ; 
            case AMF_DATA_TYPE_BOOL : 
                snprintf ( dst , dst_size , ""%s"" , * data ? ""true"" : ""false"" ) ; 
            break ; 
            case AMF_DATA_TYPE_STRING : 
                len = bytestream_get_be16 ( & data ) ; 
                if (len > dst_size)
                    return -1;
                av_strlcpy ( dst , data , FFMIN ( len + 1 , dst_size ) ) ; 
            break ; 
            default : 
                return - 1 ; 
        } 
        return 0 ; 
    } 
    len = ff_amf_tag_size ( data , data_end ) ; 
    if ( len < 0 || len >= data_end - data ) return - 1 ; 
    data += len ; 
} 
return - 1 ; 
}",541,-27.382528274289278,-0.05061465485081197
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int ff_amf_get_field_value ( const uint8_t * data , const uint8_t * data_end , const uint8_t * name , uint8_t * dst , int dst_size ) { int namelen = strlen ( name ) ; int len ; while ( * data != AMF_DATA_TYPE_OBJECT && data < data_end ) { len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 ) len = data_end - data ; data += len ; } if ( data_end - data < 3 ) return - 1 ; data ++ ; for ( ; ; ) { int size = bytestream_get_be16 ( & data ) ; if ( ! size ) break ; if ( size < 0 || size >= data_end - data ) return - 1 ; data += size ; if ( size == namelen && ! memcmp ( data - size , name , namelen ) ) { switch ( * data ++ ) { case AMF_DATA_TYPE_NUMBER : snprintf ( dst , dst_size , ""%g"" , av_int2double ( AV_RB64 ( data ) ) ) ; break ; case AMF_DATA_TYPE_BOOL : snprintf ( dst , dst_size , ""%s"" , * data ? ""true"" : ""false"" ) ; break ; case AMF_DATA_TYPE_STRING : len = bytestream_get_be16 ( & data ) ; av_strlcpy ( dst , data , FFMIN ( len + 1 , dst_size ) ) ; break ; default : return - 1 ; } return 0 ; } len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 || len >= data_end - data ) return - 1 ; data += len ; } return - 1 ; }
Fixed code:","
int ff_amf_get_field_value ( const uint8_t * data , const uint8_t * data_end , const uint8_t * name , uint8_t * dst , int dst_size ) { int namelen = strlen ( name ) ; int len ; while ( * data != AMF_DATA_TYPE_OBJECT && data < data_end ) { len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 ) len = data_end - data ; data += len ; } if ( data_end - data < 3 ) return - 1 ; data ++ ; for ( ; ; ) { int size = bytestream_get_be16 ( & data ) ; if ( ! size ) break ; if ( size < 0 || size >= data_end - data ) return - 1 ; if ( size != namelen || memcmp ( data - size , name , namelen ) ) { len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 || len >= data_end - data ) return - 1 ; data += len ; continue ; } data += size ; switch ( * data ++ ) { case AMF_DATA_TYPE_NUMBER : snprintf ( dst , dst_size , ""%g"" , av_int2double ( AV_RB64 ( data ) ) ) ; break ; case AMF_DATA_TYPE_BOOL : snprintf ( dst , dst_size , ""%s"" , * data ? ""true"" : ""false"" ) ; break ; case AMF_DATA_TYPE_STRING : len = bytestream_get_be16 ( & data ) ; av_strlcpy ( dst , data , FFMIN ( len + 1 , dst_size ) ) ; break ; default : return - 1 ; } return 0 ; } return - 1 ; }",413,-7.135552550770198,-0.017277366951017427
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int ff_amf_get_field_value ( const uint8_t * data , const uint8_t * data_end , const uint8_t * name , uint8_t * dst , int dst_size ) { int namelen = strlen ( name ) ; int len ; while ( * data != AMF_DATA_TYPE_OBJECT && data < data_end ) { len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 ) len = data_end - data ; data += len ; } if ( data_end - data < 3 ) return - 1 ; data ++ ; for ( ; ; ) { int size = bytestream_get_be16 ( & data ) ; if ( ! size ) break ; if ( size < 0 || size >= data_end - data ) return - 1 ; data += size ; if ( size == namelen && ! memcmp ( data - size , name , namelen ) ) { switch ( * data ++ ) { case AMF_DATA_TYPE_NUMBER : snprintf ( dst , dst_size , ""%g"" , av_int2double ( AV_RB64 ( data ) ) ) ; break ; case AMF_DATA_TYPE_BOOL : snprintf ( dst , dst_size , ""%s"" , * data ? ""true"" : ""false"" ) ; break ; case AMF_DATA_TYPE_STRING : len = bytestream_get_be16 ( & data ) ; av_strlcpy ( dst , data , FFMIN ( len + 1 , dst_size ) ) ; break ; default : return - 1 ; } return 0 ; } len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 || len >= data_end - data ) return - 1 ; data += len ; } return - 1 ; }
Fixed code:","
int ff_amf_get_field_value ( const uint8_t * data , const uint8_t * data_end , const uint8_t * name , uint8_t * dst , int dst_size ) { int namelen = strlen ( name ) ; int len ; while ( * data != AMF_DATA_TYPE_OBJECT && data < data_end ) { len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 ) len = data_end - data ; data += len ; } if ( data_end - data < 3 ) return - 1 ; data ++ ; for ( ; ; ) { int size = bytestream_get_be16 ( & data ) ; if ( ! size ) break ; if ( size < 0 || size > namelen || size >= data_end - data ) return - 1 ; // Added check for size if ( size == namelen && ! memcmp ( data - size , name , namelen ) ) { switch ( * data ++ ) { case AMF_DATA_TYPE_NUMBER : snprintf ( dst , dst_size , ""%g"" , av_int2double ( AV_RB64 ( data ) ) ) ; break ; case AMF_DATA_TYPE_BOOL : snprintf ( dst , dst_size , ""%s"" , * data ? ""true"" : ""false"" ) ; break ; case AMF_DATA_TYPE_STRING : len = bytestream_get_be16 ( & data ) ; if ( len > 0 && len < dst_size ) // Added check for len { av_strlcpy ( dst , data , FFMIN ( len + 1 , dst_size ) ) ; } break ; default : return - 1 ; } return 0 ; } len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 || len >= data_end - data ) return - 1 ; data += len ; } return - 1 ; }",438,-22.49443288688571,-0.05135715270978473
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int ff_amf_get_field_value ( const uint8_t * data , const uint8_t * data_end , const uint8_t * name , uint8_t * dst , int dst_size ) { int namelen = strlen ( name ) ; int len ; while ( * data != AMF_DATA_TYPE_OBJECT && data < data_end ) { len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 ) len = data_end - data ; data += len ; } if ( data_end - data < 3 ) return - 1 ; data ++ ; for ( ; ; ) { int size = bytestream_get_be16 ( & data ) ; if ( ! size ) break ; if ( size < 0 || size >= data_end - data ) return - 1 ; data += size ; if ( size == namelen && ! memcmp ( data - size , name , namelen ) ) { switch ( * data ++ ) { case AMF_DATA_TYPE_NUMBER : snprintf ( dst , dst_size , ""%g"" , av_int2double ( AV_RB64 ( data ) ) ) ; break ; case AMF_DATA_TYPE_BOOL : snprintf ( dst , dst_size , ""%s"" , * data ? ""true"" : ""false"" ) ; break ; case AMF_DATA_TYPE_STRING : len = bytestream_get_be16 ( & data ) ; av_strlcpy ( dst , data , FFMIN ( len + 1 , dst_size ) ) ; break ; default : return - 1 ; } return 0 ; } len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 || len >= data_end - data ) return - 1 ; data += len ; } return - 1 ; }
Fixed code:","
int ff_amf_get_field_value ( const uint8_t * data , const uint8_t * data_end , const uint8_t * name , uint8_t * dst , int dst_size ) { int namelen = strlen ( name ) ; int len ; while ( * data != AMF_DATA_TYPE_OBJECT && data < data_end ) { len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 ) len = data_end - data ; data += len ; } if ( data_end - data < 3 ) return - 1 ; data ++ ; for ( ; ; ) { int size = bytestream_get_be16 ( & data ) ; if ( ! size ) break ; if ( size <= 0 || size >= data_end - data ) return - 1 ; data += size ; if ( size == namelen && ! memcmp ( data - size , name , namelen ) ) { switch ( * data ++ ) { case AMF_DATA_TYPE_NUMBER : snprintf ( dst , dst_size , ""%g"" , av_int2double ( AV_RB64 ( data ) ) ) ; break ; case AMF_DATA_TYPE_BOOL : snprintf ( dst , dst_size , ""%s"" , * data ? ""true"" : ""false"" ) ; break ; case AMF_DATA_TYPE_STRING : len = bytestream_get_be16 ( & data ) ; if ( len > dst_size ) return - 1 ; av_strlcpy ( dst , data , FFMIN ( len + 1 , dst_size ) ) ; break ; default : return - 1 ; } return 0 ; } len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 || len >= data_end - data ) return - 1 ; data += len ; } return - 1 ; }",424,-10.196627887532,-0.02404865067814151
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int ff_amf_get_field_value ( const uint8_t * data , const uint8_t * data_end , const uint8_t * name , uint8_t * dst , int dst_size ) { int namelen = strlen ( name ) ; int len ; while ( * data != AMF_DATA_TYPE_OBJECT && data < data_end ) { len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 ) len = data_end - data ; data += len ; } if ( data_end - data < 3 ) return - 1 ; data ++ ; for ( ; ; ) { int size = bytestream_get_be16 ( & data ) ; if ( ! size ) break ; if ( size < 0 || size >= data_end - data ) return - 1 ; data += size ; if ( size == namelen && ! memcmp ( data - size , name , namelen ) ) { switch ( * data ++ ) { case AMF_DATA_TYPE_NUMBER : snprintf ( dst , dst_size , ""%g"" , av_int2double ( AV_RB64 ( data ) ) ) ; break ; case AMF_DATA_TYPE_BOOL : snprintf ( dst , dst_size , ""%s"" , * data ? ""true"" : ""false"" ) ; break ; case AMF_DATA_TYPE_STRING : len = bytestream_get_be16 ( & data ) ; av_strlcpy ( dst , data , FFMIN ( len + 1 , dst_size ) ) ; break ; default : return - 1 ; } return 0 ; } len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 || len >= data_end - data ) return - 1 ; data += len ; } return - 1 ; }
Fixed code:","

int ff_amf_get_field_value ( const uint8_t * data , const uint8_t * data_end , const uint8_t * name , uint8_t * dst , int dst_size ) { 
    int namelen = strlen ( name ) ;
    int len ;
    while ( * data != AMF_DATA_TYPE_OBJECT && data < data_end ) {
        len = ff_amf_tag_size ( data , data_end ) ;
 
        if ( len < 0 || len >= data_end - data )
            return - 1 ;
 
        data += len ;
    }
 
    if ( data_end - data < 3 )
        return - 1 ;
 
    data ++ ;
    for ( ; ; ) {
        int size = bytestream_get_be16 ( & data ) ;
        if ( ! size ) break ;
 
        if ( size < 0 || size >= data_end - data )
            return - 1 ;
 
        data += size ;
        if ( size == namelen && ! memcmp ( data - size , name , namelen ) ) {
            switch ( * data ++ ) {
                case AMF_DATA_TYPE_NUMBER :
                    snprintf ( dst , dst_size , ""%g"" , av_int2double ( AV_RB64 ( data ) ) ) ;
                    break ;
                case AMF_DATA_TYPE_BOOL :
                    snprintf ( dst , dst_size , ""%s"" , * data ? ""true"" : ""false"" ) ;
                    break ;
                case AMF_DATA_TYPE_STRING :
                    len = bytestream_get_be16 ( & data ) ;
                    if ( len < 0 || len >= data_end - data )
                        return - 1 ;
 
                    av_strlcpy ( dst , data , FFMIN ( len + 1 , dst_size ) ) ;
                    break ;
                default :
                    return - 1 ;
            }
            return 0 ;
        }
 
        len = ff_amf_tag_size ( data , data_end ) ;
        if ( len < 0 || len >= data_end - data )
            return - 1 ;
 
        data += len ;
    }
    return - 1 ;
}",539,-33.09211380692438,-0.061395387396891245
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int ff_amf_get_field_value ( const uint8_t * data , const uint8_t * data_end , const uint8_t * name , uint8_t * dst , int dst_size ) { int namelen = strlen ( name ) ; int len ; while ( * data != AMF_DATA_TYPE_OBJECT && data < data_end ) { len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 ) len = data_end - data ; data += len ; } if ( data_end - data < 3 ) return - 1 ; data ++ ; for ( ; ; ) { int size = bytestream_get_be16 ( & data ) ; if ( ! size ) break ; if ( size < 0 || size >= data_end - data ) return - 1 ; data += size ; if ( size == namelen && ! memcmp ( data - size , name , namelen ) ) { switch ( * data ++ ) { case AMF_DATA_TYPE_NUMBER : snprintf ( dst , dst_size , ""%g"" , av_int2double ( AV_RB64 ( data ) ) ) ; break ; case AMF_DATA_TYPE_BOOL : snprintf ( dst , dst_size , ""%s"" , * data ? ""true"" : ""false"" ) ; break ; case AMF_DATA_TYPE_STRING : len = bytestream_get_be16 ( & data ) ; av_strlcpy ( dst , data , FFMIN ( len + 1 , dst_size ) ) ; break ; default : return - 1 ; } return 0 ; } len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 || len >= data_end - data ) return - 1 ; data += len ; } return - 1 ; }
Fixed code:","
int ff_amf_get_field_value ( const uint8_t * data , const uint8_t * data_end , const uint8_t * name , uint8_t * dst , int dst_size ) { int namelen = strlen ( name ) ; int len ; while ( * data != AMF_DATA_TYPE_OBJECT && data < data_end ) { len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 || len >= data_end - data ) return - 1 ; data += len ; } if ( data_end - data < 3 ) return - 1 ; data ++ ; for ( ; ; ) { int size = bytestream_get_be16 ( & data ) ; if ( ! size ) break ; if ( size < 0 || size >= data_end - data ) return - 1 ; data += size ; if ( size == namelen && ! memcmp ( data - size , name , namelen ) ) { switch ( * data ++ ) { case AMF_DATA_TYPE_NUMBER : snprintf ( dst , dst_size , ""%g"" , av_int2double ( AV_RB64 ( data ) ) ) ; break ; case AMF_DATA_TYPE_BOOL : snprintf ( dst , dst_size , ""%s"" , * data ? ""true"" : ""false"" ) ; break ; case AMF_DATA_TYPE_STRING : len = bytestream_get_be16 ( & data ) ; if ( len < 0 || len >= data_end - data ) return - 1 ; av_strlcpy ( dst , data , FFMIN ( len + 1 , dst_size ) ) ; break ; default : return - 1 ; } return 0 ; } len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 || len >= data_end - data ) return - 1 ; data += len ; } return - 1 ; }",434,-4.173087377323101,-0.009615408703509451
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int ff_amf_get_field_value ( const uint8_t * data , const uint8_t * data_end , const uint8_t * name , uint8_t * dst , int dst_size ) { int namelen = strlen ( name ) ; int len ; while ( * data != AMF_DATA_TYPE_OBJECT && data < data_end ) { len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 ) len = data_end - data ; data += len ; } if ( data_end - data < 3 ) return - 1 ; data ++ ; for ( ; ; ) { int size = bytestream_get_be16 ( & data ) ; if ( ! size ) break ; if ( size < 0 || size >= data_end - data ) return - 1 ; data += size ; if ( size == namelen && ! memcmp ( data - size , name , namelen ) ) { switch ( * data ++ ) { case AMF_DATA_TYPE_NUMBER : snprintf ( dst , dst_size , ""%g"" , av_int2double ( AV_RB64 ( data ) ) ) ; break ; case AMF_DATA_TYPE_BOOL : snprintf ( dst , dst_size , ""%s"" , * data ? ""true"" : ""false"" ) ; break ; case AMF_DATA_TYPE_STRING : len = bytestream_get_be16 ( & data ) ; av_strlcpy ( dst , data , FFMIN ( len + 1 , dst_size ) ) ; break ; default : return - 1 ; } return 0 ; } len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 || len >= data_end - data ) return - 1 ; data += len ; } return - 1 ; }
Fixed code:","
int ff_amf_get_field_value ( const uint8_t * data , const uint8_t * data_end , const uint8_t * name , uint8_t * dst , int dst_size ) { int namelen = strlen ( name ) ; int len ; while ( * data != AMF_DATA_TYPE_OBJECT && data < data_end ) { len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 ) len = data_end - data ; data += len ; } if ( data_end - data < 3 ) return - 1 ; data ++ ; for ( ; ; ) { int size = bytestream_get_be16 ( & data ) ; if ( ! size ) break ; if ( size < 0 || size >= data_end - data ) return - 1 ; data += size ; if ( size == namelen && ! memcmp ( data - size , name , namelen ) ) { switch ( * data ++ ) { case AMF_DATA_TYPE_NUMBER : if(dst_size > 8) { //Added condition to ensure that the destination size is greater than 8 bytes before performing the copy operation. snprintf ( dst , dst_size , ""%g"" , av_int2double ( AV_RB64 ( data ) ) ) ; break ; } case AMF_DATA_TYPE_BOOL : if(dst_size > 4) { //Added condition to ensure that the destination size is greater than 4 bytes before performing the copy operation. snprintf ( dst , dst_size , ""%s"" , * data ? ""true"" : ""false"" ) ; break ; } case AMF_DATA_TYPE_STRING : len = bytestream_get_be16 ( & data ) ; if(dst_size > len) { //Added condition to ensure that the destination size is greater than the length of the source string before performing the copy operation. av_strlcpy ( dst , data , FFMIN ( len + 1 , dst_size ) ) ; break ; } default : return - 1 ; } return 0 ; } len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 || len >= data_end - data ) return - 1 ; data += len ; } return - 1 ; }",509,-44.003141114648116,-0.08645017900716723
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int ff_amf_get_field_value ( const uint8_t * data , const uint8_t * data_end , const uint8_t * name , uint8_t * dst , int dst_size ) { int namelen = strlen ( name ) ; int len ; while ( * data != AMF_DATA_TYPE_OBJECT && data < data_end ) { len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 ) len = data_end - data ; data += len ; } if ( data_end - data < 3 ) return - 1 ; data ++ ; for ( ; ; ) { int size = bytestream_get_be16 ( & data ) ; if ( ! size ) break ; if ( size < 0 || size >= data_end - data ) return - 1 ; data += size ; if ( size == namelen && ! memcmp ( data - size , name , namelen ) ) { switch ( * data ++ ) { case AMF_DATA_TYPE_NUMBER : snprintf ( dst , dst_size , ""%g"" , av_int2double ( AV_RB64 ( data ) ) ) ; break ; case AMF_DATA_TYPE_BOOL : snprintf ( dst , dst_size , ""%s"" , * data ? ""true"" : ""false"" ) ; break ; case AMF_DATA_TYPE_STRING : len = bytestream_get_be16 ( & data ) ; av_strlcpy ( dst , data , FFMIN ( len + 1 , dst_size ) ) ; break ; default : return - 1 ; } return 0 ; } len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 || len >= data_end - data ) return - 1 ; data += len ; } return - 1 ; }
Fixed code:","
int ff_amf_get_field_value ( const uint8_t * data , const uint8_t * data_end , const uint8_t * name , uint8_t * dst , int dst_size ) { int namelen = strlen ( name ) ; int len ; while ( * data != AMF_DATA_TYPE_OBJECT && data < data_end ) { len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 ) len = data_end - data ; data += len ; } if ( data_end - data < 3 ) return - 1 ; data ++ ; for ( ; ; ) { int size = bytestream_get_be16 ( & data ) ; if ( ! size ) break ; if ( size < 0 || size >= data_end - data ) return - 1 ; data += size ; if ( size == namelen && ! memcmp ( data - size , name , namelen ) ) { switch ( * data ++ ) { case AMF_DATA_TYPE_NUMBER : if(dst_size < sizeof(double)) { return -1; } snprintf ( dst , dst_size , ""%g"" , av_int2double ( AV_RB64 ( data ) ) ) ; break ; case AMF_DATA_TYPE_BOOL : if(dst_size < strlen(""true"")) { return -1; } snprintf ( dst , dst_size , ""%s"" , * data ? ""true"" : ""false"" ) ; break ; case AMF_DATA_TYPE_STRING : len = bytestream_get_be16 ( & data ) ; if(dst_size < len + 1) { return -1; } av_strlcpy ( dst , data , FFMIN ( len + 1 , dst_size ) ) ; break ; default : return - 1 ; } return 0 ; } len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 || len >= data_end - data ) return - 1 ; data += len ; } return - 1 ; }",464,-13.829170408850345,-0.029804246570798158
