Original code,Plausible Program,Total Tokens,Sum Entropy,Mean Entropy
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; usb_autopm_put_interface ( serial -> interface ) ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }
Fixed code:","
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kmalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; usb_autopm_put_interface ( serial -> interface ) ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; kfree(tty); reset_open_count : port -> port . count = 0 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }",931,-19.588184155866532,-0.02103994001704246
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; usb_autopm_put_interface ( serial -> interface ) ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }
Fixed code:","

static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; // Added kref_get for usb_serial_tty_driver __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; // Added kref_put for tty to prevent use-after-free tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; // Added kref_put for tty to prevent use-after-free tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; usb_autopm_put_interface ( serial -> interface ) ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock",1000,-26.149336088461787,-0.02614933608846179
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; usb_autopm_put_interface ( serial -> interface ) ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }
Fixed code:","
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; // Prevent use-after-free bug tty_port_tty_set ( & port -> port , NULL ) ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; // Increment ref count for tty to prevent use-after-free tty_kref_get ( tty ) ; tty_port_tty_set ( & port -> port , NULL ) ; // Decrement ref count after use tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; usb_autopm_put_interface ( serial -> interface ) ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return",1000,-40.077215516131986,-0.040077215516131984
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; usb_autopm_put_interface ( serial -> interface ) ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }
Fixed code:","
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; kref_put(&tty->kref,tty_release_dev); // Add release call tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; usb_autopm_put_interface ( serial -> interface ) ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }",988,-27.736309071429112,-0.028073187319260236
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; usb_autopm_put_interface ( serial -> interface ) ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }
Fixed code:","
static int usb_console_setup(struct console* co, char* options) {
    struct usbcons_info* info = &usbcons_info;
    int baud = 9600;
    int bits = 8;
    int parity = 'n';
    int doflow = 0;
    int cflag = CREAD | HUPCL | CLOCAL;
    char* s;
    struct usb_serial* serial;
    struct usb_serial_port* port;
    int retval;
    struct tty_struct* tty = NULL;
    struct ktermios dummy;
    if (options) {
        baud = simple_strtoul(options, NULL, 10);
        s = options;
        while (*s >= '0' && *s <= '9')
            s++;
        if (*s)
            parity = *s++;
        if (*s)
            bits = *s++ - '0';
        if (*s)
            doflow = (*s++ == 'r');
    }
    if (baud == 0)
        baud = 9600;
    switch (bits) {
    case 7:
        cflag |= CS7;
        break;
    default:
    case 8:
        cflag |= CS8;
        break;
    }
    switch (parity) {
    case 'o':
    case 'O':
        cflag |= PARODD;
        break;
    case 'e':
    case 'E':
        cflag |= PARENB;
        break;
    }
    co->cflag = cflag;
    port = usb_serial_port_get_by_minor(co->index);
    if (port == NULL) {
        pr_err(""No USB device connected to ttyUSB%i\\n"", co->index);
        return -ENODEV;
    }
    serial = port->serial;
    retval = usb_autopm_get_interface(serial->interface);
    if (retval)
        goto error_get_interface;
    if (!tty_port_initialized(&port->port)) {
        tty = kzalloc(sizeof(*tty), GFP_KERNEL);
        if (!tty) {
            retval = -ENOMEM;
            goto reset_open_count;
        }
        kref_init(&tty->kref);
        tty->driver = usb_serial_tty_driver;
        tty->index = co->index;
        init_ldsem(&tty->ldisc_sem);
        spin_lock_init(&tty->files_lock);
        INIT_LIST_HEAD(&tty->tty_files);
        kref_get(&tty->driver->kref);
        __module_get(tty->driver->owner);
        tty->ops = &usb_console_fake_tty_ops;
        tty_init_termios(tty);
        tty->termios.c_cflag = cflag;
        tty_termios_encode_baud_rate(&tty->termios, baud, baud);
        memset(&dummy, 0, sizeof(struct ktermios));
        retval = serial->type->open(tty, port);
        if (retval) {
            dev_err(&port->dev, ""could not open USB console port\\n"");
            goto fail_free_tty;
        }
        if (serial->type->set_termios) {
            serial->type->set_termios(tty, port, &dummy);
            tty_port_tty_set(&port->port, NULL);
            tty_kref_put(tty);
        }
        tty_port_set_initialized(&port->port, 1);
    }
reset_open_count:
    port->port.count = 0;
fail_free_tty:
    if (tty)
        kfree(tty);
    usb_autopm_put_interface(serial->interface);
error_get_interface:
    usb_serial_put(serial);
    return retval;
}",966,-35.76038350785593,-0.037019030546434704
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; usb_autopm_put_interface ( serial -> interface ) ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }
Fixed code:","
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } //Added kref_init about the tty struct kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; //Added kref_put about the tty struct tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : //Added kref_put about the tty struct tty_kref_put ( tty ) ; tty_port_tty_set ( & port -> port , NULL ) ; reset_open_count : port -> port . count = 0 ; usb_autopm_put_interface ( serial -> interface ) ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }",984,-31.450126552429545,-0.031961510724013764
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; usb_autopm_put_interface ( serial -> interface ) ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }
Fixed code:","
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; //added line to decrease reference count  kref_put(&tty->kref,tty_free); //added line to free memory if ref count is 0 } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ;",879,-33.33244601288856,-0.037920871459486416
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; usb_autopm_put_interface ( serial -> interface ) ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }
Fixed code:","
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; // kref_get ( & tty -> driver -> kref ) ; // Removed __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; // tty_port_tty_set ( & port -> port , NULL ) ; // Removed tty_kref_put ( tty ) ; // Removed } tty_port_set_initialized ( & port -> port , 1 ) ; } //-- port->port.count; // Removed port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : // tty_port_tty_set ( & port -> port , NULL ) ; // Removed // tty_kref_put ( tty ) ; // Removed reset_open_count : port -> port . count = 0 ; usb_autopm_put_interface ( serial -> interface ) ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }",985,-25.584175144178797,-0.02597378187226274
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; usb_autopm_put_interface ( serial -> interface ) ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }
Fixed code:","
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; usb_autopm_put_interface ( serial -> interface ) ; usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; usb_autopm_put_interface ( serial -> interface ) ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }",992,-11.685293070711579,-0.011779529305152801
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; usb_autopm_put_interface ( serial -> interface ) ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }
Fixed code:","
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; /* ADDED CODE: Prevent potential use-after-free */ kref_put(&tty->kref, tty_kref_put); tty_port_tty_set ( & port -> port , NULL ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } /* ADDED CODE: Prevent potential use-after-free */ kref_put(&port->port.count, port_count_put); port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; /* ADDED CODE: Prevent potential use-after-free */ kref_put(&tty->kref, tty_kref_put); reset_open_count : port -> port . count = 0 ; usb_autopm_put_interface ( serial -> interface ) ; error_get_interface :",1000,-34.185444844041854,-0.03418544484404185
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; usb_autopm_put_interface ( serial -> interface ) ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }
Fixed code:","
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; usb_autopm_put_interface ( serial -> interface ) ; usb_serial_put ( serial ) ; /* ADDED */ kfree(tty); /* ADDED */ mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; usb_autopm_put_interface ( serial -> interface ) ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }",976,-17.489569517548883,-0.017919640899127953
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; usb_autopm_put_interface ( serial -> interface ) ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }
Fixed code:","
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; //ADDED: if(tty != NULL) kref_put(&tty->kref, kref_put_usb_console); tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; if(tty != NULL) kref_put(&tty->kref, kref_put_usb_console); usb_autopm_put_interface ( serial -> interface ) ; error_get_interface : usb_serial_put ( serial",1000,-32.27572580519457,-0.03227572580519457
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; usb_autopm_put_interface ( serial -> interface ) ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }
Fixed code:","
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; kref_put(&tty->kref, tty_kref_put); // Add kref_put to free tty after use. mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; kref_put(&tty->kref, tty_kref_put); // Add kref_put to free tty after use. reset_open_count : port -> port . count = 0 ; usb_autopm_put_interface ( serial -> interface ) ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }",989,-21.186751836769876,-0.02142239821715862
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; usb_autopm_put_interface ( serial -> interface ) ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }
Fixed code:","
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ;  } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; kfree ( tty ) ; usb_autopm_put_interface ( serial -> interface ) ; usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : port -> port . count = 0 ; usb_autopm_put_interface ( serial -> interface ) ; error_get_interface : usb_serial_put ( serial ) ; kfree ( tty ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }",882,-21.30715773440524,-0.02415777520907624
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; usb_autopm_put_interface ( serial -> interface ) ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }
Fixed code:","
static int usb_console_setup ( struct console * co , char * options ) 
{ 
	struct usbcons_info * info = & usbcons_info ; 
	int baud = 9600 ; 
	int bits = 8 ; 
	int parity = 'n' ; 
	int doflow = 0 ; 
	int cflag = CREAD | HUPCL | CLOCAL ; 
	char * s ; 
	struct usb_serial * serial ; 
	struct usb_serial_port * port ; 
	int retval ; 
	struct tty_struct * tty = NULL ; 
	struct ktermios dummy ; 
	if ( options ) 
	{ 
		baud = simple_strtoul ( options , NULL , 10 ) ; 
		s = options ; 
		while ( * s >= '0' && * s <= '9' ) 
			s ++ ; 
		if ( * s ) 
			parity = * s ++ ; 
		if ( * s ) 
			bits = * s ++ - '0' ; 
		if ( * s ) 
			doflow = ( * s ++ == 'r' ) ; 
	} 

	if ( baud == 0 ) 
		baud = 9600 ; 
	switch ( bits ) 
	{ 
		case 7 : 
			cflag |= CS7 ; 
			break ; 
		default : 
		case 8 : 
			cflag |= CS8 ; 
			break ; 
	} 

	switch ( parity ) 
	{ 
		case 'o' : 
		case 'O' : 
			cflag |= PARODD ; 
			break ; 
		case 'e' : 
		case 'E' : 
			cflag |= PARENB ; 
			break ; 
	} 

	co -> cflag = cflag ; 
	port = usb_serial_port_get_by_minor ( co -> index ) ; 
	if ( port == NULL ) 
	{ 
		pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; 
		return - ENODEV ; 
	} 

	serial = port -> serial ; 
	retval = usb_autopm_get_interface ( serial -> interface ) ; 
	if ( retval ) 
		goto error_get_interface ; 
	tty_port_tty_set ( & port -> port , NULL ) ; 
	info -> port = port ; 
	++ port -> port . count ; 
	if ( ! tty_port_initialized ( & port -> port ) ) 
	{ 
		if ( serial -> type -> set_termios ) 
		{ 
			tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; 
			if ( ! tty ) 
			{ 
				retval = - ENOMEM ; 
				goto reset_open_count ; 
			} 
			kref_init ( & tty -> kref ) ; 
			tty -> driver = usb_serial_tty_driver ; 
			tty -> index = co -> index ; 
			init_ldsem ( & tty -> ldisc_sem ) ; 
			spin_lock_init ( & tty -> files_lock ) ; 
			INIT_LIST_HEAD ( & tty -> tty_files ) ; 
			kref_get ( & tty -> driver -> kref ) ; 
			__module_get ( tty -> driver -> owner ) ; 
			tty -> ops = & usb_console_fake_tty_ops ; 
			tty_init_termios ( tty ) ; 
			tty_port_tty_set ( & port -> port , tty ) ; 
		} 
		retval = serial -> type -> open",1000,-23.500601747861,-0.023500601747861
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; usb_autopm_put_interface ( serial -> interface ) ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }
Fixed code:","

static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; kref_put(&tty->kref, usb_console_fake_tty_release); //Added to fix CWE-416 bug } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; kref_put(&tty->kref, usb_console_fake_tty_release); //Added to fix CWE-416 bug reset_open_count : port -> port . count = 0 ; usb_autopm_put_interface ( serial -> interface ) ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return ret",1000,-24.36962392342071,-0.02436962392342071
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; usb_autopm_put_interface ( serial -> interface ) ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }
Fixed code:","
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; /* Add this line: */ kref_put(&tty->kref, tty_free); tty_port_tty_set ( & port -> port , NULL ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; /* Add this line: */ kref_put(&tty->kref, tty_free); reset_open_count : port -> port . count = 0 ; usb_autopm_put_interface ( serial -> interface ) ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }",986,-21.344675883704696,-0.02164774430396014
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; usb_autopm_put_interface ( serial -> interface ) ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }
Fixed code:","
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; /* Added code to prevent use after free */ tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : /* Added code to prevent use after free */ tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; usb_autopm_put_interface ( serial -> interface ) ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }",986,-18.332482101241173,-0.018592781035741555
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; usb_autopm_put_interface ( serial -> interface ) ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }
Fixed code:","
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } 
//Added code to fix the Use After Free vulnerability.
if (tty != NULL) {
    tty_port_tty_set ( & port -> port , NULL ) ;
    tty_kref_put ( tty ) ;
}
-- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; usb_autopm_put_interface ( serial -> interface ) ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }",996,-28.924305367330135,-0.029040467236275236
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; usb_autopm_put_interface ( serial -> interface ) ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }
Fixed code:","
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; /* Added code to fix the vulnerability */ if (tty) { tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } /* End of added code */ } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : /* Removed code to fix the vulnerability */ /* tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; */ /* End of removed code */  reset_open_count : port -> port . count = 0 ; usb_autopm_put_interface ( serial -> interface ) ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ;",1000,-28.800542146962435,-0.028800542146962434
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; usb_autopm_put_interface ( serial -> interface ) ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }
Fixed code:","

static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } // Added ref count to keep track of memory usage kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; // Added ref count to ensure memory is properly freed kref_put ( & tty -> kref , free_tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; // Added ref count to ensure memory is properly freed kref_put ( & tty -> kref , free_tty ) ; reset_open_count : port -> port . count = 0 ; usb_autopm_put_interface ( serial -> interface ) ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_",1000,-38.8244219548829,-0.0388244219548829
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; usb_autopm_put_interface ( serial -> interface ) ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }
Fixed code:","
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; /* Added Code */ kref_put(&tty->kref, tty_kref_put); /* Added Code */ tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; usb_autopm_put_interface ( serial -> interface ) ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }",994,-13.903457070903753,-0.013987381359058103
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; usb_autopm_put_interface ( serial -> interface ) ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }
Fixed code:","
static int usb_console_setup(struct console *co, char *options) {
    struct usbcons_info *info = &usbcons_info;
    int baud = 9600;
    int bits = 8;
    int parity = 'n';
    int doflow = 0;
    int cflag = CREAD | HUPCL | CLOCAL;
    char *s;
    struct usb_serial *serial;
    struct usb_serial_port *port;
    int retval;
    struct tty_struct *tty = NULL;
    struct ktermios dummy;

    if (options) {
        baud = simple_strtoul(options, NULL, 10);
        s = options;
        while (*s >= '0' && *s <= '9')
            s++;
        if (*s)
            parity = *s++;
        if (*s)
            bits = *s++ - '0';
        if (*s)
            doflow = (*s++ == 'r');
    }

    if (baud == 0)
        baud = 9600;

    switch (bits) {
    case 7:
        cflag |= CS7;
        break;
    default:
    case 8:
        cflag |= CS8;
        break;
    }

    switch (parity) {
    case 'o':
    case 'O':
        cflag |= PARODD;
        break;
    case 'e':
    case 'E':
        cflag |= PARENB;
        break;
    }

    co->cflag = cflag;
    port = usb_serial_port_get_by_minor(co->index);
    if (port == NULL) {
        pr_err(""No USB device connected to ttyUSB%i\n"", co->index);
        return -ENODEV;
    }
    serial = port->serial;
    retval = usb_autopm_get_interface(serial->interface);
    if (retval)
        goto error_get_interface;

    info->port = port;
    ++port->port.count;

    if (!tty_port_initialized(&port->port)) {
        if (serial->type->set_termios) {
            tty = kzalloc(sizeof(*tty), GFP_KERNEL);
            if (!tty) {
                retval = -ENOMEM;
                goto reset_open_count;
            }
            kref_init(&tty->kref);

            tty->driver = usb_serial_tty_driver;
            tty->index = co->index;
            init_ldsem(&tty->ldisc_sem);
            spin_lock_init(&tty->files_lock);
            INIT_LIST_HEAD(&tty->tty_files);
            kref_get(&tty->driver->kref);
            __module_get(tty->driver->owner);
            tty->ops = &usb_console_fake_tty_ops;
            tty_init_termios(tty);

            tty_port_tty_set(&port->port, tty);
        }

        retval = serial->type->open(NULL, port);
        if (retval) {
            dev_err(&port->dev, ""could not open USB console port\n"");
            goto fail;
        }

        if (serial->type->set_termios) {
            tty->termios.c_cflag = cflag;
            tty_termios_encode_baud_rate(&tty->termios, baud, baud);
            memset(&dummy, 0, sizeof(struct ktermios));
            serial->type->set_termios(tty, port, &dummy);
            tty_port_tty_set(&port->port, NULL);
            kref_put(&tty->kref, tty_kref_put);
            tty = NULL;
        }

        tty_port_set_initialized(&port->port, 1);
    }

    --port->port.count;
    port->port.console = 1;

fail:
    if (tty) {
        tty_port_tty_set(&port->port, NULL);
        k",1000,-39.33151897709111,-0.039331518977091105
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; usb_autopm_put_interface ( serial -> interface ) ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }
Fixed code:","
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_kref_put ( tty ) ; //Added kref_put to free tty after use kref_put(&tty->kref); } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; usb_autopm_put_interface ( serial -> interface ) ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }",973,-20.143735789115148,-0.020702708930231396
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; usb_autopm_put_interface ( serial -> interface ) ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }
Fixed code:","
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; kfree(tty); // Added to fix CWE-416 (Use After Free) } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; kfree(tty); // Added to fix CWE-416 (Use After Free) reset_open_count : port -> port . count = 0 ; usb_autopm_put_interface ( serial -> interface ) ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return",1000,-16.004283403184665,-0.016004283403184664
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; usb_autopm_put_interface ( serial -> interface ) ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }
Fixed code:","
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; if ( tty ) { tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; if ( tty ) tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; usb_autopm_put_interface ( serial -> interface ) ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }",980,-10.2605754886704,-0.010469974988439183
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; usb_autopm_put_interface ( serial -> interface ) ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }
Fixed code:","
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; kref_put(&tty->kref,tty_kref_put); tty_port_tty_set ( & port -> port , NULL ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; kref_put(&tty->kref,tty_kref_put); reset_open_count : port -> port . count = 0 ; usb_autopm_put_interface ( serial -> interface ) ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }",978,-12.63805514761448,-0.012922346776701923
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; usb_autopm_put_interface ( serial -> interface ) ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }
Fixed code:","
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; // ADDED: Added kref_put to free tty object kref_put(&tty->kref); tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; usb_autopm_put_interface ( serial -> interface ) ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }",992,-24.308658758882913,-0.024504696329519064
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; usb_autopm_put_interface ( serial -> interface ) ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }
Fixed code:","
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; kref_put (&tty->kref, kref_release);  // Added to free tty after use } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; kref_put (&tty->kref, kref_release);  // Added to free tty after use reset_open_count : port -> port . count = 0 ; usb_autopm_put_interface ( serial -> interface ) ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }",992,-25.82845356222696,-0.0260367475425675
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; usb_autopm_put_interface ( serial -> interface ) ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }
Fixed code:","
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } else { port -> port . console = 1 ; }  port -> port . count -- ; usb_autopm_put_interface ( serial -> interface ) ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; usb_autopm_put_interface ( serial -> interface ) ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }",990,-24.715395309165324,-0.02496504576683366
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; usb_autopm_put_interface ( serial -> interface ) ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }
Fixed code:","
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; //Added kref_put to prevent use after free kref_put(&tty->kref,tty_cleanup); tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; usb_autopm_put_interface ( serial -> interface ) ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }",994,-19.06142181531992,-0.019176480699517023
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; usb_autopm_put_interface ( serial -> interface ) ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }
Fixed code:","
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; void *ptr = NULL; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { ptr = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ptr ) { tty = (struct tty_struct *)ptr; kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } else { retval = - ENOMEM ; goto reset_open_count ; } } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; if(ptr != NULL) { tty_kref_put ( tty ) ; kfree(ptr); } reset_open_count : port -> port . count = 0 ; usb_autopm_put_interface ( serial -> interface ) ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }
",1000,-27.2155441001995,-0.027215544100199503
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; usb_autopm_put_interface ( serial -> interface ) ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }
Fixed code:","
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; // Added line to prevent use after free kfree(tty); } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; // Added line to prevent use after free kfree(tty); reset_open_count : port -> port . count = 0 ; usb_autopm_put_interface ( serial -> interface ) ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }",970,-14.310968317902866,-0.014753575585466873
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; usb_autopm_put_interface ( serial -> interface ) ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }
Fixed code:"," 
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; // Added this line to fix CWE-416 kref_put(&tty->kref, tty_kref_put); tty_port_tty_set ( & port -> port , NULL ) ; // Added this line to fix CWE-416 kfree(tty); } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; // Added this line to fix CWE-416 kref_put(&tty->kref, tty_kref_put); reset_open_count : port -> port . count = 0 ; usb_autopm_put_interface ( serial -> interface ) ; error_get_interface : usb_serial_put ( serial ) ; mutex_un",1000,-23.55099185333557,-0.02355099185333557
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; usb_autopm_put_interface ( serial -> interface ) ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }
Fixed code:","
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; //Added check to prevent use-after-free vulnerability if(info->port == NULL){ tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; } ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; usb_autopm_put_interface ( serial -> interface ) ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }",988,-25.630216210641073,-0.025941514383239953
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; usb_autopm_put_interface ( serial -> interface ) ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }
Fixed code:","
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; //ADDED: if (atomic_read(&port->port.count) > 0) goto reset_open_count; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; usb_autopm_put_interface ( serial -> interface ) ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }",994,-18.347909173990967,-0.018458661140835983
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; usb_autopm_put_interface ( serial -> interface ) ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }
Fixed code:","
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; /* Add kref_put to avoid Use After Free */ tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; kref_put( & tty->kref, usb_console_tty_release); } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; kref_put( & tty->kref, usb_console_tty_release); reset_open_count : port -> port . count = 0 ; usb_autopm_put_interface ( serial -> interface ) ; error_get_interface : usb_serial_put ( serial ) ;",1000,-25.643391102007786,-0.025643391102007786
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; usb_autopm_put_interface ( serial -> interface ) ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }
Fixed code:","
static int usb_console_setup ( struct console * co , char * options ) { 
struct usbcons_info * info = & usbcons_info ; 
int baud = 9600 ; 
int bits = 8 ; 
int parity = 'n' ; 
int doflow = 0 ; 
int cflag = CREAD | HUPCL | CLOCAL ; 
char * s ; 
struct usb_serial * serial ; 
struct usb_serial_port * port ; 
int retval ; 
struct tty_struct * tty = NULL ; 
struct ktermios dummy ; 
if ( options ) { 
    baud = simple_strtoul ( options , NULL , 10 ) ; 
    s = options ; 
    while ( * s >= '0' && * s <= '9' ) s ++ ; 
    if ( * s ) parity = * s ++ ; 
    if ( * s ) bits = * s ++ - '0' ; 
    if ( * s ) doflow = ( * s ++ == 'r' ) ; 
} 
if ( baud == 0 ) baud = 9600 ; 
switch ( bits ) { 
    case 7 : cflag |= CS7 ; break ; 
    default : case 8 : cflag |= CS8 ; break ; 
} 
switch ( parity ) { 
    case 'o' : case 'O' : cflag |= PARODD ; break ; 
    case 'e' : case 'E' : cflag |= PARENB ; break ; 
} 
co -> cflag = cflag ; 
port = usb_serial_port_get_by_minor ( co -> index ) ; 
if ( port == NULL ) { 
    pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; 
    return - ENODEV ; 
} 
serial = port -> serial ; 
retval = usb_autopm_get_interface ( serial -> interface ) ; 
if ( retval ) goto error_get_interface ; 
tty_port_tty_set ( & port -> port , NULL ) ; 
info -> port = port ; 
++ port -> port . count ; 
if ( ! tty_port_initialized ( & port -> port ) ) { 
    if ( serial -> type -> set_termios ) { 
        tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; 
        if ( ! tty ) { 
            retval = - ENOMEM ; 
            goto reset_open_count ; 
        } 
        kref_init ( & tty -> kref ) ; 
        tty -> driver = usb_serial_tty_driver ; 
        tty -> index = co -> index ; 
        init_ldsem ( & tty -> ldisc_sem ) ; 
        spin_lock_init ( & tty -> files_lock ) ; 
        INIT_LIST_HEAD ( & tty -> tty_files ) ; 
        kref_get ( & tty -> driver -> kref ) ; 
        __module_get ( tty -> driver -> owner ) ; 
        tty -> ops = & usb_console_fake_tty_ops ; 
        tty_init_termios ( tty ) ; 
        tty_port_tty_set ( & port -> port , tty ) ; 
    } 
    retval = serial -> type -> open ( NULL , port ) ; 
    if ( retval ) { 
        dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; 
        goto fail ; 
    } 
    if ( serial -> type -> set_termios ) { 
        tty -> termios . c_cflag = cflag ; 
        tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; 
        memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; 
        serial -> type -> set_termios ( tty , port , & dummy ) ; 
    } 
    tty_port_set_initialized ( & port -> port , 1 ) ; 
}
kfree",1000,-16.738950853119515,-0.016738950853119515
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; usb_autopm_put_interface ( serial -> interface ) ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }
Fixed code:","
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; kref_put(&tty->kref, tty_destroy); /* Add kref_put to free up memory */ tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; usb_autopm_put_interface ( serial -> interface ) ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }",994,-23.127738115941852,-0.023267342168955586
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; usb_autopm_put_interface ( serial -> interface ) ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }
Fixed code:","
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; kref_init ( & port -> kref ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { kref_get ( & port -> kref ) ; if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; kref_put ( & port -> kref , usb_serial_port_release ) ; usb_autopm_put_interface ( serial -> interface ) ; usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; usb_autopm_put_interface ( serial -> interface )",1000,-23.62284254410365,-0.023622842544103653
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; usb_autopm_put_interface ( serial -> interface ) ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }
Fixed code:","
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; kref_put ( & tty -> kref , tty_cleanup ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } usb_autopm_put_interface ( serial -> interface ) ; usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : usb_autopm_put_interface ( serial -> interface ) ; usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }",980,-19.803063136283647,-0.020207207281922088
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; usb_autopm_put_interface ( serial -> interface ) ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }
Fixed code:","
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; // Added Ref counting kref_get(&tty->kref); } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; // Added Ref counting kref_put(&tty->kref, tty_kref_put); } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; // Added Ref counting kref_put(&tty->kref, tty_kref_put); reset_open_count : port -> port . count = 0 ; usb_autopm_put_interface ( serial -> interface ) ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval",1000,-23.48758185090939,-0.02348758185090939
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; usb_autopm_put_interface ( serial -> interface ) ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }
Fixed code:","
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; if (!try_module_get ( tty -> driver -> owner )) { // Prevents use after free retval = - ENODEV; goto fail; } tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; usb_autopm_put_interface ( serial -> interface ) ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }",989,-22.067412098884787,-0.022312853487244478
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; usb_autopm_put_interface ( serial -> interface ) ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }
Fixed code:","
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; kfree(tty); //Fix: added kfree to free the allocated memory. } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; //Fix: added kfree to free the allocated memory. kfree(tty); tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; usb_autopm_put_interface ( serial -> interface ) ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval",1000,-27.41077471540281,-0.02741077471540281
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; usb_autopm_put_interface ( serial -> interface ) ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }
Fixed code:","
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; //Added line kfree(tty); tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; usb_autopm_put_interface ( serial -> interface ) ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }",976,-14.99946340962769,-0.015368302673798863
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; usb_autopm_put_interface ( serial -> interface ) ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }
Fixed code:","
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; if ( ! tty_port_initialized ( & port -> port ) ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail_free_tty ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail_free_tty : kfree(tty); reset_open_count : port -> port . count = 0 ; usb_autopm_put_interface ( serial -> interface ) ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }",902,-22.122943540383716,-0.024526544944993033
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; usb_autopm_put_interface ( serial -> interface ) ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }
Fixed code:","

static int usb_console_setup ( struct console* co, char* options ) {
   struct usbcons_info* info = &usbcons_info;
   int baud = 9600;
   int bits = 8;
   int parity = 'n';
   int doflow = 0;
   int cflag = CREAD | HUPCL | CLOCAL;
   char* s;
   struct usb_serial* serial;
   struct usb_serial_port* port;
   int retval;
   struct tty_struct* tty = NULL;
   struct ktermios dummy;
   
   if ( options ) {
      baud = simple_strtoul( options, NULL, 10 );
      s = options;
      while (*s >= '0' && *s <= '9') s++;
      if (*s) parity = *s++;
      if (*s) bits = *s++ - '0';
      if (*s) doflow = (*s++ == 'r');
   }
   if ( baud == 0 ) baud = 9600;
   switch (bits) {
      case 7: cflag |= CS7; break;
      default: case 8: cflag |= CS8; break;
   }
   switch (parity) {
      case 'o': case 'O': cflag |= PARODD; break;
      case 'e': case 'E': cflag |= PARENB; break;
   }
   co->cflag = cflag;
   port = usb_serial_port_get_by_minor( co->index );
   if ( port == NULL ) {
      pr_err( ""No USB device connected to ttyUSB%i\n"", co->index );
      return -ENODEV;
   }
   serial = port->serial;
   retval = usb_autopm_get_interface( serial->interface );
   if (retval) goto error_get_interface;
   tty_port_tty_set( &port->port, NULL );
   info->port = port;
   kref_get(&port->port.kref);  // Added
   ++port->port.count;
   
   if ( ! tty_port_initialized( &port->port ) ) {
      if (serial->type->set_termios) {
         tty = kzalloc( sizeof(*tty), GFP_KERNEL );
         if ( ! tty ) {
            retval = -ENOMEM;
            goto reset_open_count;
         }
         kref_init(&tty->kref);
         tty->driver = usb_serial_tty_driver;
         tty->index = co->index;
         init_ldsem( &tty->ldisc_sem );
         spin_lock_init( &tty->files_lock );
         INIT_LIST_HEAD(&tty->tty_files);
         kref_get(&tty->driver->kref);
         __module_get(tty->driver->owner);
         tty->ops = &usb_console_fake_tty_ops;
         tty_init_termios( tty );
         tty_port_tty_set( &port->port, tty );
      }
      retval = serial->type->open( NULL, port );
      if (retval) {
         dev_err( &port->dev, ""could not open USB console port\n"" );
         goto fail;
      }
      if ( serial->type->set_termios ) {
         tty->termios.c_cflag = cflag;
         tty_termios_encode_baud_rate( &tty->termios, baud, baud );
         memset( &dummy, 0, sizeof(struct ktermios) );
         serial->type->set_termios( tty, port, &dummy );
         tty_port_tty_set( &port->port, NULL );
         tty_kref_put(tty); // Added
      }
      tty_port_set_initialized( &port->port, 1 );
   }
--port->port.count;
port->port.console = 1;
kref_put(&port->port.kref, port_release); // Added
mut",1000,-72.14766704597126,-0.07214766704597127
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; usb_autopm_put_interface ( serial -> interface ) ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }
Fixed code:","
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; //Add kref_put() to free the tty_struct object kref_put(&tty->kref); tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; tty = NULL; //Add a NULL assignment to the tty_struct object } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : if(tty) { //Check for a valid tty_struct object and if so, free it. kref_put(&tty->kref); tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; tty = NULL; } reset_open_count : port -> port . count = 0 ; usb_",1000,-61.39501010451482,-0.06139501010451482
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; usb_autopm_put_interface ( serial -> interface ) ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }
Fixed code:","
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; //Add: kfree(tty); to prevent use after free kfree(tty); } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; //Add: kfree(tty); to prevent use after free kfree(tty); reset_open_count : port -> port . count = 0 ; usb_autopm_put_interface ( serial -> interface ) ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }",980,-21.22550757706046,-0.0216586812010821
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; usb_autopm_put_interface ( serial -> interface ) ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }
Fixed code:","

static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; kref_put(&tty->kref, tty_cleanup); //Added line to fix CWE-416 usb_autopm_put_interface ( serial -> interface ) ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; kref_put(&tty->kref, tty_cleanup); //Added line to fix CWE-416 reset_open_count : port -> port . count = 0 ; usb_autopm_put_interface ( serial -> interface ) ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mut",1000,-20.28933490794993,-0.02028933490794993
