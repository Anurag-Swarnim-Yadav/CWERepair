Original code,Plausible Program,Total Tokens,Sum Entropy,Mean Entropy
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
int inet6_sk_rebuild_header ( struct sock * sk ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct dst_entry * dst ; dst = __sk_dst_check ( sk , np -> dst_cookie ) ; if ( ! dst ) { struct inet_sock * inet = inet_sk ( sk ) ; struct in6_addr * final_p , final ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = sk -> sk_protocol ; fl6 . daddr = sk -> sk_v6_daddr ; fl6 . saddr = np -> saddr ; fl6 . flowlabel = np -> flow_label ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = sk -> sk_mark ; fl6 . fl6_dport = inet -> inet_dport ; fl6 . fl6_sport = inet -> inet_sport ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { sk -> sk_route_caps = 0 ; sk -> sk_err_soft = - PTR_ERR ( dst ) ; return PTR_ERR ( dst ) ; } __ip6_dst_store ( sk , dst , NULL , NULL ) ; } return 0 ; }
Fixed code:","
int inet6_sk_rebuild_header ( struct sock * sk ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct dst_entry * dst ; // Lock the sk struct to prevent use after free sk_dst_check  sk_lock(sk); dst = __sk_dst_check ( sk , np -> dst_cookie ) ; if ( ! dst ) { struct inet_sock * inet = inet_sk ( sk ) ; struct in6_addr * final_p , final ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = sk -> sk_protocol ; fl6 . daddr = sk -> sk_v6_daddr ; fl6 . saddr = np -> saddr ; fl6 . flowlabel = np -> flow_label ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = sk -> sk_mark ; fl6 . fl6_dport = inet -> inet_dport ; fl6 . fl6_sport = inet -> inet_sport ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { sk -> sk_route_caps = 0 ; sk -> sk_err_soft = - PTR_ERR ( dst ) ; sk_unlock(sk); // unlock the sk struct return PTR_ERR ( dst ) ; } __ip6_dst_store ( sk , dst , NULL , NULL ) ; } sk_unlock(sk); // unlock the sk struct return 0 ; }",445,-35.445485596949084,-0.0796527766223575
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
int inet6_sk_rebuild_header ( struct sock * sk ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct dst_entry * dst ; dst = __sk_dst_check ( sk , np -> dst_cookie ) ; if ( ! dst ) { struct inet_sock * inet = inet_sk ( sk ) ; struct in6_addr * final_p , final ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = sk -> sk_protocol ; fl6 . daddr = sk -> sk_v6_daddr ; fl6 . saddr = np -> saddr ; fl6 . flowlabel = np -> flow_label ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = sk -> sk_mark ; fl6 . fl6_dport = inet -> inet_dport ; fl6 . fl6_sport = inet -> inet_sport ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { sk -> sk_route_caps = 0 ; sk -> sk_err_soft = - PTR_ERR ( dst ) ; return PTR_ERR ( dst ) ; } __ip6_dst_store ( sk , dst , NULL , NULL ) ; } return 0 ; }
Fixed code:","
int inet6_sk_rebuild_header ( struct sock * sk ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct dst_entry * dst ; dst = __sk_dst_check ( sk , np -> dst_cookie ) ; if ( ! dst ) { struct inet_sock * inet = inet_sk ( sk ) ; struct in6_addr * final_p , final ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = sk -> sk_protocol ; fl6 . daddr = sk -> sk_v6_daddr ; fl6 . saddr = np -> saddr ; fl6 . flowlabel = np -> flow_label ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = sk -> sk_mark ; fl6 . fl6_dport = inet -> inet_dport ; fl6 . fl6_sport = inet -> inet_sport ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { sk -> sk_route_caps = 0 ; sk -> sk_err_soft = - PTR_ERR ( dst ) ; return PTR_ERR ( dst ) ; } __ip6_dst_store ( sk , dst , NULL , NULL ) ; dst_release(dst); // add reference to dst_release } return 0 ; }",412,-16.84422987156275,-0.04088405308631735
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
int inet6_sk_rebuild_header ( struct sock * sk ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct dst_entry * dst ; dst = __sk_dst_check ( sk , np -> dst_cookie ) ; if ( ! dst ) { struct inet_sock * inet = inet_sk ( sk ) ; struct in6_addr * final_p , final ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = sk -> sk_protocol ; fl6 . daddr = sk -> sk_v6_daddr ; fl6 . saddr = np -> saddr ; fl6 . flowlabel = np -> flow_label ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = sk -> sk_mark ; fl6 . fl6_dport = inet -> inet_dport ; fl6 . fl6_sport = inet -> inet_sport ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { sk -> sk_route_caps = 0 ; sk -> sk_err_soft = - PTR_ERR ( dst ) ; return PTR_ERR ( dst ) ; } __ip6_dst_store ( sk , dst , NULL , NULL ) ; } return 0 ; }
Fixed code:","
int inet6_sk_rebuild_header ( struct sock * sk ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct dst_entry * dst ; dst = __sk_dst_check ( sk , np -> dst_cookie ) ; if ( dst ) { dst_release(dst); } struct inet_sock * inet = inet_sk ( sk ) ; struct in6_addr * final_p , final ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = sk -> sk_protocol ; fl6 . daddr = sk -> sk_v6_daddr ; fl6 . saddr = np -> saddr ; fl6 . flowlabel = np -> flow_label ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = sk -> sk_mark ; fl6 . fl6_dport = inet -> inet_dport ; fl6 . fl6_sport = inet -> inet_sport ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { sk -> sk_route_caps = 0 ; sk -> sk_err_soft = - PTR_ERR ( dst ) ; return PTR_ERR ( dst ) ; } __ip6_dst_store ( sk , dst , NULL , NULL ) ; return 0 ; }",404,-4.806384872982241,-0.011896992259857032
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
int inet6_sk_rebuild_header ( struct sock * sk ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct dst_entry * dst ; dst = __sk_dst_check ( sk , np -> dst_cookie ) ; if ( ! dst ) { struct inet_sock * inet = inet_sk ( sk ) ; struct in6_addr * final_p , final ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = sk -> sk_protocol ; fl6 . daddr = sk -> sk_v6_daddr ; fl6 . saddr = np -> saddr ; fl6 . flowlabel = np -> flow_label ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = sk -> sk_mark ; fl6 . fl6_dport = inet -> inet_dport ; fl6 . fl6_sport = inet -> inet_sport ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { sk -> sk_route_caps = 0 ; sk -> sk_err_soft = - PTR_ERR ( dst ) ; return PTR_ERR ( dst ) ; } __ip6_dst_store ( sk , dst , NULL , NULL ) ; } return 0 ; }
Fixed code:","
int inet6_sk_rebuild_header ( struct sock * sk ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct dst_entry * dst ; dst = __sk_dst_check ( sk , np -> dst_cookie ) ; if ( ! dst ) { struct inet_sock * inet = inet_sk ( sk ) ; struct in6_addr * final_p , final ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = sk -> sk_protocol ; fl6 . daddr = sk -> sk_v6_daddr ; fl6 . saddr = np -> saddr ; fl6 . flowlabel = np -> flow_label ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = sk -> sk_mark ; fl6 . fl6_dport = inet -> inet_dport ; fl6 . fl6_sport = inet -> inet_sport ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { sk -> sk_route_caps = 0 ; sk -> sk_err_soft = - PTR_ERR ( dst ) ; return PTR_ERR ( dst ) ; } __ip6_dst_store ( sk , dst , NULL , kfree_dst ) ; // Added kfree_dst to free dst after use } return 0 ; }",414,-16.89942545325595,-0.040819868244579595
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
int inet6_sk_rebuild_header ( struct sock * sk ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct dst_entry * dst ; dst = __sk_dst_check ( sk , np -> dst_cookie ) ; if ( ! dst ) { struct inet_sock * inet = inet_sk ( sk ) ; struct in6_addr * final_p , final ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = sk -> sk_protocol ; fl6 . daddr = sk -> sk_v6_daddr ; fl6 . saddr = np -> saddr ; fl6 . flowlabel = np -> flow_label ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = sk -> sk_mark ; fl6 . fl6_dport = inet -> inet_dport ; fl6 . fl6_sport = inet -> inet_sport ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { sk -> sk_route_caps = 0 ; sk -> sk_err_soft = - PTR_ERR ( dst ) ; return PTR_ERR ( dst ) ; } __ip6_dst_store ( sk , dst , NULL , NULL ) ; } return 0 ; }
Fixed code:","
int inet6_sk_rebuild_header ( struct sock * sk ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct dst_entry * dst ; dst = __sk_dst_check ( sk , np -> dst_cookie ) ; if ( ! dst ) { struct inet_sock * inet = inet_sk ( sk ) ; struct in6_addr * final_p , final ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = sk -> sk_protocol ; fl6 . daddr = sk -> sk_v6_daddr ; fl6 . saddr = np -> saddr ; fl6 . flowlabel = np -> flow_label ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = sk -> sk_mark ; fl6 . fl6_dport = inet -> inet_dport ; fl6 . fl6_sport = inet -> inet_sport ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { sk_dst_reset ( sk ) ; sk -> sk_route_caps = 0 ; sk -> sk_err_soft = - PTR_ERR ( dst ) ; return PTR_ERR ( dst ) ; } __ip6_dst_store ( sk , dst , NULL , NULL ) ; } return 0 ; }",408,-4.937863832535782,-0.01210260743268574
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
int inet6_sk_rebuild_header ( struct sock * sk ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct dst_entry * dst ; dst = __sk_dst_check ( sk , np -> dst_cookie ) ; if ( ! dst ) { struct inet_sock * inet = inet_sk ( sk ) ; struct in6_addr * final_p , final ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = sk -> sk_protocol ; fl6 . daddr = sk -> sk_v6_daddr ; fl6 . saddr = np -> saddr ; fl6 . flowlabel = np -> flow_label ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = sk -> sk_mark ; fl6 . fl6_dport = inet -> inet_dport ; fl6 . fl6_sport = inet -> inet_sport ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { sk -> sk_route_caps = 0 ; sk -> sk_err_soft = - PTR_ERR ( dst ) ; return PTR_ERR ( dst ) ; } __ip6_dst_store ( sk , dst , NULL , NULL ) ; } return 0 ; }
Fixed code:","
int inet6_sk_rebuild_header ( struct sock * sk ) { 
    struct ipv6_pinfo * np = inet6_sk ( sk ) ; 
    struct dst_entry * dst ; 
    dst = __sk_dst_check ( sk , np -> dst_cookie ) ; 
    if ( ! dst ) { 
        struct inet_sock * inet = inet_sk ( sk ) ; 
        struct in6_addr * final_p , final ; 
        struct flowi6 fl6 ; 
        memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; 
        fl6 . flowi6_proto = sk -> sk_protocol ; 
        fl6 . daddr = sk -> sk_v6_daddr ; 
        fl6 . saddr = np -> saddr ; 
        fl6 . flowlabel = np -> flow_label ; 
        fl6 . flowi6_oif = sk -> sk_bound_dev_if ; 
        fl6 . flowi6_mark = sk -> sk_mark ; 
        fl6 . fl6_dport = inet -> inet_dport ; 
        fl6 . fl6_sport = inet -> inet_sport ; 
        security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; 
        final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ;
        dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; 
        if ( IS_ERR ( dst ) ) { 
            sk -> sk_route_caps = 0 ; 
            sk -> sk_err_soft = - PTR_ERR ( dst ) ; 
            return PTR_ERR ( dst ) ; 
        } 
        dst_release(dst); // Add this line to prevent use-after-free
        __ip6_dst_store ( sk , dst , NULL , NULL ) ; 
    } 
    return 0 ; 
}",500,-22.590257081321756,-0.045180514162643515
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
int inet6_sk_rebuild_header ( struct sock * sk ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct dst_entry * dst ; dst = __sk_dst_check ( sk , np -> dst_cookie ) ; if ( ! dst ) { struct inet_sock * inet = inet_sk ( sk ) ; struct in6_addr * final_p , final ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = sk -> sk_protocol ; fl6 . daddr = sk -> sk_v6_daddr ; fl6 . saddr = np -> saddr ; fl6 . flowlabel = np -> flow_label ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = sk -> sk_mark ; fl6 . fl6_dport = inet -> inet_dport ; fl6 . fl6_sport = inet -> inet_sport ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { sk -> sk_route_caps = 0 ; sk -> sk_err_soft = - PTR_ERR ( dst ) ; return PTR_ERR ( dst ) ; } __ip6_dst_store ( sk , dst , NULL , NULL ) ; } return 0 ; }
Fixed code:","
int inet6_sk_rebuild_header ( struct sock * sk ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct dst_entry * dst ; dst = __sk_dst_check ( sk , np -> dst_cookie ) ; if ( ! dst ) { struct inet_sock * inet = inet_sk ( sk ) ; struct in6_addr * final_p , final ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = sk -> sk_protocol ; fl6 . daddr = sk -> sk_v6_daddr ; fl6 . saddr = np -> saddr ; fl6 . flowlabel = np -> flow_label ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = sk -> sk_mark ; fl6 . fl6_dport = inet -> inet_dport ; fl6 . fl6_sport = inet -> inet_sport ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { sk -> sk_route_caps = 0 ; sk -> sk_err_soft = - PTR_ERR ( dst ) ; return PTR_ERR ( dst ) ; } if ( dst ) { __ip6_dst_store ( sk , dst , NULL , NULL ) ; dst_release(dst); } return 0 ; }",410,-10.23046120654771,-0.02495234440621393
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
int inet6_sk_rebuild_header ( struct sock * sk ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct dst_entry * dst ; dst = __sk_dst_check ( sk , np -> dst_cookie ) ; if ( ! dst ) { struct inet_sock * inet = inet_sk ( sk ) ; struct in6_addr * final_p , final ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = sk -> sk_protocol ; fl6 . daddr = sk -> sk_v6_daddr ; fl6 . saddr = np -> saddr ; fl6 . flowlabel = np -> flow_label ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = sk -> sk_mark ; fl6 . fl6_dport = inet -> inet_dport ; fl6 . fl6_sport = inet -> inet_sport ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { sk -> sk_route_caps = 0 ; sk -> sk_err_soft = - PTR_ERR ( dst ) ; return PTR_ERR ( dst ) ; } __ip6_dst_store ( sk , dst , NULL , NULL ) ; } return 0 ; }
Fixed code:","
int inet6_sk_rebuild_header ( struct sock * sk ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct dst_entry * dst ; // Acquire lock to prevent other threads from accessing dst dst_acquire_lock(sk); dst = __sk_dst_check ( sk , np -> dst_cookie ) ; if ( ! dst ) { struct inet_sock * inet = inet_sk ( sk ) ; struct in6_addr * final_p , final ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = sk -> sk_protocol ; fl6 . daddr = sk -> sk_v6_daddr ; fl6 . saddr = np -> saddr ; fl6 . flowlabel = np -> flow_label ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = sk -> sk_mark ; fl6 . fl6_dport = inet -> inet_dport ; fl6 . fl6_sport = inet -> inet_sport ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { sk -> sk_route_caps = 0 ; sk -> sk_err_soft = - PTR_ERR ( dst ) ; //Release lock before returning dst_release_lock(sk); return PTR_ERR ( dst ) ; } __ip6_dst_store ( sk , dst , NULL , NULL ) ; } //Release lock before returning dst_release_lock(sk); return 0 ; }",444,-29.982338029325398,-0.06752778835433648
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
int inet6_sk_rebuild_header ( struct sock * sk ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct dst_entry * dst ; dst = __sk_dst_check ( sk , np -> dst_cookie ) ; if ( ! dst ) { struct inet_sock * inet = inet_sk ( sk ) ; struct in6_addr * final_p , final ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = sk -> sk_protocol ; fl6 . daddr = sk -> sk_v6_daddr ; fl6 . saddr = np -> saddr ; fl6 . flowlabel = np -> flow_label ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = sk -> sk_mark ; fl6 . fl6_dport = inet -> inet_dport ; fl6 . fl6_sport = inet -> inet_sport ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { sk -> sk_route_caps = 0 ; sk -> sk_err_soft = - PTR_ERR ( dst ) ; return PTR_ERR ( dst ) ; } __ip6_dst_store ( sk , dst , NULL , NULL ) ; } return 0 ; }
Fixed code:","
int inet6_sk_rebuild_header ( struct sock * sk ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct dst_entry * dst ; dst = __sk_dst_check ( sk , np -> dst_cookie ) ; if ( ! dst ) { struct inet_sock * inet = inet_sk ( sk ) ; struct in6_addr * final_p , final ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = sk -> sk_protocol ; fl6 . daddr = sk -> sk_v6_daddr ; fl6 . saddr = np -> saddr ; fl6 . flowlabel = np -> flow_label ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = sk -> sk_mark ; fl6 . fl6_dport = inet -> inet_dport ; fl6 . fl6_sport = inet -> inet_sport ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { sk -> sk_route_caps = 0 ; sk -> sk_err_soft = - PTR_ERR ( dst ) ; dst_release(dst); return PTR_ERR ( dst ) ; } __ip6_dst_store ( sk , dst , NULL , NULL ) ; } return 0 ; }

The fixed code adds a line ‘dst_release(dst);’ which releases the previously allocated dst memory before the function returns. This prevents the code from accessing the freed memory.",447,-45.55738917098848,-0.10191809657939258
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
int inet6_sk_rebuild_header ( struct sock * sk ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct dst_entry * dst ; dst = __sk_dst_check ( sk , np -> dst_cookie ) ; if ( ! dst ) { struct inet_sock * inet = inet_sk ( sk ) ; struct in6_addr * final_p , final ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = sk -> sk_protocol ; fl6 . daddr = sk -> sk_v6_daddr ; fl6 . saddr = np -> saddr ; fl6 . flowlabel = np -> flow_label ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = sk -> sk_mark ; fl6 . fl6_dport = inet -> inet_dport ; fl6 . fl6_sport = inet -> inet_sport ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { sk -> sk_route_caps = 0 ; sk -> sk_err_soft = - PTR_ERR ( dst ) ; return PTR_ERR ( dst ) ; } __ip6_dst_store ( sk , dst , NULL , NULL ) ; } return 0 ; }
Fixed code:","
int inet6_sk_rebuild_header ( struct sock * sk ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct dst_entry * dst ; dst = __sk_dst_check ( sk , np -> dst_cookie ) ; if ( ! dst ) { struct inet_sock * inet = inet_sk ( sk ) ; struct in6_addr * final_p , final ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = sk -> sk_protocol ; fl6 . daddr = sk -> sk_v6_daddr ; fl6 . saddr = np -> saddr ; fl6 . flowlabel = np -> flow_label ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = sk -> sk_mark ; fl6 . fl6_dport = inet -> inet_dport ; fl6 . fl6_sport = inet -> inet_sport ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { sk -> sk_route_caps = 0 ; sk -> sk_err_soft = - PTR_ERR ( dst ) ; dst_release(dst); // Added return PTR_ERR ( dst ) ; } __ip6_dst_store ( sk , dst , NULL , NULL ) ; } return 0 ; }",407,-8.304141173570855,-0.020403295266758856
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
int inet6_sk_rebuild_header ( struct sock * sk ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct dst_entry * dst ; dst = __sk_dst_check ( sk , np -> dst_cookie ) ; if ( ! dst ) { struct inet_sock * inet = inet_sk ( sk ) ; struct in6_addr * final_p , final ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = sk -> sk_protocol ; fl6 . daddr = sk -> sk_v6_daddr ; fl6 . saddr = np -> saddr ; fl6 . flowlabel = np -> flow_label ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = sk -> sk_mark ; fl6 . fl6_dport = inet -> inet_dport ; fl6 . fl6_sport = inet -> inet_sport ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { sk -> sk_route_caps = 0 ; sk -> sk_err_soft = - PTR_ERR ( dst ) ; return PTR_ERR ( dst ) ; } __ip6_dst_store ( sk , dst , NULL , NULL ) ; } return 0 ; }
Fixed code:","
int inet6_sk_rebuild_header ( struct sock * sk ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct dst_entry * dst ; dst = __sk_dst_check ( sk , np -> dst_cookie ) ; if ( ! dst ) { struct inet_sock * inet = inet_sk ( sk ) ; struct in6_addr * final_p , final ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = sk -> sk_protocol ; fl6 . daddr = sk -> sk_v6_daddr ; fl6 . saddr = np -> saddr ; fl6 . flowlabel = np -> flow_label ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = sk -> sk_mark ; fl6 . fl6_dport = inet -> inet_dport ; fl6 . fl6_sport = inet -> inet_sport ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { sk -> sk_route_caps = 0 ; sk -> sk_err_soft = - PTR_ERR ( dst ) ; return PTR_ERR ( dst ) ; } dst_confirm ( dst ) ; __ip6_dst_store ( sk , dst , NULL , NULL ) ; } return 0 ; }",406,-10.397358246006881,-0.025609256763563747
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
int inet6_sk_rebuild_header ( struct sock * sk ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct dst_entry * dst ; dst = __sk_dst_check ( sk , np -> dst_cookie ) ; if ( ! dst ) { struct inet_sock * inet = inet_sk ( sk ) ; struct in6_addr * final_p , final ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = sk -> sk_protocol ; fl6 . daddr = sk -> sk_v6_daddr ; fl6 . saddr = np -> saddr ; fl6 . flowlabel = np -> flow_label ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = sk -> sk_mark ; fl6 . fl6_dport = inet -> inet_dport ; fl6 . fl6_sport = inet -> inet_sport ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { sk -> sk_route_caps = 0 ; sk -> sk_err_soft = - PTR_ERR ( dst ) ; return PTR_ERR ( dst ) ; } __ip6_dst_store ( sk , dst , NULL , NULL ) ; } return 0 ; }
Fixed code:","
int inet6_sk_rebuild_header ( struct sock * sk ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct dst_entry * dst ; dst = __sk_dst_check ( sk , np -> dst_cookie ) ; if ( ! dst ) { struct inet_sock * inet = inet_sk ( sk ) ; struct in6_addr * final_p , final ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = sk -> sk_protocol ; fl6 . daddr = sk -> sk_v6_daddr ; fl6 . saddr = np -> saddr ; fl6 . flowlabel = np -> flow_label ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = sk -> sk_mark ; fl6 . fl6_dport = inet -> inet_dport ; fl6 . fl6_sport = inet -> inet_sport ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { sk -> sk_route_caps = 0 ; sk -> sk_err_soft = - PTR_ERR ( dst ) ; return PTR_ERR ( dst ) ; } else { if ( dst ) { dst_release ( dst ) ; } } __ip6_dst_store ( sk , dst , NULL , NULL ) ; } return 0 ; }",414,-10.383706195091154,-0.02508141593017187
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
int inet6_sk_rebuild_header ( struct sock * sk ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct dst_entry * dst ; dst = __sk_dst_check ( sk , np -> dst_cookie ) ; if ( ! dst ) { struct inet_sock * inet = inet_sk ( sk ) ; struct in6_addr * final_p , final ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = sk -> sk_protocol ; fl6 . daddr = sk -> sk_v6_daddr ; fl6 . saddr = np -> saddr ; fl6 . flowlabel = np -> flow_label ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = sk -> sk_mark ; fl6 . fl6_dport = inet -> inet_dport ; fl6 . fl6_sport = inet -> inet_sport ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { sk -> sk_route_caps = 0 ; sk -> sk_err_soft = - PTR_ERR ( dst ) ; return PTR_ERR ( dst ) ; } __ip6_dst_store ( sk , dst , NULL , NULL ) ; } return 0 ; }
Fixed code:","
int inet6_sk_rebuild_header ( struct sock * sk ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct dst_entry * dst ; dst = __sk_dst_check ( sk , np -> dst_cookie ) ; if ( ! dst ) { struct inet_sock * inet = inet_sk ( sk ) ; struct in6_addr * final_p , final ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = sk -> sk_protocol ; fl6 . daddr = sk -> sk_v6_daddr ; fl6 . saddr = np -> saddr ; fl6 . flowlabel = np -> flow_label ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = sk -> sk_mark ; fl6 . fl6_dport = inet -> inet_dport ; fl6 . fl6_sport = inet -> inet_sport ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { sk -> sk_route_caps = 0 ; sk -> sk_err_soft = - PTR_ERR ( dst ) ; dst_release ( dst ) ; return PTR_ERR ( dst ) ; } __ip6_dst_store ( sk , dst , NULL , NULL ) ; } return 0 ; }

In the fixed code, the call to dst_release() is added to the if statement to ensure that the dst_entry object is freed when it is no longer needed. This prevents the possibility of a use-after-free vulnerability.",455,-30.582683951786887,-0.06721469000392723
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
int inet6_sk_rebuild_header ( struct sock * sk ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct dst_entry * dst ; dst = __sk_dst_check ( sk , np -> dst_cookie ) ; if ( ! dst ) { struct inet_sock * inet = inet_sk ( sk ) ; struct in6_addr * final_p , final ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = sk -> sk_protocol ; fl6 . daddr = sk -> sk_v6_daddr ; fl6 . saddr = np -> saddr ; fl6 . flowlabel = np -> flow_label ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = sk -> sk_mark ; fl6 . fl6_dport = inet -> inet_dport ; fl6 . fl6_sport = inet -> inet_sport ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { sk -> sk_route_caps = 0 ; sk -> sk_err_soft = - PTR_ERR ( dst ) ; return PTR_ERR ( dst ) ; } __ip6_dst_store ( sk , dst , NULL , NULL ) ; } return 0 ; }
Fixed code:","
int inet6_sk_rebuild_header ( struct sock * sk ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct dst_entry * dst ; dst = __sk_dst_check ( sk , np -> dst_cookie ) ; if ( ! dst ) { struct inet_sock * inet = inet_sk ( sk ) ; struct in6_addr * final_p , final ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = sk -> sk_protocol ; fl6 . daddr = sk -> sk_v6_daddr ; fl6 . saddr = np -> saddr ; fl6 . flowlabel = np -> flow_label ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = sk -> sk_mark ; fl6 . fl6_dport = inet -> inet_dport ; fl6 . fl6_sport = inet -> inet_sport ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { sk -> sk_route_caps = 0 ; sk -> sk_err_soft = - PTR_ERR ( dst ) ; kfree(dst); //Added to fix vulnerability return PTR_ERR ( dst ) ; } __ip6_dst_store ( sk , dst , NULL , NULL ) ; kfree(dst); //Added to fix vulnerability } return 0 ; }",420,-16.16192397286948,-0.03848077136397495
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
int inet6_sk_rebuild_header ( struct sock * sk ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct dst_entry * dst ; dst = __sk_dst_check ( sk , np -> dst_cookie ) ; if ( ! dst ) { struct inet_sock * inet = inet_sk ( sk ) ; struct in6_addr * final_p , final ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = sk -> sk_protocol ; fl6 . daddr = sk -> sk_v6_daddr ; fl6 . saddr = np -> saddr ; fl6 . flowlabel = np -> flow_label ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = sk -> sk_mark ; fl6 . fl6_dport = inet -> inet_dport ; fl6 . fl6_sport = inet -> inet_sport ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { sk -> sk_route_caps = 0 ; sk -> sk_err_soft = - PTR_ERR ( dst ) ; return PTR_ERR ( dst ) ; } __ip6_dst_store ( sk , dst , NULL , NULL ) ; } return 0 ; }
Fixed code:","
int inet6_sk_rebuild_header ( struct sock * sk ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct dst_entry * dst ; dst = __sk_dst_check ( sk , np -> dst_cookie ) ; if ( ! dst ) { struct inet_sock * inet = inet_sk ( sk ) ; struct in6_addr * final_p , final ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = sk -> sk_protocol ; fl6 . daddr = sk -> sk_v6_daddr ; fl6 . saddr = np -> saddr ; fl6 . flowlabel = np -> flow_label ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = sk -> sk_mark ; fl6 . fl6_dport = inet -> inet_dport ; fl6 . fl6_sport = inet -> inet_sport ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; dst = ip6_dst_alloc ( sk , DST_NOCOUNT , 0 ) ; if ( ! dst ) { sk -> sk_route_caps = 0 ; sk -> sk_err_soft = - ENOMEM ; return - ENOMEM ; } dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { sk -> sk_route_caps = 0 ; sk -> sk_err_soft = - PTR_ERR ( dst ) ; dst_release ( dst ) ; return PTR_ERR ( dst ) ; } __ip6_dst_store ( sk , dst , NULL , NULL ) ; } return 0 ; }",463,-17.159310582929425,-0.037061145967450165
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
int inet6_sk_rebuild_header ( struct sock * sk ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct dst_entry * dst ; dst = __sk_dst_check ( sk , np -> dst_cookie ) ; if ( ! dst ) { struct inet_sock * inet = inet_sk ( sk ) ; struct in6_addr * final_p , final ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = sk -> sk_protocol ; fl6 . daddr = sk -> sk_v6_daddr ; fl6 . saddr = np -> saddr ; fl6 . flowlabel = np -> flow_label ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = sk -> sk_mark ; fl6 . fl6_dport = inet -> inet_dport ; fl6 . fl6_sport = inet -> inet_sport ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { sk -> sk_route_caps = 0 ; sk -> sk_err_soft = - PTR_ERR ( dst ) ; return PTR_ERR ( dst ) ; } __ip6_dst_store ( sk , dst , NULL , NULL ) ; } return 0 ; }
Fixed code:","
int inet6_sk_rebuild_header ( struct sock * sk ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct dst_entry * dst ; dst = __sk_dst_check ( sk , np -> dst_cookie ) ; if ( ! dst ) { struct inet_sock * inet = inet_sk ( sk ) ; struct in6_addr * final_p , final ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = sk -> sk_protocol ; fl6 . daddr = sk -> sk_v6_daddr ; fl6 . saddr = np -> saddr ; fl6 . flowlabel = np -> flow_label ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = sk -> sk_mark ; fl6 . fl6_dport = inet -> inet_dport ; fl6 . fl6_sport = inet -> inet_sport ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { sk -> sk_route_caps = 0 ; sk -> sk_err_soft = - PTR_ERR ( dst ) ; return PTR_ERR ( dst ) ; } //add a reference count before assigning the dst to the socket dst_hold(dst); __ip6_dst_store ( sk , dst , NULL , NULL ) ; //release the reference count after assigning the dst dst_release(dst); } return 0 ; }",433,-28.422163111365602,-0.06564009956435474
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
int inet6_sk_rebuild_header ( struct sock * sk ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct dst_entry * dst ; dst = __sk_dst_check ( sk , np -> dst_cookie ) ; if ( ! dst ) { struct inet_sock * inet = inet_sk ( sk ) ; struct in6_addr * final_p , final ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = sk -> sk_protocol ; fl6 . daddr = sk -> sk_v6_daddr ; fl6 . saddr = np -> saddr ; fl6 . flowlabel = np -> flow_label ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = sk -> sk_mark ; fl6 . fl6_dport = inet -> inet_dport ; fl6 . fl6_sport = inet -> inet_sport ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { sk -> sk_route_caps = 0 ; sk -> sk_err_soft = - PTR_ERR ( dst ) ; return PTR_ERR ( dst ) ; } __ip6_dst_store ( sk , dst , NULL , NULL ) ; } return 0 ; }
Fixed code:","
int inet6_sk_rebuild_header ( struct sock * sk ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct dst_entry * dst ; dst = __sk_dst_check ( sk , np -> dst_cookie ) ; if ( ! dst ) { struct inet_sock * inet = inet_sk ( sk ) ; struct in6_addr * final_p , final ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = sk -> sk_protocol ; fl6 . daddr = sk -> sk_v6_daddr ; fl6 . saddr = np -> saddr ; fl6 . flowlabel = np -> flow_label ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = sk -> sk_mark ; fl6 . fl6_dport = inet -> inet_dport ; fl6 . fl6_sport = inet -> inet_sport ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { sk -> sk_route_caps = 0 ; sk -> sk_err_soft = - PTR_ERR ( dst ) ; return PTR_ERR ( dst ) ; } /* Added code to prevent Use After Free */ if ( dst -> child ) dst_release ( dst -> child ) ; __ip6_dst_store ( sk , dst , NULL , NULL ) ; } return 0 ; }",422,-20.499116147469238,-0.048576104614856015
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
int inet6_sk_rebuild_header ( struct sock * sk ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct dst_entry * dst ; dst = __sk_dst_check ( sk , np -> dst_cookie ) ; if ( ! dst ) { struct inet_sock * inet = inet_sk ( sk ) ; struct in6_addr * final_p , final ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = sk -> sk_protocol ; fl6 . daddr = sk -> sk_v6_daddr ; fl6 . saddr = np -> saddr ; fl6 . flowlabel = np -> flow_label ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = sk -> sk_mark ; fl6 . fl6_dport = inet -> inet_dport ; fl6 . fl6_sport = inet -> inet_sport ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { sk -> sk_route_caps = 0 ; sk -> sk_err_soft = - PTR_ERR ( dst ) ; return PTR_ERR ( dst ) ; } __ip6_dst_store ( sk , dst , NULL , NULL ) ; } return 0 ; }
Fixed code:","
int inet6_sk_rebuild_header ( struct sock * sk ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct dst_entry * dst ; dst = __sk_dst_check ( sk , np -> dst_cookie ) ; if ( ! dst ) { struct inet_sock * inet = inet_sk ( sk ) ; struct in6_addr * final_p , final ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = sk -> sk_protocol ; fl6 . daddr = sk -> sk_v6_daddr ; fl6 . saddr = np -> saddr ; fl6 . flowlabel = np -> flow_label ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = sk -> sk_mark ; fl6 . fl6_dport = inet -> inet_dport ; fl6 . fl6_sport = inet -> inet_sport ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { sk -> sk_route_caps = 0 ; sk -> sk_err_soft = - PTR_ERR ( dst ) ; return PTR_ERR ( dst ) ; } dst_release(dst); /* Add dst_release to fix CWE-416 */ __ip6_dst_store ( sk , dst , NULL , NULL ) ; } return 0 ; }",417,-15.954179922846249,-0.03825942427541067
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
int inet6_sk_rebuild_header ( struct sock * sk ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct dst_entry * dst ; dst = __sk_dst_check ( sk , np -> dst_cookie ) ; if ( ! dst ) { struct inet_sock * inet = inet_sk ( sk ) ; struct in6_addr * final_p , final ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = sk -> sk_protocol ; fl6 . daddr = sk -> sk_v6_daddr ; fl6 . saddr = np -> saddr ; fl6 . flowlabel = np -> flow_label ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = sk -> sk_mark ; fl6 . fl6_dport = inet -> inet_dport ; fl6 . fl6_sport = inet -> inet_sport ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { sk -> sk_route_caps = 0 ; sk -> sk_err_soft = - PTR_ERR ( dst ) ; return PTR_ERR ( dst ) ; } __ip6_dst_store ( sk , dst , NULL , NULL ) ; } return 0 ; }
Fixed code:","
int inet6_sk_rebuild_header ( struct sock * sk ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct dst_entry * dst , *old_dst = NULL; dst = __sk_dst_check ( sk , np -> dst_cookie ) ; if ( ! dst ) { struct inet_sock * inet = inet_sk ( sk ) ; struct in6_addr * final_p , final ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = sk -> sk_protocol ; fl6 . daddr = sk -> sk_v6_daddr ; fl6 . saddr = np -> saddr ; fl6 . flowlabel = np -> flow_label ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = sk -> sk_mark ; fl6 . fl6_dport = inet -> inet_dport ; fl6 . fl6_sport = inet -> inet_sport ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { sk -> sk_route_caps = 0 ; sk -> sk_err_soft = - PTR_ERR ( dst ) ; return PTR_ERR ( dst ) ; } old_dst = np->dst; __ip6_dst_store ( sk , dst , NULL , NULL ) ; /*Free the old_dst*/ if (old_dst)  dst_release(old_dst); } return 0 ; }",441,-25.109717335401086,-0.056938134547394756
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
int inet6_sk_rebuild_header ( struct sock * sk ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct dst_entry * dst ; dst = __sk_dst_check ( sk , np -> dst_cookie ) ; if ( ! dst ) { struct inet_sock * inet = inet_sk ( sk ) ; struct in6_addr * final_p , final ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = sk -> sk_protocol ; fl6 . daddr = sk -> sk_v6_daddr ; fl6 . saddr = np -> saddr ; fl6 . flowlabel = np -> flow_label ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = sk -> sk_mark ; fl6 . fl6_dport = inet -> inet_dport ; fl6 . fl6_sport = inet -> inet_sport ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { sk -> sk_route_caps = 0 ; sk -> sk_err_soft = - PTR_ERR ( dst ) ; return PTR_ERR ( dst ) ; } __ip6_dst_store ( sk , dst , NULL , NULL ) ; } return 0 ; }
Fixed code:","
int inet6_sk_rebuild_header ( struct sock * sk ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct dst_entry * dst ; dst = __sk_dst_check ( sk , np -> dst_cookie ) ; if ( ! dst ) { struct inet_sock * inet = inet_sk ( sk ) ; struct in6_addr * final_p , final ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = sk -> sk_protocol ; fl6 . daddr = sk -> sk_v6_daddr ; fl6 . saddr = np -> saddr ; fl6 . flowlabel = np -> flow_label ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = sk -> sk_mark ; fl6 . fl6_dport = inet -> inet_dport ; fl6 . fl6_sport = inet -> inet_sport ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { sk -> sk_route_caps = 0 ; sk -> sk_err_soft = - PTR_ERR ( dst ) ; return PTR_ERR ( dst ) ; } 
// Added line
if (dst) 
    dst_release(dst);
// Added line
__ip6_dst_store ( sk , dst , NULL , NULL ) ; } return 0 ; }",424,-23.874227273222747,-0.05630713979533667
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
int inet6_sk_rebuild_header ( struct sock * sk ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct dst_entry * dst ; dst = __sk_dst_check ( sk , np -> dst_cookie ) ; if ( ! dst ) { struct inet_sock * inet = inet_sk ( sk ) ; struct in6_addr * final_p , final ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = sk -> sk_protocol ; fl6 . daddr = sk -> sk_v6_daddr ; fl6 . saddr = np -> saddr ; fl6 . flowlabel = np -> flow_label ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = sk -> sk_mark ; fl6 . fl6_dport = inet -> inet_dport ; fl6 . fl6_sport = inet -> inet_sport ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { sk -> sk_route_caps = 0 ; sk -> sk_err_soft = - PTR_ERR ( dst ) ; return PTR_ERR ( dst ) ; } __ip6_dst_store ( sk , dst , NULL , NULL ) ; } return 0 ; }
Fixed code:","
int inet6_sk_rebuild_header ( struct sock * sk ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct dst_entry * dst ; dst = __sk_dst_check ( sk , np -> dst_cookie ) ; if ( dst ) { dst_release(dst); } 
struct inet_sock * inet = inet_sk ( sk ) ; struct in6_addr * final_p , final ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = sk -> sk_protocol ; fl6 . daddr = sk -> sk_v6_daddr ; fl6 . saddr = np -> saddr ; fl6 . flowlabel = np -> flow_label ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = sk -> sk_mark ; fl6 . fl6_dport = inet -> inet_dport ; fl6 . fl6_sport = inet -> inet_sport ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { sk -> sk_route_caps = 0 ; sk -> sk_err_soft = - PTR_ERR ( dst ) ; return PTR_ERR ( dst ) ; } __ip6_dst_store ( sk , dst , NULL , NULL ) ;
 return 0 ; }",407,-11.780463969292162,-0.02894462891717976
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
int inet6_sk_rebuild_header ( struct sock * sk ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct dst_entry * dst ; dst = __sk_dst_check ( sk , np -> dst_cookie ) ; if ( ! dst ) { struct inet_sock * inet = inet_sk ( sk ) ; struct in6_addr * final_p , final ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = sk -> sk_protocol ; fl6 . daddr = sk -> sk_v6_daddr ; fl6 . saddr = np -> saddr ; fl6 . flowlabel = np -> flow_label ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = sk -> sk_mark ; fl6 . fl6_dport = inet -> inet_dport ; fl6 . fl6_sport = inet -> inet_sport ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { sk -> sk_route_caps = 0 ; sk -> sk_err_soft = - PTR_ERR ( dst ) ; return PTR_ERR ( dst ) ; } __ip6_dst_store ( sk , dst , NULL , NULL ) ; } return 0 ; }
Fixed code:","
int inet6_sk_rebuild_header ( struct sock * sk ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct dst_entry * dst ; dst = __sk_dst_check ( sk , np -> dst_cookie ) ; if ( ! dst ) { struct inet_sock * inet = inet_sk ( sk ) ; struct in6_addr * final_p , final ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = sk -> sk_protocol ; fl6 . daddr = sk -> sk_v6_daddr ; fl6 . saddr = np -> saddr ; fl6 . flowlabel = np -> flow_label ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = sk -> sk_mark ; fl6 . fl6_dport = inet -> inet_dport ; fl6 . fl6_sport = inet -> inet_sport ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { sk -> sk_route_caps = 0 ; sk -> sk_err_soft = PTR_ERR ( dst ) ; kfree(dst); return -EINVAL; } __ip6_dst_store ( sk , dst , NULL , NULL ) ; } return 0 ; }",399,-17.29128896331736,-0.04333656381783799
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
int inet6_sk_rebuild_header ( struct sock * sk ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct dst_entry * dst ; dst = __sk_dst_check ( sk , np -> dst_cookie ) ; if ( ! dst ) { struct inet_sock * inet = inet_sk ( sk ) ; struct in6_addr * final_p , final ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = sk -> sk_protocol ; fl6 . daddr = sk -> sk_v6_daddr ; fl6 . saddr = np -> saddr ; fl6 . flowlabel = np -> flow_label ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = sk -> sk_mark ; fl6 . fl6_dport = inet -> inet_dport ; fl6 . fl6_sport = inet -> inet_sport ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { sk -> sk_route_caps = 0 ; sk -> sk_err_soft = - PTR_ERR ( dst ) ; return PTR_ERR ( dst ) ; } __ip6_dst_store ( sk , dst , NULL , NULL ) ; } return 0 ; }
Fixed code:","
int inet6_sk_rebuild_header ( struct sock * sk ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct dst_entry * dst ; dst = __sk_dst_check ( sk , np -> dst_cookie ) ; if ( dst ) { dst_release ( dst ) ; } struct inet_sock * inet = inet_sk ( sk ) ; struct in6_addr * final_p , final ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = sk -> sk_protocol ; fl6 . daddr = sk -> sk_v6_daddr ; fl6 . saddr = np -> saddr ; fl6 . flowlabel = np -> flow_label ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = sk -> sk_mark ; fl6 . fl6_dport = inet -> inet_dport ; fl6 . fl6_sport = inet -> inet_sport ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { sk -> sk_route_caps = 0 ; sk -> sk_err_soft = - PTR_ERR ( dst ) ; return PTR_ERR ( dst ) ; } __ip6_dst_store ( sk , dst , NULL , NULL ) ; return 0 ; }",404,-5.338557103991244,-0.013214250257404069
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
int inet6_sk_rebuild_header ( struct sock * sk ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct dst_entry * dst ; dst = __sk_dst_check ( sk , np -> dst_cookie ) ; if ( ! dst ) { struct inet_sock * inet = inet_sk ( sk ) ; struct in6_addr * final_p , final ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = sk -> sk_protocol ; fl6 . daddr = sk -> sk_v6_daddr ; fl6 . saddr = np -> saddr ; fl6 . flowlabel = np -> flow_label ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = sk -> sk_mark ; fl6 . fl6_dport = inet -> inet_dport ; fl6 . fl6_sport = inet -> inet_sport ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { sk -> sk_route_caps = 0 ; sk -> sk_err_soft = - PTR_ERR ( dst ) ; return PTR_ERR ( dst ) ; } __ip6_dst_store ( sk , dst , NULL , NULL ) ; } return 0 ; }
Fixed code:","
int inet6_sk_rebuild_header ( struct sock * sk ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct dst_entry * dst ; dst = __sk_dst_check ( sk , np -> dst_cookie ) ; if ( ! dst ) { struct inet_sock * inet = inet_sk ( sk ) ; struct in6_addr * final_p , final ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = sk -> sk_protocol ; fl6 . daddr = sk -> sk_v6_daddr ; fl6 . saddr = np -> saddr ; fl6 . flowlabel = np -> flow_label ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = sk -> sk_mark ; fl6 . fl6_dport = inet -> inet_dport ; fl6 . fl6_sport = inet -> inet_sport ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { sk -> sk_route_caps = 0 ; sk -> sk_err_soft = - PTR_ERR ( dst ) ; return PTR_ERR ( dst ) ; } else { /* Add a reference to the dst_entry to prevent it from being freed */ dst_hold(dst); } __ip6_dst_store ( sk , dst , NULL , NULL ) ; } /* Release the reference to the dst_entry to prevent a memory leak */ dst_release(dst); return 0 ; }",446,-25.501418273457453,-0.057178067877707295
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
int inet6_sk_rebuild_header ( struct sock * sk ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct dst_entry * dst ; dst = __sk_dst_check ( sk , np -> dst_cookie ) ; if ( ! dst ) { struct inet_sock * inet = inet_sk ( sk ) ; struct in6_addr * final_p , final ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = sk -> sk_protocol ; fl6 . daddr = sk -> sk_v6_daddr ; fl6 . saddr = np -> saddr ; fl6 . flowlabel = np -> flow_label ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = sk -> sk_mark ; fl6 . fl6_dport = inet -> inet_dport ; fl6 . fl6_sport = inet -> inet_sport ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { sk -> sk_route_caps = 0 ; sk -> sk_err_soft = - PTR_ERR ( dst ) ; return PTR_ERR ( dst ) ; } __ip6_dst_store ( sk , dst , NULL , NULL ) ; } return 0 ; }
Fixed code:","
int inet6_sk_rebuild_header ( struct sock * sk ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct dst_entry * dst ; dst = __sk_dst_check ( sk , np -> dst_cookie ) ; if ( ! dst ) { struct inet_sock * inet = inet_sk ( sk ) ; struct in6_addr * final_p , final ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = sk -> sk_protocol ; fl6 . daddr = sk -> sk_v6_daddr ; fl6 . saddr = np -> saddr ; fl6 . flowlabel = np -> flow_label ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = sk -> sk_mark ; fl6 . fl6_dport = inet -> inet_dport ; fl6 . fl6_sport = inet -> inet_sport ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { sk -> sk_route_caps = 0 ; sk -> sk_err_soft = - PTR_ERR ( dst ) ; kfree ( dst ) ; return PTR_ERR ( dst ) ; } __ip6_dst_store ( sk , dst , NULL , NULL ) ; } return 0 ; }",404,-4.025572157185741,-0.009964287517786488
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
int inet6_sk_rebuild_header ( struct sock * sk ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct dst_entry * dst ; dst = __sk_dst_check ( sk , np -> dst_cookie ) ; if ( ! dst ) { struct inet_sock * inet = inet_sk ( sk ) ; struct in6_addr * final_p , final ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = sk -> sk_protocol ; fl6 . daddr = sk -> sk_v6_daddr ; fl6 . saddr = np -> saddr ; fl6 . flowlabel = np -> flow_label ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = sk -> sk_mark ; fl6 . fl6_dport = inet -> inet_dport ; fl6 . fl6_sport = inet -> inet_sport ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { sk -> sk_route_caps = 0 ; sk -> sk_err_soft = - PTR_ERR ( dst ) ; return PTR_ERR ( dst ) ; } __ip6_dst_store ( sk , dst , NULL , NULL ) ; } return 0 ; }
Fixed code:","
int inet6_sk_rebuild_header ( struct sock * sk ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct dst_entry * dst ; dst = __sk_dst_check ( sk , np -> dst_cookie ) ; if ( ! dst ) { struct inet_sock * inet = inet_sk ( sk ) ; struct in6_addr * final_p , final ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = sk -> sk_protocol ; fl6 . daddr = sk -> sk_v6_daddr ; fl6 . saddr = np -> saddr ; fl6 . flowlabel = np -> flow_label ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = sk -> sk_mark ; fl6 . fl6_dport = inet -> inet_dport ; fl6 . fl6_sport = inet -> inet_sport ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { sk -> sk_route_caps = 0 ; sk -> sk_err_soft = - PTR_ERR ( dst ) ; dst_release ( dst ) ; return PTR_ERR ( dst ) ; } __ip6_dst_store ( sk , dst , NULL , NULL ) ; } return 0 ; }",405,-4.421875581023178,-0.01091821131116834
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
int inet6_sk_rebuild_header ( struct sock * sk ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct dst_entry * dst ; dst = __sk_dst_check ( sk , np -> dst_cookie ) ; if ( ! dst ) { struct inet_sock * inet = inet_sk ( sk ) ; struct in6_addr * final_p , final ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = sk -> sk_protocol ; fl6 . daddr = sk -> sk_v6_daddr ; fl6 . saddr = np -> saddr ; fl6 . flowlabel = np -> flow_label ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = sk -> sk_mark ; fl6 . fl6_dport = inet -> inet_dport ; fl6 . fl6_sport = inet -> inet_sport ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { sk -> sk_route_caps = 0 ; sk -> sk_err_soft = - PTR_ERR ( dst ) ; return PTR_ERR ( dst ) ; } __ip6_dst_store ( sk , dst , NULL , NULL ) ; } return 0 ; }
Fixed code:","
int inet6_sk_rebuild_header ( struct sock * sk ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct dst_entry * dst ; dst = __sk_dst_check ( sk , np -> dst_cookie ) ; if ( ! dst ) { struct inet_sock * inet = inet_sk ( sk ) ; struct in6_addr * final_p , final ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = sk -> sk_protocol ; fl6 . daddr = sk -> sk_v6_daddr ; fl6 . saddr = np -> saddr ; fl6 . flowlabel = np -> flow_label ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = sk -> sk_mark ; fl6 . fl6_dport = inet -> inet_dport ; fl6 . fl6_sport = inet -> inet_sport ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { sk -> sk_route_caps = 0 ; sk -> sk_err_soft = - PTR_ERR ( dst ) ; dst_release ( dst ) ; return PTR_ERR ( dst ) ; } __ip6_dst_store ( sk , dst , NULL , NULL ) ; } return 0 ; }",405,-4.492544588548942,-0.011092702687775164
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
int inet6_sk_rebuild_header ( struct sock * sk ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct dst_entry * dst ; dst = __sk_dst_check ( sk , np -> dst_cookie ) ; if ( ! dst ) { struct inet_sock * inet = inet_sk ( sk ) ; struct in6_addr * final_p , final ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = sk -> sk_protocol ; fl6 . daddr = sk -> sk_v6_daddr ; fl6 . saddr = np -> saddr ; fl6 . flowlabel = np -> flow_label ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = sk -> sk_mark ; fl6 . fl6_dport = inet -> inet_dport ; fl6 . fl6_sport = inet -> inet_sport ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { sk -> sk_route_caps = 0 ; sk -> sk_err_soft = - PTR_ERR ( dst ) ; return PTR_ERR ( dst ) ; } __ip6_dst_store ( sk , dst , NULL , NULL ) ; } return 0 ; }
Fixed code:","
int inet6_sk_rebuild_header ( struct sock * sk ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct dst_entry * dst ; dst = __sk_dst_check ( sk , np -> dst_cookie ) ; if ( ! dst ) { struct inet_sock * inet = inet_sk ( sk ) ; struct in6_addr * final_p , final ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = sk -> sk_protocol ; fl6 . daddr = sk -> sk_v6_daddr ; fl6 . saddr = np -> saddr ; fl6 . flowlabel = np -> flow_label ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = sk -> sk_mark ; fl6 . fl6_dport = inet -> inet_dport ; fl6 . fl6_sport = inet -> inet_sport ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { sk -> sk_route_caps = 0 ; sk -> sk_err_soft = - PTR_ERR ( dst ) ; return PTR_ERR ( dst ) ; } /* Added code to free dst to prevent Use After Free */ kfree(dst); dst = NULL; __ip6_dst_store ( sk , dst , NULL , NULL ) ; } return 0 ; }",420,-21.961864646102736,-0.05229015391929223
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
int inet6_sk_rebuild_header ( struct sock * sk ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct dst_entry * dst ; dst = __sk_dst_check ( sk , np -> dst_cookie ) ; if ( ! dst ) { struct inet_sock * inet = inet_sk ( sk ) ; struct in6_addr * final_p , final ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = sk -> sk_protocol ; fl6 . daddr = sk -> sk_v6_daddr ; fl6 . saddr = np -> saddr ; fl6 . flowlabel = np -> flow_label ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = sk -> sk_mark ; fl6 . fl6_dport = inet -> inet_dport ; fl6 . fl6_sport = inet -> inet_sport ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { sk -> sk_route_caps = 0 ; sk -> sk_err_soft = - PTR_ERR ( dst ) ; return PTR_ERR ( dst ) ; } __ip6_dst_store ( sk , dst , NULL , NULL ) ; } return 0 ; }
Fixed code:","
int inet6_sk_rebuild_header(struct sock *sk) { 
    struct ipv6_pinfo *np = inet6_sk(sk); 
    struct dst_entry *dst; 
    dst = __sk_dst_check(sk, np->dst_cookie); 

    if (!dst) { 
        struct inet_sock *inet = inet_sk(sk); 
        struct in6_addr *final_p, final; 
        struct flowi6 fl6; 
        memset(&fl6, 0, sizeof(fl6)); 
        fl6.flowi6_proto = sk->sk_protocol; 
        fl6.daddr = sk->sk_v6_daddr; 
        fl6.saddr = np->saddr; 
        fl6.flowlabel = np->flow_label; 
        fl6.flowi6_oif = sk->sk_bound_dev_if; 
        fl6.flowi6_mark = sk->sk_mark; 
        fl6.fl6_dport = inet->inet_dport; 
        fl6.fl6_sport = inet->inet_sport; 
        security_sk_classify_flow(sk, flowi6_to_flowi(&fl6)); 
        final_p = fl6_update_dst(&fl6, np->opt, &final); 
        dst = ip6_dst_lookup_flow(sk, &fl6, final_p); 
        if (IS_ERR(dst)) { 
            sk->sk_route_caps = 0; 
            sk->sk_err_soft = -PTR_ERR(dst); 
            return PTR_ERR(dst); 
        } 
        dst_release(dst); //Free the dst struct
        __ip6_dst_store(sk, dst, NULL, NULL); //Store the dst struct
    } 
    return 0; 
}",485,-32.85952337897642,-0.06775159459582766
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
int inet6_sk_rebuild_header ( struct sock * sk ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct dst_entry * dst ; dst = __sk_dst_check ( sk , np -> dst_cookie ) ; if ( ! dst ) { struct inet_sock * inet = inet_sk ( sk ) ; struct in6_addr * final_p , final ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = sk -> sk_protocol ; fl6 . daddr = sk -> sk_v6_daddr ; fl6 . saddr = np -> saddr ; fl6 . flowlabel = np -> flow_label ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = sk -> sk_mark ; fl6 . fl6_dport = inet -> inet_dport ; fl6 . fl6_sport = inet -> inet_sport ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { sk -> sk_route_caps = 0 ; sk -> sk_err_soft = - PTR_ERR ( dst ) ; return PTR_ERR ( dst ) ; } __ip6_dst_store ( sk , dst , NULL , NULL ) ; } return 0 ; }
Fixed code:","
int inet6_sk_rebuild_header ( struct sock * sk ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct dst_entry * dst ; dst = __sk_dst_check ( sk , np -> dst_cookie ) ; 
if ( ! dst ) { struct inet_sock * inet = inet_sk ( sk ) ; struct in6_addr * final_p , final ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = sk -> sk_protocol ; fl6 . daddr = sk -> sk_v6_daddr ; fl6 . saddr = np -> saddr ; fl6 . flowlabel = np -> flow_label ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = sk -> sk_mark ; fl6 . fl6_dport = inet -> inet_dport ; fl6 . fl6_sport = inet -> inet_sport ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; 
if ( IS_ERR ( dst ) ) { sk -> sk_route_caps = 0 ; sk -> sk_err_soft = - PTR_ERR ( dst ) ; } else { sk_dst_set(sk, dst); }
return 0 ; }
return 0 ; }",393,-23.50605316089302,-0.059811840104053486
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
int inet6_sk_rebuild_header ( struct sock * sk ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct dst_entry * dst ; dst = __sk_dst_check ( sk , np -> dst_cookie ) ; if ( ! dst ) { struct inet_sock * inet = inet_sk ( sk ) ; struct in6_addr * final_p , final ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = sk -> sk_protocol ; fl6 . daddr = sk -> sk_v6_daddr ; fl6 . saddr = np -> saddr ; fl6 . flowlabel = np -> flow_label ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = sk -> sk_mark ; fl6 . fl6_dport = inet -> inet_dport ; fl6 . fl6_sport = inet -> inet_sport ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { sk -> sk_route_caps = 0 ; sk -> sk_err_soft = - PTR_ERR ( dst ) ; return PTR_ERR ( dst ) ; } __ip6_dst_store ( sk , dst , NULL , NULL ) ; } return 0 ; }
Fixed code:","
int inet6_sk_rebuild_header ( struct sock * sk ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct dst_entry * dst ; dst = __sk_dst_check ( sk , np -> dst_cookie ) ; if ( dst ) { dst_release(dst); } struct inet_sock * inet = inet_sk ( sk ) ; struct in6_addr * final_p , final ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = sk -> sk_protocol ; fl6 . daddr = sk -> sk_v6_daddr ; fl6 . saddr = np -> saddr ; fl6 . flowlabel = np -> flow_label ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = sk -> sk_mark ; fl6 . fl6_dport = inet -> inet_dport ; fl6 . fl6_sport = inet -> inet_sport ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { sk -> sk_route_caps = 0 ; sk -> sk_err_soft = - PTR_ERR ( dst ) ; return PTR_ERR ( dst ) ; } __ip6_dst_store ( sk , dst , NULL , NULL ) ; 

return 0 ; }",407,-8.978131902308135,-0.022059292143263232
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
int inet6_sk_rebuild_header ( struct sock * sk ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct dst_entry * dst ; dst = __sk_dst_check ( sk , np -> dst_cookie ) ; if ( ! dst ) { struct inet_sock * inet = inet_sk ( sk ) ; struct in6_addr * final_p , final ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = sk -> sk_protocol ; fl6 . daddr = sk -> sk_v6_daddr ; fl6 . saddr = np -> saddr ; fl6 . flowlabel = np -> flow_label ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = sk -> sk_mark ; fl6 . fl6_dport = inet -> inet_dport ; fl6 . fl6_sport = inet -> inet_sport ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { sk -> sk_route_caps = 0 ; sk -> sk_err_soft = - PTR_ERR ( dst ) ; return PTR_ERR ( dst ) ; } __ip6_dst_store ( sk , dst , NULL , NULL ) ; } return 0 ; }
Fixed code:","
int inet6_sk_rebuild_header ( struct sock * sk ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct dst_entry * dst ; dst = __sk_dst_check ( sk , np -> dst_cookie ) ; if ( ! dst ) { struct inet_sock * inet = inet_sk ( sk ) ; struct in6_addr * final_p , final ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = sk -> sk_protocol ; fl6 . daddr = sk -> sk_v6_daddr ; fl6 . saddr = np -> saddr ; fl6 . flowlabel = np -> flow_label ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = sk -> sk_mark ; fl6 . fl6_dport = inet -> inet_dport ; fl6 . fl6_sport = inet -> inet_sport ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { sk -> sk_route_caps = 0 ; sk -> sk_err_soft = - PTR_ERR ( dst ) ; return PTR_ERR ( dst ) ; } } else { dst_release(dst); } __ip6_dst_store ( sk , dst , NULL , NULL ) ; return 0 ; }",408,-7.0612546253907515,-0.017306996630859686
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
int inet6_sk_rebuild_header ( struct sock * sk ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct dst_entry * dst ; dst = __sk_dst_check ( sk , np -> dst_cookie ) ; if ( ! dst ) { struct inet_sock * inet = inet_sk ( sk ) ; struct in6_addr * final_p , final ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = sk -> sk_protocol ; fl6 . daddr = sk -> sk_v6_daddr ; fl6 . saddr = np -> saddr ; fl6 . flowlabel = np -> flow_label ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = sk -> sk_mark ; fl6 . fl6_dport = inet -> inet_dport ; fl6 . fl6_sport = inet -> inet_sport ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { sk -> sk_route_caps = 0 ; sk -> sk_err_soft = - PTR_ERR ( dst ) ; return PTR_ERR ( dst ) ; } __ip6_dst_store ( sk , dst , NULL , NULL ) ; } return 0 ; }
Fixed code:","
int inet6_sk_rebuild_header ( struct sock * sk ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct dst_entry * dst, *dst_next ; dst = __sk_dst_check ( sk , np -> dst_cookie ) ; 
if ( ! dst ) { struct inet_sock * inet = inet_sk ( sk ) ; struct in6_addr * final_p , final ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = sk -> sk_protocol ; fl6 . daddr = sk -> sk_v6_daddr ; fl6 . saddr = np -> saddr ; fl6 . flowlabel = np -> flow_label ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = sk -> sk_mark ; fl6 . fl6_dport = inet -> inet_dport ; fl6 . fl6_sport = inet -> inet_sport ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; dst_next = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst_next ) ) { sk -> sk_route_caps = 0 ; sk -> sk_err_soft = - PTR_ERR ( dst_next ) ; return PTR_ERR ( dst_next ) ; 
} __ip6_dst_store ( sk , dst_next , NULL , NULL ) ; 
if (dst) { dst_release(dst); } 
dst = dst_next; 
} return 0 ; }",445,-33.87481136787337,-0.07612317161319858
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
int inet6_sk_rebuild_header ( struct sock * sk ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct dst_entry * dst ; dst = __sk_dst_check ( sk , np -> dst_cookie ) ; if ( ! dst ) { struct inet_sock * inet = inet_sk ( sk ) ; struct in6_addr * final_p , final ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = sk -> sk_protocol ; fl6 . daddr = sk -> sk_v6_daddr ; fl6 . saddr = np -> saddr ; fl6 . flowlabel = np -> flow_label ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = sk -> sk_mark ; fl6 . fl6_dport = inet -> inet_dport ; fl6 . fl6_sport = inet -> inet_sport ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { sk -> sk_route_caps = 0 ; sk -> sk_err_soft = - PTR_ERR ( dst ) ; return PTR_ERR ( dst ) ; } __ip6_dst_store ( sk , dst , NULL , NULL ) ; } return 0 ; }
Fixed code:","
int inet6_sk_rebuild_header ( struct sock * sk ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct dst_entry * dst ; dst = __sk_dst_check ( sk , np -> dst_cookie ) ; if ( ! dst ) { struct inet_sock * inet = inet_sk ( sk ) ; struct in6_addr * final_p , final ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = sk -> sk_protocol ; fl6 . daddr = sk -> sk_v6_daddr ; fl6 . saddr = np -> saddr ; fl6 . flowlabel = np -> flow_label ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = sk -> sk_mark ; fl6 . fl6_dport = inet -> inet_dport ; fl6 . fl6_sport = inet -> inet_sport ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { sk -> sk_route_caps = 0 ; sk -> sk_err_soft = - PTR_ERR ( dst ) ; kfree_skb ( dst ) ; return PTR_ERR ( dst ) ; } __ip6_dst_store ( sk , dst , NULL , NULL ) ; } return 0 ; }
In the fixed code, the free function kfree_skb is added before the return statement to free the memory allocated to dst. This prevents the use-after-free issue and fixes the vulnerability.",449,-41.95050728321928,-0.09343097390472001
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
int inet6_sk_rebuild_header ( struct sock * sk ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct dst_entry * dst ; dst = __sk_dst_check ( sk , np -> dst_cookie ) ; if ( ! dst ) { struct inet_sock * inet = inet_sk ( sk ) ; struct in6_addr * final_p , final ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = sk -> sk_protocol ; fl6 . daddr = sk -> sk_v6_daddr ; fl6 . saddr = np -> saddr ; fl6 . flowlabel = np -> flow_label ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = sk -> sk_mark ; fl6 . fl6_dport = inet -> inet_dport ; fl6 . fl6_sport = inet -> inet_sport ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { sk -> sk_route_caps = 0 ; sk -> sk_err_soft = - PTR_ERR ( dst ) ; return PTR_ERR ( dst ) ; } __ip6_dst_store ( sk , dst , NULL , NULL ) ; } return 0 ; }
Fixed code:","
int inet6_sk_rebuild_header ( struct sock * sk ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct dst_entry * dst ; dst = __sk_dst_check ( sk , np -> dst_cookie ) ; if ( ! dst ) { struct inet_sock * inet = inet_sk ( sk ) ; struct in6_addr * final_p , final ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = sk -> sk_protocol ; fl6 . daddr = sk -> sk_v6_daddr ; fl6 . saddr = np -> saddr ; fl6 . flowlabel = np -> flow_label ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = sk -> sk_mark ; fl6 . fl6_dport = inet -> inet_dport ; fl6 . fl6_sport = inet -> inet_sport ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { sk -> sk_route_caps = 0 ; sk -> sk_err_soft = - PTR_ERR ( dst ) ; dst_release ( dst ) ; return PTR_ERR ( dst ) ; } __ip6_dst_store ( sk , dst , NULL , NULL ) ; } return 0 ; }",405,-4.629477020594331,-0.011430807458257608
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
int inet6_sk_rebuild_header ( struct sock * sk ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct dst_entry * dst ; dst = __sk_dst_check ( sk , np -> dst_cookie ) ; if ( ! dst ) { struct inet_sock * inet = inet_sk ( sk ) ; struct in6_addr * final_p , final ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = sk -> sk_protocol ; fl6 . daddr = sk -> sk_v6_daddr ; fl6 . saddr = np -> saddr ; fl6 . flowlabel = np -> flow_label ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = sk -> sk_mark ; fl6 . fl6_dport = inet -> inet_dport ; fl6 . fl6_sport = inet -> inet_sport ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { sk -> sk_route_caps = 0 ; sk -> sk_err_soft = - PTR_ERR ( dst ) ; return PTR_ERR ( dst ) ; } __ip6_dst_store ( sk , dst , NULL , NULL ) ; } return 0 ; }
Fixed code:","
int inet6_sk_rebuild_header ( struct sock * sk ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct dst_entry * dst ; dst = __sk_dst_check ( sk , np -> dst_cookie ) ; if ( ! dst ) { struct inet_sock * inet = inet_sk ( sk ) ; struct in6_addr * final_p , final ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = sk -> sk_protocol ; fl6 . daddr = sk -> sk_v6_daddr ; fl6 . saddr = np -> saddr ; fl6 . flowlabel = np -> flow_label ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = sk -> sk_mark ; fl6 . fl6_dport = inet -> inet_dport ; fl6 . fl6_sport = inet -> inet_sport ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { sk -> sk_route_caps = 0 ; sk -> sk_err_soft = - PTR_ERR ( dst ) ; return PTR_ERR ( dst ) ; } // added reference count to prevent use after free dst_hold(dst); __ip6_dst_store ( sk , dst , NULL , NULL ) ; } return 0 ; // added code to drop reference count for dst dst_release(dst); }",430,-34.32719092968167,-0.07983067658065504
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
int inet6_sk_rebuild_header ( struct sock * sk ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct dst_entry * dst ; dst = __sk_dst_check ( sk , np -> dst_cookie ) ; if ( ! dst ) { struct inet_sock * inet = inet_sk ( sk ) ; struct in6_addr * final_p , final ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = sk -> sk_protocol ; fl6 . daddr = sk -> sk_v6_daddr ; fl6 . saddr = np -> saddr ; fl6 . flowlabel = np -> flow_label ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = sk -> sk_mark ; fl6 . fl6_dport = inet -> inet_dport ; fl6 . fl6_sport = inet -> inet_sport ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { sk -> sk_route_caps = 0 ; sk -> sk_err_soft = - PTR_ERR ( dst ) ; return PTR_ERR ( dst ) ; } __ip6_dst_store ( sk , dst , NULL , NULL ) ; } return 0 ; }
Fixed code:","
int inet6_sk_rebuild_header ( struct sock * sk ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct dst_entry * dst ; dst = __sk_dst_check ( sk , np -> dst_cookie ) ; if ( ! dst ) { struct inet_sock * inet = inet_sk ( sk ) ; struct in6_addr * final_p , final ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = sk -> sk_protocol ; fl6 . daddr = sk -> sk_v6_daddr ; fl6 . saddr = np -> saddr ; fl6 . flowlabel = np -> flow_label ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = sk -> sk_mark ; fl6 . fl6_dport = inet -> inet_dport ; fl6 . fl6_sport = inet -> inet_sport ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { sk -> sk_route_caps = 0 ; sk -> sk_err_soft = - PTR_ERR ( dst ) ; kfree ( dst ) ; return PTR_ERR ( dst ) ; } __ip6_dst_store ( sk , dst , NULL , NULL ) ; } return 0 ; }",404,-4.068042301258,-0.010069411636777229
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
int inet6_sk_rebuild_header ( struct sock * sk ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct dst_entry * dst ; dst = __sk_dst_check ( sk , np -> dst_cookie ) ; if ( ! dst ) { struct inet_sock * inet = inet_sk ( sk ) ; struct in6_addr * final_p , final ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = sk -> sk_protocol ; fl6 . daddr = sk -> sk_v6_daddr ; fl6 . saddr = np -> saddr ; fl6 . flowlabel = np -> flow_label ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = sk -> sk_mark ; fl6 . fl6_dport = inet -> inet_dport ; fl6 . fl6_sport = inet -> inet_sport ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { sk -> sk_route_caps = 0 ; sk -> sk_err_soft = - PTR_ERR ( dst ) ; return PTR_ERR ( dst ) ; } __ip6_dst_store ( sk , dst , NULL , NULL ) ; } return 0 ; }
Fixed code:","
int inet6_sk_rebuild_header ( struct sock * sk ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct dst_entry * dst ; dst = __sk_dst_check ( sk , np -> dst_cookie ) ; if ( ! dst ) { struct inet_sock * inet = inet_sk ( sk ) ; struct in6_addr * final_p , final ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = sk -> sk_protocol ; fl6 . daddr = sk -> sk_v6_daddr ; fl6 . saddr = np -> saddr ; fl6 . flowlabel = np -> flow_label ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = sk -> sk_mark ; fl6 . fl6_dport = inet -> inet_dport ; fl6 . fl6_sport = inet -> inet_sport ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { sk -> sk_route_caps = 0 ; sk -> sk_err_soft = - PTR_ERR ( dst ) ; return PTR_ERR ( dst ) ; } else { //Added code to fix CWE-416 dst_release(dst); __ip6_dst_store ( sk , dst , NULL , NULL ) ; } } return 0 ; }",417,-14.043681092946265,-0.033677892309223655
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
int inet6_sk_rebuild_header ( struct sock * sk ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct dst_entry * dst ; dst = __sk_dst_check ( sk , np -> dst_cookie ) ; if ( ! dst ) { struct inet_sock * inet = inet_sk ( sk ) ; struct in6_addr * final_p , final ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = sk -> sk_protocol ; fl6 . daddr = sk -> sk_v6_daddr ; fl6 . saddr = np -> saddr ; fl6 . flowlabel = np -> flow_label ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = sk -> sk_mark ; fl6 . fl6_dport = inet -> inet_dport ; fl6 . fl6_sport = inet -> inet_sport ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { sk -> sk_route_caps = 0 ; sk -> sk_err_soft = - PTR_ERR ( dst ) ; return PTR_ERR ( dst ) ; } __ip6_dst_store ( sk , dst , NULL , NULL ) ; } return 0 ; }
Fixed code:","
int inet6_sk_rebuild_header ( struct sock * sk ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct dst_entry * dst = NULL ; dst = __sk_dst_check ( sk , np -> dst_cookie ) ; if ( dst != NULL ) { return 0 ; } struct inet_sock * inet = inet_sk ( sk ) ; struct in6_addr * final_p , final ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = sk -> sk_protocol ; fl6 . daddr = sk -> sk_v6_daddr ; fl6 . saddr = np -> saddr ; fl6 . flowlabel = np -> flow_label ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = sk -> sk_mark ; fl6 . fl6_dport = inet -> inet_dport ; fl6 . fl6_sport = inet -> inet_sport ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { sk -> sk_route_caps = 0 ; sk -> sk_err_soft = - PTR_ERR ( dst ) ; dst_release ( dst ) ; return PTR_ERR ( dst ) ; } dst_release ( dst ) ; __ip6_dst_store ( sk , dst , NULL , NULL ) ; return 0 ; }",418,-18.21516795489917,-0.04357695682990232
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
int inet6_sk_rebuild_header ( struct sock * sk ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct dst_entry * dst ; dst = __sk_dst_check ( sk , np -> dst_cookie ) ; if ( ! dst ) { struct inet_sock * inet = inet_sk ( sk ) ; struct in6_addr * final_p , final ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = sk -> sk_protocol ; fl6 . daddr = sk -> sk_v6_daddr ; fl6 . saddr = np -> saddr ; fl6 . flowlabel = np -> flow_label ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = sk -> sk_mark ; fl6 . fl6_dport = inet -> inet_dport ; fl6 . fl6_sport = inet -> inet_sport ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { sk -> sk_route_caps = 0 ; sk -> sk_err_soft = - PTR_ERR ( dst ) ; return PTR_ERR ( dst ) ; } __ip6_dst_store ( sk , dst , NULL , NULL ) ; } return 0 ; }
Fixed code:","
int inet6_sk_rebuild_header ( struct sock * sk ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct dst_entry * dst ; dst = __sk_dst_check ( sk , np -> dst_cookie ) ; if ( ! dst ) { struct inet_sock * inet = inet_sk ( sk ) ; struct in6_addr * final_p , final ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = sk -> sk_protocol ; fl6 . daddr = sk -> sk_v6_daddr ; fl6 . saddr = np -> saddr ; fl6 . flowlabel = np -> flow_label ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = sk -> sk_mark ; fl6 . fl6_dport = inet -> inet_dport ; fl6 . fl6_sport = inet -> inet_sport ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { sk -> sk_route_caps = 0 ; sk -> sk_err_soft = - PTR_ERR ( dst ) ; return PTR_ERR ( dst ) ; } __ip6_dst_store ( sk , dst , NULL , NULL ) ; } else { kfree(dst); // Added line to free the dst pointer } return 0 ; }",415,-23.98759743980007,-0.05780143961397607
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
int inet6_sk_rebuild_header ( struct sock * sk ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct dst_entry * dst ; dst = __sk_dst_check ( sk , np -> dst_cookie ) ; if ( ! dst ) { struct inet_sock * inet = inet_sk ( sk ) ; struct in6_addr * final_p , final ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = sk -> sk_protocol ; fl6 . daddr = sk -> sk_v6_daddr ; fl6 . saddr = np -> saddr ; fl6 . flowlabel = np -> flow_label ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = sk -> sk_mark ; fl6 . fl6_dport = inet -> inet_dport ; fl6 . fl6_sport = inet -> inet_sport ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { sk -> sk_route_caps = 0 ; sk -> sk_err_soft = - PTR_ERR ( dst ) ; return PTR_ERR ( dst ) ; } __ip6_dst_store ( sk , dst , NULL , NULL ) ; } return 0 ; }
Fixed code:","
int inet6_sk_rebuild_header ( struct sock * sk ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct dst_entry * dst ; dst = __sk_dst_check ( sk , np -> dst_cookie ) ; if ( ! dst ) { struct inet_sock * inet = inet_sk ( sk ) ; struct in6_addr * final_p , final ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = sk -> sk_protocol ; fl6 . daddr = sk -> sk_v6_daddr ; fl6 . saddr = np -> saddr ; fl6 . flowlabel = np -> flow_label ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = sk -> sk_mark ; fl6 . fl6_dport = inet -> inet_dport ; fl6 . fl6_sport = inet -> inet_sport ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; 
 /* Add reference to prevent use after free */ 
dst_hold(dst);
dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { sk -> sk_route_caps = 0 ; sk -> sk_err_soft = - PTR_ERR ( dst ) ; return PTR_ERR ( dst ) ; } __ip6_dst_store ( sk , dst , NULL , NULL ) ;
/* Release reference to prevent use after free */ 
dst_release(dst);
 } return 0 ; }",442,-32.260430408832676,-0.07298739911500605
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
int inet6_sk_rebuild_header ( struct sock * sk ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct dst_entry * dst ; dst = __sk_dst_check ( sk , np -> dst_cookie ) ; if ( ! dst ) { struct inet_sock * inet = inet_sk ( sk ) ; struct in6_addr * final_p , final ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = sk -> sk_protocol ; fl6 . daddr = sk -> sk_v6_daddr ; fl6 . saddr = np -> saddr ; fl6 . flowlabel = np -> flow_label ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = sk -> sk_mark ; fl6 . fl6_dport = inet -> inet_dport ; fl6 . fl6_sport = inet -> inet_sport ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { sk -> sk_route_caps = 0 ; sk -> sk_err_soft = - PTR_ERR ( dst ) ; return PTR_ERR ( dst ) ; } __ip6_dst_store ( sk , dst , NULL , NULL ) ; } return 0 ; }
Fixed code:","
int inet6_sk_rebuild_header ( struct sock * sk ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct dst_entry * dst ; dst = __sk_dst_check ( sk , np -> dst_cookie ) ; if ( ! dst ) { struct inet_sock * inet = inet_sk ( sk ) ; struct in6_addr * final_p , final ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = sk -> sk_protocol ; fl6 . daddr = sk -> sk_v6_daddr ; fl6 . saddr = np -> saddr ; fl6 . flowlabel = np -> flow_label ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = sk -> sk_mark ; fl6 . fl6_dport = inet -> inet_dport ; fl6 . fl6_sport = inet -> inet_sport ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { sk -> sk_route_caps = 0 ; sk -> sk_err_soft = - PTR_ERR ( dst ) ; kfree(dst); return PTR_ERR ( dst ) ; } __ip6_dst_store ( sk , dst , NULL , NULL ) ; } return 0 ; }

The fixed code adds a call to kfree() to free the memory allocated for the dst object before returning an error. This ensures that the dst object is not used after it has been freed, thus preventing a Use After Free vulnerability.",453,-28.474164751471168,-0.06285687583106218
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
int inet6_sk_rebuild_header ( struct sock * sk ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct dst_entry * dst ; dst = __sk_dst_check ( sk , np -> dst_cookie ) ; if ( ! dst ) { struct inet_sock * inet = inet_sk ( sk ) ; struct in6_addr * final_p , final ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = sk -> sk_protocol ; fl6 . daddr = sk -> sk_v6_daddr ; fl6 . saddr = np -> saddr ; fl6 . flowlabel = np -> flow_label ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = sk -> sk_mark ; fl6 . fl6_dport = inet -> inet_dport ; fl6 . fl6_sport = inet -> inet_sport ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { sk -> sk_route_caps = 0 ; sk -> sk_err_soft = - PTR_ERR ( dst ) ; return PTR_ERR ( dst ) ; } __ip6_dst_store ( sk , dst , NULL , NULL ) ; } return 0 ; }
Fixed code:","
int inet6_sk_rebuild_header ( struct sock * sk ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct dst_entry * dst ; dst = __sk_dst_check ( sk , np -> dst_cookie ) ; if ( ! dst ) { struct inet_sock * inet = inet_sk ( sk ) ; struct in6_addr * final_p , final ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = sk -> sk_protocol ; fl6 . daddr = sk -> sk_v6_daddr ; fl6 . saddr = np -> saddr ; fl6 . flowlabel = np -> flow_label ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = sk -> sk_mark ; fl6 . fl6_dport = inet -> inet_dport ; fl6 . fl6_sport = inet -> inet_sport ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { sk_dst_reset ( sk ) ; sk -> sk_route_caps = 0 ; sk -> sk_err_soft = - PTR_ERR ( dst ) ; return PTR_ERR ( dst ) ; } __ip6_dst_store ( sk , dst , NULL , NULL ) ; } return 0 ; }",408,-5.0057674226929,-0.012269037800717891
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
int inet6_sk_rebuild_header ( struct sock * sk ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct dst_entry * dst ; dst = __sk_dst_check ( sk , np -> dst_cookie ) ; if ( ! dst ) { struct inet_sock * inet = inet_sk ( sk ) ; struct in6_addr * final_p , final ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = sk -> sk_protocol ; fl6 . daddr = sk -> sk_v6_daddr ; fl6 . saddr = np -> saddr ; fl6 . flowlabel = np -> flow_label ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = sk -> sk_mark ; fl6 . fl6_dport = inet -> inet_dport ; fl6 . fl6_sport = inet -> inet_sport ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { sk -> sk_route_caps = 0 ; sk -> sk_err_soft = - PTR_ERR ( dst ) ; return PTR_ERR ( dst ) ; } __ip6_dst_store ( sk , dst , NULL , NULL ) ; } return 0 ; }
Fixed code:","
int inet6_sk_rebuild_header ( struct sock * sk ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct dst_entry * dst ; dst = __sk_dst_check ( sk , np -> dst_cookie ) ; if ( ! dst ) { struct inet_sock * inet = inet_sk ( sk ) ; struct in6_addr * final_p , final ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = sk -> sk_protocol ; fl6 . daddr = sk -> sk_v6_daddr ; fl6 . saddr = np -> saddr ; fl6 . flowlabel = np -> flow_label ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = sk -> sk_mark ; fl6 . fl6_dport = inet -> inet_dport ; fl6 . fl6_sport = inet -> inet_sport ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { sk -> sk_route_caps = 0 ; sk -> sk_err_soft = - PTR_ERR ( dst ) ; return PTR_ERR ( dst ) ; } dst_release(dst); __ip6_dst_store ( sk , dst , NULL , NULL ) ; } return 0 ; }",405,-5.741315420066072,-0.014176087456953264
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
int inet6_sk_rebuild_header ( struct sock * sk ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct dst_entry * dst ; dst = __sk_dst_check ( sk , np -> dst_cookie ) ; if ( ! dst ) { struct inet_sock * inet = inet_sk ( sk ) ; struct in6_addr * final_p , final ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = sk -> sk_protocol ; fl6 . daddr = sk -> sk_v6_daddr ; fl6 . saddr = np -> saddr ; fl6 . flowlabel = np -> flow_label ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = sk -> sk_mark ; fl6 . fl6_dport = inet -> inet_dport ; fl6 . fl6_sport = inet -> inet_sport ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { sk -> sk_route_caps = 0 ; sk -> sk_err_soft = - PTR_ERR ( dst ) ; return PTR_ERR ( dst ) ; } __ip6_dst_store ( sk , dst , NULL , NULL ) ; } return 0 ; }
Fixed code:","
int inet6_sk_rebuild_header ( struct sock * sk ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct dst_entry * dst ; 
dst = __sk_dst_check ( sk , np -> dst_cookie ) ; if ( dst ) { //dst has been updated, clear the cookie and don't use cached dst np -> dst_cookie = 0; dst = NULL; } 
if ( ! dst ) { struct inet_sock * inet = inet_sk ( sk ) ; struct in6_addr * final_p , final ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = sk -> sk_protocol ; fl6 . daddr = sk -> sk_v6_daddr ; fl6 . saddr = np -> saddr ; fl6 . flowlabel = np -> flow_label ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = sk -> sk_mark ; fl6 . fl6_dport = inet -> inet_dport ; fl6 . fl6_sport = inet -> inet_sport ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { sk -> sk_route_caps = 0 ; sk -> sk_err_soft = - PTR_ERR ( dst ) ; return PTR_ERR ( dst ) ; } __ip6_dst_store ( sk , dst , NULL , NULL ) ; } return 0 ; }",437,-50.355167961848394,-0.1152292173040009
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
int inet6_sk_rebuild_header ( struct sock * sk ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct dst_entry * dst ; dst = __sk_dst_check ( sk , np -> dst_cookie ) ; if ( ! dst ) { struct inet_sock * inet = inet_sk ( sk ) ; struct in6_addr * final_p , final ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = sk -> sk_protocol ; fl6 . daddr = sk -> sk_v6_daddr ; fl6 . saddr = np -> saddr ; fl6 . flowlabel = np -> flow_label ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = sk -> sk_mark ; fl6 . fl6_dport = inet -> inet_dport ; fl6 . fl6_sport = inet -> inet_sport ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { sk -> sk_route_caps = 0 ; sk -> sk_err_soft = - PTR_ERR ( dst ) ; return PTR_ERR ( dst ) ; } __ip6_dst_store ( sk , dst , NULL , NULL ) ; } return 0 ; }
Fixed code:","
int inet6_sk_rebuild_header ( struct sock * sk ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct dst_entry * dst ; dst = __sk_dst_check ( sk , np -> dst_cookie ) ; if ( ! dst ) { struct inet_sock * inet = inet_sk ( sk ) ; struct in6_addr * final_p , final ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = sk -> sk_protocol ; fl6 . daddr = sk -> sk_v6_daddr ; fl6 . saddr = np -> saddr ; fl6 . flowlabel = np -> flow_label ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = sk -> sk_mark ; fl6 . fl6_dport = inet -> inet_dport ; fl6 . fl6_sport = inet -> inet_sport ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; {   // Add braces.
    struct dst_entry *new_dst; // Add new_dst.
    new_dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; // Lookup new_dst.
    if ( IS_ERR ( new_dst ) ) { // Check if the new_dst is valid.
        sk -> sk_route_caps = 0 ; sk -> sk_err_soft = - PTR_ERR ( new_dst ) ; return PTR_ERR ( new_dst ) ;
    }
    dst_release ( dst ) ; // Free old dst.
    dst = new_dst ; // Replace old dst with new dst.
    __ip6_dst_store ( sk , dst , NULL , NULL ) ;
} } return 0 ; }",497,-71.09119457003017,-0.14304063293768646
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
int inet6_sk_rebuild_header ( struct sock * sk ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct dst_entry * dst ; dst = __sk_dst_check ( sk , np -> dst_cookie ) ; if ( ! dst ) { struct inet_sock * inet = inet_sk ( sk ) ; struct in6_addr * final_p , final ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = sk -> sk_protocol ; fl6 . daddr = sk -> sk_v6_daddr ; fl6 . saddr = np -> saddr ; fl6 . flowlabel = np -> flow_label ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = sk -> sk_mark ; fl6 . fl6_dport = inet -> inet_dport ; fl6 . fl6_sport = inet -> inet_sport ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { sk -> sk_route_caps = 0 ; sk -> sk_err_soft = - PTR_ERR ( dst ) ; return PTR_ERR ( dst ) ; } __ip6_dst_store ( sk , dst , NULL , NULL ) ; } return 0 ; }
Fixed code:","
int inet6_sk_rebuild_header ( struct sock * sk ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct dst_entry * dst ; dst = __sk_dst_check ( sk , np -> dst_cookie ) ; if ( ! dst ) { struct inet_sock * inet = inet_sk ( sk ) ; struct in6_addr * final_p , final ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = sk -> sk_protocol ; fl6 . daddr = sk -> sk_v6_daddr ; fl6 . saddr = np -> saddr ; fl6 . flowlabel = np -> flow_label ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = sk -> sk_mark ; fl6 . fl6_dport = inet -> inet_dport ; fl6 . fl6_sport = inet -> inet_sport ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { sk -> sk_route_caps = 0 ; sk -> sk_err_soft = - PTR_ERR ( dst ) ; return PTR_ERR ( dst ) ; } __ip6_dst_store ( sk , dst , dst_release , NULL ) ; } return 0 ; }

The fixed code adds dst_release as the second argument in the function call to __ip6_dst_store. dst_release is a function that will free the memory allocated to the dst pointer, avoiding a use-after-free vulnerability.",453,-42.2840462036994,-0.0933422653503298
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
int inet6_sk_rebuild_header ( struct sock * sk ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct dst_entry * dst ; dst = __sk_dst_check ( sk , np -> dst_cookie ) ; if ( ! dst ) { struct inet_sock * inet = inet_sk ( sk ) ; struct in6_addr * final_p , final ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = sk -> sk_protocol ; fl6 . daddr = sk -> sk_v6_daddr ; fl6 . saddr = np -> saddr ; fl6 . flowlabel = np -> flow_label ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = sk -> sk_mark ; fl6 . fl6_dport = inet -> inet_dport ; fl6 . fl6_sport = inet -> inet_sport ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { sk -> sk_route_caps = 0 ; sk -> sk_err_soft = - PTR_ERR ( dst ) ; return PTR_ERR ( dst ) ; } __ip6_dst_store ( sk , dst , NULL , NULL ) ; } return 0 ; }
Fixed code:","
int inet6_sk_rebuild_header ( struct sock * sk ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct dst_entry * dst ; dst = __sk_dst_check ( sk , np -> dst_cookie ) ; if ( ! dst ) { struct inet_sock * inet = inet_sk ( sk ) ; struct in6_addr * final_p , final ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = sk -> sk_protocol ; fl6 . daddr = sk -> sk_v6_daddr ; fl6 . saddr = np -> saddr ; fl6 . flowlabel = np -> flow_label ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = sk -> sk_mark ; fl6 . fl6_dport = inet -> inet_dport ; fl6 . fl6_sport = inet -> inet_sport ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { sk -> sk_route_caps = 0 ; sk -> sk_err_soft = - PTR_ERR ( dst ) ; kfree(dst); /* Added Line */ return PTR_ERR ( dst ) ; } __ip6_dst_store ( sk , dst , NULL , NULL ) ; } return 0 ; }",408,-12.431744301969811,-0.03046996152443581
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
int inet6_sk_rebuild_header ( struct sock * sk ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct dst_entry * dst ; dst = __sk_dst_check ( sk , np -> dst_cookie ) ; if ( ! dst ) { struct inet_sock * inet = inet_sk ( sk ) ; struct in6_addr * final_p , final ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = sk -> sk_protocol ; fl6 . daddr = sk -> sk_v6_daddr ; fl6 . saddr = np -> saddr ; fl6 . flowlabel = np -> flow_label ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = sk -> sk_mark ; fl6 . fl6_dport = inet -> inet_dport ; fl6 . fl6_sport = inet -> inet_sport ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { sk -> sk_route_caps = 0 ; sk -> sk_err_soft = - PTR_ERR ( dst ) ; return PTR_ERR ( dst ) ; } __ip6_dst_store ( sk , dst , NULL , NULL ) ; } return 0 ; }
Fixed code:","
int inet6_sk_rebuild_header ( struct sock * sk ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct dst_entry * dst ; dst = __sk_dst_check ( sk , np -> dst_cookie ) ; if ( ! dst ) { struct inet_sock * inet = inet_sk ( sk ) ; struct in6_addr * final_p , final ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = sk -> sk_protocol ; fl6 . daddr = sk -> sk_v6_daddr ; fl6 . saddr = np -> saddr ; fl6 . flowlabel = np -> flow_label ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = sk -> sk_mark ; fl6 . fl6_dport = inet -> inet_dport ; fl6 . fl6_sport = inet -> inet_sport ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; /* ADDED */ if (dst) { /* ADDED */ dst_release(dst); /* ADDED */ } /* ADDED */ if ( IS_ERR ( dst ) ) { sk -> sk_route_caps = 0 ; sk -> sk_err_soft = - PTR_ERR ( dst ) ; return PTR_ERR ( dst ) ; } __ip6_dst_store ( sk , dst , NULL , NULL ) ; } return 0 ; }",428,-17.0449876598828,-0.03982473752309065
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
int inet6_sk_rebuild_header ( struct sock * sk ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct dst_entry * dst ; dst = __sk_dst_check ( sk , np -> dst_cookie ) ; if ( ! dst ) { struct inet_sock * inet = inet_sk ( sk ) ; struct in6_addr * final_p , final ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = sk -> sk_protocol ; fl6 . daddr = sk -> sk_v6_daddr ; fl6 . saddr = np -> saddr ; fl6 . flowlabel = np -> flow_label ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = sk -> sk_mark ; fl6 . fl6_dport = inet -> inet_dport ; fl6 . fl6_sport = inet -> inet_sport ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { sk -> sk_route_caps = 0 ; sk -> sk_err_soft = - PTR_ERR ( dst ) ; return PTR_ERR ( dst ) ; } __ip6_dst_store ( sk , dst , NULL , NULL ) ; } return 0 ; }
Fixed code:","
int inet6_sk_rebuild_header ( struct sock * sk ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct dst_entry * dst ; dst = __sk_dst_check ( sk , np -> dst_cookie ) ; if ( ! dst ) { struct inet_sock * inet = inet_sk ( sk ) ; struct in6_addr * final_p , final ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = sk -> sk_protocol ; fl6 . daddr = sk -> sk_v6_daddr ; fl6 . saddr = np -> saddr ; fl6 . flowlabel = np -> flow_label ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = sk -> sk_mark ; fl6 . fl6_dport = inet -> inet_dport ; fl6 . fl6_sport = inet -> inet_sport ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { sk -> sk_route_caps = 0 ; sk -> sk_err_soft = - PTR_ERR ( dst ) ; dst_release ( dst ) ; return PTR_ERR ( dst ) ; } __ip6_dst_store ( sk , dst , NULL , NULL ) ; } return 0 ; }",405,-4.468123119075079,-0.011032402763148343
