Original code,Plausible Program,Total Tokens,Sum Entropy,Mean Entropy
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { struct packet_sock * po = pkt_sk ( sk ) ; struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } if ( ! po -> running ) return - EINVAL ; if ( po -> fanout ) return - EALREADY ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; } mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : mutex_unlock ( & fanout_mutex ) ; if ( err ) { kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }
Fixed code:","
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { struct packet_sock * po = pkt_sk ( sk ) ; struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } if ( ! po -> running ) return - EINVAL ; if ( po -> fanout ) return - EALREADY ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; } mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : mutex_unlock ( & fanout_mutex ) ; if ( err ) { kfree ( po -> rollover ) ; po -> rollover = NULL ; kfree ( match ) ; } return err ; }",869,-8.407572662065386,-0.00967499730962645
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { struct packet_sock * po = pkt_sk ( sk ) ; struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } if ( ! po -> running ) return - EINVAL ; if ( po -> fanout ) return - EALREADY ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; } mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : mutex_unlock ( & fanout_mutex ) ; if ( err ) { kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }
Fixed code:","
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { struct packet_sock * po = pkt_sk ( sk ) ; struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } if ( ! po -> running ) return - EINVAL ; if ( po -> fanout ) return - EALREADY ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { po -> rollover = kmalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; } mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kmalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : mutex_unlock ( & fanout_mutex ) ; if ( err ) { kfree ( po -> rollover ) ; po -> rollover = NULL ; kfree(match); } return err ; }",866,-9.596385459249209,-0.011081276511835115
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { struct packet_sock * po = pkt_sk ( sk ) ; struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } if ( ! po -> running ) return - EINVAL ; if ( po -> fanout ) return - EALREADY ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; } mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : mutex_unlock ( & fanout_mutex ) ; if ( err ) { kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }
Fixed code:","
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { struct packet_sock * po = pkt_sk ( sk ) ; struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } if ( ! po -> running ) return - EINVAL ; if ( po -> fanout ) return - EALREADY ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; } mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { /* Added code to fix the Use After Free vulnerability */ if (po->prot_hook) { __dev_remove_pack ( & po -> prot_hook ) ; } po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : mutex_unlock ( & fanout_mutex ) ; if ( err ) { kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }",884,-19.716393169328246,-0.022303612182498017
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { struct packet_sock * po = pkt_sk ( sk ) ; struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } if ( ! po -> running ) return - EINVAL ; if ( po -> fanout ) return - EALREADY ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; } mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : mutex_unlock ( & fanout_mutex ) ; if ( err ) { kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }
Fixed code:","
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { 
struct packet_sock * po = pkt_sk ( sk ) ; 
struct packet_fanout * f , * match ; 
u8 type = type_flags & 0xff ; 
u8 flags = type_flags >> 8 ; 
int err ; 
switch ( type ) { 
case PACKET_FANOUT_ROLLOVER : 
if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) 
return - EINVAL ; 
case PACKET_FANOUT_HASH : 
case PACKET_FANOUT_LB : 
case PACKET_FANOUT_CPU : 
case PACKET_FANOUT_RND : 
case PACKET_FANOUT_QM : 
case PACKET_FANOUT_CBPF : 
case PACKET_FANOUT_EBPF : 
break ; 
default : 
return - EINVAL ; 
} 
if ( ! po -> running ) 
return - EINVAL ; 
if ( po -> fanout ) 
return - EALREADY ; 
if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { 
po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; 
if ( ! po -> rollover ) 
return - ENOMEM ; 
atomic_long_set ( & po -> rollover -> num , 0 ) ; 
atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; 
atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; 
} 
mutex_lock ( & fanout_mutex ) ; 
match = NULL ; 
list_for_each_entry ( f , & fanout_list , list ) { 
if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { 
match = f ; 
break ; 
} 
} 
err = - EINVAL ; 
if ( match && match -> flags != flags ) 
goto out ; 
if ( ! match ) { 
err = - ENOMEM ; 
match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; 
if ( ! match ) 
goto out ; 
write_pnet ( & match -> net , sock_net ( sk ) ) ; 
match -> id = id ; 
match -> type = type ; 
match -> flags = flags ; 
INIT_LIST_HEAD ( & match -> list ) ; 
spin_lock_init ( & match -> lock ) ; 
atomic_set ( & match -> sk_ref , 0 ) ; 
fanout_init_data ( match ) ; 
match -> prot_hook . type = po -> prot_hook . type ; 
match -> prot_hook . dev = po -> prot_hook . dev ; 
match -> prot_hook . func = packet_rcv_fanout ; 
match -> prot_hook . af_packet_priv = match ; 
match -> prot_hook . id_match = match_fanout_group ; 
err = dev_add_pack_dynamic ( & match -> prot_hook ) ; 
if (err < 0 ) { 
kfree ( match ) ; 
goto out ; 
} 
list_add ( & match -> list , & fanout_list ) ; 
} 
err = - EINVAL ; 
if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { 
err = - ENOSPC ; 
if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { 
__dev_remove_pack ( & po -> prot_hook ) ; 
po -> fanout = match ; 
atomic_inc ( & match -> sk_ref ) ; 
__fanout_link ( sk , po ) ; 
err = 0 ; 
",1000,-31.228573059948953,-0.031228573059948955
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { struct packet_sock * po = pkt_sk ( sk ) ; struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } if ( ! po -> running ) return - EINVAL ; if ( po -> fanout ) return - EALREADY ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; } mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : mutex_unlock ( & fanout_mutex ) ; if ( err ) { kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }
Fixed code:","
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { struct packet_sock * po = pkt_sk ( sk ) ; struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } if ( ! po -> running ) return - EINVAL ; if ( po -> fanout ) return - EALREADY ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; } mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; //Add reference to the packet_sock object, so that the match object cannot be freed. po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : mutex_unlock ( & fanout_mutex ) ; if ( err ) { kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }",883,-36.15837264304669,-0.040949459391898854
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { struct packet_sock * po = pkt_sk ( sk ) ; struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } if ( ! po -> running ) return - EINVAL ; if ( po -> fanout ) return - EALREADY ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; } mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : mutex_unlock ( & fanout_mutex ) ; if ( err ) { kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }
Fixed code:","
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { struct packet_sock * po = pkt_sk ( sk ) ; struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } if ( ! po -> running ) return - EINVAL ; if ( po -> fanout ) return - EALREADY ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; } mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : mutex_unlock ( & fanout_mutex ) ; if ( err ) { kfree ( po -> rollover ) ; po -> rollover = NULL ; kfree ( match ); // Added to prevent Use-After-Free errors } return err ; }",878,-22.093467773615924,-0.025163402931225425
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { struct packet_sock * po = pkt_sk ( sk ) ; struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } if ( ! po -> running ) return - EINVAL ; if ( po -> fanout ) return - EALREADY ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; } mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : mutex_unlock ( & fanout_mutex ) ; if ( err ) { kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }
Fixed code:","
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { struct packet_sock * po = pkt_sk ( sk ) ; struct packet_fanout * f , * match , *f_cpy; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } if ( ! po -> running ) return - EINVAL ; if ( po -> fanout ) return - EALREADY ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; } mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; //Add f_cpy to store a copy of the memory location if ( ! match ) { f_cpy = match; goto out ; } write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : //Add kfree to free the memory location kfree(f_cpy); mutex_unlock ( & fanout_mutex ) ; if ( err ) { kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }",909,-47.924397036336664,-0.05272210895086542
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { struct packet_sock * po = pkt_sk ( sk ) ; struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } if ( ! po -> running ) return - EINVAL ; if ( po -> fanout ) return - EALREADY ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; } mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : mutex_unlock ( & fanout_mutex ) ; if ( err ) { kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }
Fixed code:","
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { struct packet_sock * po = pkt_sk ( sk ) ; struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } if ( ! po -> running ) return - EINVAL ; if ( po -> fanout ) return - EALREADY ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; } mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } else { kfree ( match ); } out : mutex_unlock ( & fanout_mutex ) ; if ( err ) { kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }",871,-10.239773993402228,-0.011756342127901524
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { struct packet_sock * po = pkt_sk ( sk ) ; struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } if ( ! po -> running ) return - EINVAL ; if ( po -> fanout ) return - EALREADY ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; } mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : mutex_unlock ( & fanout_mutex ) ; if ( err ) { kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }
Fixed code:","
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { struct packet_sock * po = pkt_sk ( sk ) ; struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } if ( ! po -> running ) return - EINVAL ; if ( po -> fanout ) return - EALREADY ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; } mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) { kfree(match); match = NULL; goto out ; } if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : mutex_unlock ( & fanout_mutex ) ; if ( err ) { kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }",874,-7.239710708271143,-0.00828342186301046
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { struct packet_sock * po = pkt_sk ( sk ) ; struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } if ( ! po -> running ) return - EINVAL ; if ( po -> fanout ) return - EALREADY ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; } mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : mutex_unlock ( & fanout_mutex ) ; if ( err ) { kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }
Fixed code:","
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { struct packet_sock * po = pkt_sk ( sk ) ; struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } if ( ! po -> running ) return - EINVAL ; if ( po -> fanout ) return - EALREADY ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; } mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : if ( err ) { // Add kfree(match) to avoid use-after-free mutex_unlock ( & fanout_mutex ) ; kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }",877,-22.264080175171728,-0.025386636459716908
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { struct packet_sock * po = pkt_sk ( sk ) ; struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } if ( ! po -> running ) return - EINVAL ; if ( po -> fanout ) return - EALREADY ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; } mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : mutex_unlock ( & fanout_mutex ) ; if ( err ) { kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }
Fixed code:","
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { struct packet_sock * po = pkt_sk ( sk ) ; struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } if ( ! po -> running ) return - EINVAL ; if ( po -> fanout ) return - EALREADY ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; } mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : if ( err ) { kfree ( po -> rollover ) ; po -> rollover = NULL ; kfree ( match ) ; match = NULL ; } mutex_unlock ( & fanout_mutex ) ; return err ; }",873,-9.938822822430689,-0.011384676772543744
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { struct packet_sock * po = pkt_sk ( sk ) ; struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } if ( ! po -> running ) return - EINVAL ; if ( po -> fanout ) return - EALREADY ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; } mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : mutex_unlock ( & fanout_mutex ) ; if ( err ) { kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }
Fixed code:","
static int fanout_add(struct sock *sk, u16 id, u16 type_flags) {
  struct packet_sock *po = pkt_sk(sk);
  struct packet_fanout *f, *match;
  u8 type = type_flags & 0xff;
  u8 flags = type_flags >> 8;
  int err;
  
  switch (type) {
    case PACKET_FANOUT_ROLLOVER:
      if (type_flags & PACKET_FANOUT_FLAG_ROLLOVER)
        return -EINVAL;
    case PACKET_FANOUT_HASH:
    case PACKET_FANOUT_LB:
    case PACKET_FANOUT_CPU:
    case PACKET_FANOUT_RND:
    case PACKET_FANOUT_QM:
    case PACKET_FANOUT_CBPF:
    case PACKET_FANOUT_EBPF:
      break;
    default:
      return -EINVAL;
  }
  if (!po->running)
    return -EINVAL;
  if (po->fanout)
    return -EALREADY;
  if (type == PACKET_FANOUT_ROLLOVER || (type_flags & PACKET_FANOUT_FLAG_ROLLOVER)) {
    po->rollover = kzalloc(sizeof(*po->rollover), GFP_KERNEL);
    if (!po->rollover)
      return -ENOMEM;
    atomic_long_set(&po->rollover->num, 0);
    atomic_long_set(&po->rollover->num_huge, 0);
    atomic_long_set(&po->rollover->num_failed, 0);
  }
  mutex_lock(&fanout_mutex);
  match = NULL;
  list_for_each_entry(f, &fanout_list, list) {
    if (f->id == id && read_pnet(&f->net) == sock_net(sk)) {
      match = f;
      break;
    }
  }
  err = -EINVAL;
  if (match && match->flags != flags)
    goto out;
  if (!match) {
    err = -ENOMEM;
    match = kzalloc(sizeof(*match), GFP_KERNEL);
    if (!match)
      goto out;
    write_pnet(&match->net, sock_net(sk));
    match->id = id;
    match->type = type;
    match->flags = flags;
    INIT_LIST_HEAD(&match->list);
    spin_lock_init(&match->lock);
    atomic_set(&match->sk_ref, 0);
    fanout_init_data(match);
    match->prot_hook.type = po->prot_hook.type;
    match->prot_hook.dev = po->prot_hook.dev;
    match->prot_hook.func = packet_rcv_fanout;
    match->prot_hook.af_packet_priv = match;
    match->prot_hook.id_match = match_fanout_group;
    dev_add_pack(&match->prot_hook);
    list_add(&match->list, &fanout_list);
  }
  err = -EINVAL;
  if (match->type == type && match->prot_hook.type == po->prot_hook.type &&
      match->prot_hook.dev == po->prot_hook.dev) {
    err = -ENOSPC;
    if (atomic_read(&match->sk_ref) < PACKET_FANOUT_MAX) {
      __dev_remove_pack(&po->prot_hook);
      // Add reference to the match struct so that it cannot be freed before use
      atomic_inc(&match->ref);
      po->fanout = match;
      atomic_inc(&match->sk_ref);
      __fanout_link(sk, po);
      err = 0;
    }
  }
out:
  // Decrement reference to the match struct
  atomic_dec(&match->ref);
  mutex_unlock(&fanout_mutex);
",1000,-50.22918825205884,-0.05022918825205884
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { struct packet_sock * po = pkt_sk ( sk ) ; struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } if ( ! po -> running ) return - EINVAL ; if ( po -> fanout ) return - EALREADY ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; } mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : mutex_unlock ( & fanout_mutex ) ; if ( err ) { kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }
Fixed code:","
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { struct packet_sock * po = pkt_sk ( sk ) ; struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } if ( ! po -> running ) return - EINVAL ; if ( po -> fanout ) return - EALREADY ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; } mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; if ( po -> fanout )  // Added line to check if fanout is already set. 
    {
        // Add code to free any memory associated with po->fanout
        kfree ( po -> fanout ); 
    }
    po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : mutex_unlock ( & fanout_mutex ) ; if ( err ) { kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }",918,-49.68604246763112,-0.05412422926757202
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { struct packet_sock * po = pkt_sk ( sk ) ; struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } if ( ! po -> running ) return - EINVAL ; if ( po -> fanout ) return - EALREADY ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; } mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : mutex_unlock ( & fanout_mutex ) ; if ( err ) { kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }
Fixed code:","
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { struct packet_sock * po = pkt_sk ( sk ) ; struct packet_fanout * f , * match = NULL ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } if ( ! po -> running ) return - EINVAL ; if ( po -> fanout ) return - EALREADY ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; } mutex_lock ( & fanout_mutex ) ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) { kfree ( po -> rollover ) ; po -> rollover = NULL ; goto out ; } write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : mutex_unlock ( & fanout_mutex ) ; return err ; }",857,-9.957665440876092,-0.011619212883169302
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { struct packet_sock * po = pkt_sk ( sk ) ; struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } if ( ! po -> running ) return - EINVAL ; if ( po -> fanout ) return - EALREADY ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; } mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : mutex_unlock ( & fanout_mutex ) ; if ( err ) { kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }
Fixed code:","
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { struct packet_sock * po = pkt_sk ( sk ) ; struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } if ( ! po -> running ) return - EINVAL ; if ( po -> fanout ) return - EALREADY ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; } mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { if ( po -> fanout ) { kfree ( po -> fanout ) ; po -> fanout = NULL ; } __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : mutex_unlock ( & fanout_mutex ) ; if ( err ) { kfree ( po -> fanout ) ; kfree ( po -> rollover ) ; po -> fanout = NULL ; po -> rollover = NULL ; } return err ; }",904,-13.979157568960789,-0.015463669877169014
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { struct packet_sock * po = pkt_sk ( sk ) ; struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } if ( ! po -> running ) return - EINVAL ; if ( po -> fanout ) return - EALREADY ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; } mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : mutex_unlock ( & fanout_mutex ) ; if ( err ) { kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }
Fixed code:","
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { struct packet_sock * po = pkt_sk ( sk ) ; struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } if ( ! po -> running ) return - EINVAL ; if ( po -> fanout ) return - EALREADY ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; } mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto fanout_add_out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto fanout_add_out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } fanout_add_out : if ( err ) { //Add a check to ensure that the fanout is not already free before attempting to free it if ( po -> fanout )  kfree ( po -> rollover ) ; po -> rollover = NULL ; } mutex_unlock ( & fanout_mutex ) ; return err ; }",905,-51.292568477214964,-0.056676871245541396
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { struct packet_sock * po = pkt_sk ( sk ) ; struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } if ( ! po -> running ) return - EINVAL ; if ( po -> fanout ) return - EALREADY ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; } mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : mutex_unlock ( & fanout_mutex ) ; if ( err ) { kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }
Fixed code:","
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { struct packet_sock * po = pkt_sk ( sk ) ; struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } if ( ! po -> running ) return - EINVAL ; if ( po -> fanout ) return - EALREADY ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; } mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; kref_get ( & match -> refcount ) ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) { kref_put ( & match -> refcount ) ; goto out ; } if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; kref_init ( & match -> refcount ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : mutex_unlock ( & fanout_mutex ) ; if ( err ) { kref_put ( & match -> refcount ) ; kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }",913,-14.31289526609514,-0.015676774661659516
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { struct packet_sock * po = pkt_sk ( sk ) ; struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } if ( ! po -> running ) return - EINVAL ; if ( po -> fanout ) return - EALREADY ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; } mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : mutex_unlock ( & fanout_mutex ) ; if ( err ) { kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }
Fixed code:","
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { struct packet_sock * po = pkt_sk ( sk ) ; struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } if ( ! po -> running ) return - EINVAL ; if ( po -> fanout ) return - EALREADY ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; } mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags && atomic_read ( & match -> sk_ref ) >= PACKET_FANOUT_MAX ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : mutex_unlock ( & fanout_mutex ) ; if ( err ) { kfree ( match ) ; // Add this line kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }
Now, in the above code, a check is added to the if-block that checks if the fanout reference count is greater than or equal to the maximum allowed number of fanouts. If it is greater than the maximum, the request is rejected and the fanout is not allocated. This prevents the Use After Free vulnerability as the fanout is never allocated if the reference count is greater than the maximum.",977,-102.03762072078523,-0.10443973461697567
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { struct packet_sock * po = pkt_sk ( sk ) ; struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } if ( ! po -> running ) return - EINVAL ; if ( po -> fanout ) return - EALREADY ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; } mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : mutex_unlock ( & fanout_mutex ) ; if ( err ) { kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }
Fixed code:","
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { struct packet_sock * po = pkt_sk ( sk ) ; struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } if ( ! po -> running ) return - EINVAL ; if ( po -> fanout ) return - EALREADY ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; } mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out_unlock ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out_unlock ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out_unlock: mutex_unlock ( & fanout_mutex ) ; if ( err ) { kfree ( po -> rollover ) ; po -> rollover = NULL ; kfree ( match ) ; // Added this line to fix the vulnerability } return err ; }",886,-17.547269902557318,-0.01980504503674641
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { struct packet_sock * po = pkt_sk ( sk ) ; struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } if ( ! po -> running ) return - EINVAL ; if ( po -> fanout ) return - EALREADY ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; } mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : mutex_unlock ( & fanout_mutex ) ; if ( err ) { kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }
Fixed code:","
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { struct packet_sock * po = pkt_sk ( sk ) ; struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } if ( ! po -> running ) return - EINVAL ; if ( po -> fanout ) return - EALREADY ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; } mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { if (atomic_inc_not_zero(&match->sk_ref) == 0) { kfree(match); match = NULL; } else { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } } out : mutex_unlock ( & fanout_mutex ) ; if ( err ) { kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }",896,-15.186460518534895,-0.016949174685864838
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { struct packet_sock * po = pkt_sk ( sk ) ; struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } if ( ! po -> running ) return - EINVAL ; if ( po -> fanout ) return - EALREADY ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; } mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : mutex_unlock ( & fanout_mutex ) ; if ( err ) { kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }
Fixed code:","
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { struct packet_sock * po = pkt_sk ( sk ) ; struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } if ( ! po -> running ) return - EINVAL ; if ( po -> fanout ) return - EALREADY ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; } mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) { kfree(match); match = NULL; goto out ; } if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : mutex_unlock ( & fanout_mutex ) ; if ( err ) { kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }",874,-7.037495663701962,-0.008052054535128103
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { struct packet_sock * po = pkt_sk ( sk ) ; struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } if ( ! po -> running ) return - EINVAL ; if ( po -> fanout ) return - EALREADY ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; } mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : mutex_unlock ( & fanout_mutex ) ; if ( err ) { kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }
Fixed code:","
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { struct packet_sock * po = pkt_sk ( sk ) ; struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } if ( ! po -> running ) return - EINVAL ; if ( po -> fanout ) return - EALREADY ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; } mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : mutex_unlock ( & fanout_mutex ) ; if ( err ) { kfree ( po -> rollover ) ; po -> rollover = NULL ; // Add this line kfree(match); // Add this line } return err ; }",876,-14.367625179126785,-0.016401398606309115
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { struct packet_sock * po = pkt_sk ( sk ) ; struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } if ( ! po -> running ) return - EINVAL ; if ( po -> fanout ) return - EALREADY ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; } mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : mutex_unlock ( & fanout_mutex ) ; if ( err ) { kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }
Fixed code:","

static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { struct packet_sock * po = pkt_sk ( sk ) ; struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } if ( ! po -> running ) return - EINVAL ; if ( po -> fanout ) return - EALREADY ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; } mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; // Prevent use-after-free vulnerability by // checking if the pointer is valid or not before // assigning it to the fanout. if ( match ) { po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } } out : mutex_unlock ( & fanout_mutex ) ; if ( err ) { kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }",897,-44.70940582473673,-0.049843261789004153
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { struct packet_sock * po = pkt_sk ( sk ) ; struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } if ( ! po -> running ) return - EINVAL ; if ( po -> fanout ) return - EALREADY ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; } mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : mutex_unlock ( & fanout_mutex ) ; if ( err ) { kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }
Fixed code:","
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { struct packet_sock * po = pkt_sk ( sk ) ; struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } if ( ! po -> running ) return - EINVAL ; if ( po -> fanout ) return - EALREADY ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; } mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) { kfree(match); match = NULL; } if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : mutex_unlock ( & fanout_mutex ) ; if ( err ) { kfree ( po -> rollover ) ; kfree(match); po -> rollover = NULL ; } return err ; }",876,-8.042238469012075,-0.009180637521703281
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { struct packet_sock * po = pkt_sk ( sk ) ; struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } if ( ! po -> running ) return - EINVAL ; if ( po -> fanout ) return - EALREADY ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; } mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : mutex_unlock ( & fanout_mutex ) ; if ( err ) { kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }
Fixed code:","
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { struct packet_sock * po = pkt_sk ( sk ) ; struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } if ( ! po -> running ) return - EINVAL ; if ( po -> fanout ) return - EALREADY ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; } mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) { kfree(match); goto out ; } if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : mutex_unlock ( & fanout_mutex ) ; if ( err ) { kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }",870,-6.179150362785682,-0.007102471681362853
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { struct packet_sock * po = pkt_sk ( sk ) ; struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } if ( ! po -> running ) return - EINVAL ; if ( po -> fanout ) return - EALREADY ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; } mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : mutex_unlock ( & fanout_mutex ) ; if ( err ) { kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }
Fixed code:"," 
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { struct packet_sock * po = pkt_sk ( sk ) ; struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } if ( ! po -> running ) return - EINVAL ; if ( po -> fanout ) return - EALREADY ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; } mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { sock_hold(sk); //Add sock_hold to prevent use-after-free __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : mutex_unlock ( & fanout_mutex ) ; if ( err ) { sock_put(sk); //Add sock_put to prevent use-after-free kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }",900,-23.316027291361653,-0.025906696990401837
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { struct packet_sock * po = pkt_sk ( sk ) ; struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } if ( ! po -> running ) return - EINVAL ; if ( po -> fanout ) return - EALREADY ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; } mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : mutex_unlock ( & fanout_mutex ) ; if ( err ) { kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }
Fixed code:","
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { struct packet_sock * po = pkt_sk ( sk ) ; struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } if ( ! po -> running ) return - EINVAL ; if ( po -> fanout ) return - EALREADY ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; } mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { if ( po->fanout ) { atomic_dec(&po->fanout->sk_ref); kfree(po->fanout); } __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : mutex_unlock ( & fanout_mutex ) ; if ( err ) { kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }",893,-13.581039636536582,-0.01520833105995138
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { struct packet_sock * po = pkt_sk ( sk ) ; struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } if ( ! po -> running ) return - EINVAL ; if ( po -> fanout ) return - EALREADY ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; } mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : mutex_unlock ( & fanout_mutex ) ; if ( err ) { kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }
Fixed code:","
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { struct packet_sock * po = pkt_sk ( sk ) ; struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } if ( ! po -> running ) return - EINVAL ; if ( po -> fanout ) return - EALREADY ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; } mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : mutex_unlock ( & fanout_mutex ) ; if ( err ) { kzfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }
The vulnerability is fixed by replacing the kfree() function with the kzfree() function. The kfree() function frees a memory block allocated with the kernel's allocator. While the kzfree() function zeroes the memory before freeing it. This prevents the use of the freed memory after it has been deallocated.",934,-58.717246605390095,-0.06286643105502152
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { struct packet_sock * po = pkt_sk ( sk ) ; struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } if ( ! po -> running ) return - EINVAL ; if ( po -> fanout ) return - EALREADY ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; } mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : mutex_unlock ( & fanout_mutex ) ; if ( err ) { kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }
Fixed code:","
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { struct packet_sock * po = pkt_sk ( sk ) ; struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } if ( ! po -> running ) return - EINVAL ; if ( po -> fanout ) return - EALREADY ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; } mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; }  else { kfree ( po -> rollover ) ; po -> rollover = NULL ; } } out : mutex_unlock ( & fanout_mutex ) ; return err ; }",861,-15.306909823391324,-0.01777806018976925
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { struct packet_sock * po = pkt_sk ( sk ) ; struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } if ( ! po -> running ) return - EINVAL ; if ( po -> fanout ) return - EALREADY ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; } mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : mutex_unlock ( & fanout_mutex ) ; if ( err ) { kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }
Fixed code:","
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { struct packet_sock * po = pkt_sk ( sk ) ; struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } 
if ( ! po -> running ) return - EINVAL ; if ( po -> fanout ) return - EALREADY ; 

if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { 
	po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; 
	if ( ! po -> rollover ) return - ENOMEM ; 
	atomic_long_set ( & po -> rollover -> num , 0 ) ; 
	atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; 
	atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; 
} 

mutex_lock ( & fanout_mutex ) ; match = NULL ; 
list_for_each_entry ( f , & fanout_list , list ) { 
	if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { 
		match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; 
		if ( ! match ) { 
			err = - ENOMEM ; 
			goto out ; 
		} 
		write_pnet ( & match -> net , sock_net ( sk ) ) ; 
		match -> id = id ; 
		match -> type = type ; 
		match -> flags = flags ; 
		INIT_LIST_HEAD ( & match -> list ) ; 
		spin_lock_init ( & match -> lock ) ; 
		atomic_set ( & match -> sk_ref , 0 ) ; 
		fanout_init_data ( match ) ; 
		match -> prot_hook . type = po -> prot_hook . type ; 
		match -> prot_hook . dev = po -> prot_hook . dev ; 
		match -> prot_hook . func = packet_rcv_fanout ; 
		match -> prot_hook . af_packet_priv = match ; 
		match -> prot_hook . id_match = match_fanout_group ; 
		dev_add_pack ( & match -> prot_hook ) ; 
		list_add ( & match -> list , & fanout_list ) ; 
		break ; 
	} 
} 

err = - EINVAL ; 
if ( match && match -> flags != flags ) { 
	kfree ( match ) ; 
	goto out ; 
} 

if ( ! match ) { 
	err = - ENOMEM ; 
	match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; 
	if ( ! match ) goto out ; 
	write_pnet ( & match -> net , sock_net ( sk ) ) ; 
	match -> id = id ; 
	match -> type = type ; 
	match -> flags = flags ; 
	INIT_LIST_HEAD ( & match -> list ) ; 
	spin_lock_init ( & match -> lock ) ; 
	atomic_set ( & match -> sk_ref , 0 ) ; 
	fanout_init_data ( match ) ; 
	match -> prot_hook . type = po",1000,-32.17945663007033,-0.032179456630070324
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { struct packet_sock * po = pkt_sk ( sk ) ; struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } if ( ! po -> running ) return - EINVAL ; if ( po -> fanout ) return - EALREADY ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; } mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : mutex_unlock ( & fanout_mutex ) ; if ( err ) { kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }
Fixed code:","
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { struct packet_sock * po = pkt_sk ( sk ) ; struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } if ( ! po -> running ) return - EINVAL ; if ( po -> fanout ) return - EALREADY ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; } mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { /* Add kfree to avoid Use After Free vulnerability */ kfree(po->fanout); __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : mutex_unlock ( & fanout_mutex ) ; if ( err ) { kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }",882,-15.360693989664822,-0.017415752822749233
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { struct packet_sock * po = pkt_sk ( sk ) ; struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } if ( ! po -> running ) return - EINVAL ; if ( po -> fanout ) return - EALREADY ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; } mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : mutex_unlock ( & fanout_mutex ) ; if ( err ) { kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }
Fixed code:","
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { struct packet_sock * po = pkt_sk ( sk ) ; struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } if ( ! po -> running ) return - EINVAL ; if ( po -> fanout ) return - EALREADY ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; } mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) { mutex_unlock ( & fanout_mutex ) ; goto out ; } if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) { mutex_unlock ( & fanout_mutex ) ; goto out ; } write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : mutex_unlock ( & fanout_mutex ) ; if ( err ) { kfree ( po -> rollover ) ; po -> rollover = NULL ; kfree ( match ) ; } return err ; }",901,-10.899950362448399,-0.0120976141647596
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { struct packet_sock * po = pkt_sk ( sk ) ; struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } if ( ! po -> running ) return - EINVAL ; if ( po -> fanout ) return - EALREADY ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; } mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : mutex_unlock ( & fanout_mutex ) ; if ( err ) { kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }
Fixed code:","
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { struct packet_sock * po = pkt_sk ( sk ) ; struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } if ( ! po -> running ) return - EINVAL ; if ( po -> fanout ) return - EALREADY ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; } mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) { // If the flags do not match, clean up the allocated memory and unlock the mutex if ( po->rollover ) { kfree ( po->rollover ); po->rollover = NULL; } mutex_unlock (&fanout_mutex); goto out; } if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) { // If match is null, clean up the allocated memory and unlock the mutex if ( po->rollover ) { kfree ( po->rollover ); po->rollover = NULL; } mutex_unlock (&fanout_mutex); goto out; } write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : return err ; }",937,-47.85169106055324,-0.05106904061958724
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { struct packet_sock * po = pkt_sk ( sk ) ; struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } if ( ! po -> running ) return - EINVAL ; if ( po -> fanout ) return - EALREADY ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; } mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : mutex_unlock ( & fanout_mutex ) ; if ( err ) { kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }
Fixed code:","
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { struct packet_sock * po = pkt_sk ( sk ) ; struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } if ( ! po -> running ) return - EINVAL ; if ( po -> fanout ) return - EALREADY ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; } mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : mutex_unlock ( & fanout_mutex ) ; if ( err ) { if(po->rollover != NULL) { kfree ( po -> rollover ) ; po -> rollover = NULL ; } } return err ; }",874,-12.996523839246764,-0.014870164575797214
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { struct packet_sock * po = pkt_sk ( sk ) ; struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } if ( ! po -> running ) return - EINVAL ; if ( po -> fanout ) return - EALREADY ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; } mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : mutex_unlock ( & fanout_mutex ) ; if ( err ) { kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }
Fixed code:","
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { struct packet_sock * po = pkt_sk ( sk ) ; struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } if ( ! po -> running ) return - EINVAL ; if ( po -> fanout ) return - EALREADY ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; } mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match  -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : mutex_unlock ( & fanout_mutex ) ; if ( err && po -> rollover ) { kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }",869,-21.42257068983483,-0.02465198008036229
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { struct packet_sock * po = pkt_sk ( sk ) ; struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } if ( ! po -> running ) return - EINVAL ; if ( po -> fanout ) return - EALREADY ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; } mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : mutex_unlock ( & fanout_mutex ) ; if ( err ) { kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }
Fixed code:","
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { struct packet_sock * po = pkt_sk ( sk ) ; struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } if ( ! po -> running ) return - EINVAL ; if ( po -> fanout ) return - EALREADY ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; } mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) { kfree(po->rollover); po->rollover = NULL; goto out; } if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) { kfree(po->rollover); po->rollover = NULL; goto out; } write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : mutex_unlock ( & fanout_mutex ) ; return err ; }",875,-7.337796419340251,-0.008386053050674573
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { struct packet_sock * po = pkt_sk ( sk ) ; struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } if ( ! po -> running ) return - EINVAL ; if ( po -> fanout ) return - EALREADY ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; } mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : mutex_unlock ( & fanout_mutex ) ; if ( err ) { kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }
Fixed code:","
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { struct packet_sock * po = pkt_sk ( sk ) ; struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } if ( ! po -> running ) return - EINVAL ; if ( po -> fanout ) return - EALREADY ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; } mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : if ( err ) { kfree ( po -> rollover ) ; po -> rollover = NULL ; kfree ( match ) ; } mutex_unlock ( & fanout_mutex ) ; return err ; }",869,-7.684692640784585,-0.008843144580879845
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { struct packet_sock * po = pkt_sk ( sk ) ; struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } if ( ! po -> running ) return - EINVAL ; if ( po -> fanout ) return - EALREADY ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; } mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : mutex_unlock ( & fanout_mutex ) ; if ( err ) { kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }
Fixed code:","

static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { 
    struct packet_sock * po = pkt_sk ( sk ) ; 
    struct packet_fanout * f , * match ; 
    u8 type = type_flags & 0xff ; 
    u8 flags = type_flags >> 8 ; 
    int err ; 
    switch ( type ) { 
        case PACKET_FANOUT_ROLLOVER : 
            if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) 
                return - EINVAL ; 
        case PACKET_FANOUT_HASH : 
        case PACKET_FANOUT_LB : 
        case PACKET_FANOUT_CPU : 
        case PACKET_FANOUT_RND : 
        case PACKET_FANOUT_QM : 
        case PACKET_FANOUT_CBPF : 
        case PACKET_FANOUT_EBPF : 
            break ; 
        default : 
            return - EINVAL ; 
    } 
    if ( ! po -> running ) 
        return - EINVAL ; 
    if ( po -> fanout ) 
        return - EALREADY ; 
    if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { 
        po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; 
        if ( ! po -> rollover ) 
            return - ENOMEM ; 
        atomic_long_set ( & po -> rollover -> num , 0 ) ; 
        atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; 
        atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; 
    } 
    mutex_lock ( & fanout_mutex ) ; 
    match = NULL ; 
    list_for_each_entry ( f , & fanout_list , list ) { 
        if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { 
            match = f ; 
            break ; 
        } 
    } 
    err = - EINVAL ; 
    if ( match && match -> flags != flags ) 
        goto out ; 
    if ( ! match ) { 
        err = - ENOMEM ; 
        match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; 
        if ( ! match ) 
            goto out ; 
        write_pnet ( & match -> net , sock_net ( sk ) ) ; 
        match -> id = id ; 
        match -> type = type ; 
        match -> flags = flags ; 
        INIT_LIST_HEAD ( & match -> list ) ; 
        spin_lock_init ( & match -> lock ) ; 
        atomic_set ( & match -> sk_ref , 0 ) ; 
        fanout_init_data ( match ) ; 
        match -> prot_hook . type = po -> prot_hook . type ; 
        match -> prot_hook . dev = po -> prot_hook . dev ; 
        match -> prot_hook . func = packet_rcv_fanout ; 
        match -> prot_hook . af_packet_priv = match ; 
        match -> prot_hook . id_match = match_fanout_group ; 
        dev_add_pack ( & match -> prot_hook ) ; 
        list_add ( & match -> list , & fanout_list ) ; 
    } 
    err = - EINVAL ; 
    if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { 
        err = - ENOSPC ; 
        if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { 
            __dev_remove_pack ( & po -> prot_hook ) ; 
            po -> fanout",1000,-10.135555324166816,-0.010135555324166816
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { struct packet_sock * po = pkt_sk ( sk ) ; struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } if ( ! po -> running ) return - EINVAL ; if ( po -> fanout ) return - EALREADY ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; } mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : mutex_unlock ( & fanout_mutex ) ; if ( err ) { kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }
Fixed code:","
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { struct packet_sock * po = pkt_sk ( sk ) ; struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } if ( ! po -> running ) return - EINVAL ; if ( po -> fanout ) return - EALREADY ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; } mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { if (po->fanout) { __dev_remove_pack ( & po -> fanout -> prot_hook ) ; kfree(po->fanout); } __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : mutex_unlock ( & fanout_mutex ) ; if ( err ) { kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }",898,-11.48908350769749,-0.012794079629952661
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { struct packet_sock * po = pkt_sk ( sk ) ; struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } if ( ! po -> running ) return - EINVAL ; if ( po -> fanout ) return - EALREADY ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; } mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : mutex_unlock ( & fanout_mutex ) ; if ( err ) { kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }
Fixed code:","
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { struct packet_sock * po = pkt_sk ( sk ) ; struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } if ( ! po -> running ) return - EINVAL ; if ( po -> fanout ) return - EALREADY ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; } mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } else { // Add freeing of allocated memory here kfree(match); } } out : mutex_unlock ( & fanout_mutex ) ; if ( err ) { kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }",871,-26.724028842045858,-0.030682007855391342
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { struct packet_sock * po = pkt_sk ( sk ) ; struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } if ( ! po -> running ) return - EINVAL ; if ( po -> fanout ) return - EALREADY ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; } mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : mutex_unlock ( & fanout_mutex ) ; if ( err ) { kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }
Fixed code:","
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { struct packet_sock * po = pkt_sk ( sk ) ; struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } if ( ! po -> running ) return - EINVAL ; if ( po -> fanout ) return - EALREADY ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; } mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; kref_get ( & match -> refcount ) ; err = 0 ; } } out : mutex_unlock ( & fanout_mutex ) ; if ( err ) { kref_put ( & match -> refcount , fanout_free ) ; kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }",892,-15.581687981303082,-0.017468260068725427
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { struct packet_sock * po = pkt_sk ( sk ) ; struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } if ( ! po -> running ) return - EINVAL ; if ( po -> fanout ) return - EALREADY ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; } mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : mutex_unlock ( & fanout_mutex ) ; if ( err ) { kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }
Fixed code:","
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { struct packet_sock * po = pkt_sk ( sk ) ; struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } if ( ! po -> running ) return - EINVAL ; 
if ( po -> fanout ) return - EALREADY ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; } mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { if (po-> fanout) {
					// Free the fanout that was previously allocated, to prevent use-after-free vulnerability
					kfree(po->fanout);
					po->fanout = NULL;
				}
				__dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : mutex_unlock ( & fanout_mutex ) ; if ( err ) { kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }",935,-54.005394215858644,-0.057759779910009246
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { struct packet_sock * po = pkt_sk ( sk ) ; struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } if ( ! po -> running ) return - EINVAL ; if ( po -> fanout ) return - EALREADY ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; } mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : mutex_unlock ( & fanout_mutex ) ; if ( err ) { kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }
Fixed code:","
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { struct packet_sock * po = pkt_sk ( sk ) ; struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } if ( ! po -> running ) return - EINVAL ; if ( po -> fanout ) return - EALREADY ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; } mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto free_out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto free_out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } free_out: if ( err ) { kfree ( match ) ; kfree ( po -> rollover ) ; po -> rollover = NULL ; } mutex_unlock ( & fanout_mutex ) ;  return err ; }",876,-13.002273232336787,-0.014842777662484917
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { struct packet_sock * po = pkt_sk ( sk ) ; struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } if ( ! po -> running ) return - EINVAL ; if ( po -> fanout ) return - EALREADY ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; } mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : mutex_unlock ( & fanout_mutex ) ; if ( err ) { kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }
Fixed code:","
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { struct packet_sock * po = pkt_sk ( sk ) ; struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } if ( ! po -> running ) return - EINVAL ; if ( po -> fanout ) return - EALREADY ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; } mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) {  match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; if(!dev_add_pack ( & match -> prot_hook )) { list_add ( & match -> list , & fanout_list ) ; } } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : mutex_unlock ( & fanout_mutex ) ; if ( err ) { kfree ( po -> rollover ) ; po -> rollover = NULL ; kfree ( match ) ; // Added line to fix CWE-416 } return err ; }",883,-29.16928598204479,-0.03303429896041313
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { struct packet_sock * po = pkt_sk ( sk ) ; struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } if ( ! po -> running ) return - EINVAL ; if ( po -> fanout ) return - EALREADY ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; } mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : mutex_unlock ( & fanout_mutex ) ; if ( err ) { kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }
Fixed code:","
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { struct packet_sock * po = pkt_sk ( sk ) ; struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } if ( ! po -> running ) return - EINVAL ; if ( po -> fanout ) return - EALREADY ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; } mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) { kfree ( match ) ; match = NULL ; } if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : mutex_unlock ( & fanout_mutex ) ; if ( err ) { kfree ( po -> rollover ) ; po -> rollover = NULL ; if ( match ) { kfree ( match ) ; } } return err ; }",884,-11.79628610426352,-0.013344215050071856
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { struct packet_sock * po = pkt_sk ( sk ) ; struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } if ( ! po -> running ) return - EINVAL ; if ( po -> fanout ) return - EALREADY ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; } mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : mutex_unlock ( & fanout_mutex ) ; if ( err ) { kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }
Fixed code:","
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { struct packet_sock * po = pkt_sk ( sk ) ; struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } if ( ! po -> running ) return - EINVAL ; if ( po -> fanout ) return - EALREADY ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; } mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { // Added reference counting inc. and dec. kref_get(&po->fanout->refcount); __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : mutex_unlock ( & fanout_mutex ) ; if ( err ) { kref_put(&po->fanout->refcount,fanout_release); kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }",903,-39.14327483826585,-0.04334803415090349
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { struct packet_sock * po = pkt_sk ( sk ) ; struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } if ( ! po -> running ) return - EINVAL ; if ( po -> fanout ) return - EALREADY ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; } mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : mutex_unlock ( & fanout_mutex ) ; if ( err ) { kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }
Fixed code:","
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { struct packet_sock * po = pkt_sk ( sk ) ; struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } if ( ! po -> running ) return - EINVAL ; if ( po -> fanout ) return - EALREADY ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; } mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } if ( match && match -> flags != flags ) { mutex_unlock ( & fanout_mutex ) ; return - EINVAL ; } if ( ! match ) { match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) { mutex_unlock ( & fanout_mutex ) ; return - ENOMEM ; } write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } if ( match -> type != type || match -> prot_hook . type != po -> prot_hook . type || match -> prot_hook . dev != po -> prot_hook . dev ) { kfree ( match ) ; mutex_unlock ( & fanout_mutex ) ; return - EINVAL ; } if ( atomic_read ( & match -> sk_ref ) >= PACKET_FANOUT_MAX ) { kfree ( match ) ; mutex_unlock ( & fanout_mutex ) ; return - ENOSPC ; } __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; mutex_unlock ( & fanout_mutex ) ; return 0 ; }",897,-11.43044993080113,-0.01274297651148398
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { struct packet_sock * po = pkt_sk ( sk ) ; struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } if ( ! po -> running ) return - EINVAL ; if ( po -> fanout ) return - EALREADY ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; } mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : mutex_unlock ( & fanout_mutex ) ; if ( err ) { kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }
Fixed code:","
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { struct packet_sock * po = pkt_sk ( sk ) ; struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } if ( ! po -> running ) return - EINVAL ; if ( po -> fanout ) return - EALREADY ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; } mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } else { kfree(match); } } out : mutex_unlock ( & fanout_mutex ) ; if ( err ) { kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }",871,-8.199092501459656,-0.009413424226704542
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { struct packet_sock * po = pkt_sk ( sk ) ; struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } if ( ! po -> running ) return - EINVAL ; if ( po -> fanout ) return - EALREADY ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; } mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : mutex_unlock ( & fanout_mutex ) ; if ( err ) { kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }
Fixed code:","
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { struct packet_sock * po = pkt_sk ( sk ) ; struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } if ( ! po -> running ) return - EINVAL ; if ( po -> fanout ) return - EALREADY ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; } mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { if ( f->ref_count > 0 ) { match = f ; atomic_inc(&f->ref_count); break ; } else { match = f ; break ; } } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; match->ref_count=0; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; match->ref_count++; } } out : mutex_unlock ( & fanout_mutex ) ; if ( err ) { kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }",908,-32.195705356923305,-0.035457825282955185
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { struct packet_sock * po = pkt_sk ( sk ) ; struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } if ( ! po -> running ) return - EINVAL ; if ( po -> fanout ) return - EALREADY ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; } mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : mutex_unlock ( & fanout_mutex ) ; if ( err ) { kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }
Fixed code:","
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { struct packet_sock * po = pkt_sk ( sk ) ; struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } if ( ! po -> running ) return - EINVAL ; if ( po -> fanout ) return - EALREADY ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; } mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) { po->rollover = NULL; goto out; } write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : mutex_unlock ( & fanout_mutex ) ; if ( err ) { kfree ( po -> rollover ) ; po -> rollover = NULL ; kfree(match); } return err ; }",877,-11.90814903572968,-0.01357827712169861
