Original code,Plausible Program,Total Tokens,Sum Entropy,Mean Entropy
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int usbhid_parse ( struct hid_device * hid ) { struct usb_interface * intf = to_usb_interface ( hid -> dev . parent ) ; struct usb_host_interface * interface = intf -> cur_altsetting ; struct usb_device * dev = interface_to_usbdev ( intf ) ; struct hid_descriptor * hdesc ; u32 quirks = 0 ; unsigned int rsize = 0 ; char * rdesc ; int ret , n ; quirks = usbhid_lookup_quirk ( le16_to_cpu ( dev -> descriptor . idVendor ) , le16_to_cpu ( dev -> descriptor . idProduct ) ) ; if ( quirks & HID_QUIRK_IGNORE ) return - ENODEV ; if ( interface -> desc . bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT ) { if ( interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_KEYBOARD || interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_MOUSE ) quirks |= HID_QUIRK_NOGET ; } if ( usb_get_extra_descriptor ( interface , HID_DT_HID , & hdesc ) && ( ! interface -> desc . bNumEndpoints || usb_get_extra_descriptor ( & interface -> endpoint [ 0 ] , HID_DT_HID , & hdesc ) ) ) { dbg_hid ( ""class descriptor not present\\n"" ) ; return - ENODEV ; } hid -> version = le16_to_cpu ( hdesc -> bcdHID ) ; hid -> country = hdesc -> bCountryCode ; for ( n = 0 ; n < hdesc -> bNumDescriptors ; n ++ ) if ( hdesc -> desc [ n ] . bDescriptorType == HID_DT_REPORT ) rsize = le16_to_cpu ( hdesc -> desc [ n ] . wDescriptorLength ) ; if ( ! rsize || rsize > HID_MAX_DESCRIPTOR_SIZE ) { dbg_hid ( ""weird size of report descriptor (%u)\\n"" , rsize ) ; return - EINVAL ; } rdesc = kmalloc ( rsize , GFP_KERNEL ) ; if ( ! rdesc ) return - ENOMEM ; hid_set_idle ( dev , interface -> desc . bInterfaceNumber , 0 , 0 ) ; ret = hid_get_class_descriptor ( dev , interface -> desc . bInterfaceNumber , HID_DT_REPORT , rdesc , rsize ) ; if ( ret < 0 ) { dbg_hid ( ""reading report descriptor failed\\n"" ) ; kfree ( rdesc ) ; goto err ; } ret = hid_parse_report ( hid , rdesc , rsize ) ; kfree ( rdesc ) ; if ( ret ) { dbg_hid ( ""parsing report descriptor failed\\n"" ) ; goto err ; } hid -> quirks |= quirks ; return 0 ; err : return ret ; }
Fixed code:","
static int usbhid_parse ( struct hid_device * hid ) { struct usb_interface * intf = to_usb_interface ( hid -> dev . parent ) ; struct usb_host_interface * interface = intf -> cur_altsetting ; struct usb_device * dev = interface_to_usbdev ( intf ) ; struct hid_descriptor * hdesc ; u32 quirks = 0 ; unsigned int rsize = 0 ; char * rdesc ; int ret , n ; quirks = usbhid_lookup_quirk ( le16_to_cpu ( dev -> descriptor . idVendor ) , le16_to_cpu ( dev -> descriptor . idProduct ) ) ; if ( quirks & HID_QUIRK_IGNORE ) return - ENODEV ; if ( interface -> desc . bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT ) { if ( interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_KEYBOARD || interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_MOUSE ) quirks |= HID_QUIRK_NOGET ; } if ( usb_get_extra_descriptor ( interface , HID_DT_HID , & hdesc ) && ( ! interface -> desc . bNumEndpoints || usb_get_extra_descriptor ( & interface -> endpoint [ 0 ] , HID_DT_HID , & hdesc ) ) ) { dbg_hid ( ""class descriptor not present\\n"" ) ; return - ENODEV ; } if(hid && hdesc)  { hid -> version = le16_to_cpu ( hdesc -> bcdHID ) ; hid -> country = hdesc -> bCountryCode ; for ( n = 0 ; n < hdesc -> bNumDescriptors ; n ++ ) if ( hdesc -> desc [ n ] . bDescriptorType == HID_DT_REPORT ) rsize = le16_to_cpu ( hdesc -> desc [ n ] . wDescriptorLength ) ; if ( ! rsize || rsize > HID_MAX_DESCRIPTOR_SIZE ) { dbg_hid ( ""weird size of report descriptor (%u)\\n"" , rsize ) ; return - EINVAL ; } rdesc = kmalloc ( rsize , GFP_KERNEL ) ; if ( ! rdesc ) return - ENOMEM ; hid_set_idle ( dev , interface -> desc . bInterfaceNumber , 0 , 0 ) ; ret = hid_get_class_descriptor ( dev , interface -> desc . bInterfaceNumber , HID_DT_REPORT , rdesc , rsize ) ; if ( ret < 0 ) { dbg_hid ( ""reading report descriptor failed\\n"" ) ; kfree ( rdesc ) ; goto err ; } ret = hid_parse_report ( hid , rdesc , rsize ) ; kfree ( rdesc ) ; if ( ret ) { dbg_hid ( ""parsing report descriptor failed\\n"" ) ; goto err ; } hid -> quirks |= quirks ; return 0 ; } err : return ret ; }",700,-19.46166093770094,-0.0278023727681442
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int usbhid_parse ( struct hid_device * hid ) { struct usb_interface * intf = to_usb_interface ( hid -> dev . parent ) ; struct usb_host_interface * interface = intf -> cur_altsetting ; struct usb_device * dev = interface_to_usbdev ( intf ) ; struct hid_descriptor * hdesc ; u32 quirks = 0 ; unsigned int rsize = 0 ; char * rdesc ; int ret , n ; quirks = usbhid_lookup_quirk ( le16_to_cpu ( dev -> descriptor . idVendor ) , le16_to_cpu ( dev -> descriptor . idProduct ) ) ; if ( quirks & HID_QUIRK_IGNORE ) return - ENODEV ; if ( interface -> desc . bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT ) { if ( interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_KEYBOARD || interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_MOUSE ) quirks |= HID_QUIRK_NOGET ; } if ( usb_get_extra_descriptor ( interface , HID_DT_HID , & hdesc ) && ( ! interface -> desc . bNumEndpoints || usb_get_extra_descriptor ( & interface -> endpoint [ 0 ] , HID_DT_HID , & hdesc ) ) ) { dbg_hid ( ""class descriptor not present\\n"" ) ; return - ENODEV ; } hid -> version = le16_to_cpu ( hdesc -> bcdHID ) ; hid -> country = hdesc -> bCountryCode ; for ( n = 0 ; n < hdesc -> bNumDescriptors ; n ++ ) if ( hdesc -> desc [ n ] . bDescriptorType == HID_DT_REPORT ) rsize = le16_to_cpu ( hdesc -> desc [ n ] . wDescriptorLength ) ; if ( ! rsize || rsize > HID_MAX_DESCRIPTOR_SIZE ) { dbg_hid ( ""weird size of report descriptor (%u)\\n"" , rsize ) ; return - EINVAL ; } rdesc = kmalloc ( rsize , GFP_KERNEL ) ; if ( ! rdesc ) return - ENOMEM ; hid_set_idle ( dev , interface -> desc . bInterfaceNumber , 0 , 0 ) ; ret = hid_get_class_descriptor ( dev , interface -> desc . bInterfaceNumber , HID_DT_REPORT , rdesc , rsize ) ; if ( ret < 0 ) { dbg_hid ( ""reading report descriptor failed\\n"" ) ; kfree ( rdesc ) ; goto err ; } ret = hid_parse_report ( hid , rdesc , rsize ) ; kfree ( rdesc ) ; if ( ret ) { dbg_hid ( ""parsing report descriptor failed\\n"" ) ; goto err ; } hid -> quirks |= quirks ; return 0 ; err : return ret ; }
Fixed code:","
static int usbhid_parse ( struct hid_device * hid ) { struct usb_interface * intf = to_usb_interface ( hid -> dev . parent ) ; struct usb_host_interface * interface = intf -> cur_altsetting ; struct usb_device * dev = interface_to_usbdev ( intf ) ; struct hid_descriptor * hdesc ; u32 quirks = 0 ; unsigned int rsize = 0 ; char * rdesc ; int ret , n ; if ( intf -> num_altsetting < 1 ) { return - ENODEV ; } quirks = usbhid_lookup_quirk ( le16_to_cpu ( dev -> descriptor . idVendor ) , le16_to_cpu ( dev -> descriptor . idProduct ) ) ; if ( quirks & HID_QUIRK_IGNORE ) return - ENODEV ; if ( interface -> desc . bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT ) { if ( interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_KEYBOARD || interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_MOUSE ) quirks |= HID_QUIRK_NOGET ; } if ( usb_get_extra_descriptor ( interface , HID_DT_HID , & hdesc ) && ( ! interface -> desc . bNumEndpoints || usb_get_extra_descriptor ( & interface -> endpoint [ 0 ] , HID_DT_HID , & hdesc ) ) ) { dbg_hid ( ""class descriptor not present\\n"" ) ; return - ENODEV ; } hid -> version = le16_to_cpu ( hdesc -> bcdHID ) ; hid -> country = hdesc -> bCountryCode ; for ( n = 0 ; n < hdesc -> bNumDescriptors ; n ++ ) if ( hdesc -> desc [ n ] . bDescriptorType == HID_DT_REPORT ) { rsize = le16_to_cpu ( hdesc -> desc [ n ] . wDescriptorLength ) ; if ( rsize > HID_MAX_DESCRIPTOR_SIZE ) { dbg_hid ( ""weird size of report descriptor (%u)\\n"" , rsize ) ; return - EINVAL ; } } rdesc = kmalloc ( rsize , GFP_KERNEL ) ; if ( ! rdesc ) return - ENOMEM ; hid_set_idle ( dev , interface -> desc . bInterfaceNumber , 0 , 0 ) ; ret = hid_get_class_descriptor ( dev , interface -> desc . bInterfaceNumber , HID_DT_REPORT , rdesc , rsize ) ; if ( ret < 0 ) { dbg_hid ( ""reading report descriptor failed\\n"" ) ; kfree ( rdesc ) ; goto err ; } ret = hid_parse_report ( hid , rdesc , rsize ) ; kfree ( rdesc ) ; if ( ret ) { dbg_hid ( ""parsing report descriptor failed\\n"" ) ; goto err ; } hid -> quirks |= quirks ; return 0 ; err : return ret ; }",709,-12.822898660507608,-0.018085893738374624
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int usbhid_parse ( struct hid_device * hid ) { struct usb_interface * intf = to_usb_interface ( hid -> dev . parent ) ; struct usb_host_interface * interface = intf -> cur_altsetting ; struct usb_device * dev = interface_to_usbdev ( intf ) ; struct hid_descriptor * hdesc ; u32 quirks = 0 ; unsigned int rsize = 0 ; char * rdesc ; int ret , n ; quirks = usbhid_lookup_quirk ( le16_to_cpu ( dev -> descriptor . idVendor ) , le16_to_cpu ( dev -> descriptor . idProduct ) ) ; if ( quirks & HID_QUIRK_IGNORE ) return - ENODEV ; if ( interface -> desc . bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT ) { if ( interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_KEYBOARD || interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_MOUSE ) quirks |= HID_QUIRK_NOGET ; } if ( usb_get_extra_descriptor ( interface , HID_DT_HID , & hdesc ) && ( ! interface -> desc . bNumEndpoints || usb_get_extra_descriptor ( & interface -> endpoint [ 0 ] , HID_DT_HID , & hdesc ) ) ) { dbg_hid ( ""class descriptor not present\\n"" ) ; return - ENODEV ; } hid -> version = le16_to_cpu ( hdesc -> bcdHID ) ; hid -> country = hdesc -> bCountryCode ; for ( n = 0 ; n < hdesc -> bNumDescriptors ; n ++ ) if ( hdesc -> desc [ n ] . bDescriptorType == HID_DT_REPORT ) rsize = le16_to_cpu ( hdesc -> desc [ n ] . wDescriptorLength ) ; if ( ! rsize || rsize > HID_MAX_DESCRIPTOR_SIZE ) { dbg_hid ( ""weird size of report descriptor (%u)\\n"" , rsize ) ; return - EINVAL ; } rdesc = kmalloc ( rsize , GFP_KERNEL ) ; if ( ! rdesc ) return - ENOMEM ; hid_set_idle ( dev , interface -> desc . bInterfaceNumber , 0 , 0 ) ; ret = hid_get_class_descriptor ( dev , interface -> desc . bInterfaceNumber , HID_DT_REPORT , rdesc , rsize ) ; if ( ret < 0 ) { dbg_hid ( ""reading report descriptor failed\\n"" ) ; kfree ( rdesc ) ; goto err ; } ret = hid_parse_report ( hid , rdesc , rsize ) ; kfree ( rdesc ) ; if ( ret ) { dbg_hid ( ""parsing report descriptor failed\\n"" ) ; goto err ; } hid -> quirks |= quirks ; return 0 ; err : return ret ; }
Fixed code:","
static int usbhid_parse ( struct hid_device * hid ) { struct usb_interface * intf = to_usb_interface ( hid -> dev . parent ) ; struct usb_host_interface * interface = intf -> cur_altsetting ; struct usb_device * dev = interface_to_usbdev ( intf ) ; struct hid_descriptor * hdesc ; u32 quirks = 0 ; unsigned int rsize = 0 ; char * rdesc ; int ret , n ; quirks = usbhid_lookup_quirk ( le16_to_cpu ( dev -> descriptor . idVendor ) , le16_to_cpu ( dev -> descriptor . idProduct ) ) ; if ( quirks & HID_QUIRK_IGNORE ) return - ENODEV ; if ( interface -> desc . bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT ) { if ( interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_KEYBOARD || interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_MOUSE ) quirks |= HID_QUIRK_NOGET ; } if ( usb_get_extra_descriptor ( interface , HID_DT_HID , & hdesc ) && ( ! interface -> desc . bNumEndpoints || usb_get_extra_descriptor ( & interface -> endpoint [ 0 ] , HID_DT_HID , & hdesc ) ) ) { dbg_hid ( ""class descriptor not present\\n"" ) ; return - ENODEV ; } hid -> version = le16_to_cpu ( hdesc -> bcdHID ) ; hid -> country = hdesc -> bCountryCode ; for ( n = 0 ; n < hdesc -> bNumDescriptors ; n ++ ) if ( n < HID_MAX_DESCRIPTOR_SIZE && hdesc -> desc [ n ] . bDescriptorType == HID_DT_REPORT ) rsize = le16_to_cpu ( hdesc -> desc [ n ] . wDescriptorLength ) ; if ( ! rsize || rsize > HID_MAX_DESCRIPTOR_SIZE ) { dbg_hid ( ""weird size of report descriptor (%u)\\n"" , rsize ) ; return - EINVAL ; } rdesc = kmalloc ( rsize , GFP_KERNEL ) ; if ( ! rdesc ) return - ENOMEM ; hid_set_idle ( dev , interface -> desc . bInterfaceNumber , 0 , 0 ) ; ret = hid_get_class_descriptor ( dev , interface -> desc . bInterfaceNumber , HID_DT_REPORT , rdesc , rsize ) ; if ( ret < 0 ) { dbg_hid ( ""reading report descriptor failed\\n"" ) ; kfree ( rdesc ) ; goto err ; } ret = hid_parse_report ( hid , rdesc , rsize ) ; kfree ( rdesc ) ; if ( ret ) { dbg_hid ( ""parsing report descriptor failed\\n"" ) ; goto err ; } hid -> quirks |= quirks ; return 0 ; err : return ret ; }",703,-5.5453239269824754,-0.00788808524464079
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int usbhid_parse ( struct hid_device * hid ) { struct usb_interface * intf = to_usb_interface ( hid -> dev . parent ) ; struct usb_host_interface * interface = intf -> cur_altsetting ; struct usb_device * dev = interface_to_usbdev ( intf ) ; struct hid_descriptor * hdesc ; u32 quirks = 0 ; unsigned int rsize = 0 ; char * rdesc ; int ret , n ; quirks = usbhid_lookup_quirk ( le16_to_cpu ( dev -> descriptor . idVendor ) , le16_to_cpu ( dev -> descriptor . idProduct ) ) ; if ( quirks & HID_QUIRK_IGNORE ) return - ENODEV ; if ( interface -> desc . bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT ) { if ( interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_KEYBOARD || interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_MOUSE ) quirks |= HID_QUIRK_NOGET ; } if ( usb_get_extra_descriptor ( interface , HID_DT_HID , & hdesc ) && ( ! interface -> desc . bNumEndpoints || usb_get_extra_descriptor ( & interface -> endpoint [ 0 ] , HID_DT_HID , & hdesc ) ) ) { dbg_hid ( ""class descriptor not present\\n"" ) ; return - ENODEV ; } hid -> version = le16_to_cpu ( hdesc -> bcdHID ) ; hid -> country = hdesc -> bCountryCode ; for ( n = 0 ; n < hdesc -> bNumDescriptors ; n ++ ) if ( hdesc -> desc [ n ] . bDescriptorType == HID_DT_REPORT ) rsize = le16_to_cpu ( hdesc -> desc [ n ] . wDescriptorLength ) ; if ( ! rsize || rsize > HID_MAX_DESCRIPTOR_SIZE ) { dbg_hid ( ""weird size of report descriptor (%u)\\n"" , rsize ) ; return - EINVAL ; } rdesc = kmalloc ( rsize , GFP_KERNEL ) ; if ( ! rdesc ) return - ENOMEM ; hid_set_idle ( dev , interface -> desc . bInterfaceNumber , 0 , 0 ) ; ret = hid_get_class_descriptor ( dev , interface -> desc . bInterfaceNumber , HID_DT_REPORT , rdesc , rsize ) ; if ( ret < 0 ) { dbg_hid ( ""reading report descriptor failed\\n"" ) ; kfree ( rdesc ) ; goto err ; } ret = hid_parse_report ( hid , rdesc , rsize ) ; kfree ( rdesc ) ; if ( ret ) { dbg_hid ( ""parsing report descriptor failed\\n"" ) ; goto err ; } hid -> quirks |= quirks ; return 0 ; err : return ret ; }
Fixed code:","

static int usbhid_parse ( struct hid_device * hid ) { struct usb_interface * intf = to_usb_interface ( hid -> dev . parent ) ; struct usb_host_interface * interface = intf -> cur_altsetting ; struct usb_device * dev = interface_to_usbdev ( intf ) ; struct hid_descriptor * hdesc ; u32 quirks = 0 ; unsigned int rsize = 0 ; char * rdesc ; int ret , n ; quirks = usbhid_lookup_quirk ( le16_to_cpu ( dev -> descriptor . idVendor ) , le16_to_cpu ( dev -> descriptor . idProduct ) ) ; if ( quirks & HID_QUIRK_IGNORE ) return - ENODEV ; if ( interface -> desc . bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT ) { if ( interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_KEYBOARD || interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_MOUSE ) quirks |= HID_QUIRK_NOGET ; } if ( usb_get_extra_descriptor ( interface , HID_DT_HID , & hdesc ) && ( ! interface -> desc . bNumEndpoints || usb_get_extra_descriptor ( & interface -> endpoint [ 0 ] , HID_DT_HID , & hdesc ) ) ) { dbg_hid ( ""class descriptor not present\\n"" ) ; return - ENODEV ; } if ( hdesc == NULL ) { dbg_hid ( ""hdesc is NULL\\n"" ); return - ENODEV; } hid -> version = le16_to_cpu ( hdesc -> bcdHID ) ; hid -> country = hdesc -> bCountryCode ; for ( n = 0 ; n < hdesc -> bNumDescriptors ; n ++ ) if ( hdesc -> desc [ n ] . bDescriptorType == HID_DT_REPORT ) rsize = le16_to_cpu ( hdesc -> desc [ n ] . wDescriptorLength ) ; if ( ! rsize || rsize > HID_MAX_DESCRIPTOR_SIZE ) { dbg_hid ( ""weird size of report descriptor (%u)\\n"" , rsize ) ; return - EINVAL ; } rdesc = kmalloc ( rsize , GFP_KERNEL ) ; if ( ! rdesc ) return - ENOMEM ; hid_set_idle ( dev , interface -> desc . bInterfaceNumber , 0 , 0 ) ; ret = hid_get_class_descriptor ( dev , interface -> desc . bInterfaceNumber , HID_DT_REPORT , rdesc , rsize ) ; if ( ret < 0 ) { dbg_hid ( ""reading report descriptor failed\\n"" ) ; kfree ( rdesc ) ; goto err ; } ret = hid_parse_report ( hid , rdesc , rsize ) ; kfree ( rdesc ) ; if ( ret ) { dbg_hid ( ""parsing report descriptor failed\\n"" ) ; goto err ; } hid -> quirks |= quirks ; return 0 ; err : return ret ; }",720,-13.196549758981881,-0.01832854133191928
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int usbhid_parse ( struct hid_device * hid ) { struct usb_interface * intf = to_usb_interface ( hid -> dev . parent ) ; struct usb_host_interface * interface = intf -> cur_altsetting ; struct usb_device * dev = interface_to_usbdev ( intf ) ; struct hid_descriptor * hdesc ; u32 quirks = 0 ; unsigned int rsize = 0 ; char * rdesc ; int ret , n ; quirks = usbhid_lookup_quirk ( le16_to_cpu ( dev -> descriptor . idVendor ) , le16_to_cpu ( dev -> descriptor . idProduct ) ) ; if ( quirks & HID_QUIRK_IGNORE ) return - ENODEV ; if ( interface -> desc . bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT ) { if ( interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_KEYBOARD || interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_MOUSE ) quirks |= HID_QUIRK_NOGET ; } if ( usb_get_extra_descriptor ( interface , HID_DT_HID , & hdesc ) && ( ! interface -> desc . bNumEndpoints || usb_get_extra_descriptor ( & interface -> endpoint [ 0 ] , HID_DT_HID , & hdesc ) ) ) { dbg_hid ( ""class descriptor not present\\n"" ) ; return - ENODEV ; } hid -> version = le16_to_cpu ( hdesc -> bcdHID ) ; hid -> country = hdesc -> bCountryCode ; for ( n = 0 ; n < hdesc -> bNumDescriptors ; n ++ ) if ( hdesc -> desc [ n ] . bDescriptorType == HID_DT_REPORT ) rsize = le16_to_cpu ( hdesc -> desc [ n ] . wDescriptorLength ) ; if ( ! rsize || rsize > HID_MAX_DESCRIPTOR_SIZE ) { dbg_hid ( ""weird size of report descriptor (%u)\\n"" , rsize ) ; return - EINVAL ; } rdesc = kmalloc ( rsize , GFP_KERNEL ) ; if ( ! rdesc ) return - ENOMEM ; hid_set_idle ( dev , interface -> desc . bInterfaceNumber , 0 , 0 ) ; ret = hid_get_class_descriptor ( dev , interface -> desc . bInterfaceNumber , HID_DT_REPORT , rdesc , rsize ) ; if ( ret < 0 ) { dbg_hid ( ""reading report descriptor failed\\n"" ) ; kfree ( rdesc ) ; goto err ; } ret = hid_parse_report ( hid , rdesc , rsize ) ; kfree ( rdesc ) ; if ( ret ) { dbg_hid ( ""parsing report descriptor failed\\n"" ) ; goto err ; } hid -> quirks |= quirks ; return 0 ; err : return ret ; }
Fixed code:","
static int usbhid_parse ( struct hid_device * hid ) { struct usb_interface * intf = to_usb_interface ( hid -> dev . parent ) ; struct usb_host_interface * interface = intf -> cur_altsetting ; struct usb_device * dev = interface_to_usbdev ( intf ) ; struct hid_descriptor * hdesc ; u32 quirks = 0 ; unsigned int rsize = 0 ; char * rdesc ; int ret , n ; quirks = usbhid_lookup_quirk ( le16_to_cpu ( dev -> descriptor . idVendor ) , le16_to_cpu ( dev -> descriptor . idProduct ) ) ; if ( quirks & HID_QUIRK_IGNORE ) return - ENODEV ; if ( interface -> desc . bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT ) { if ( interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_KEYBOARD || interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_MOUSE ) quirks |= HID_QUIRK_NOGET ; } if ( usb_get_extra_descriptor ( interface , HID_DT_HID , & hdesc ) && ( ! interface -> desc . bNumEndpoints || usb_get_extra_descriptor ( & interface -> endpoint [ 0 ] , HID_DT_HID , & hdesc ) ) ) { dbg_hid ( ""class descriptor not present\\n"" ) ; return - ENODEV ; } hid -> version = le16_to_cpu ( hdesc -> bcdHID ) ; hid -> country = hdesc -> bCountryCode ; for ( n = 0 ; n < hdesc -> bNumDescriptors ; n ++ ) { if ( n < HID_MAX_DESCRIPTOR_SIZE && hdesc -> desc [ n ] . bDescriptorType == HID_DT_REPORT ) { rsize = le16_to_cpu ( hdesc -> desc [ n ] . wDescriptorLength ) ; } else { dbg_hid ( ""weird size of report descriptor (%u)\\n"" , rsize ) ; return - EINVAL ; } } if ( ! rsize || rsize > HID_MAX_DESCRIPTOR_SIZE ) { dbg_hid ( ""weird size of report descriptor (%u)\\n"" , rsize ) ; return - EINVAL ; } rdesc = kmalloc ( rsize , GFP_KERNEL ) ; if ( ! rdesc ) return - ENOMEM ; hid_set_idle ( dev , interface -> desc . bInterfaceNumber , 0 , 0 ) ; ret = hid_get_class_descriptor ( dev , interface -> desc . bInterfaceNumber , HID_DT_REPORT , rdesc , rsize ) ; if ( ret < 0 ) { dbg_hid ( ""reading report descriptor failed\\n"" ) ; kfree ( rdesc ) ; goto err ; } ret = hid_parse_report ( hid , rdesc , rsize ) ; kfree ( rdesc ) ; if ( ret ) { dbg_hid ( ""parsing report descriptor failed\\n"" ) ; goto err ; } hid -> quirks |= quirks ; return 0 ; err : return ret ; }",739,-9.8238409802817,-0.013293424871829093
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int usbhid_parse ( struct hid_device * hid ) { struct usb_interface * intf = to_usb_interface ( hid -> dev . parent ) ; struct usb_host_interface * interface = intf -> cur_altsetting ; struct usb_device * dev = interface_to_usbdev ( intf ) ; struct hid_descriptor * hdesc ; u32 quirks = 0 ; unsigned int rsize = 0 ; char * rdesc ; int ret , n ; quirks = usbhid_lookup_quirk ( le16_to_cpu ( dev -> descriptor . idVendor ) , le16_to_cpu ( dev -> descriptor . idProduct ) ) ; if ( quirks & HID_QUIRK_IGNORE ) return - ENODEV ; if ( interface -> desc . bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT ) { if ( interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_KEYBOARD || interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_MOUSE ) quirks |= HID_QUIRK_NOGET ; } if ( usb_get_extra_descriptor ( interface , HID_DT_HID , & hdesc ) && ( ! interface -> desc . bNumEndpoints || usb_get_extra_descriptor ( & interface -> endpoint [ 0 ] , HID_DT_HID , & hdesc ) ) ) { dbg_hid ( ""class descriptor not present\\n"" ) ; return - ENODEV ; } hid -> version = le16_to_cpu ( hdesc -> bcdHID ) ; hid -> country = hdesc -> bCountryCode ; for ( n = 0 ; n < hdesc -> bNumDescriptors ; n ++ ) if ( hdesc -> desc [ n ] . bDescriptorType == HID_DT_REPORT ) rsize = le16_to_cpu ( hdesc -> desc [ n ] . wDescriptorLength ) ; if ( ! rsize || rsize > HID_MAX_DESCRIPTOR_SIZE ) { dbg_hid ( ""weird size of report descriptor (%u)\\n"" , rsize ) ; return - EINVAL ; } rdesc = kmalloc ( rsize , GFP_KERNEL ) ; if ( ! rdesc ) return - ENOMEM ; hid_set_idle ( dev , interface -> desc . bInterfaceNumber , 0 , 0 ) ; ret = hid_get_class_descriptor ( dev , interface -> desc . bInterfaceNumber , HID_DT_REPORT , rdesc , rsize ) ; if ( ret < 0 ) { dbg_hid ( ""reading report descriptor failed\\n"" ) ; kfree ( rdesc ) ; goto err ; } ret = hid_parse_report ( hid , rdesc , rsize ) ; kfree ( rdesc ) ; if ( ret ) { dbg_hid ( ""parsing report descriptor failed\\n"" ) ; goto err ; } hid -> quirks |= quirks ; return 0 ; err : return ret ; }
Fixed code:","

static int usbhid_parse(struct hid_device *hid) {
	struct usb_interface *intf = to_usb_interface(hid->dev.parent);
	struct usb_host_interface *interface = intf->cur_altsetting;
	struct usb_device *dev = interface_to_usbdev(intf);
	struct hid_descriptor *hdesc;
	u32 quirks = 0;
	unsigned int rsize = 0;
	char *rdesc;
	int ret, n;
	quirks = usbhid_lookup_quirk(le16_to_cpu(dev->descriptor.idVendor), le16_to_cpu(dev->descriptor.idProduct));
	if (quirks & HID_QUIRK_IGNORE)
		return -ENODEV;
	if (interface->desc.bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT) {
		if (interface->desc.bInterfaceProtocol == USB_INTERFACE_PROTOCOL_KEYBOARD ||
				interface->desc.bInterfaceProtocol == USB_INTERFACE_PROTOCOL_MOUSE)
			quirks |= HID_QUIRK_NOGET;
	}
	if (usb_get_extra_descriptor(interface, HID_DT_HID, &hdesc) &&
	    (!interface->desc.bNumEndpoints ||
	     usb_get_extra_descriptor(&interface->endpoint[0], HID_DT_HID, &hdesc))) {
		dbg_hid(""class descriptor not present\n"");
		return -ENODEV;
	}
	hid->version = le16_to_cpu(hdesc->bcdHID);
	hid->country = hdesc->bCountryCode;
	for (n = 0; n < hdesc->bNumDescriptors; n++) {
		if (hdesc->desc[n].bDescriptorType == HID_DT_REPORT) {
			if(hdesc->desc[n].wDescriptorLength > 0 && hdesc->desc[n].wDescriptorLength <= HID_MAX_DESCRIPTOR_SIZE) {
				rsize = le16_to_cpu(hdesc->desc[n].wDescriptorLength);
			}
		}
	}

	if (!rsize) {
		dbg_hid(""weird size of report descriptor (%u)\n"", rsize);
		return -EINVAL;
	}
	rdesc = kmalloc(rsize, GFP_KERNEL);
	if (!rdesc)
		return -ENOMEM;
	hid_set_idle(dev, interface->desc.bInterfaceNumber, 0, 0);
	ret = hid_get_class_descriptor(dev, interface->desc.bInterfaceNumber, HID_DT_REPORT, rdesc, rsize);
	if (ret < 0) {
		dbg_hid(""reading report descriptor failed\n"");
		kfree(rdesc);
		goto err;
	}
	ret = hid_parse_report(hid, rdesc, rsize);
	kfree(rdesc);
	if (ret) {
		dbg_hid(""parsing report descriptor failed\n"");
		goto err;
	}
	hid->quirks |= quirks;
	return 0;
err:
	return ret;
}",841,-35.00846940634636,-0.04162719311099448
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int usbhid_parse ( struct hid_device * hid ) { struct usb_interface * intf = to_usb_interface ( hid -> dev . parent ) ; struct usb_host_interface * interface = intf -> cur_altsetting ; struct usb_device * dev = interface_to_usbdev ( intf ) ; struct hid_descriptor * hdesc ; u32 quirks = 0 ; unsigned int rsize = 0 ; char * rdesc ; int ret , n ; quirks = usbhid_lookup_quirk ( le16_to_cpu ( dev -> descriptor . idVendor ) , le16_to_cpu ( dev -> descriptor . idProduct ) ) ; if ( quirks & HID_QUIRK_IGNORE ) return - ENODEV ; if ( interface -> desc . bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT ) { if ( interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_KEYBOARD || interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_MOUSE ) quirks |= HID_QUIRK_NOGET ; } if ( usb_get_extra_descriptor ( interface , HID_DT_HID , & hdesc ) && ( ! interface -> desc . bNumEndpoints || usb_get_extra_descriptor ( & interface -> endpoint [ 0 ] , HID_DT_HID , & hdesc ) ) ) { dbg_hid ( ""class descriptor not present\\n"" ) ; return - ENODEV ; } hid -> version = le16_to_cpu ( hdesc -> bcdHID ) ; hid -> country = hdesc -> bCountryCode ; for ( n = 0 ; n < hdesc -> bNumDescriptors ; n ++ ) if ( hdesc -> desc [ n ] . bDescriptorType == HID_DT_REPORT ) rsize = le16_to_cpu ( hdesc -> desc [ n ] . wDescriptorLength ) ; if ( ! rsize || rsize > HID_MAX_DESCRIPTOR_SIZE ) { dbg_hid ( ""weird size of report descriptor (%u)\\n"" , rsize ) ; return - EINVAL ; } rdesc = kmalloc ( rsize , GFP_KERNEL ) ; if ( ! rdesc ) return - ENOMEM ; hid_set_idle ( dev , interface -> desc . bInterfaceNumber , 0 , 0 ) ; ret = hid_get_class_descriptor ( dev , interface -> desc . bInterfaceNumber , HID_DT_REPORT , rdesc , rsize ) ; if ( ret < 0 ) { dbg_hid ( ""reading report descriptor failed\\n"" ) ; kfree ( rdesc ) ; goto err ; } ret = hid_parse_report ( hid , rdesc , rsize ) ; kfree ( rdesc ) ; if ( ret ) { dbg_hid ( ""parsing report descriptor failed\\n"" ) ; goto err ; } hid -> quirks |= quirks ; return 0 ; err : return ret ; }
Fixed code:","

static int usbhid_parse ( struct hid_device * hid ) { struct usb_interface * intf = to_usb_interface ( hid -> dev . parent ) ; struct usb_host_interface * interface = intf -> cur_altsetting ; struct usb_device * dev = interface_to_usbdev ( intf ) ; struct hid_descriptor * hdesc ; u32 quirks = 0 ; unsigned int rsize = 0 ; char * rdesc ; int ret , n ; quirks = usbhid_lookup_quirk ( le16_to_cpu ( dev -> descriptor . idVendor ) , le16_to_cpu ( dev -> descriptor . idProduct ) ) ; if ( quirks & HID_QUIRK_IGNORE ) return - ENODEV ; if ( interface -> desc . bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT ) { if ( interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_KEYBOARD || interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_MOUSE ) quirks |= HID_QUIRK_NOGET ; } if ( usb_get_extra_descriptor ( interface , HID_DT_HID , & hdesc ) && ( ! interface -> desc . bNumEndpoints || usb_get_extra_descriptor ( & interface -> endpoint [ 0 ] , HID_DT_HID , & hdesc ) ) ) { dbg_hid ( ""class descriptor not present\\n"" ) ; return - ENODEV ; } hid -> version = le16_to_cpu ( hdesc -> bcdHID ) ; hid -> country = hdesc -> bCountryCode ; for ( n = 0 ; n < hdesc -> bNumDescriptors ; n ++ ) { if ( n < HID_MAX_DESCRIPTOR_SIZE && hdesc -> desc [ n ] . bDescriptorType == HID_DT_REPORT ) rsize = le16_to_cpu ( hdesc -> desc [ n ] . wDescriptorLength ) ; } if ( ! rsize || rsize > HID_MAX_DESCRIPTOR_SIZE ) { dbg_hid ( ""weird size of report descriptor (%u)\\n"" , rsize ) ; return - EINVAL ; } rdesc = kmalloc ( rsize , GFP_KERNEL ) ; if ( ! rdesc ) return - ENOMEM ; hid_set_idle ( dev , interface -> desc . bInterfaceNumber , 0 , 0 ) ; ret = hid_get_class_descriptor ( dev , interface -> desc . bInterfaceNumber , HID_DT_REPORT , rdesc , rsize ) ; if ( ret < 0 ) { dbg_hid ( ""reading report descriptor failed\\n"" ) ; kfree ( rdesc ) ; goto err ; } ret = hid_parse_report ( hid , rdesc , rsize ) ; kfree ( rdesc ) ; if ( ret ) { dbg_hid ( ""parsing report descriptor failed\\n"" ) ; goto err ; } hid -> quirks |= quirks ; return 0 ; err : return ret ; }",706,-9.413908278108034,-0.013334147702702597
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int usbhid_parse ( struct hid_device * hid ) { struct usb_interface * intf = to_usb_interface ( hid -> dev . parent ) ; struct usb_host_interface * interface = intf -> cur_altsetting ; struct usb_device * dev = interface_to_usbdev ( intf ) ; struct hid_descriptor * hdesc ; u32 quirks = 0 ; unsigned int rsize = 0 ; char * rdesc ; int ret , n ; quirks = usbhid_lookup_quirk ( le16_to_cpu ( dev -> descriptor . idVendor ) , le16_to_cpu ( dev -> descriptor . idProduct ) ) ; if ( quirks & HID_QUIRK_IGNORE ) return - ENODEV ; if ( interface -> desc . bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT ) { if ( interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_KEYBOARD || interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_MOUSE ) quirks |= HID_QUIRK_NOGET ; } if ( usb_get_extra_descriptor ( interface , HID_DT_HID , & hdesc ) && ( ! interface -> desc . bNumEndpoints || usb_get_extra_descriptor ( & interface -> endpoint [ 0 ] , HID_DT_HID , & hdesc ) ) ) { dbg_hid ( ""class descriptor not present\\n"" ) ; return - ENODEV ; } hid -> version = le16_to_cpu ( hdesc -> bcdHID ) ; hid -> country = hdesc -> bCountryCode ; for ( n = 0 ; n < hdesc -> bNumDescriptors ; n ++ ) if ( hdesc -> desc [ n ] . bDescriptorType == HID_DT_REPORT ) rsize = le16_to_cpu ( hdesc -> desc [ n ] . wDescriptorLength ) ; if ( ! rsize || rsize > HID_MAX_DESCRIPTOR_SIZE ) { dbg_hid ( ""weird size of report descriptor (%u)\\n"" , rsize ) ; return - EINVAL ; } rdesc = kmalloc ( rsize , GFP_KERNEL ) ; if ( ! rdesc ) return - ENOMEM ; hid_set_idle ( dev , interface -> desc . bInterfaceNumber , 0 , 0 ) ; ret = hid_get_class_descriptor ( dev , interface -> desc . bInterfaceNumber , HID_DT_REPORT , rdesc , rsize ) ; if ( ret < 0 ) { dbg_hid ( ""reading report descriptor failed\\n"" ) ; kfree ( rdesc ) ; goto err ; } ret = hid_parse_report ( hid , rdesc , rsize ) ; kfree ( rdesc ) ; if ( ret ) { dbg_hid ( ""parsing report descriptor failed\\n"" ) ; goto err ; } hid -> quirks |= quirks ; return 0 ; err : return ret ; }
Fixed code:","

static int usbhid_parse ( struct hid_device * hid ) {
  struct usb_interface * intf = to_usb_interface ( hid -> dev . parent ) ;
  struct usb_host_interface * interface = intf -> cur_altsetting ;
  struct usb_device * dev = interface_to_usbdev ( intf ) ;
  struct hid_descriptor * hdesc ;
  u32 quirks = 0 ;
  unsigned int rsize = 0 ;
  char * rdesc ;
  int ret , n ;
  quirks = usbhid_lookup_quirk ( le16_to_cpu ( dev -> descriptor . idVendor ) , le16_to_cpu ( dev -> descriptor . idProduct ) ) ;
  if ( quirks & HID_QUIRK_IGNORE ) return - ENODEV ;
  if ( interface -> desc . bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT ) {
    if ( interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_KEYBOARD || interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_MOUSE ) quirks |= HID_QUIRK_NOGET ;
  }
  if ( usb_get_extra_descriptor ( interface , HID_DT_HID , & hdesc ) && ( ! interface -> desc . bNumEndpoints || usb_get_extra_descriptor ( & interface -> endpoint [ 0 ] , HID_DT_HID , & hdesc ) ) ) {
    dbg_hid ( ""class descriptor not present\\n"" ) ;
    return - ENODEV ;
  }
  hid -> version = le16_to_cpu ( hdesc -> bcdHID ) ;
  hid -> country = hdesc -> bCountryCode ;
  for ( n = 0 ; n < hdesc -> bNumDescriptors ; n ++ ) {
    if ( n >= HID_MAX_DESCRIPTORS ) { // Added to prevent out-of-bounds read
      dbg_hid ( ""too many HID descriptors\\n"" ) ;
      return - EINVAL ;
    }
    if ( hdesc -> desc [ n ] . bDescriptorType == HID_DT_REPORT ) rsize = le16_to_cpu ( hdesc -> desc [ n ] . wDescriptorLength ) ;
  }
  if ( ! rsize || rsize > HID_MAX_DESCRIPTOR_SIZE ) {
    dbg_hid ( ""weird size of report descriptor (%u)\\n"" , rsize ) ;
    return - EINVAL ;
  }
  rdesc = kmalloc ( rsize , GFP_KERNEL ) ;
  if ( ! rdesc ) return - ENOMEM ;
  hid_set_idle ( dev , interface -> desc . bInterfaceNumber , 0 , 0 ) ;
  ret = hid_get_class_descriptor ( dev , interface -> desc . bInterfaceNumber , HID_DT_REPORT , rdesc , rsize ) ;
  if ( ret < 0 ) {
    dbg_hid ( ""reading report descriptor failed\\n"" ) ;
    kfree ( rdesc ) ;
    goto err ;
  }
  ret = hid_parse_report ( hid , rdesc , rsize ) ;
  kfree ( rdesc ) ;
  if ( ret ) {
    dbg_hid ( ""parsing report descriptor failed\\n"" ) ;
    goto err ;
  }
  hid -> quirks |= quirks ;
  return 0 ;
err :
  return ret ;
}",841,-25.632127269811814,-0.03047815370964544
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int usbhid_parse ( struct hid_device * hid ) { struct usb_interface * intf = to_usb_interface ( hid -> dev . parent ) ; struct usb_host_interface * interface = intf -> cur_altsetting ; struct usb_device * dev = interface_to_usbdev ( intf ) ; struct hid_descriptor * hdesc ; u32 quirks = 0 ; unsigned int rsize = 0 ; char * rdesc ; int ret , n ; quirks = usbhid_lookup_quirk ( le16_to_cpu ( dev -> descriptor . idVendor ) , le16_to_cpu ( dev -> descriptor . idProduct ) ) ; if ( quirks & HID_QUIRK_IGNORE ) return - ENODEV ; if ( interface -> desc . bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT ) { if ( interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_KEYBOARD || interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_MOUSE ) quirks |= HID_QUIRK_NOGET ; } if ( usb_get_extra_descriptor ( interface , HID_DT_HID , & hdesc ) && ( ! interface -> desc . bNumEndpoints || usb_get_extra_descriptor ( & interface -> endpoint [ 0 ] , HID_DT_HID , & hdesc ) ) ) { dbg_hid ( ""class descriptor not present\\n"" ) ; return - ENODEV ; } hid -> version = le16_to_cpu ( hdesc -> bcdHID ) ; hid -> country = hdesc -> bCountryCode ; for ( n = 0 ; n < hdesc -> bNumDescriptors ; n ++ ) if ( hdesc -> desc [ n ] . bDescriptorType == HID_DT_REPORT ) rsize = le16_to_cpu ( hdesc -> desc [ n ] . wDescriptorLength ) ; if ( ! rsize || rsize > HID_MAX_DESCRIPTOR_SIZE ) { dbg_hid ( ""weird size of report descriptor (%u)\\n"" , rsize ) ; return - EINVAL ; } rdesc = kmalloc ( rsize , GFP_KERNEL ) ; if ( ! rdesc ) return - ENOMEM ; hid_set_idle ( dev , interface -> desc . bInterfaceNumber , 0 , 0 ) ; ret = hid_get_class_descriptor ( dev , interface -> desc . bInterfaceNumber , HID_DT_REPORT , rdesc , rsize ) ; if ( ret < 0 ) { dbg_hid ( ""reading report descriptor failed\\n"" ) ; kfree ( rdesc ) ; goto err ; } ret = hid_parse_report ( hid , rdesc , rsize ) ; kfree ( rdesc ) ; if ( ret ) { dbg_hid ( ""parsing report descriptor failed\\n"" ) ; goto err ; } hid -> quirks |= quirks ; return 0 ; err : return ret ; }
Fixed code:"," 
static int usbhid_parse ( struct hid_device * hid ) { struct usb_interface * intf = to_usb_interface ( hid -> dev . parent ) ; struct usb_host_interface * interface = intf -> cur_altsetting ; struct usb_device * dev = interface_to_usbdev ( intf ) ; struct hid_descriptor * hdesc ; u32 quirks = 0 ; unsigned int rsize = 0 ; char * rdesc ; int ret , n ; quirks = usbhid_lookup_quirk ( le16_to_cpu ( dev -> descriptor . idVendor ) , le16_to_cpu ( dev -> descriptor . idProduct ) ) ; if ( quirks & HID_QUIRK_IGNORE ) return - ENODEV ; if ( interface -> desc . bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT ) { if ( interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_KEYBOARD || interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_MOUSE ) quirks |= HID_QUIRK_NOGET ; } if ( usb_get_extra_descriptor ( interface , HID_DT_HID , & hdesc ) && ( ! interface -> desc . bNumEndpoints || usb_get_extra_descriptor ( & interface -> endpoint [ 0 ] , HID_DT_HID , & hdesc ) ) ) { dbg_hid ( ""class descriptor not present\\n"" ) ; return - ENODEV ; } hid -> version = le16_to_cpu ( hdesc -> bcdHID ) ; hid -> country = hdesc -> bCountryCode ; for ( n = 0 ; n < hdesc -> bNumDescriptors ; n ++ ) if ( hdesc -> desc [ n ] . bDescriptorType == HID_DT_REPORT ) { //check for valid index if(n < HID_MAX_DESCRIPTOR_SIZE) { rsize = le16_to_cpu ( hdesc -> desc [ n ] . wDescriptorLength ) ; } } if ( ! rsize || rsize > HID_MAX_DESCRIPTOR_SIZE ) { dbg_hid ( ""weird size of report descriptor (%u)\\n"" , rsize ) ; return - EINVAL ; } rdesc = kmalloc ( rsize , GFP_KERNEL ) ; if ( ! rdesc ) return - ENOMEM ; hid_set_idle ( dev , interface -> desc . bInterfaceNumber , 0 , 0 ) ; ret = hid_get_class_descriptor ( dev , interface -> desc . bInterfaceNumber , HID_DT_REPORT , rdesc , rsize ) ;  if ( ret < 0 ) { dbg_hid ( ""reading report descriptor failed\\n"" ) ; kfree ( rdesc ) ; goto err ; } ret = hid_parse_report ( hid , rdesc , rsize ) ; kfree ( rdesc ) ; if ( ret ) { dbg_hid ( ""parsing report descriptor failed\\n"" ) ; goto err ; } hid -> quirks |= quirks ; return 0 ; err : return ret ; }",716,-31.637595404092757,-0.04418658575990608
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int usbhid_parse ( struct hid_device * hid ) { struct usb_interface * intf = to_usb_interface ( hid -> dev . parent ) ; struct usb_host_interface * interface = intf -> cur_altsetting ; struct usb_device * dev = interface_to_usbdev ( intf ) ; struct hid_descriptor * hdesc ; u32 quirks = 0 ; unsigned int rsize = 0 ; char * rdesc ; int ret , n ; quirks = usbhid_lookup_quirk ( le16_to_cpu ( dev -> descriptor . idVendor ) , le16_to_cpu ( dev -> descriptor . idProduct ) ) ; if ( quirks & HID_QUIRK_IGNORE ) return - ENODEV ; if ( interface -> desc . bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT ) { if ( interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_KEYBOARD || interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_MOUSE ) quirks |= HID_QUIRK_NOGET ; } if ( usb_get_extra_descriptor ( interface , HID_DT_HID , & hdesc ) && ( ! interface -> desc . bNumEndpoints || usb_get_extra_descriptor ( & interface -> endpoint [ 0 ] , HID_DT_HID , & hdesc ) ) ) { dbg_hid ( ""class descriptor not present\\n"" ) ; return - ENODEV ; } hid -> version = le16_to_cpu ( hdesc -> bcdHID ) ; hid -> country = hdesc -> bCountryCode ; for ( n = 0 ; n < hdesc -> bNumDescriptors ; n ++ ) if ( hdesc -> desc [ n ] . bDescriptorType == HID_DT_REPORT ) rsize = le16_to_cpu ( hdesc -> desc [ n ] . wDescriptorLength ) ; if ( ! rsize || rsize > HID_MAX_DESCRIPTOR_SIZE ) { dbg_hid ( ""weird size of report descriptor (%u)\\n"" , rsize ) ; return - EINVAL ; } rdesc = kmalloc ( rsize , GFP_KERNEL ) ; if ( ! rdesc ) return - ENOMEM ; hid_set_idle ( dev , interface -> desc . bInterfaceNumber , 0 , 0 ) ; ret = hid_get_class_descriptor ( dev , interface -> desc . bInterfaceNumber , HID_DT_REPORT , rdesc , rsize ) ; if ( ret < 0 ) { dbg_hid ( ""reading report descriptor failed\\n"" ) ; kfree ( rdesc ) ; goto err ; } ret = hid_parse_report ( hid , rdesc , rsize ) ; kfree ( rdesc ) ; if ( ret ) { dbg_hid ( ""parsing report descriptor failed\\n"" ) ; goto err ; } hid -> quirks |= quirks ; return 0 ; err : return ret ; }
Fixed code:","
static int usbhid_parse ( struct hid_device * hid ) { struct usb_interface * intf = to_usb_interface ( hid -> dev . parent ) ; struct usb_host_interface * interface = intf -> cur_altsetting ; struct usb_device * dev = interface_to_usbdev ( intf ) ; struct hid_descriptor * hdesc ; u32 quirks = 0 ; unsigned int rsize = 0 ; char * rdesc ; int ret , n ; quirks = usbhid_lookup_quirk ( le16_to_cpu ( dev -> descriptor . idVendor ) , le16_to_cpu ( dev -> descriptor . idProduct ) ) ; if ( quirks & HID_QUIRK_IGNORE ) return - ENODEV ; if ( interface -> desc . bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT ) { if ( interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_KEYBOARD || interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_MOUSE ) quirks |= HID_QUIRK_NOGET ; } rsize = HID_MAX_DESCRIPTOR_SIZE; // Add to check for the max size of the descriptor 

if ( usb_get_extra_descriptor ( interface , HID_DT_HID , & hdesc ) && ( ! interface -> desc . bNumEndpoints || usb_get_extra_descriptor ( & interface -> endpoint [ 0 ] , HID_DT_HID , & hdesc ) ) ) { dbg_hid ( ""class descriptor not present\\n"" ) ; return - ENODEV ; } hid -> version = le16_to_cpu ( hdesc -> bcdHID ) ; hid -> country = hdesc -> bCountryCode ; for ( n = 0 ; n < hdesc -> bNumDescriptors ; n ++ ) if ( hdesc -> desc [ n ] . bDescriptorType == HID_DT_REPORT ) rsize = le16_to_cpu ( hdesc -> desc [ n ] . wDescriptorLength ) ; if ( ! rsize || rsize > HID_MAX_DESCRIPTOR_SIZE ) { dbg_hid ( ""weird size of report descriptor (%u)\\n"" , rsize ) ; return - EINVAL ; } rdesc = kmalloc ( rsize , GFP_KERNEL ) ; if ( ! rdesc ) return - ENOMEM ; hid_set_idle ( dev , interface -> desc . bInterfaceNumber , 0 , 0 ) ; ret = hid_get_class_descriptor ( dev , interface -> desc . bInterfaceNumber , HID_DT_REPORT , rdesc , rsize ) ; if ( ret < 0 ) { dbg_hid ( ""reading report descriptor failed\\n"" ) ; kfree ( rdesc ) ; goto err ; } ret = hid_parse_report ( hid , rdesc , rsize ) ; kfree ( rdesc ) ; if ( ret ) { dbg_hid ( ""parsing report descriptor failed\\n"" ) ; goto err ; } hid -> quirks |= quirks ; return 0 ; err : return ret ; }",718,-30.967561580839053,-0.04313030860841094
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int usbhid_parse ( struct hid_device * hid ) { struct usb_interface * intf = to_usb_interface ( hid -> dev . parent ) ; struct usb_host_interface * interface = intf -> cur_altsetting ; struct usb_device * dev = interface_to_usbdev ( intf ) ; struct hid_descriptor * hdesc ; u32 quirks = 0 ; unsigned int rsize = 0 ; char * rdesc ; int ret , n ; quirks = usbhid_lookup_quirk ( le16_to_cpu ( dev -> descriptor . idVendor ) , le16_to_cpu ( dev -> descriptor . idProduct ) ) ; if ( quirks & HID_QUIRK_IGNORE ) return - ENODEV ; if ( interface -> desc . bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT ) { if ( interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_KEYBOARD || interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_MOUSE ) quirks |= HID_QUIRK_NOGET ; } if ( usb_get_extra_descriptor ( interface , HID_DT_HID , & hdesc ) && ( ! interface -> desc . bNumEndpoints || usb_get_extra_descriptor ( & interface -> endpoint [ 0 ] , HID_DT_HID , & hdesc ) ) ) { dbg_hid ( ""class descriptor not present\\n"" ) ; return - ENODEV ; } hid -> version = le16_to_cpu ( hdesc -> bcdHID ) ; hid -> country = hdesc -> bCountryCode ; for ( n = 0 ; n < hdesc -> bNumDescriptors ; n ++ ) if ( hdesc -> desc [ n ] . bDescriptorType == HID_DT_REPORT ) rsize = le16_to_cpu ( hdesc -> desc [ n ] . wDescriptorLength ) ; if ( ! rsize || rsize > HID_MAX_DESCRIPTOR_SIZE ) { dbg_hid ( ""weird size of report descriptor (%u)\\n"" , rsize ) ; return - EINVAL ; } rdesc = kmalloc ( rsize , GFP_KERNEL ) ; if ( ! rdesc ) return - ENOMEM ; hid_set_idle ( dev , interface -> desc . bInterfaceNumber , 0 , 0 ) ; ret = hid_get_class_descriptor ( dev , interface -> desc . bInterfaceNumber , HID_DT_REPORT , rdesc , rsize ) ; if ( ret < 0 ) { dbg_hid ( ""reading report descriptor failed\\n"" ) ; kfree ( rdesc ) ; goto err ; } ret = hid_parse_report ( hid , rdesc , rsize ) ; kfree ( rdesc ) ; if ( ret ) { dbg_hid ( ""parsing report descriptor failed\\n"" ) ; goto err ; } hid -> quirks |= quirks ; return 0 ; err : return ret ; }
Fixed code:","
static int usbhid_parse ( struct hid_device * hid ) { struct usb_interface * intf = to_usb_interface ( hid -> dev . parent ) ; struct usb_host_interface * interface = intf -> cur_altsetting ; struct usb_device * dev = interface_to_usbdev ( intf ) ; struct hid_descriptor * hdesc ; u32 quirks = 0 ; unsigned int rsize = 0 ; char * rdesc ; int ret , n ; quirks = usbhid_lookup_quirk ( le16_to_cpu ( dev -> descriptor . idVendor ) , le16_to_cpu ( dev -> descriptor . idProduct ) ) ; if ( quirks & HID_QUIRK_IGNORE ) return - ENODEV ; if ( interface -> desc . bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT ) { if ( interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_KEYBOARD || interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_MOUSE ) quirks |= HID_QUIRK_NOGET ; } if ( usb_get_extra_descriptor ( interface , HID_DT_HID , & hdesc ) && ( ! interface -> desc . bNumEndpoints || usb_get_extra_descriptor ( & interface -> endpoint [ 0 ] , HID_DT_HID , & hdesc ) ) ) { dbg_hid ( ""class descriptor not present\\n"" ) ; return - ENODEV ; } hid -> version = le16_to_cpu ( hdesc -> bcdHID ) ; hid -> country = hdesc -> bCountryCode ; if (hdesc->bNumDescriptors > 0 && hdesc->bNumDescriptors < HID_MAX_DESCRIPTOR_SIZE) { // Added an if statement to prevent out-of-bounds read. for ( n = 0 ; n < hdesc -> bNumDescriptors ; n ++ ) if ( hdesc -> desc [ n ] . bDescriptorType == HID_DT_REPORT ) rsize = le16_to_cpu ( hdesc -> desc [ n ] . wDescriptorLength ) ; } else { // Added an else statement to handle a bNumDescriptors value > HID_MAX_DESCRIPTOR_SIZE. dbg_hid ( ""weird size of report descriptor (%u)\\n"" , rsize ) ; return - EINVAL ; } if ( ! rsize || rsize > HID_MAX_DESCRIPTOR_SIZE ) { dbg_hid ( ""weird size of report descriptor (%u)\\n"" , rsize ) ; return - EINVAL ; } rdesc = kmalloc ( rsize , GFP_KERNEL ) ; if ( ! rdesc ) return - ENOMEM ; hid_set_idle ( dev , interface -> desc . bInterfaceNumber , 0 , 0 ) ; ret = hid_get_class_descriptor ( dev , interface -> desc . bInterfaceNumber , HID_DT_REPORT , rdesc , rsize ) ; if ( ret < 0 ) { dbg_hid ( ""reading report descriptor failed\\n"" ) ; kfree ( rdesc ) ; goto err ; } ret = hid_parse_report ( hid , rdesc , rsize ) ; kfree ( rdesc ) ; if ( ret ) { dbg_hid ( ""parsing report descriptor failed\\n"" ) ; goto err ; } hid -> quirks |= quirks ; return 0 ; err : return ret ; }",798,-45.34398691865286,-0.05682203874517902
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int usbhid_parse ( struct hid_device * hid ) { struct usb_interface * intf = to_usb_interface ( hid -> dev . parent ) ; struct usb_host_interface * interface = intf -> cur_altsetting ; struct usb_device * dev = interface_to_usbdev ( intf ) ; struct hid_descriptor * hdesc ; u32 quirks = 0 ; unsigned int rsize = 0 ; char * rdesc ; int ret , n ; quirks = usbhid_lookup_quirk ( le16_to_cpu ( dev -> descriptor . idVendor ) , le16_to_cpu ( dev -> descriptor . idProduct ) ) ; if ( quirks & HID_QUIRK_IGNORE ) return - ENODEV ; if ( interface -> desc . bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT ) { if ( interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_KEYBOARD || interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_MOUSE ) quirks |= HID_QUIRK_NOGET ; } if ( usb_get_extra_descriptor ( interface , HID_DT_HID , & hdesc ) && ( ! interface -> desc . bNumEndpoints || usb_get_extra_descriptor ( & interface -> endpoint [ 0 ] , HID_DT_HID , & hdesc ) ) ) { dbg_hid ( ""class descriptor not present\\n"" ) ; return - ENODEV ; } hid -> version = le16_to_cpu ( hdesc -> bcdHID ) ; hid -> country = hdesc -> bCountryCode ; for ( n = 0 ; n < hdesc -> bNumDescriptors ; n ++ ) if ( hdesc -> desc [ n ] . bDescriptorType == HID_DT_REPORT ) rsize = le16_to_cpu ( hdesc -> desc [ n ] . wDescriptorLength ) ; if ( ! rsize || rsize > HID_MAX_DESCRIPTOR_SIZE ) { dbg_hid ( ""weird size of report descriptor (%u)\\n"" , rsize ) ; return - EINVAL ; } rdesc = kmalloc ( rsize , GFP_KERNEL ) ; if ( ! rdesc ) return - ENOMEM ; hid_set_idle ( dev , interface -> desc . bInterfaceNumber , 0 , 0 ) ; ret = hid_get_class_descriptor ( dev , interface -> desc . bInterfaceNumber , HID_DT_REPORT , rdesc , rsize ) ; if ( ret < 0 ) { dbg_hid ( ""reading report descriptor failed\\n"" ) ; kfree ( rdesc ) ; goto err ; } ret = hid_parse_report ( hid , rdesc , rsize ) ; kfree ( rdesc ) ; if ( ret ) { dbg_hid ( ""parsing report descriptor failed\\n"" ) ; goto err ; } hid -> quirks |= quirks ; return 0 ; err : return ret ; }
Fixed code:","
static int usbhid_parse ( struct hid_device * hid ) { struct usb_interface * intf = to_usb_interface ( hid -> dev . parent ) ; struct usb_host_interface * interface = intf -> cur_altsetting ; struct usb_device * dev = interface_to_usbdev ( intf ) ; struct hid_descriptor * hdesc ; u32 quirks = 0 ; unsigned int rsize = 0 ; char * rdesc ; int ret , n ; quirks = usbhid_lookup_quirk ( le16_to_cpu ( dev -> descriptor . idVendor ) , le16_to_cpu ( dev -> descriptor . idProduct ) ) ; if ( quirks & HID_QUIRK_IGNORE ) return - ENODEV ; if ( interface -> desc . bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT ) { if ( interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_KEYBOARD || interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_MOUSE ) quirks |= HID_QUIRK_NOGET ; } if ( usb_get_extra_descriptor ( interface , HID_DT_HID , & hdesc ) && ( ! interface -> desc . bNumEndpoints || usb_get_extra_descriptor ( & interface -> endpoint [ 0 ] , HID_DT_HID , & hdesc ) ) ) { dbg_hid ( ""class descriptor not present\\n"" ) ; return - ENODEV ; } if (hdesc) { // Added condition to check for out of bounds read. hid -> version = le16_to_cpu ( hdesc -> bcdHID ) ; hid -> country = hdesc -> bCountryCode ; for ( n = 0 ; n < hdesc -> bNumDescriptors ; n ++ ) if ( hdesc -> desc [ n ] . bDescriptorType == HID_DT_REPORT ) rsize = le16_to_cpu ( hdesc -> desc [ n ] . wDescriptorLength ) ; if ( ! rsize || rsize > HID_MAX_DESCRIPTOR_SIZE ) { dbg_hid ( ""weird size of report descriptor (%u)\\n"" , rsize ) ; return - EINVAL ; } rdesc = kmalloc ( rsize , GFP_KERNEL ) ; if ( ! rdesc ) return - ENOMEM ; hid_set_idle ( dev , interface -> desc . bInterfaceNumber , 0 , 0 ) ; ret = hid_get_class_descriptor ( dev , interface -> desc . bInterfaceNumber , HID_DT_REPORT , rdesc , rsize ) ; if ( ret < 0 ) { dbg_hid ( ""reading report descriptor failed\\n"" ) ; kfree ( rdesc ) ; goto err ; } ret = hid_parse_report ( hid , rdesc , rsize ) ; kfree ( rdesc ) ; if ( ret ) { dbg_hid ( ""parsing report descriptor failed\\n"" ) ; goto err ; } hid -> quirks |= quirks ; return 0 ; } err : return ret ; }",708,-22.12848283317157,-0.03125491925589205
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int usbhid_parse ( struct hid_device * hid ) { struct usb_interface * intf = to_usb_interface ( hid -> dev . parent ) ; struct usb_host_interface * interface = intf -> cur_altsetting ; struct usb_device * dev = interface_to_usbdev ( intf ) ; struct hid_descriptor * hdesc ; u32 quirks = 0 ; unsigned int rsize = 0 ; char * rdesc ; int ret , n ; quirks = usbhid_lookup_quirk ( le16_to_cpu ( dev -> descriptor . idVendor ) , le16_to_cpu ( dev -> descriptor . idProduct ) ) ; if ( quirks & HID_QUIRK_IGNORE ) return - ENODEV ; if ( interface -> desc . bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT ) { if ( interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_KEYBOARD || interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_MOUSE ) quirks |= HID_QUIRK_NOGET ; } if ( usb_get_extra_descriptor ( interface , HID_DT_HID , & hdesc ) && ( ! interface -> desc . bNumEndpoints || usb_get_extra_descriptor ( & interface -> endpoint [ 0 ] , HID_DT_HID , & hdesc ) ) ) { dbg_hid ( ""class descriptor not present\\n"" ) ; return - ENODEV ; } hid -> version = le16_to_cpu ( hdesc -> bcdHID ) ; hid -> country = hdesc -> bCountryCode ; for ( n = 0 ; n < hdesc -> bNumDescriptors ; n ++ ) if ( hdesc -> desc [ n ] . bDescriptorType == HID_DT_REPORT ) rsize = le16_to_cpu ( hdesc -> desc [ n ] . wDescriptorLength ) ; if ( ! rsize || rsize > HID_MAX_DESCRIPTOR_SIZE ) { dbg_hid ( ""weird size of report descriptor (%u)\\n"" , rsize ) ; return - EINVAL ; } rdesc = kmalloc ( rsize , GFP_KERNEL ) ; if ( ! rdesc ) return - ENOMEM ; hid_set_idle ( dev , interface -> desc . bInterfaceNumber , 0 , 0 ) ; ret = hid_get_class_descriptor ( dev , interface -> desc . bInterfaceNumber , HID_DT_REPORT , rdesc , rsize ) ; if ( ret < 0 ) { dbg_hid ( ""reading report descriptor failed\\n"" ) ; kfree ( rdesc ) ; goto err ; } ret = hid_parse_report ( hid , rdesc , rsize ) ; kfree ( rdesc ) ; if ( ret ) { dbg_hid ( ""parsing report descriptor failed\\n"" ) ; goto err ; } hid -> quirks |= quirks ; return 0 ; err : return ret ; }
Fixed code:","
static int usbhid_parse ( struct hid_device * hid ) { struct usb_interface * intf = to_usb_interface ( hid -> dev . parent ) ; struct usb_host_interface * interface = intf -> cur_altsetting ; struct usb_device * dev = interface_to_usbdev ( intf ) ; struct hid_descriptor * hdesc ; u32 quirks = 0 ; unsigned int rsize = 0 ; char * rdesc ; int ret , n ; quirks = usbhid_lookup_quirk ( le16_to_cpu ( dev -> descriptor . idVendor ) , le16_to_cpu ( dev -> descriptor . idProduct ) ) ; if ( quirks & HID_QUIRK_IGNORE ) return - ENODEV ; if ( interface -> desc . bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT ) { if ( interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_KEYBOARD || interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_MOUSE ) quirks |= HID_QUIRK_NOGET ; } if ( usb_get_extra_descriptor ( interface , HID_DT_HID , & hdesc ) && ( ! interface -> desc . bNumEndpoints || usb_get_extra_descriptor ( & interface -> endpoint [ 0 ] , HID_DT_HID , & hdesc ) ) ) { dbg_hid ( ""class descriptor not present\\n"" ) ; return - ENODEV ; } hid -> version = le16_to_cpu ( hdesc -> bcdHID ) ; hid -> country = hdesc -> bCountryCode ; for ( n = 0 ; n < hdesc -> bNumDescriptors ; n ++ ) { if ( n < HID_MAX_DESCRIPTOR && hdesc -> desc [ n ] . bDescriptorType == HID_DT_REPORT ) { rsize = le16_to_cpu ( hdesc -> desc [ n ] . wDescriptorLength ) ; } } if ( ! rsize || rsize > HID_MAX_DESCRIPTOR_SIZE ) { dbg_hid ( ""weird size of report descriptor (%u)\\n"" , rsize ) ; return - EINVAL ; } rdesc = kmalloc ( rsize , GFP_KERNEL ) ; if ( ! rdesc ) return - ENOMEM ; hid_set_idle ( dev , interface -> desc . bInterfaceNumber , 0 , 0 ) ; ret = hid_get_class_descriptor ( dev , interface -> desc . bInterfaceNumber , HID_DT_REPORT , rdesc , rsize ) ; if ( ret < 0 ) { dbg_hid ( ""reading report descriptor failed\\n"" ) ; kfree ( rdesc ) ; goto err ; } ret = hid_parse_report ( hid , rdesc , rsize ) ; kfree ( rdesc ) ; if ( ret ) { dbg_hid ( ""parsing report descriptor failed\\n"" ) ; goto err ; } hid -> quirks |= quirks ; return 0 ; err : return ret ; }",705,-8.632174441658108,-0.012244219066181714
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int usbhid_parse ( struct hid_device * hid ) { struct usb_interface * intf = to_usb_interface ( hid -> dev . parent ) ; struct usb_host_interface * interface = intf -> cur_altsetting ; struct usb_device * dev = interface_to_usbdev ( intf ) ; struct hid_descriptor * hdesc ; u32 quirks = 0 ; unsigned int rsize = 0 ; char * rdesc ; int ret , n ; quirks = usbhid_lookup_quirk ( le16_to_cpu ( dev -> descriptor . idVendor ) , le16_to_cpu ( dev -> descriptor . idProduct ) ) ; if ( quirks & HID_QUIRK_IGNORE ) return - ENODEV ; if ( interface -> desc . bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT ) { if ( interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_KEYBOARD || interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_MOUSE ) quirks |= HID_QUIRK_NOGET ; } if ( usb_get_extra_descriptor ( interface , HID_DT_HID , & hdesc ) && ( ! interface -> desc . bNumEndpoints || usb_get_extra_descriptor ( & interface -> endpoint [ 0 ] , HID_DT_HID , & hdesc ) ) ) { dbg_hid ( ""class descriptor not present\\n"" ) ; return - ENODEV ; } hid -> version = le16_to_cpu ( hdesc -> bcdHID ) ; hid -> country = hdesc -> bCountryCode ; for ( n = 0 ; n < hdesc -> bNumDescriptors ; n ++ ) if ( hdesc -> desc [ n ] . bDescriptorType == HID_DT_REPORT ) rsize = le16_to_cpu ( hdesc -> desc [ n ] . wDescriptorLength ) ; if ( ! rsize || rsize > HID_MAX_DESCRIPTOR_SIZE ) { dbg_hid ( ""weird size of report descriptor (%u)\\n"" , rsize ) ; return - EINVAL ; } rdesc = kmalloc ( rsize , GFP_KERNEL ) ; if ( ! rdesc ) return - ENOMEM ; hid_set_idle ( dev , interface -> desc . bInterfaceNumber , 0 , 0 ) ; ret = hid_get_class_descriptor ( dev , interface -> desc . bInterfaceNumber , HID_DT_REPORT , rdesc , rsize ) ; if ( ret < 0 ) { dbg_hid ( ""reading report descriptor failed\\n"" ) ; kfree ( rdesc ) ; goto err ; } ret = hid_parse_report ( hid , rdesc , rsize ) ; kfree ( rdesc ) ; if ( ret ) { dbg_hid ( ""parsing report descriptor failed\\n"" ) ; goto err ; } hid -> quirks |= quirks ; return 0 ; err : return ret ; }
Fixed code:","

static int usbhid_parse ( struct hid_device * hid ) { struct usb_interface * intf = to_usb_interface ( hid -> dev . parent ) ; struct usb_host_interface * interface = intf -> cur_altsetting ; struct usb_device * dev = interface_to_usbdev ( intf ) ; struct hid_descriptor * hdesc ; u32 quirks = 0 ; unsigned int rsize = 0 ; char * rdesc ; int ret , n ; quirks = usbhid_lookup_quirk ( le16_to_cpu ( dev -> descriptor . idVendor ) , le16_to_cpu ( dev -> descriptor . idProduct ) ) ; if ( quirks & HID_QUIRK_IGNORE ) return - ENODEV ; if ( interface -> desc . bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT ) { if ( interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_KEYBOARD || interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_MOUSE ) quirks |= HID_QUIRK_NOGET ; } if ( usb_get_extra_descriptor ( interface , HID_DT_HID , & hdesc ) && ( ! interface -> desc . bNumEndpoints || usb_get_extra_descriptor ( & interface -> endpoint [ 0 ] , HID_DT_HID , & hdesc ) ) ) { dbg_hid ( ""class descriptor not present\\n"" ) ; return - ENODEV ; } hid -> version = le16_to_cpu ( hdesc -> bcdHID ) ; hid -> country = hdesc -> bCountryCode ; 

//Replacing the For loop with the length of the descriptor to prevent out of bounds array access
for ( n = 0 ; n < hdesc -> bNumDescriptors && n < HID_MAX_DESCRIPTOR_SIZE; n ++ ) if ( hdesc -> desc [ n ] . bDescriptorType == HID_DT_REPORT ) rsize = le16_to_cpu ( hdesc -> desc [ n ] . wDescriptorLength ) ; if ( ! rsize || rsize > HID_MAX_DESCRIPTOR_SIZE ) { dbg_hid ( ""weird size of report descriptor (%u)\\n"" , rsize ) ; return - EINVAL ; } rdesc = kmalloc ( rsize , GFP_KERNEL ) ; if ( ! rdesc ) return - ENOMEM ; hid_set_idle ( dev , interface -> desc . bInterfaceNumber , 0 , 0 ) ; ret = hid_get_class_descriptor ( dev , interface -> desc . bInterfaceNumber , HID_DT_REPORT , rdesc , rsize ) ; if ( ret < 0 ) { dbg_hid ( ""reading report descriptor failed\\n"" ) ; kfree ( rdesc ) ; goto err ; } ret = hid_parse_report ( hid , rdesc , rsize ) ; kfree ( rdesc ) ; if ( ret ) { dbg_hid ( ""parsing report descriptor failed\\n"" ) ; goto err ; } hid -> quirks |= quirks ; return 0 ; err : return ret ; }",727,-48.07386898105821,-0.06612636723666879
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int usbhid_parse ( struct hid_device * hid ) { struct usb_interface * intf = to_usb_interface ( hid -> dev . parent ) ; struct usb_host_interface * interface = intf -> cur_altsetting ; struct usb_device * dev = interface_to_usbdev ( intf ) ; struct hid_descriptor * hdesc ; u32 quirks = 0 ; unsigned int rsize = 0 ; char * rdesc ; int ret , n ; quirks = usbhid_lookup_quirk ( le16_to_cpu ( dev -> descriptor . idVendor ) , le16_to_cpu ( dev -> descriptor . idProduct ) ) ; if ( quirks & HID_QUIRK_IGNORE ) return - ENODEV ; if ( interface -> desc . bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT ) { if ( interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_KEYBOARD || interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_MOUSE ) quirks |= HID_QUIRK_NOGET ; } if ( usb_get_extra_descriptor ( interface , HID_DT_HID , & hdesc ) && ( ! interface -> desc . bNumEndpoints || usb_get_extra_descriptor ( & interface -> endpoint [ 0 ] , HID_DT_HID , & hdesc ) ) ) { dbg_hid ( ""class descriptor not present\\n"" ) ; return - ENODEV ; } hid -> version = le16_to_cpu ( hdesc -> bcdHID ) ; hid -> country = hdesc -> bCountryCode ; for ( n = 0 ; n < hdesc -> bNumDescriptors ; n ++ ) if ( hdesc -> desc [ n ] . bDescriptorType == HID_DT_REPORT ) rsize = le16_to_cpu ( hdesc -> desc [ n ] . wDescriptorLength ) ; if ( ! rsize || rsize > HID_MAX_DESCRIPTOR_SIZE ) { dbg_hid ( ""weird size of report descriptor (%u)\\n"" , rsize ) ; return - EINVAL ; } rdesc = kmalloc ( rsize , GFP_KERNEL ) ; if ( ! rdesc ) return - ENOMEM ; hid_set_idle ( dev , interface -> desc . bInterfaceNumber , 0 , 0 ) ; ret = hid_get_class_descriptor ( dev , interface -> desc . bInterfaceNumber , HID_DT_REPORT , rdesc , rsize ) ; if ( ret < 0 ) { dbg_hid ( ""reading report descriptor failed\\n"" ) ; kfree ( rdesc ) ; goto err ; } ret = hid_parse_report ( hid , rdesc , rsize ) ; kfree ( rdesc ) ; if ( ret ) { dbg_hid ( ""parsing report descriptor failed\\n"" ) ; goto err ; } hid -> quirks |= quirks ; return 0 ; err : return ret ; }
Fixed code:","
static int usbhid_parse ( struct hid_device * hid ) { struct usb_interface * intf = to_usb_interface ( hid -> dev . parent ) ; struct usb_host_interface * interface = intf -> cur_altsetting ; struct usb_device * dev = interface_to_usbdev ( intf ) ; struct hid_descriptor * hdesc ; u32 quirks = 0 ; unsigned int rsize = 0 ; char * rdesc ; int ret , n ; quirks = usbhid_lookup_quirk ( le16_to_cpu ( dev -> descriptor . idVendor ) , le16_to_cpu ( dev -> descriptor . idProduct ) ) ; if ( quirks & HID_QUIRK_IGNORE ) return - ENODEV ; if ( interface -> desc . bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT ) { if ( interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_KEYBOARD || interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_MOUSE ) quirks |= HID_QUIRK_NOGET ; } if ( usb_get_extra_descriptor ( interface , HID_DT_HID , & hdesc ) && ( ! interface -> desc . bNumEndpoints || usb_get_extra_descriptor ( & interface -> endpoint [ 0 ] , HID_DT_HID , & hdesc ) ) ) { dbg_hid ( ""class descriptor not present\\n"" ) ; return - ENODEV ; } hid -> version = le16_to_cpu ( hdesc -> bcdHID ) ; hid -> country = hdesc -> bCountryCode ; for ( n = 0 ; n < hdesc -> bNumDescriptors ; n ++ ) { if ( n > HID_MAX_DESCRIPTOR_SIZE) { dbg_hid( ""index of report descriptor out of bounds\\n"") ; return - EINVAL ; } if ( hdesc -> desc [ n ] . bDescriptorType == HID_DT_REPORT ) rsize = le16_to_cpu ( hdesc -> desc [ n ] . wDescriptorLength ) ; } if ( ! rsize || rsize > HID_MAX_DESCRIPTOR_SIZE ) { dbg_hid ( ""weird size of report descriptor (%u)\\n"" , rsize ) ; return - EINVAL ; } rdesc = kmalloc ( rsize , GFP_KERNEL ) ; if ( ! rdesc ) return - ENOMEM ; hid_set_idle ( dev , interface -> desc . bInterfaceNumber , 0 , 0 ) ; ret = hid_get_class_descriptor ( dev , interface -> desc . bInterfaceNumber , HID_DT_REPORT , rdesc , rsize ) ; if ( ret < 0 ) { dbg_hid ( ""reading report descriptor failed\\n"" ) ; kfree ( rdesc ) ; goto err ; } ret = hid_parse_report ( hid , rdesc , rsize ) ; kfree ( rdesc ) ; if ( ret ) { dbg_hid ( ""parsing report descriptor failed\\n"" ) ; goto err ; } hid -> quirks |= quirks ; return 0 ; err : return ret ; }",732,-26.587715495253388,-0.03632201570389807
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int usbhid_parse ( struct hid_device * hid ) { struct usb_interface * intf = to_usb_interface ( hid -> dev . parent ) ; struct usb_host_interface * interface = intf -> cur_altsetting ; struct usb_device * dev = interface_to_usbdev ( intf ) ; struct hid_descriptor * hdesc ; u32 quirks = 0 ; unsigned int rsize = 0 ; char * rdesc ; int ret , n ; quirks = usbhid_lookup_quirk ( le16_to_cpu ( dev -> descriptor . idVendor ) , le16_to_cpu ( dev -> descriptor . idProduct ) ) ; if ( quirks & HID_QUIRK_IGNORE ) return - ENODEV ; if ( interface -> desc . bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT ) { if ( interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_KEYBOARD || interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_MOUSE ) quirks |= HID_QUIRK_NOGET ; } if ( usb_get_extra_descriptor ( interface , HID_DT_HID , & hdesc ) && ( ! interface -> desc . bNumEndpoints || usb_get_extra_descriptor ( & interface -> endpoint [ 0 ] , HID_DT_HID , & hdesc ) ) ) { dbg_hid ( ""class descriptor not present\\n"" ) ; return - ENODEV ; } hid -> version = le16_to_cpu ( hdesc -> bcdHID ) ; hid -> country = hdesc -> bCountryCode ; for ( n = 0 ; n < hdesc -> bNumDescriptors ; n ++ ) if ( hdesc -> desc [ n ] . bDescriptorType == HID_DT_REPORT ) rsize = le16_to_cpu ( hdesc -> desc [ n ] . wDescriptorLength ) ; if ( ! rsize || rsize > HID_MAX_DESCRIPTOR_SIZE ) { dbg_hid ( ""weird size of report descriptor (%u)\\n"" , rsize ) ; return - EINVAL ; } rdesc = kmalloc ( rsize , GFP_KERNEL ) ; if ( ! rdesc ) return - ENOMEM ; hid_set_idle ( dev , interface -> desc . bInterfaceNumber , 0 , 0 ) ; ret = hid_get_class_descriptor ( dev , interface -> desc . bInterfaceNumber , HID_DT_REPORT , rdesc , rsize ) ; if ( ret < 0 ) { dbg_hid ( ""reading report descriptor failed\\n"" ) ; kfree ( rdesc ) ; goto err ; } ret = hid_parse_report ( hid , rdesc , rsize ) ; kfree ( rdesc ) ; if ( ret ) { dbg_hid ( ""parsing report descriptor failed\\n"" ) ; goto err ; } hid -> quirks |= quirks ; return 0 ; err : return ret ; }
Fixed code:","

static int usbhid_parse ( struct hid_device * hid ) { struct usb_interface * intf = to_usb_interface ( hid -> dev . parent ) ; struct usb_host_interface * interface = intf -> cur_altsetting ; struct usb_device * dev = interface_to_usbdev ( intf ) ; struct hid_descriptor * hdesc ; u32 quirks = 0 ; unsigned int rsize = 0 ; char * rdesc ; int ret , n ; quirks = usbhid_lookup_quirk ( le16_to_cpu ( dev -> descriptor . idVendor ) , le16_to_cpu ( dev -> descriptor . idProduct ) ) ; if ( quirks & HID_QUIRK_IGNORE ) return - ENODEV ; if ( interface -> desc . bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT ) { if ( interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_KEYBOARD || interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_MOUSE ) quirks |= HID_QUIRK_NOGET ; } if ( usb_get_extra_descriptor ( interface , HID_DT_HID , & hdesc ) && ( ! interface -> desc . bNumEndpoints || usb_get_extra_descriptor ( & interface -> endpoint [ 0 ] , HID_DT_HID , & hdesc ) ) ) { dbg_hid ( ""class descriptor not present\\n"" ) ; return - ENODEV ; } hid -> version = le16_to_cpu ( hdesc -> bcdHID ) ; hid -> country = hdesc -> bCountryCode ; if(hdesc -> bNumDescriptors == 0) { return 0; } for ( n = 0 ; n < hdesc -> bNumDescriptors ; n ++ ) if ( hdesc -> desc [ n ] . bDescriptorType == HID_DT_REPORT ) rsize = le16_to_cpu ( hdesc -> desc [ n ] . wDescriptorLength ) ; if ( ! rsize || rsize > HID_MAX_DESCRIPTOR_SIZE ) { dbg_hid ( ""weird size of report descriptor (%u)\\n"" , rsize ) ; return - EINVAL ; } rdesc = kmalloc ( rsize , GFP_KERNEL ) ; if ( ! rdesc ) return - ENOMEM ; hid_set_idle ( dev , interface -> desc . bInterfaceNumber , 0 , 0 ) ; ret = hid_get_class_descriptor ( dev , interface -> desc . bInterfaceNumber , HID_DT_REPORT , rdesc , rsize ) ; if ( ret < 0 ) { dbg_hid ( ""reading report descriptor failed\\n"" ) ; kfree ( rdesc ) ; goto err ; } ret = hid_parse_report ( hid , rdesc , rsize ) ; kfree ( rdesc ) ; if ( ret ) { dbg_hid ( ""parsing report descriptor failed\\n"" ) ; goto err ; } hid -> quirks |= quirks ; return 0 ; err : return ret ; }",709,-18.081026872568952,-0.025502153557925178
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int usbhid_parse ( struct hid_device * hid ) { struct usb_interface * intf = to_usb_interface ( hid -> dev . parent ) ; struct usb_host_interface * interface = intf -> cur_altsetting ; struct usb_device * dev = interface_to_usbdev ( intf ) ; struct hid_descriptor * hdesc ; u32 quirks = 0 ; unsigned int rsize = 0 ; char * rdesc ; int ret , n ; quirks = usbhid_lookup_quirk ( le16_to_cpu ( dev -> descriptor . idVendor ) , le16_to_cpu ( dev -> descriptor . idProduct ) ) ; if ( quirks & HID_QUIRK_IGNORE ) return - ENODEV ; if ( interface -> desc . bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT ) { if ( interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_KEYBOARD || interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_MOUSE ) quirks |= HID_QUIRK_NOGET ; } if ( usb_get_extra_descriptor ( interface , HID_DT_HID , & hdesc ) && ( ! interface -> desc . bNumEndpoints || usb_get_extra_descriptor ( & interface -> endpoint [ 0 ] , HID_DT_HID , & hdesc ) ) ) { dbg_hid ( ""class descriptor not present\\n"" ) ; return - ENODEV ; } hid -> version = le16_to_cpu ( hdesc -> bcdHID ) ; hid -> country = hdesc -> bCountryCode ; for ( n = 0 ; n < hdesc -> bNumDescriptors ; n ++ ) if ( hdesc -> desc [ n ] . bDescriptorType == HID_DT_REPORT ) rsize = le16_to_cpu ( hdesc -> desc [ n ] . wDescriptorLength ) ; if ( ! rsize || rsize > HID_MAX_DESCRIPTOR_SIZE ) { dbg_hid ( ""weird size of report descriptor (%u)\\n"" , rsize ) ; return - EINVAL ; } rdesc = kmalloc ( rsize , GFP_KERNEL ) ; if ( ! rdesc ) return - ENOMEM ; hid_set_idle ( dev , interface -> desc . bInterfaceNumber , 0 , 0 ) ; ret = hid_get_class_descriptor ( dev , interface -> desc . bInterfaceNumber , HID_DT_REPORT , rdesc , rsize ) ; if ( ret < 0 ) { dbg_hid ( ""reading report descriptor failed\\n"" ) ; kfree ( rdesc ) ; goto err ; } ret = hid_parse_report ( hid , rdesc , rsize ) ; kfree ( rdesc ) ; if ( ret ) { dbg_hid ( ""parsing report descriptor failed\\n"" ) ; goto err ; } hid -> quirks |= quirks ; return 0 ; err : return ret ; }
Fixed code:","
static int usbhid_parse ( struct hid_device * hid ) { struct usb_interface * intf = to_usb_interface ( hid -> dev . parent ) ; struct usb_host_interface * interface = intf -> cur_altsetting ; struct usb_device * dev = interface_to_usbdev ( intf ) ; struct hid_descriptor * hdesc ; u32 quirks = 0 ; unsigned int rsize = 0 ; char * rdesc ; int ret , n ; if ( rsize > HID_MAX_DESCRIPTOR_SIZE ) { dbg_hid ( ""weird size of report descriptor (%u)\\n"" , rsize ) ; return - EINVAL ; } quirks = usbhid_lookup_quirk ( le16_to_cpu ( dev -> descriptor . idVendor ) , le16_to_cpu ( dev -> descriptor . idProduct ) ) ; if ( quirks & HID_QUIRK_IGNORE ) return - ENODEV ; if ( interface -> desc . bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT ) { if ( interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_KEYBOARD || interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_MOUSE ) quirks |= HID_QUIRK_NOGET ; } if ( usb_get_extra_descriptor ( interface , HID_DT_HID , & hdesc ) && ( ! interface -> desc . bNumEndpoints || usb_get_extra_descriptor ( & interface -> endpoint [ 0 ] , HID_DT_HID , & hdesc ) ) ) { dbg_hid ( ""class descriptor not present\\n"" ) ; return - ENODEV ; } hid -> version = le16_to_cpu ( hdesc -> bcdHID ) ; hid -> country = hdesc -> bCountryCode ; for ( n = 0 ; n < hdesc -> bNumDescriptors ; n ++ ) if ( hdesc -> desc [ n ] . bDescriptorType == HID_DT_REPORT ) rsize = le16_to_cpu ( hdesc -> desc [ n ] . wDescriptorLength ) ; if ( ! rsize ) { dbg_hid ( ""No descriptor length found\\n"" ) ; return - EINVAL ; } rdesc = kmalloc ( rsize , GFP_KERNEL ) ; if ( ! rdesc ) return - ENOMEM ; hid_set_idle ( dev , interface -> desc . bInterfaceNumber , 0 , 0 ) ; ret = hid_get_class_descriptor ( dev , interface -> desc . bInterfaceNumber , HID_DT_REPORT , rdesc , rsize ) ; if ( ret < 0 ) { dbg_hid ( ""reading report descriptor failed\\n"" ) ; kfree ( rdesc ) ; goto err ; } ret = hid_parse_report ( hid , rdesc , rsize ) ; kfree ( rdesc ) ; if ( ret ) { dbg_hid ( ""parsing report descriptor failed\\n"" ) ; goto err ; } hid -> quirks |= quirks ; return 0 ; err : return ret ; }",715,-16.123988849921414,-0.022551033356533447
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int usbhid_parse ( struct hid_device * hid ) { struct usb_interface * intf = to_usb_interface ( hid -> dev . parent ) ; struct usb_host_interface * interface = intf -> cur_altsetting ; struct usb_device * dev = interface_to_usbdev ( intf ) ; struct hid_descriptor * hdesc ; u32 quirks = 0 ; unsigned int rsize = 0 ; char * rdesc ; int ret , n ; quirks = usbhid_lookup_quirk ( le16_to_cpu ( dev -> descriptor . idVendor ) , le16_to_cpu ( dev -> descriptor . idProduct ) ) ; if ( quirks & HID_QUIRK_IGNORE ) return - ENODEV ; if ( interface -> desc . bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT ) { if ( interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_KEYBOARD || interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_MOUSE ) quirks |= HID_QUIRK_NOGET ; } if ( usb_get_extra_descriptor ( interface , HID_DT_HID , & hdesc ) && ( ! interface -> desc . bNumEndpoints || usb_get_extra_descriptor ( & interface -> endpoint [ 0 ] , HID_DT_HID , & hdesc ) ) ) { dbg_hid ( ""class descriptor not present\\n"" ) ; return - ENODEV ; } hid -> version = le16_to_cpu ( hdesc -> bcdHID ) ; hid -> country = hdesc -> bCountryCode ; for ( n = 0 ; n < hdesc -> bNumDescriptors ; n ++ ) if ( hdesc -> desc [ n ] . bDescriptorType == HID_DT_REPORT ) rsize = le16_to_cpu ( hdesc -> desc [ n ] . wDescriptorLength ) ; if ( ! rsize || rsize > HID_MAX_DESCRIPTOR_SIZE ) { dbg_hid ( ""weird size of report descriptor (%u)\\n"" , rsize ) ; return - EINVAL ; } rdesc = kmalloc ( rsize , GFP_KERNEL ) ; if ( ! rdesc ) return - ENOMEM ; hid_set_idle ( dev , interface -> desc . bInterfaceNumber , 0 , 0 ) ; ret = hid_get_class_descriptor ( dev , interface -> desc . bInterfaceNumber , HID_DT_REPORT , rdesc , rsize ) ; if ( ret < 0 ) { dbg_hid ( ""reading report descriptor failed\\n"" ) ; kfree ( rdesc ) ; goto err ; } ret = hid_parse_report ( hid , rdesc , rsize ) ; kfree ( rdesc ) ; if ( ret ) { dbg_hid ( ""parsing report descriptor failed\\n"" ) ; goto err ; } hid -> quirks |= quirks ; return 0 ; err : return ret ; }
Fixed code:","
static int usbhid_parse ( struct hid_device * hid ) { struct usb_interface * intf = to_usb_interface ( hid -> dev . parent ) ; struct usb_host_interface * interface = intf -> cur_altsetting ; struct usb_device * dev = interface_to_usbdev ( intf ) ; struct hid_descriptor * hdesc ; u32 quirks = 0 ; unsigned int rsize = 0 ; char * rdesc ; int ret , n ; quirks = usbhid_lookup_quirk ( le16_to_cpu ( dev -> descriptor . idVendor ) , le16_to_cpu ( dev -> descriptor . idProduct ) ) ; if ( quirks & HID_QUIRK_IGNORE ) return - ENODEV ; if ( interface -> desc . bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT ) { if ( interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_KEYBOARD || interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_MOUSE ) quirks |= HID_QUIRK_NOGET ; } if ( usb_get_extra_descriptor ( interface , HID_DT_HID , & hdesc ) && ( ! interface -> desc . bNumEndpoints || usb_get_extra_descriptor ( & interface -> endpoint [ 0 ] , HID_DT_HID , & hdesc ) ) ) { dbg_hid ( ""class descriptor not present\\n"" ) ; return - ENODEV ; } hid -> version = le16_to_cpu ( hdesc -> bcdHID ) ; hid -> country = hdesc -> bCountryCode ; for ( n = 0 ; n < hdesc -> bNumDescriptors ; n ++ ) { if ( n >= HID_MAX_DESCRIPTOR_SIZE ) break; if ( hdesc -> desc [ n ] . bDescriptorType == HID_DT_REPORT ) rsize = le16_to_cpu ( hdesc -> desc [ n ] . wDescriptorLength ) ; } if ( ! rsize || rsize > HID_MAX_DESCRIPTOR_SIZE ) { dbg_hid ( ""weird size of report descriptor (%u)\\n"" , rsize ) ; return - EINVAL ; } rdesc = kmalloc ( rsize , GFP_KERNEL ) ; if ( ! rdesc ) return - ENOMEM ; hid_set_idle ( dev , interface -> desc . bInterfaceNumber , 0 , 0 ) ; ret = hid_get_class_descriptor ( dev , interface -> desc . bInterfaceNumber , HID_DT_REPORT , rdesc , rsize ) ; if ( ret < 0 ) { dbg_hid ( ""reading report descriptor failed\\n"" ) ; kfree ( rdesc ) ; goto err ; } ret = hid_parse_report ( hid , rdesc , rsize ) ; kfree ( rdesc ) ; if ( ret ) { dbg_hid ( ""parsing report descriptor failed\\n"" ) ; goto err ; } hid -> quirks |= quirks ; return 0 ; err : return ret ; }",709,-7.233258162675896,-0.010202056646933563
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int usbhid_parse ( struct hid_device * hid ) { struct usb_interface * intf = to_usb_interface ( hid -> dev . parent ) ; struct usb_host_interface * interface = intf -> cur_altsetting ; struct usb_device * dev = interface_to_usbdev ( intf ) ; struct hid_descriptor * hdesc ; u32 quirks = 0 ; unsigned int rsize = 0 ; char * rdesc ; int ret , n ; quirks = usbhid_lookup_quirk ( le16_to_cpu ( dev -> descriptor . idVendor ) , le16_to_cpu ( dev -> descriptor . idProduct ) ) ; if ( quirks & HID_QUIRK_IGNORE ) return - ENODEV ; if ( interface -> desc . bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT ) { if ( interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_KEYBOARD || interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_MOUSE ) quirks |= HID_QUIRK_NOGET ; } if ( usb_get_extra_descriptor ( interface , HID_DT_HID , & hdesc ) && ( ! interface -> desc . bNumEndpoints || usb_get_extra_descriptor ( & interface -> endpoint [ 0 ] , HID_DT_HID , & hdesc ) ) ) { dbg_hid ( ""class descriptor not present\\n"" ) ; return - ENODEV ; } hid -> version = le16_to_cpu ( hdesc -> bcdHID ) ; hid -> country = hdesc -> bCountryCode ; for ( n = 0 ; n < hdesc -> bNumDescriptors ; n ++ ) if ( hdesc -> desc [ n ] . bDescriptorType == HID_DT_REPORT ) rsize = le16_to_cpu ( hdesc -> desc [ n ] . wDescriptorLength ) ; if ( ! rsize || rsize > HID_MAX_DESCRIPTOR_SIZE ) { dbg_hid ( ""weird size of report descriptor (%u)\\n"" , rsize ) ; return - EINVAL ; } rdesc = kmalloc ( rsize , GFP_KERNEL ) ; if ( ! rdesc ) return - ENOMEM ; hid_set_idle ( dev , interface -> desc . bInterfaceNumber , 0 , 0 ) ; ret = hid_get_class_descriptor ( dev , interface -> desc . bInterfaceNumber , HID_DT_REPORT , rdesc , rsize ) ; if ( ret < 0 ) { dbg_hid ( ""reading report descriptor failed\\n"" ) ; kfree ( rdesc ) ; goto err ; } ret = hid_parse_report ( hid , rdesc , rsize ) ; kfree ( rdesc ) ; if ( ret ) { dbg_hid ( ""parsing report descriptor failed\\n"" ) ; goto err ; } hid -> quirks |= quirks ; return 0 ; err : return ret ; }
Fixed code:"," 
static int usbhid_parse ( struct hid_device * hid ) { struct usb_interface * intf = to_usb_interface ( hid -> dev . parent ) ; struct usb_host_interface * interface = intf -> cur_altsetting ; struct usb_device * dev = interface_to_usbdev ( intf ) ; struct hid_descriptor * hdesc ; u32 quirks = 0 ; unsigned int rsize = 0 ; char * rdesc ; int ret , n ; quirks = usbhid_lookup_quirk ( le16_to_cpu ( dev -> descriptor . idVendor ) , le16_to_cpu ( dev -> descriptor . idProduct ) ) ; if ( quirks & HID_QUIRK_IGNORE ) return - ENODEV ; if ( interface -> desc . bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT ) { if ( interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_KEYBOARD || interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_MOUSE ) quirks |= HID_QUIRK_NOGET ; } if ( usb_get_extra_descriptor ( interface , HID_DT_HID , & hdesc ) && ( ! interface -> desc . bNumEndpoints || usb_get_extra_descriptor ( & interface -> endpoint [ 0 ] , HID_DT_HID , & hdesc ) ) ) { dbg_hid ( ""class descriptor not present\\n"" ) ; return - ENODEV ; } hid -> version = le16_to_cpu ( hdesc -> bcdHID ) ; hid -> country = hdesc -> bCountryCode ; for ( n = 0 ; n < hdesc -> bNumDescriptors ; n ++ ) if ( n < HID_MAX_DESCRIPTOR_SIZE && hdesc -> desc [ n ] . bDescriptorType == HID_DT_REPORT ) rsize = le16_to_cpu ( hdesc -> desc [ n ] . wDescriptorLength ) ; if ( ! rsize || rsize > HID_MAX_DESCRIPTOR_SIZE ) { dbg_hid ( ""weird size of report descriptor (%u)\\n"" , rsize ) ; return - EINVAL ; } rdesc = kmalloc ( rsize , GFP_KERNEL ) ; if ( ! rdesc ) return - ENOMEM ; hid_set_idle ( dev , interface -> desc . bInterfaceNumber , 0 , 0 ) ; ret = hid_get_class_descriptor ( dev , interface -> desc . bInterfaceNumber , HID_DT_REPORT , rdesc , rsize ) ; if ( ret < 0 ) { dbg_hid ( ""reading report descriptor failed\\n"" ) ; kfree ( rdesc ) ; goto err ; } ret = hid_parse_report ( hid , rdesc , rsize ) ; kfree ( rdesc ) ; if ( ret ) { dbg_hid ( ""parsing report descriptor failed\\n"" ) ; goto err ; } hid -> quirks |= quirks ; return 0 ; err : return ret ; }",704,-8.273169763365305,-0.011751661595689354
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int usbhid_parse ( struct hid_device * hid ) { struct usb_interface * intf = to_usb_interface ( hid -> dev . parent ) ; struct usb_host_interface * interface = intf -> cur_altsetting ; struct usb_device * dev = interface_to_usbdev ( intf ) ; struct hid_descriptor * hdesc ; u32 quirks = 0 ; unsigned int rsize = 0 ; char * rdesc ; int ret , n ; quirks = usbhid_lookup_quirk ( le16_to_cpu ( dev -> descriptor . idVendor ) , le16_to_cpu ( dev -> descriptor . idProduct ) ) ; if ( quirks & HID_QUIRK_IGNORE ) return - ENODEV ; if ( interface -> desc . bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT ) { if ( interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_KEYBOARD || interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_MOUSE ) quirks |= HID_QUIRK_NOGET ; } if ( usb_get_extra_descriptor ( interface , HID_DT_HID , & hdesc ) && ( ! interface -> desc . bNumEndpoints || usb_get_extra_descriptor ( & interface -> endpoint [ 0 ] , HID_DT_HID , & hdesc ) ) ) { dbg_hid ( ""class descriptor not present\\n"" ) ; return - ENODEV ; } hid -> version = le16_to_cpu ( hdesc -> bcdHID ) ; hid -> country = hdesc -> bCountryCode ; for ( n = 0 ; n < hdesc -> bNumDescriptors ; n ++ ) if ( hdesc -> desc [ n ] . bDescriptorType == HID_DT_REPORT ) rsize = le16_to_cpu ( hdesc -> desc [ n ] . wDescriptorLength ) ; if ( ! rsize || rsize > HID_MAX_DESCRIPTOR_SIZE ) { dbg_hid ( ""weird size of report descriptor (%u)\\n"" , rsize ) ; return - EINVAL ; } rdesc = kmalloc ( rsize , GFP_KERNEL ) ; if ( ! rdesc ) return - ENOMEM ; hid_set_idle ( dev , interface -> desc . bInterfaceNumber , 0 , 0 ) ; ret = hid_get_class_descriptor ( dev , interface -> desc . bInterfaceNumber , HID_DT_REPORT , rdesc , rsize ) ; if ( ret < 0 ) { dbg_hid ( ""reading report descriptor failed\\n"" ) ; kfree ( rdesc ) ; goto err ; } ret = hid_parse_report ( hid , rdesc , rsize ) ; kfree ( rdesc ) ; if ( ret ) { dbg_hid ( ""parsing report descriptor failed\\n"" ) ; goto err ; } hid -> quirks |= quirks ; return 0 ; err : return ret ; }
Fixed code:","
static int usbhid_parse ( struct hid_device * hid ) { struct usb_interface * intf = to_usb_interface ( hid -> dev . parent ) ; struct usb_host_interface * interface = intf -> cur_altsetting ; struct usb_device * dev = interface_to_usbdev ( intf ) ; struct hid_descriptor * hdesc ; u32 quirks = 0 ; unsigned int rsize = 0 ; char * rdesc ; int ret , n ; 

if (intf == NULL || interface == NULL || dev == NULL) {
    return -ENODEV;
}

quirks = usbhid_lookup_quirk ( le16_to_cpu ( dev -> descriptor . idVendor ) , le16_to_cpu ( dev -> descriptor . idProduct ) ) ; if ( quirks & HID_QUIRK_IGNORE ) return - ENODEV ; if ( interface -> desc . bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT ) { if ( interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_KEYBOARD || interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_MOUSE ) quirks |= HID_QUIRK_NOGET ; } if ( usb_get_extra_descriptor ( interface , HID_DT_HID , & hdesc ) && ( ! interface -> desc . bNumEndpoints || usb_get_extra_descriptor ( & interface -> endpoint [ 0 ] , HID_DT_HID , & hdesc ) ) ) { dbg_hid ( ""class descriptor not present\\n"" ) ; return - ENODEV ; } hid -> version = le16_to_cpu ( hdesc -> bcdHID ) ; hid -> country = hdesc -> bCountryCode ; for ( n = 0 ; n < hdesc -> bNumDescriptors ; n ++ ) {
    if (n > HID_MAX_DESCRIPTOR_SIZE) {
        dbg_hid ( ""out-of-bounds read\\n"" ) ; 
        return -ENOMEM;   
    }
    if ( hdesc -> desc [ n ] . bDescriptorType == HID_DT_REPORT ) rsize = le16_to_cpu ( hdesc -> desc [ n ] . wDescriptorLength ) ; 
}
if ( ! rsize || rsize > HID_MAX_DESCRIPTOR_SIZE ) { dbg_hid ( ""weird size of report descriptor (%u)\\n"" , rsize ) ; return - EINVAL ; } rdesc = kmalloc ( rsize , GFP_KERNEL ) ; if ( ! rdesc ) return - ENOMEM ; hid_set_idle ( dev , interface -> desc . bInterfaceNumber , 0 , 0 ) ; ret = hid_get_class_descriptor ( dev , interface -> desc . bInterfaceNumber , HID_DT_REPORT , rdesc , rsize ) ; if ( ret < 0 ) { dbg_hid ( ""reading report descriptor failed\\n"" ) ; kfree ( rdesc ) ; goto err ; } ret = hid_parse_report ( hid , rdesc , rsize ) ; kfree ( rdesc ) ; if ( ret ) { dbg_hid ( ""parsing report descriptor failed\\n"" ) ; goto err ; } hid -> quirks |= quirks ; return 0 ; err : return ret ; }",781,-37.91668839777842,-0.04854889679613114
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int usbhid_parse ( struct hid_device * hid ) { struct usb_interface * intf = to_usb_interface ( hid -> dev . parent ) ; struct usb_host_interface * interface = intf -> cur_altsetting ; struct usb_device * dev = interface_to_usbdev ( intf ) ; struct hid_descriptor * hdesc ; u32 quirks = 0 ; unsigned int rsize = 0 ; char * rdesc ; int ret , n ; quirks = usbhid_lookup_quirk ( le16_to_cpu ( dev -> descriptor . idVendor ) , le16_to_cpu ( dev -> descriptor . idProduct ) ) ; if ( quirks & HID_QUIRK_IGNORE ) return - ENODEV ; if ( interface -> desc . bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT ) { if ( interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_KEYBOARD || interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_MOUSE ) quirks |= HID_QUIRK_NOGET ; } if ( usb_get_extra_descriptor ( interface , HID_DT_HID , & hdesc ) && ( ! interface -> desc . bNumEndpoints || usb_get_extra_descriptor ( & interface -> endpoint [ 0 ] , HID_DT_HID , & hdesc ) ) ) { dbg_hid ( ""class descriptor not present\\n"" ) ; return - ENODEV ; } hid -> version = le16_to_cpu ( hdesc -> bcdHID ) ; hid -> country = hdesc -> bCountryCode ; for ( n = 0 ; n < hdesc -> bNumDescriptors ; n ++ ) if ( hdesc -> desc [ n ] . bDescriptorType == HID_DT_REPORT ) rsize = le16_to_cpu ( hdesc -> desc [ n ] . wDescriptorLength ) ; if ( ! rsize || rsize > HID_MAX_DESCRIPTOR_SIZE ) { dbg_hid ( ""weird size of report descriptor (%u)\\n"" , rsize ) ; return - EINVAL ; } rdesc = kmalloc ( rsize , GFP_KERNEL ) ; if ( ! rdesc ) return - ENOMEM ; hid_set_idle ( dev , interface -> desc . bInterfaceNumber , 0 , 0 ) ; ret = hid_get_class_descriptor ( dev , interface -> desc . bInterfaceNumber , HID_DT_REPORT , rdesc , rsize ) ; if ( ret < 0 ) { dbg_hid ( ""reading report descriptor failed\\n"" ) ; kfree ( rdesc ) ; goto err ; } ret = hid_parse_report ( hid , rdesc , rsize ) ; kfree ( rdesc ) ; if ( ret ) { dbg_hid ( ""parsing report descriptor failed\\n"" ) ; goto err ; } hid -> quirks |= quirks ; return 0 ; err : return ret ; }
Fixed code:","
static int usbhid_parse ( struct hid_device * hid ) { struct usb_interface * intf = to_usb_interface ( hid -> dev . parent ) ; struct usb_host_interface * interface = intf -> cur_altsetting ; struct usb_device * dev = interface_to_usbdev ( intf ) ; struct hid_descriptor * hdesc ; u32 quirks = 0 ; unsigned int rsize = 0 ; char * rdesc ; int ret , n ; quirks = usbhid_lookup_quirk ( le16_to_cpu ( dev -> descriptor . idVendor ) , le16_to_cpu ( dev -> descriptor . idProduct ) ) ; if ( quirks & HID_QUIRK_IGNORE ) return - ENODEV ; if ( interface -> desc . bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT ) { if ( interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_KEYBOARD || interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_MOUSE ) quirks |= HID_QUIRK_NOGET ; } if ( usb_get_extra_descriptor ( interface , HID_DT_HID , & hdesc ) && ( ! interface -> desc . bNumEndpoints || usb_get_extra_descriptor ( & interface -> endpoint [ 0 ] , HID_DT_HID , & hdesc ) ) ) { dbg_hid ( ""class descriptor not present\\n"" ) ; return - ENODEV ; } hid -> version = le16_to_cpu ( hdesc -> bcdHID ) ; hid -> country = hdesc -> bCountryCode ; for ( n = 0 ; n < hdesc -> bNumDescriptors ; n ++ ) { //Check if descriptor index is within valid range. if(n >= hdesc->bNumDescriptors) { dbg_hid(""Invalid descriptor index\\n"") ; return - EINVAL; } if ( hdesc -> desc [ n ] . bDescriptorType == HID_DT_REPORT ) rsize = le16_to_cpu ( hdesc -> desc [ n ] . wDescriptorLength ) ; } if ( ! rsize || rsize > HID_MAX_DESCRIPTOR_SIZE ) { dbg_hid ( ""weird size of report descriptor (%u)\\n"" , rsize ) ; return - EINVAL ; } rdesc = kmalloc ( rsize , GFP_KERNEL ) ; if ( ! rdesc ) return - ENOMEM ; hid_set_idle ( dev , interface -> desc . bInterfaceNumber , 0 , 0 ) ; ret = hid_get_class_descriptor ( dev , interface -> desc . bInterfaceNumber , HID_DT_REPORT , rdesc , rsize ) ; if ( ret < 0 ) { dbg_hid ( ""reading report descriptor failed\\n"" ) ; kfree ( rdesc ) ; goto err ; } ret = hid_parse_report ( hid , rdesc , rsize ) ; kfree ( rdesc ) ; if ( ret ) { dbg_hid ( ""parsing report descriptor failed\\n"" ) ; goto err ; } hid -> quirks |= quirks ; return 0 ; err : return ret ; }",735,-35.84912197699133,-0.04877431561495418
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int usbhid_parse ( struct hid_device * hid ) { struct usb_interface * intf = to_usb_interface ( hid -> dev . parent ) ; struct usb_host_interface * interface = intf -> cur_altsetting ; struct usb_device * dev = interface_to_usbdev ( intf ) ; struct hid_descriptor * hdesc ; u32 quirks = 0 ; unsigned int rsize = 0 ; char * rdesc ; int ret , n ; quirks = usbhid_lookup_quirk ( le16_to_cpu ( dev -> descriptor . idVendor ) , le16_to_cpu ( dev -> descriptor . idProduct ) ) ; if ( quirks & HID_QUIRK_IGNORE ) return - ENODEV ; if ( interface -> desc . bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT ) { if ( interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_KEYBOARD || interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_MOUSE ) quirks |= HID_QUIRK_NOGET ; } if ( usb_get_extra_descriptor ( interface , HID_DT_HID , & hdesc ) && ( ! interface -> desc . bNumEndpoints || usb_get_extra_descriptor ( & interface -> endpoint [ 0 ] , HID_DT_HID , & hdesc ) ) ) { dbg_hid ( ""class descriptor not present\\n"" ) ; return - ENODEV ; } hid -> version = le16_to_cpu ( hdesc -> bcdHID ) ; hid -> country = hdesc -> bCountryCode ; for ( n = 0 ; n < hdesc -> bNumDescriptors ; n ++ ) if ( hdesc -> desc [ n ] . bDescriptorType == HID_DT_REPORT ) rsize = le16_to_cpu ( hdesc -> desc [ n ] . wDescriptorLength ) ; if ( ! rsize || rsize > HID_MAX_DESCRIPTOR_SIZE ) { dbg_hid ( ""weird size of report descriptor (%u)\\n"" , rsize ) ; return - EINVAL ; } rdesc = kmalloc ( rsize , GFP_KERNEL ) ; if ( ! rdesc ) return - ENOMEM ; hid_set_idle ( dev , interface -> desc . bInterfaceNumber , 0 , 0 ) ; ret = hid_get_class_descriptor ( dev , interface -> desc . bInterfaceNumber , HID_DT_REPORT , rdesc , rsize ) ; if ( ret < 0 ) { dbg_hid ( ""reading report descriptor failed\\n"" ) ; kfree ( rdesc ) ; goto err ; } ret = hid_parse_report ( hid , rdesc , rsize ) ; kfree ( rdesc ) ; if ( ret ) { dbg_hid ( ""parsing report descriptor failed\\n"" ) ; goto err ; } hid -> quirks |= quirks ; return 0 ; err : return ret ; }
Fixed code:","
static int usbhid_parse ( struct hid_device * hid ) { struct usb_interface * intf = to_usb_interface ( hid -> dev . parent ) ; struct usb_host_interface * interface = intf -> cur_altsetting ; struct usb_device * dev = interface_to_usbdev ( intf ) ; struct hid_descriptor * hdesc ; u32 quirks = 0 ; unsigned int rsize = 0 ; char * rdesc ; int ret , n ; if (intf == NULL || interface == NULL || dev == NULL) return -ENODEV; quirks = usbhid_lookup_quirk ( le16_to_cpu ( dev -> descriptor . idVendor ) , le16_to_cpu ( dev -> descriptor . idProduct ) ) ; if ( quirks & HID_QUIRK_IGNORE ) return - ENODEV ; if ( interface -> desc . bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT ) { if ( interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_KEYBOARD || interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_MOUSE ) quirks |= HID_QUIRK_NOGET ; } if ( usb_get_extra_descriptor ( interface , HID_DT_HID , & hdesc ) && ( ! interface -> desc . bNumEndpoints || usb_get_extra_descriptor ( & interface -> endpoint [ 0 ] , HID_DT_HID , & hdesc ) ) ) { dbg_hid ( ""class descriptor not present\\n"" ) ; return - ENODEV ; } hid -> version = le16_to_cpu ( hdesc -> bcdHID ) ; hid -> country = hdesc -> bCountryCode ; for ( n = 0 ; n < hdesc -> bNumDescriptors ; n ++ ) { if (n >= HID_MAX_DESCRIPTOR_SIZE) break; if ( hdesc -> desc [ n ] . bDescriptorType == HID_DT_REPORT ) rsize = le16_to_cpu ( hdesc -> desc [ n ] . wDescriptorLength ) ; } if ( ! rsize || rsize > HID_MAX_DESCRIPTOR_SIZE ) { dbg_hid ( ""weird size of report descriptor (%u)\\n"" , rsize ) ; return - EINVAL ; } rdesc = kmalloc ( rsize , GFP_KERNEL ) ; if ( ! rdesc ) return - ENOMEM ; hid_set_idle ( dev , interface -> desc . bInterfaceNumber , 0 , 0 ) ; ret = hid_get_class_descriptor ( dev , interface -> desc . bInterfaceNumber , HID_DT_REPORT , rdesc , rsize ) ; if ( ret < 0 ) { dbg_hid ( ""reading report descriptor failed\\n"" ) ; kfree ( rdesc ) ; goto err ; } ret = hid_parse_report ( hid , rdesc , rsize ) ; kfree ( rdesc ) ; if ( ret ) { dbg_hid ( ""parsing report descriptor failed\\n"" ) ; goto err ; } hid -> quirks |= quirks ; return 0 ; err : return ret ; }",730,-15.040621039146957,-0.020603590464584872
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int usbhid_parse ( struct hid_device * hid ) { struct usb_interface * intf = to_usb_interface ( hid -> dev . parent ) ; struct usb_host_interface * interface = intf -> cur_altsetting ; struct usb_device * dev = interface_to_usbdev ( intf ) ; struct hid_descriptor * hdesc ; u32 quirks = 0 ; unsigned int rsize = 0 ; char * rdesc ; int ret , n ; quirks = usbhid_lookup_quirk ( le16_to_cpu ( dev -> descriptor . idVendor ) , le16_to_cpu ( dev -> descriptor . idProduct ) ) ; if ( quirks & HID_QUIRK_IGNORE ) return - ENODEV ; if ( interface -> desc . bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT ) { if ( interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_KEYBOARD || interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_MOUSE ) quirks |= HID_QUIRK_NOGET ; } if ( usb_get_extra_descriptor ( interface , HID_DT_HID , & hdesc ) && ( ! interface -> desc . bNumEndpoints || usb_get_extra_descriptor ( & interface -> endpoint [ 0 ] , HID_DT_HID , & hdesc ) ) ) { dbg_hid ( ""class descriptor not present\\n"" ) ; return - ENODEV ; } hid -> version = le16_to_cpu ( hdesc -> bcdHID ) ; hid -> country = hdesc -> bCountryCode ; for ( n = 0 ; n < hdesc -> bNumDescriptors ; n ++ ) if ( hdesc -> desc [ n ] . bDescriptorType == HID_DT_REPORT ) rsize = le16_to_cpu ( hdesc -> desc [ n ] . wDescriptorLength ) ; if ( ! rsize || rsize > HID_MAX_DESCRIPTOR_SIZE ) { dbg_hid ( ""weird size of report descriptor (%u)\\n"" , rsize ) ; return - EINVAL ; } rdesc = kmalloc ( rsize , GFP_KERNEL ) ; if ( ! rdesc ) return - ENOMEM ; hid_set_idle ( dev , interface -> desc . bInterfaceNumber , 0 , 0 ) ; ret = hid_get_class_descriptor ( dev , interface -> desc . bInterfaceNumber , HID_DT_REPORT , rdesc , rsize ) ; if ( ret < 0 ) { dbg_hid ( ""reading report descriptor failed\\n"" ) ; kfree ( rdesc ) ; goto err ; } ret = hid_parse_report ( hid , rdesc , rsize ) ; kfree ( rdesc ) ; if ( ret ) { dbg_hid ( ""parsing report descriptor failed\\n"" ) ; goto err ; } hid -> quirks |= quirks ; return 0 ; err : return ret ; }
Fixed code:","
static int usbhid_parse ( struct hid_device * hid ) { struct usb_interface * intf = to_usb_interface ( hid -> dev . parent ) ; struct usb_host_interface * interface = intf -> cur_altsetting ; struct usb_device * dev = interface_to_usbdev ( intf ) ; struct hid_descriptor * hdesc ; u32 quirks = 0 ; unsigned int rsize = 0 ; char * rdesc ; int ret , n ; quirks = usbhid_lookup_quirk ( le16_to_cpu ( dev -> descriptor . idVendor ) , le16_to_cpu ( dev -> descriptor . idProduct ) ) ; if ( quirks & HID_QUIRK_IGNORE ) return - ENODEV ; if ( interface -> desc . bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT ) { if ( interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_KEYBOARD || interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_MOUSE ) quirks |= HID_QUIRK_NOGET ; } if ( usb_get_extra_descriptor ( interface , HID_DT_HID , & hdesc ) && ( ! interface -> desc . bNumEndpoints || usb_get_extra_descriptor ( & interface -> endpoint [ 0 ] , HID_DT_HID , & hdesc ) ) ) { dbg_hid ( ""class descriptor not present\\n"" ) ; return - ENODEV ; } hid -> version = le16_to_cpu ( hdesc -> bcdHID ) ; hid -> country = hdesc -> bCountryCode ; for ( n = 0 ; n < hdesc -> bNumDescriptors ; n ++ ) if ( hdesc -> desc [ n ] . bDescriptorType == HID_DT_REPORT ) rsize = le16_to_cpu ( hdesc -> desc [ n ] . wDescriptorLength ) ; if ( ! rsize || rsize > HID_MAX_DESCRIPTOR_SIZE || n >= hdesc->bNumDescriptors ) { dbg_hid ( ""weird size of report descriptor (%u)\\n"" , rsize ) ; return - EINVAL ; } rdesc = kmalloc ( rsize , GFP_KERNEL ) ; if ( ! rdesc ) return - ENOMEM ; hid_set_idle ( dev , interface -> desc . bInterfaceNumber , 0 , 0 ) ; ret = hid_get_class_descriptor ( dev , interface -> desc . bInterfaceNumber , HID_DT_REPORT , rdesc , rsize ) ; if ( ret < 0 ) { dbg_hid ( ""reading report descriptor failed\\n"" ) ; kfree ( rdesc ) ; goto err ; } ret = hid_parse_report ( hid , rdesc , rsize ) ; kfree ( rdesc ) ; if ( ret ) { dbg_hid ( ""parsing report descriptor failed\\n"" ) ; goto err ; } hid -> quirks |= quirks ; return 0 ; err : return ret ; }",701,-11.85637489860076,-0.016913516260486105
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int usbhid_parse ( struct hid_device * hid ) { struct usb_interface * intf = to_usb_interface ( hid -> dev . parent ) ; struct usb_host_interface * interface = intf -> cur_altsetting ; struct usb_device * dev = interface_to_usbdev ( intf ) ; struct hid_descriptor * hdesc ; u32 quirks = 0 ; unsigned int rsize = 0 ; char * rdesc ; int ret , n ; quirks = usbhid_lookup_quirk ( le16_to_cpu ( dev -> descriptor . idVendor ) , le16_to_cpu ( dev -> descriptor . idProduct ) ) ; if ( quirks & HID_QUIRK_IGNORE ) return - ENODEV ; if ( interface -> desc . bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT ) { if ( interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_KEYBOARD || interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_MOUSE ) quirks |= HID_QUIRK_NOGET ; } if ( usb_get_extra_descriptor ( interface , HID_DT_HID , & hdesc ) && ( ! interface -> desc . bNumEndpoints || usb_get_extra_descriptor ( & interface -> endpoint [ 0 ] , HID_DT_HID , & hdesc ) ) ) { dbg_hid ( ""class descriptor not present\\n"" ) ; return - ENODEV ; } hid -> version = le16_to_cpu ( hdesc -> bcdHID ) ; hid -> country = hdesc -> bCountryCode ; for ( n = 0 ; n < hdesc -> bNumDescriptors ; n ++ ) if ( hdesc -> desc [ n ] . bDescriptorType == HID_DT_REPORT ) rsize = le16_to_cpu ( hdesc -> desc [ n ] . wDescriptorLength ) ; if ( ! rsize || rsize > HID_MAX_DESCRIPTOR_SIZE ) { dbg_hid ( ""weird size of report descriptor (%u)\\n"" , rsize ) ; return - EINVAL ; } rdesc = kmalloc ( rsize , GFP_KERNEL ) ; if ( ! rdesc ) return - ENOMEM ; hid_set_idle ( dev , interface -> desc . bInterfaceNumber , 0 , 0 ) ; ret = hid_get_class_descriptor ( dev , interface -> desc . bInterfaceNumber , HID_DT_REPORT , rdesc , rsize ) ; if ( ret < 0 ) { dbg_hid ( ""reading report descriptor failed\\n"" ) ; kfree ( rdesc ) ; goto err ; } ret = hid_parse_report ( hid , rdesc , rsize ) ; kfree ( rdesc ) ; if ( ret ) { dbg_hid ( ""parsing report descriptor failed\\n"" ) ; goto err ; } hid -> quirks |= quirks ; return 0 ; err : return ret ; }
Fixed code:"," 

static int usbhid_parse ( struct hid_device * hid ) { struct usb_interface * intf = to_usb_interface ( hid -> dev . parent ) ; struct usb_host_interface * interface = intf -> cur_altsetting ; struct usb_device * dev = interface_to_usbdev ( intf ) ; struct hid_descriptor * hdesc ; u32 quirks = 0 ; unsigned int rsize = 0 ; char * rdesc ; int ret , n ; quirks = usbhid_lookup_quirk ( le16_to_cpu ( dev -> descriptor . idVendor ) , le16_to_cpu ( dev -> descriptor . idProduct ) ) ; if ( quirks & HID_QUIRK_IGNORE ) return - ENODEV ; if ( interface -> desc . bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT ) { if ( interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_KEYBOARD || interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_MOUSE ) quirks |= HID_QUIRK_NOGET ; } if ( usb_get_extra_descriptor ( interface , HID_DT_HID , & hdesc ) && ( ! interface -> desc . bNumEndpoints || usb_get_extra_descriptor ( & interface -> endpoint [ 0 ] , HID_DT_HID , & hdesc ) ) ) { dbg_hid ( ""class descriptor not present\\n"" ) ; return - ENODEV ; } hid -> version = le16_to_cpu ( hdesc -> bcdHID ) ; hid -> country = hdesc -> bCountryCode ; for ( n = 0 ; n < hdesc -> bNumDescriptors ; n ++ ) {
    if ( n > HID_MAX_DESCRIPTOR_SIZE ) {
      dbg_hid(""Out-of-bounds read detected\n"");
      return -1;
    }
    if ( hdesc -> desc [ n ] . bDescriptorType == HID_DT_REPORT ) rsize = le16_to_cpu ( hdesc -> desc [ n ] . wDescriptorLength ) ; 
  }
  if ( ! rsize || rsize > HID_MAX_DESCRIPTOR_SIZE ) { dbg_hid ( ""weird size of report descriptor (%u)\\n"" , rsize ) ; return - EINVAL ; } rdesc = kmalloc ( rsize , GFP_KERNEL ) ; if ( ! rdesc ) return - ENOMEM ; hid_set_idle ( dev , interface -> desc . bInterfaceNumber , 0 , 0 ) ; ret = hid_get_class_descriptor ( dev , interface -> desc . bInterfaceNumber , HID_DT_REPORT , rdesc , rsize ) ; if ( ret < 0 ) { dbg_hid ( ""reading report descriptor failed\\n"" ) ; kfree ( rdesc ) ; goto err ; } ret = hid_parse_report ( hid , rdesc , rsize ) ; kfree ( rdesc ) ; if ( ret ) { dbg_hid ( ""parsing report descriptor failed\\n"" ) ; goto err ; } hid -> quirks |= quirks ; return 0 ; err : return ret ; }",746,-27.360967942663706,-0.03667690072743124
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int usbhid_parse ( struct hid_device * hid ) { struct usb_interface * intf = to_usb_interface ( hid -> dev . parent ) ; struct usb_host_interface * interface = intf -> cur_altsetting ; struct usb_device * dev = interface_to_usbdev ( intf ) ; struct hid_descriptor * hdesc ; u32 quirks = 0 ; unsigned int rsize = 0 ; char * rdesc ; int ret , n ; quirks = usbhid_lookup_quirk ( le16_to_cpu ( dev -> descriptor . idVendor ) , le16_to_cpu ( dev -> descriptor . idProduct ) ) ; if ( quirks & HID_QUIRK_IGNORE ) return - ENODEV ; if ( interface -> desc . bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT ) { if ( interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_KEYBOARD || interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_MOUSE ) quirks |= HID_QUIRK_NOGET ; } if ( usb_get_extra_descriptor ( interface , HID_DT_HID , & hdesc ) && ( ! interface -> desc . bNumEndpoints || usb_get_extra_descriptor ( & interface -> endpoint [ 0 ] , HID_DT_HID , & hdesc ) ) ) { dbg_hid ( ""class descriptor not present\\n"" ) ; return - ENODEV ; } hid -> version = le16_to_cpu ( hdesc -> bcdHID ) ; hid -> country = hdesc -> bCountryCode ; for ( n = 0 ; n < hdesc -> bNumDescriptors ; n ++ ) if ( hdesc -> desc [ n ] . bDescriptorType == HID_DT_REPORT ) rsize = le16_to_cpu ( hdesc -> desc [ n ] . wDescriptorLength ) ; if ( ! rsize || rsize > HID_MAX_DESCRIPTOR_SIZE ) { dbg_hid ( ""weird size of report descriptor (%u)\\n"" , rsize ) ; return - EINVAL ; } rdesc = kmalloc ( rsize , GFP_KERNEL ) ; if ( ! rdesc ) return - ENOMEM ; hid_set_idle ( dev , interface -> desc . bInterfaceNumber , 0 , 0 ) ; ret = hid_get_class_descriptor ( dev , interface -> desc . bInterfaceNumber , HID_DT_REPORT , rdesc , rsize ) ; if ( ret < 0 ) { dbg_hid ( ""reading report descriptor failed\\n"" ) ; kfree ( rdesc ) ; goto err ; } ret = hid_parse_report ( hid , rdesc , rsize ) ; kfree ( rdesc ) ; if ( ret ) { dbg_hid ( ""parsing report descriptor failed\\n"" ) ; goto err ; } hid -> quirks |= quirks ; return 0 ; err : return ret ; }
Fixed code:","
static int usbhid_parse ( struct hid_device * hid ) { struct usb_interface * intf = to_usb_interface ( hid -> dev . parent ) ; struct usb_host_interface * interface = intf -> cur_altsetting ; struct usb_device * dev = interface_to_usbdev ( intf ) ; struct hid_descriptor * hdesc ; u32 quirks = 0 ; unsigned int rsize = 0 ; char * rdesc ; int ret , n ; quirks = usbhid_lookup_quirk ( le16_to_cpu ( dev -> descriptor . idVendor ) , le16_to_cpu ( dev -> descriptor . idProduct ) ) ; if ( quirks & HID_QUIRK_IGNORE ) return - ENODEV ; if ( interface -> desc . bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT ) { if ( interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_KEYBOARD || interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_MOUSE ) quirks |= HID_QUIRK_NOGET ; } if ( usb_get_extra_descriptor ( interface , HID_DT_HID , & hdesc ) && ( ! interface -> desc . bNumEndpoints || usb_get_extra_descriptor ( & interface -> endpoint [ 0 ] , HID_DT_HID , & hdesc ) ) ) { dbg_hid ( ""class descriptor not present\\n"" ) ; return - ENODEV ; } else { if ( hdesc == NULL ) { dbg_hid ( ""error: hdesc is NULL\\n"" ) ; return - ENODEV ; } } hid -> version = le16_to_cpu ( hdesc -> bcdHID ) ; hid -> country = hdesc -> bCountryCode ; for ( n = 0 ; n < hdesc -> bNumDescriptors ; n ++ ) if ( hdesc -> desc [ n ] . bDescriptorType == HID_DT_REPORT ) rsize = le16_to_cpu ( hdesc -> desc [ n ] . wDescriptorLength ) ; if ( ! rsize || rsize > HID_MAX_DESCRIPTOR_SIZE ) { dbg_hid ( ""weird size of report descriptor (%u)\\n"" , rsize ) ; return - EINVAL ; } rdesc = kmalloc ( rsize , GFP_KERNEL ) ; if ( ! rdesc ) return - ENOMEM ; hid_set_idle ( dev , interface -> desc . bInterfaceNumber , 0 , 0 ) ; ret = hid_get_class_descriptor ( dev , interface -> desc . bInterfaceNumber , HID_DT_REPORT , rdesc , rsize ) ; if ( ret < 0 ) { dbg_hid ( ""reading report descriptor failed\\n"" ) ; kfree ( rdesc ) ; goto err ; } ret = hid_parse_report ( hid , rdesc , rsize ) ; kfree ( rdesc ) ; if ( ret ) { dbg_hid ( ""parsing report descriptor failed\\n"" ) ; goto err ; } hid -> quirks |= quirks ; return 0 ; err : return ret ; }",725,-19.369268940799948,-0.02671623302179303
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int usbhid_parse ( struct hid_device * hid ) { struct usb_interface * intf = to_usb_interface ( hid -> dev . parent ) ; struct usb_host_interface * interface = intf -> cur_altsetting ; struct usb_device * dev = interface_to_usbdev ( intf ) ; struct hid_descriptor * hdesc ; u32 quirks = 0 ; unsigned int rsize = 0 ; char * rdesc ; int ret , n ; quirks = usbhid_lookup_quirk ( le16_to_cpu ( dev -> descriptor . idVendor ) , le16_to_cpu ( dev -> descriptor . idProduct ) ) ; if ( quirks & HID_QUIRK_IGNORE ) return - ENODEV ; if ( interface -> desc . bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT ) { if ( interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_KEYBOARD || interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_MOUSE ) quirks |= HID_QUIRK_NOGET ; } if ( usb_get_extra_descriptor ( interface , HID_DT_HID , & hdesc ) && ( ! interface -> desc . bNumEndpoints || usb_get_extra_descriptor ( & interface -> endpoint [ 0 ] , HID_DT_HID , & hdesc ) ) ) { dbg_hid ( ""class descriptor not present\\n"" ) ; return - ENODEV ; } hid -> version = le16_to_cpu ( hdesc -> bcdHID ) ; hid -> country = hdesc -> bCountryCode ; for ( n = 0 ; n < hdesc -> bNumDescriptors ; n ++ ) if ( hdesc -> desc [ n ] . bDescriptorType == HID_DT_REPORT ) rsize = le16_to_cpu ( hdesc -> desc [ n ] . wDescriptorLength ) ; if ( ! rsize || rsize > HID_MAX_DESCRIPTOR_SIZE ) { dbg_hid ( ""weird size of report descriptor (%u)\\n"" , rsize ) ; return - EINVAL ; } rdesc = kmalloc ( rsize , GFP_KERNEL ) ; if ( ! rdesc ) return - ENOMEM ; hid_set_idle ( dev , interface -> desc . bInterfaceNumber , 0 , 0 ) ; ret = hid_get_class_descriptor ( dev , interface -> desc . bInterfaceNumber , HID_DT_REPORT , rdesc , rsize ) ; if ( ret < 0 ) { dbg_hid ( ""reading report descriptor failed\\n"" ) ; kfree ( rdesc ) ; goto err ; } ret = hid_parse_report ( hid , rdesc , rsize ) ; kfree ( rdesc ) ; if ( ret ) { dbg_hid ( ""parsing report descriptor failed\\n"" ) ; goto err ; } hid -> quirks |= quirks ; return 0 ; err : return ret ; }
Fixed code:","
static int usbhid_parse ( struct hid_device * hid ) { struct usb_interface * intf = to_usb_interface ( hid -> dev . parent ) ; struct usb_host_interface * interface = intf -> cur_altsetting ; struct usb_device * dev = interface_to_usbdev ( intf ) ; struct hid_descriptor * hdesc ; u32 quirks = 0 ; unsigned int rsize = 0 ; char * rdesc ; int ret , n ; quirks = usbhid_lookup_quirk ( le16_to_cpu ( dev -> descriptor . idVendor ) , le16_to_cpu ( dev -> descriptor . idProduct ) ) ; if ( quirks & HID_QUIRK_IGNORE ) return - ENODEV ; if ( interface -> desc . bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT ) { if ( interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_KEYBOARD || interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_MOUSE ) quirks |= HID_QUIRK_NOGET ; } if ( usb_get_extra_descriptor ( interface , HID_DT_HID , & hdesc ) && ( ! interface -> desc . bNumEndpoints || usb_get_extra_descriptor ( & interface -> endpoint [ 0 ] , HID_DT_HID , & hdesc ) ) ) { dbg_hid ( ""class descriptor not present\\n"" ) ; return - ENODEV ; } 

// Prevent Out-of-bounds Read
if(interface->desc.bNumEndpoints >= 0 && interface->desc.bNumEndpoints <= MAX_ENDPOINTS){
  hid -> version = le16_to_cpu ( hdesc -> bcdHID ) ; 
  hid -> country = hdesc -> bCountryCode ; 
  for ( n = 0 ; n < hdesc -> bNumDescriptors ; n ++ ) 
    if ( hdesc -> desc [ n ] . bDescriptorType == HID_DT_REPORT ) 
      rsize = le16_to_cpu ( hdesc -> desc [ n ] . wDescriptorLength ) ; 
    
  if ( ! rsize || rsize > HID_MAX_DESCRIPTOR_SIZE ) { 
    dbg_hid ( ""weird size of report descriptor (%u)\\n"" , rsize ) ; 
    return - EINVAL ; 
  } 
  rdesc = kmalloc ( rsize , GFP_KERNEL ) ; 
  if ( ! rdesc ) return - ENOMEM ; 
  hid_set_idle ( dev , interface -> desc . bInterfaceNumber , 0 , 0 ) ; 
  ret = hid_get_class_descriptor ( dev , interface -> desc . bInterfaceNumber , HID_DT_REPORT , rdesc , rsize ) ; 
  if ( ret < 0 ) { 
    dbg_hid ( ""reading report descriptor failed\\n"" ) ; 
    kfree ( rdesc ) ; 
    goto err ; 
  } 
  ret = hid_parse_report ( hid , rdesc , rsize ) ; 
  kfree ( rdesc ) ; 
  if ( ret ) { 
    dbg_hid ( ""parsing report descriptor failed\\n"" ) ; 
    goto err ; 
  } 
  hid -> quirks |= quirks ; 
  return 0 ; 
  err : 
  return ret ; 
}
else{
  return - EINVAL;
}
}",835,-44.82769566228802,-0.05368586306860841
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int usbhid_parse ( struct hid_device * hid ) { struct usb_interface * intf = to_usb_interface ( hid -> dev . parent ) ; struct usb_host_interface * interface = intf -> cur_altsetting ; struct usb_device * dev = interface_to_usbdev ( intf ) ; struct hid_descriptor * hdesc ; u32 quirks = 0 ; unsigned int rsize = 0 ; char * rdesc ; int ret , n ; quirks = usbhid_lookup_quirk ( le16_to_cpu ( dev -> descriptor . idVendor ) , le16_to_cpu ( dev -> descriptor . idProduct ) ) ; if ( quirks & HID_QUIRK_IGNORE ) return - ENODEV ; if ( interface -> desc . bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT ) { if ( interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_KEYBOARD || interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_MOUSE ) quirks |= HID_QUIRK_NOGET ; } if ( usb_get_extra_descriptor ( interface , HID_DT_HID , & hdesc ) && ( ! interface -> desc . bNumEndpoints || usb_get_extra_descriptor ( & interface -> endpoint [ 0 ] , HID_DT_HID , & hdesc ) ) ) { dbg_hid ( ""class descriptor not present\\n"" ) ; return - ENODEV ; } hid -> version = le16_to_cpu ( hdesc -> bcdHID ) ; hid -> country = hdesc -> bCountryCode ; for ( n = 0 ; n < hdesc -> bNumDescriptors ; n ++ ) if ( hdesc -> desc [ n ] . bDescriptorType == HID_DT_REPORT ) rsize = le16_to_cpu ( hdesc -> desc [ n ] . wDescriptorLength ) ; if ( ! rsize || rsize > HID_MAX_DESCRIPTOR_SIZE ) { dbg_hid ( ""weird size of report descriptor (%u)\\n"" , rsize ) ; return - EINVAL ; } rdesc = kmalloc ( rsize , GFP_KERNEL ) ; if ( ! rdesc ) return - ENOMEM ; hid_set_idle ( dev , interface -> desc . bInterfaceNumber , 0 , 0 ) ; ret = hid_get_class_descriptor ( dev , interface -> desc . bInterfaceNumber , HID_DT_REPORT , rdesc , rsize ) ; if ( ret < 0 ) { dbg_hid ( ""reading report descriptor failed\\n"" ) ; kfree ( rdesc ) ; goto err ; } ret = hid_parse_report ( hid , rdesc , rsize ) ; kfree ( rdesc ) ; if ( ret ) { dbg_hid ( ""parsing report descriptor failed\\n"" ) ; goto err ; } hid -> quirks |= quirks ; return 0 ; err : return ret ; }
Fixed code:","
static int usbhid_parse ( struct hid_device * hid ) { struct usb_interface * intf = to_usb_interface ( hid -> dev . parent ) ; struct usb_host_interface * interface = intf -> cur_altsetting ; struct usb_device * dev = interface_to_usbdev ( intf ) ; struct hid_descriptor * hdesc ; u32 quirks = 0 ; unsigned int rsize = 0 ; char * rdesc ; int ret , n ; quirks = usbhid_lookup_quirk ( le16_to_cpu ( dev -> descriptor . idVendor ) , le16_to_cpu ( dev -> descriptor . idProduct ) ) ; if ( quirks & HID_QUIRK_IGNORE ) return - ENODEV ; if ( interface -> desc . bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT ) { if ( interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_KEYBOARD || interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_MOUSE ) quirks |= HID_QUIRK_NOGET ; } if ( usb_get_extra_descriptor ( interface , HID_DT_HID , & hdesc ) && ( ! interface -> desc . bNumEndpoints || usb_get_extra_descriptor ( & interface -> endpoint [ 0 ] , HID_DT_HID , & hdesc ) ) ) { dbg_hid ( ""class descriptor not present\\n"" ) ; return - ENODEV ; } hid -> version = le16_to_cpu ( hdesc -> bcdHID ) ; hid -> country = hdesc -> bCountryCode ; for ( n = 0 ; n < hdesc -> bNumDescriptors ; n ++ ) { if ( n >= HID_MAX_DESCRIPTOR_SIZE ) break; //Added if statement to prevent out-of-bounds read if ( hdesc -> desc [ n ] . bDescriptorType == HID_DT_REPORT ) rsize = le16_to_cpu ( hdesc -> desc [ n ] . wDescriptorLength ) ; } if ( ! rsize || rsize > HID_MAX_DESCRIPTOR_SIZE ) { dbg_hid ( ""weird size of report descriptor (%u)\\n"" , rsize ) ; return - EINVAL ; } rdesc = kmalloc ( rsize , GFP_KERNEL ) ; if ( ! rdesc ) return - ENOMEM ; hid_set_idle ( dev , interface -> desc . bInterfaceNumber , 0 , 0 ) ; ret = hid_get_class_descriptor ( dev , interface -> desc . bInterfaceNumber , HID_DT_REPORT , rdesc , rsize ) ; if ( ret < 0 ) { dbg_hid ( ""reading report descriptor failed\\n"" ) ; kfree ( rdesc ) ; goto err ; } ret = hid_parse_report ( hid , rdesc , rsize ) ; kfree ( rdesc ) ; if ( ret ) { dbg_hid ( ""parsing report descriptor failed\\n"" ) ; goto err ; } hid -> quirks |= quirks ; return 0 ; err : return ret ; }",722,-14.715407734702959,-0.020381451156098282
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int usbhid_parse ( struct hid_device * hid ) { struct usb_interface * intf = to_usb_interface ( hid -> dev . parent ) ; struct usb_host_interface * interface = intf -> cur_altsetting ; struct usb_device * dev = interface_to_usbdev ( intf ) ; struct hid_descriptor * hdesc ; u32 quirks = 0 ; unsigned int rsize = 0 ; char * rdesc ; int ret , n ; quirks = usbhid_lookup_quirk ( le16_to_cpu ( dev -> descriptor . idVendor ) , le16_to_cpu ( dev -> descriptor . idProduct ) ) ; if ( quirks & HID_QUIRK_IGNORE ) return - ENODEV ; if ( interface -> desc . bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT ) { if ( interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_KEYBOARD || interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_MOUSE ) quirks |= HID_QUIRK_NOGET ; } if ( usb_get_extra_descriptor ( interface , HID_DT_HID , & hdesc ) && ( ! interface -> desc . bNumEndpoints || usb_get_extra_descriptor ( & interface -> endpoint [ 0 ] , HID_DT_HID , & hdesc ) ) ) { dbg_hid ( ""class descriptor not present\\n"" ) ; return - ENODEV ; } hid -> version = le16_to_cpu ( hdesc -> bcdHID ) ; hid -> country = hdesc -> bCountryCode ; for ( n = 0 ; n < hdesc -> bNumDescriptors ; n ++ ) if ( hdesc -> desc [ n ] . bDescriptorType == HID_DT_REPORT ) rsize = le16_to_cpu ( hdesc -> desc [ n ] . wDescriptorLength ) ; if ( ! rsize || rsize > HID_MAX_DESCRIPTOR_SIZE ) { dbg_hid ( ""weird size of report descriptor (%u)\\n"" , rsize ) ; return - EINVAL ; } rdesc = kmalloc ( rsize , GFP_KERNEL ) ; if ( ! rdesc ) return - ENOMEM ; hid_set_idle ( dev , interface -> desc . bInterfaceNumber , 0 , 0 ) ; ret = hid_get_class_descriptor ( dev , interface -> desc . bInterfaceNumber , HID_DT_REPORT , rdesc , rsize ) ; if ( ret < 0 ) { dbg_hid ( ""reading report descriptor failed\\n"" ) ; kfree ( rdesc ) ; goto err ; } ret = hid_parse_report ( hid , rdesc , rsize ) ; kfree ( rdesc ) ; if ( ret ) { dbg_hid ( ""parsing report descriptor failed\\n"" ) ; goto err ; } hid -> quirks |= quirks ; return 0 ; err : return ret ; }
Fixed code:"," 

static int usbhid_parse ( struct hid_device * hid ) { struct usb_interface * intf = to_usb_interface ( hid -> dev . parent ) ; struct usb_host_interface * interface = intf -> cur_altsetting ; struct usb_device * dev = interface_to_usbdev ( intf ) ; struct hid_descriptor * hdesc ; u32 quirks = 0 ; unsigned int rsize = 0 ; char * rdesc ; int ret , n ; quirks = usbhid_lookup_quirk ( le16_to_cpu ( dev -> descriptor . idVendor ) , le16_to_cpu ( dev -> descriptor . idProduct ) ) ; if ( quirks & HID_QUIRK_IGNORE ) return - ENODEV ; if ( interface -> desc . bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT ) { if ( interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_KEYBOARD || interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_MOUSE ) quirks |= HID_QUIRK_NOGET ; } if ( usb_get_extra_descriptor ( interface , HID_DT_HID , & hdesc ) && ( ! interface -> desc . bNumEndpoints || usb_get_extra_descriptor ( & interface -> endpoint [ 0 ] , HID_DT_HID , & hdesc ) ) ) { dbg_hid ( ""class descriptor not present\\n"" ) ; return - ENODEV ; } hid -> version = le16_to_cpu ( hdesc -> bcdHID ) ; hid -> country = hdesc -> bCountryCode ; for ( n = 0 ; n < hdesc -> bNumDescriptors ; n ++ ) {
  if ( n < HID_MAX_DESCRIPTOR_SIZE && hdesc -> desc [ n ] . bDescriptorType == HID_DT_REPORT ) {
    rsize = le16_to_cpu ( hdesc -> desc [ n ] . wDescriptorLength ) ;
  }
}
if ( ! rsize || rsize > HID_MAX_DESCRIPTOR_SIZE ) { dbg_hid ( ""weird size of report descriptor (%u)\\n"" , rsize ) ; return - EINVAL ; } rdesc = kmalloc ( rsize , GFP_KERNEL ) ; if ( ! rdesc ) return - ENOMEM ; hid_set_idle ( dev , interface -> desc . bInterfaceNumber , 0 , 0 ) ; ret = hid_get_class_descriptor ( dev , interface -> desc . bInterfaceNumber , HID_DT_REPORT , rdesc , rsize ) ; if ( ret < 0 ) { dbg_hid ( ""reading report descriptor failed\\n"" ) ; kfree ( rdesc ) ; goto err ; } ret = hid_parse_report ( hid , rdesc , rsize ) ; kfree ( rdesc ) ; if ( ret ) { dbg_hid ( ""parsing report descriptor failed\\n"" ) ; goto err ; } hid -> quirks |= quirks ; return 0 ; err : return ret ; }",717,-15.327025163121547,-0.021376604132666035
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int usbhid_parse ( struct hid_device * hid ) { struct usb_interface * intf = to_usb_interface ( hid -> dev . parent ) ; struct usb_host_interface * interface = intf -> cur_altsetting ; struct usb_device * dev = interface_to_usbdev ( intf ) ; struct hid_descriptor * hdesc ; u32 quirks = 0 ; unsigned int rsize = 0 ; char * rdesc ; int ret , n ; quirks = usbhid_lookup_quirk ( le16_to_cpu ( dev -> descriptor . idVendor ) , le16_to_cpu ( dev -> descriptor . idProduct ) ) ; if ( quirks & HID_QUIRK_IGNORE ) return - ENODEV ; if ( interface -> desc . bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT ) { if ( interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_KEYBOARD || interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_MOUSE ) quirks |= HID_QUIRK_NOGET ; } if ( usb_get_extra_descriptor ( interface , HID_DT_HID , & hdesc ) && ( ! interface -> desc . bNumEndpoints || usb_get_extra_descriptor ( & interface -> endpoint [ 0 ] , HID_DT_HID , & hdesc ) ) ) { dbg_hid ( ""class descriptor not present\\n"" ) ; return - ENODEV ; } hid -> version = le16_to_cpu ( hdesc -> bcdHID ) ; hid -> country = hdesc -> bCountryCode ; for ( n = 0 ; n < hdesc -> bNumDescriptors ; n ++ ) if ( hdesc -> desc [ n ] . bDescriptorType == HID_DT_REPORT ) rsize = le16_to_cpu ( hdesc -> desc [ n ] . wDescriptorLength ) ; if ( ! rsize || rsize > HID_MAX_DESCRIPTOR_SIZE ) { dbg_hid ( ""weird size of report descriptor (%u)\\n"" , rsize ) ; return - EINVAL ; } rdesc = kmalloc ( rsize , GFP_KERNEL ) ; if ( ! rdesc ) return - ENOMEM ; hid_set_idle ( dev , interface -> desc . bInterfaceNumber , 0 , 0 ) ; ret = hid_get_class_descriptor ( dev , interface -> desc . bInterfaceNumber , HID_DT_REPORT , rdesc , rsize ) ; if ( ret < 0 ) { dbg_hid ( ""reading report descriptor failed\\n"" ) ; kfree ( rdesc ) ; goto err ; } ret = hid_parse_report ( hid , rdesc , rsize ) ; kfree ( rdesc ) ; if ( ret ) { dbg_hid ( ""parsing report descriptor failed\\n"" ) ; goto err ; } hid -> quirks |= quirks ; return 0 ; err : return ret ; }
Fixed code:","
static int usbhid_parse ( struct hid_device * hid ) { struct usb_interface * intf = to_usb_interface ( hid -> dev . parent ) ; struct usb_host_interface * interface = intf -> cur_altsetting ; struct usb_device * dev = interface_to_usbdev ( intf ) ; struct hid_descriptor * hdesc ; u32 quirks = 0 ; unsigned int rsize = 0 ; char * rdesc ; int ret , n ; quirks = usbhid_lookup_quirk ( le16_to_cpu ( dev -> descriptor . idVendor ) , le16_to_cpu ( dev -> descriptor . idProduct ) ) ; if ( quirks & HID_QUIRK_IGNORE ) return - ENODEV ; if ( interface -> desc . bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT ) { if ( interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_KEYBOARD || interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_MOUSE ) quirks |= HID_QUIRK_NOGET ; } if ( usb_get_extra_descriptor ( interface , HID_DT_HID , & hdesc ) && ( ! interface -> desc . bNumEndpoints || usb_get_extra_descriptor ( & interface -> endpoint [ 0 ] , HID_DT_HID , & hdesc ) ) ) { dbg_hid ( ""class descriptor not present\\n"" ) ; return - ENODEV ; } hid -> version = le16_to_cpu ( hdesc -> bcdHID ) ; hid -> country = hdesc -> bCountryCode ; for ( n = 0 ; n < hdesc -> bNumDescriptors ; n ++ ){ if ( n >= HID_MAX_DESCRIPTOR_SIZE) break; // Added check to prevent out-of-bounds access if ( hdesc -> desc [ n ] . bDescriptorType == HID_DT_REPORT ) rsize = le16_to_cpu ( hdesc -> desc [ n ] . wDescriptorLength ) ; } if ( ! rsize || rsize > HID_MAX_DESCRIPTOR_SIZE ) { dbg_hid ( ""weird size of report descriptor (%u)\\n"" , rsize ) ; return - EINVAL ; } rdesc = kmalloc ( rsize , GFP_KERNEL ) ; if ( ! rdesc ) return - ENOMEM ; hid_set_idle ( dev , interface -> desc . bInterfaceNumber , 0 , 0 ) ; ret = hid_get_class_descriptor ( dev , interface -> desc . bInterfaceNumber , HID_DT_REPORT , rdesc , rsize ) ; if ( ret < 0 ) { dbg_hid ( ""reading report descriptor failed\\n"" ) ; kfree ( rdesc ) ; goto err ; } ret = hid_parse_report ( hid , rdesc , rsize ) ; kfree ( rdesc ) ; if ( ret ) { dbg_hid ( ""parsing report descriptor failed\\n"" ) ; goto err ; } hid -> quirks |= quirks ; return 0 ; err : return ret ; }",721,-23.099291112321175,-0.0320378517507922
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int usbhid_parse ( struct hid_device * hid ) { struct usb_interface * intf = to_usb_interface ( hid -> dev . parent ) ; struct usb_host_interface * interface = intf -> cur_altsetting ; struct usb_device * dev = interface_to_usbdev ( intf ) ; struct hid_descriptor * hdesc ; u32 quirks = 0 ; unsigned int rsize = 0 ; char * rdesc ; int ret , n ; quirks = usbhid_lookup_quirk ( le16_to_cpu ( dev -> descriptor . idVendor ) , le16_to_cpu ( dev -> descriptor . idProduct ) ) ; if ( quirks & HID_QUIRK_IGNORE ) return - ENODEV ; if ( interface -> desc . bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT ) { if ( interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_KEYBOARD || interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_MOUSE ) quirks |= HID_QUIRK_NOGET ; } if ( usb_get_extra_descriptor ( interface , HID_DT_HID , & hdesc ) && ( ! interface -> desc . bNumEndpoints || usb_get_extra_descriptor ( & interface -> endpoint [ 0 ] , HID_DT_HID , & hdesc ) ) ) { dbg_hid ( ""class descriptor not present\\n"" ) ; return - ENODEV ; } hid -> version = le16_to_cpu ( hdesc -> bcdHID ) ; hid -> country = hdesc -> bCountryCode ; for ( n = 0 ; n < hdesc -> bNumDescriptors ; n ++ ) if ( hdesc -> desc [ n ] . bDescriptorType == HID_DT_REPORT ) rsize = le16_to_cpu ( hdesc -> desc [ n ] . wDescriptorLength ) ; if ( ! rsize || rsize > HID_MAX_DESCRIPTOR_SIZE ) { dbg_hid ( ""weird size of report descriptor (%u)\\n"" , rsize ) ; return - EINVAL ; } rdesc = kmalloc ( rsize , GFP_KERNEL ) ; if ( ! rdesc ) return - ENOMEM ; hid_set_idle ( dev , interface -> desc . bInterfaceNumber , 0 , 0 ) ; ret = hid_get_class_descriptor ( dev , interface -> desc . bInterfaceNumber , HID_DT_REPORT , rdesc , rsize ) ; if ( ret < 0 ) { dbg_hid ( ""reading report descriptor failed\\n"" ) ; kfree ( rdesc ) ; goto err ; } ret = hid_parse_report ( hid , rdesc , rsize ) ; kfree ( rdesc ) ; if ( ret ) { dbg_hid ( ""parsing report descriptor failed\\n"" ) ; goto err ; } hid -> quirks |= quirks ; return 0 ; err : return ret ; }
Fixed code:","
static int usbhid_parse ( struct hid_device * hid ) { struct usb_interface * intf = to_usb_interface ( hid -> dev . parent ) ; struct usb_host_interface * interface = intf -> cur_altsetting ; struct usb_device * dev = interface_to_usbdev ( intf ) ; struct hid_descriptor * hdesc ; u32 quirks = 0 ; unsigned int rsize = 0 ; char * rdesc ; int ret , n ; quirks = usbhid_lookup_quirk ( le16_to_cpu ( dev -> descriptor . idVendor ) , le16_to_cpu ( dev -> descriptor . idProduct ) ) ; if ( quirks & HID_QUIRK_IGNORE ) return - ENODEV ; if ( interface -> desc . bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT ) { if ( interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_KEYBOARD || interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_MOUSE ) quirks |= HID_QUIRK_NOGET ; } if ( usb_get_extra_descriptor ( interface , HID_DT_HID , & hdesc ) && ( ! interface -> desc . bNumEndpoints || usb_get_extra_descriptor ( & interface -> endpoint [ 0 ] , HID_DT_HID , & hdesc ) ) ) { dbg_hid ( ""class descriptor not present\\n"" ) ; return - ENODEV ; } hid -> version = le16_to_cpu ( hdesc -> bcdHID ) ; hid -> country = hdesc -> bCountryCode ; for ( n = 0 ; n <= hdesc -> bNumDescriptors ; n ++ ) { //changed n < to n <= if ( n == hdesc -> bNumDescriptors || hdesc -> desc [ n ] . bDescriptorType == HID_DT_REPORT ) { //Added check to make sure n <= bNumDescriptors rsize = le16_to_cpu ( hdesc -> desc [ n ] . wDescriptorLength ) ; break ; //Added break statement } } if ( ! rsize || rsize > HID_MAX_DESCRIPTOR_SIZE ) { dbg_hid ( ""weird size of report descriptor (%u)\\n"" , rsize ) ; return - EINVAL ; } rdesc = kmalloc ( rsize , GFP_KERNEL ) ; if ( ! rdesc ) return - ENOMEM ; hid_set_idle ( dev , interface -> desc . bInterfaceNumber , 0 , 0 ) ; ret = hid_get_class_descriptor ( dev , interface -> desc . bInterfaceNumber , HID_DT_REPORT , rdesc , rsize ) ; if ( ret < 0 ) { dbg_hid ( ""reading report descriptor failed\\n"" ) ; kfree ( rdesc ) ; goto err ; } ret = hid_parse_report ( hid , rdesc , rsize ) ; kfree ( rdesc ) ; if ( ret ) { dbg_hid ( ""parsing report descriptor failed\\n"" ) ; goto err ; } hid -> quirks |= quirks ; return 0 ; err : return ret ; }",731,-34.48477625361586,-0.047174796516574365
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int usbhid_parse ( struct hid_device * hid ) { struct usb_interface * intf = to_usb_interface ( hid -> dev . parent ) ; struct usb_host_interface * interface = intf -> cur_altsetting ; struct usb_device * dev = interface_to_usbdev ( intf ) ; struct hid_descriptor * hdesc ; u32 quirks = 0 ; unsigned int rsize = 0 ; char * rdesc ; int ret , n ; quirks = usbhid_lookup_quirk ( le16_to_cpu ( dev -> descriptor . idVendor ) , le16_to_cpu ( dev -> descriptor . idProduct ) ) ; if ( quirks & HID_QUIRK_IGNORE ) return - ENODEV ; if ( interface -> desc . bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT ) { if ( interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_KEYBOARD || interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_MOUSE ) quirks |= HID_QUIRK_NOGET ; } if ( usb_get_extra_descriptor ( interface , HID_DT_HID , & hdesc ) && ( ! interface -> desc . bNumEndpoints || usb_get_extra_descriptor ( & interface -> endpoint [ 0 ] , HID_DT_HID , & hdesc ) ) ) { dbg_hid ( ""class descriptor not present\\n"" ) ; return - ENODEV ; } hid -> version = le16_to_cpu ( hdesc -> bcdHID ) ; hid -> country = hdesc -> bCountryCode ; for ( n = 0 ; n < hdesc -> bNumDescriptors ; n ++ ) if ( hdesc -> desc [ n ] . bDescriptorType == HID_DT_REPORT ) rsize = le16_to_cpu ( hdesc -> desc [ n ] . wDescriptorLength ) ; if ( ! rsize || rsize > HID_MAX_DESCRIPTOR_SIZE ) { dbg_hid ( ""weird size of report descriptor (%u)\\n"" , rsize ) ; return - EINVAL ; } rdesc = kmalloc ( rsize , GFP_KERNEL ) ; if ( ! rdesc ) return - ENOMEM ; hid_set_idle ( dev , interface -> desc . bInterfaceNumber , 0 , 0 ) ; ret = hid_get_class_descriptor ( dev , interface -> desc . bInterfaceNumber , HID_DT_REPORT , rdesc , rsize ) ; if ( ret < 0 ) { dbg_hid ( ""reading report descriptor failed\\n"" ) ; kfree ( rdesc ) ; goto err ; } ret = hid_parse_report ( hid , rdesc , rsize ) ; kfree ( rdesc ) ; if ( ret ) { dbg_hid ( ""parsing report descriptor failed\\n"" ) ; goto err ; } hid -> quirks |= quirks ; return 0 ; err : return ret ; }
Fixed code:","
static int usbhid_parse ( struct hid_device * hid ) { struct usb_interface * intf = to_usb_interface ( hid -> dev . parent ) ; struct usb_host_interface * interface = intf -> cur_altsetting ; struct usb_device * dev = interface_to_usbdev ( intf ) ; struct hid_descriptor * hdesc ; u32 quirks = 0 ; unsigned int rsize = 0 ; char * rdesc ; int ret , n ; quirks = usbhid_lookup_quirk ( le16_to_cpu ( dev -> descriptor . idVendor ) , le16_to_cpu ( dev -> descriptor . idProduct ) ) ; if ( quirks & HID_QUIRK_IGNORE ) return - ENODEV ; if ( interface -> desc . bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT ) { if ( interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_KEYBOARD || interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_MOUSE ) quirks |= HID_QUIRK_NOGET ; } if ( usb_get_extra_descriptor ( interface , HID_DT_HID , & hdesc ) && ( ! interface -> desc . bNumEndpoints || usb_get_extra_descriptor ( & interface -> endpoint [ 0 ] , HID_DT_HID , & hdesc ) ) ) { dbg_hid ( ""class descriptor not present\\n"" ) ; return - ENODEV ; } hid -> version = le16_to_cpu ( hdesc -> bcdHID ) ; hid -> country = hdesc -> bCountryCode ; for ( n = 0 ; n < hdesc -> bNumDescriptors ; n ++ ) if ( n < HID_MAX_DESCRIPTORS && hdesc -> desc [ n ] . bDescriptorType == HID_DT_REPORT ) rsize = le16_to_cpu ( hdesc -> desc [ n ] . wDescriptorLength ) ; if ( ! rsize || rsize > HID_MAX_DESCRIPTOR_SIZE ) { dbg_hid ( ""weird size of report descriptor (%u)\\n"" , rsize ) ; return - EINVAL ; } rdesc = kmalloc ( rsize , GFP_KERNEL ) ; if ( ! rdesc ) return - ENOMEM ; hid_set_idle ( dev , interface -> desc . bInterfaceNumber , 0 , 0 ) ; ret = hid_get_class_descriptor ( dev , interface -> desc . bInterfaceNumber , HID_DT_REPORT , rdesc , rsize ) ; if ( ret < 0 ) { dbg_hid ( ""reading report descriptor failed\\n"" ) ; kfree ( rdesc ) ; goto err ; } ret = hid_parse_report ( hid , rdesc , rsize ) ; kfree ( rdesc ) ; if ( ret ) { dbg_hid ( ""parsing report descriptor failed\\n"" ) ; goto err ; } hid -> quirks |= quirks ; return 0 ; err : return ret ; }",702,-4.890253966453269,-0.006966173741386423
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int usbhid_parse ( struct hid_device * hid ) { struct usb_interface * intf = to_usb_interface ( hid -> dev . parent ) ; struct usb_host_interface * interface = intf -> cur_altsetting ; struct usb_device * dev = interface_to_usbdev ( intf ) ; struct hid_descriptor * hdesc ; u32 quirks = 0 ; unsigned int rsize = 0 ; char * rdesc ; int ret , n ; quirks = usbhid_lookup_quirk ( le16_to_cpu ( dev -> descriptor . idVendor ) , le16_to_cpu ( dev -> descriptor . idProduct ) ) ; if ( quirks & HID_QUIRK_IGNORE ) return - ENODEV ; if ( interface -> desc . bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT ) { if ( interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_KEYBOARD || interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_MOUSE ) quirks |= HID_QUIRK_NOGET ; } if ( usb_get_extra_descriptor ( interface , HID_DT_HID , & hdesc ) && ( ! interface -> desc . bNumEndpoints || usb_get_extra_descriptor ( & interface -> endpoint [ 0 ] , HID_DT_HID , & hdesc ) ) ) { dbg_hid ( ""class descriptor not present\\n"" ) ; return - ENODEV ; } hid -> version = le16_to_cpu ( hdesc -> bcdHID ) ; hid -> country = hdesc -> bCountryCode ; for ( n = 0 ; n < hdesc -> bNumDescriptors ; n ++ ) if ( hdesc -> desc [ n ] . bDescriptorType == HID_DT_REPORT ) rsize = le16_to_cpu ( hdesc -> desc [ n ] . wDescriptorLength ) ; if ( ! rsize || rsize > HID_MAX_DESCRIPTOR_SIZE ) { dbg_hid ( ""weird size of report descriptor (%u)\\n"" , rsize ) ; return - EINVAL ; } rdesc = kmalloc ( rsize , GFP_KERNEL ) ; if ( ! rdesc ) return - ENOMEM ; hid_set_idle ( dev , interface -> desc . bInterfaceNumber , 0 , 0 ) ; ret = hid_get_class_descriptor ( dev , interface -> desc . bInterfaceNumber , HID_DT_REPORT , rdesc , rsize ) ; if ( ret < 0 ) { dbg_hid ( ""reading report descriptor failed\\n"" ) ; kfree ( rdesc ) ; goto err ; } ret = hid_parse_report ( hid , rdesc , rsize ) ; kfree ( rdesc ) ; if ( ret ) { dbg_hid ( ""parsing report descriptor failed\\n"" ) ; goto err ; } hid -> quirks |= quirks ; return 0 ; err : return ret ; }
Fixed code:","
static int usbhid_parse ( struct hid_device * hid ) { struct usb_interface * intf = to_usb_interface ( hid -> dev . parent ) ; struct usb_host_interface * interface = intf -> cur_altsetting ; struct usb_device * dev = interface_to_usbdev ( intf ) ; struct hid_descriptor * hdesc ; u32 quirks = 0 ; unsigned int rsize = 0 ; char * rdesc ; int ret , n ; quirks = usbhid_lookup_quirk ( le16_to_cpu ( dev -> descriptor . idVendor ) , le16_to_cpu ( dev -> descriptor . idProduct ) ) ; if ( quirks & HID_QUIRK_IGNORE ) return - ENODEV ; if ( interface -> desc . bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT ) { if ( interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_KEYBOARD || interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_MOUSE ) quirks |= HID_QUIRK_NOGET ; } if ( usb_get_extra_descriptor ( interface , HID_DT_HID , & hdesc ) && ( ! interface -> desc . bNumEndpoints || usb_get_extra_descriptor ( & interface -> endpoint [ 0 ] , HID_DT_HID , & hdesc ) ) ) { dbg_hid ( ""class descriptor not present\\n"" ) ; return - ENODEV ; } hid -> version = le16_to_cpu ( hdesc -> bcdHID ) ; hid -> country = hdesc -> bCountryCode ; for ( n = 0 ; n < hdesc -> bNumDescriptors ; n ++ ) if ( hdesc -> desc [ n ] . bDescriptorType == HID_DT_REPORT ) rsize = le16_to_cpu ( hdesc -> desc [ n ] . wDescriptorLength ) ; if ( ! rsize || rsize > HID_MAX_DESCRIPTOR_SIZE ) { dbg_hid ( ""weird size of report descriptor (%u)\\n"" , rsize ) ; return - EINVAL ; } if (rsize < HID_MAX_DESCRIPTOR_SIZE) { rdesc = kmalloc ( HID_MAX_DESCRIPTOR_SIZE , GFP_KERNEL ) ; //ADDED LINE OF CODE } else { rdesc = kmalloc ( rsize , GFP_KERNEL ) ; //ADDED LINE OF CODE } if ( ! rdesc ) return - ENOMEM ; hid_set_idle ( dev , interface -> desc . bInterfaceNumber , 0 , 0 ) ; ret = hid_get_class_descriptor ( dev , interface -> desc . bInterfaceNumber , HID_DT_REPORT , rdesc , rsize ) ; if ( ret < 0 ) { dbg_hid ( ""reading report descriptor failed\\n"" ) ; kfree ( rdesc ) ; goto err ; } ret = hid_parse_report ( hid , rdesc , rsize ) ; kfree ( rdesc ) ; if ( ret ) { dbg_hid ( ""parsing report descriptor failed\\n"" ) ; goto err ; } hid -> quirks |= quirks ; return 0 ; err : return ret ; }",748,-23.96135062114338,-0.03203389120473714
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int usbhid_parse ( struct hid_device * hid ) { struct usb_interface * intf = to_usb_interface ( hid -> dev . parent ) ; struct usb_host_interface * interface = intf -> cur_altsetting ; struct usb_device * dev = interface_to_usbdev ( intf ) ; struct hid_descriptor * hdesc ; u32 quirks = 0 ; unsigned int rsize = 0 ; char * rdesc ; int ret , n ; quirks = usbhid_lookup_quirk ( le16_to_cpu ( dev -> descriptor . idVendor ) , le16_to_cpu ( dev -> descriptor . idProduct ) ) ; if ( quirks & HID_QUIRK_IGNORE ) return - ENODEV ; if ( interface -> desc . bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT ) { if ( interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_KEYBOARD || interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_MOUSE ) quirks |= HID_QUIRK_NOGET ; } if ( usb_get_extra_descriptor ( interface , HID_DT_HID , & hdesc ) && ( ! interface -> desc . bNumEndpoints || usb_get_extra_descriptor ( & interface -> endpoint [ 0 ] , HID_DT_HID , & hdesc ) ) ) { dbg_hid ( ""class descriptor not present\\n"" ) ; return - ENODEV ; } hid -> version = le16_to_cpu ( hdesc -> bcdHID ) ; hid -> country = hdesc -> bCountryCode ; for ( n = 0 ; n < hdesc -> bNumDescriptors ; n ++ ) if ( hdesc -> desc [ n ] . bDescriptorType == HID_DT_REPORT ) rsize = le16_to_cpu ( hdesc -> desc [ n ] . wDescriptorLength ) ; if ( ! rsize || rsize > HID_MAX_DESCRIPTOR_SIZE ) { dbg_hid ( ""weird size of report descriptor (%u)\\n"" , rsize ) ; return - EINVAL ; } rdesc = kmalloc ( rsize , GFP_KERNEL ) ; if ( ! rdesc ) return - ENOMEM ; hid_set_idle ( dev , interface -> desc . bInterfaceNumber , 0 , 0 ) ; ret = hid_get_class_descriptor ( dev , interface -> desc . bInterfaceNumber , HID_DT_REPORT , rdesc , rsize ) ; if ( ret < 0 ) { dbg_hid ( ""reading report descriptor failed\\n"" ) ; kfree ( rdesc ) ; goto err ; } ret = hid_parse_report ( hid , rdesc , rsize ) ; kfree ( rdesc ) ; if ( ret ) { dbg_hid ( ""parsing report descriptor failed\\n"" ) ; goto err ; } hid -> quirks |= quirks ; return 0 ; err : return ret ; }
Fixed code:","
static int usbhid_parse ( struct hid_device * hid ) { struct usb_interface * intf = to_usb_interface ( hid -> dev . parent ) ; struct usb_host_interface * interface = intf -> cur_altsetting ; struct usb_device * dev = interface_to_usbdev ( intf ) ; struct hid_descriptor * hdesc ; u32 quirks = 0 ; unsigned int rsize = 0 ; char * rdesc ; int ret , n ; quirks = usbhid_lookup_quirk ( le16_to_cpu ( dev -> descriptor . idVendor ) , le16_to_cpu ( dev -> descriptor . idProduct ) ) ; if ( quirks & HID_QUIRK_IGNORE ) return - ENODEV ; if ( interface -> desc . bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT ) { if ( interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_KEYBOARD || interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_MOUSE ) quirks |= HID_QUIRK_NOGET ; } if ( usb_get_extra_descriptor ( interface , HID_DT_HID , & hdesc ) && ( ! interface -> desc . bNumEndpoints || usb_get_extra_descriptor ( & interface -> endpoint [ 0 ] , HID_DT_HID , & hdesc ) ) ) { dbg_hid ( ""class descriptor not present\\n"" ) ; return - ENODEV ; } hid -> version = le16_to_cpu ( hdesc -> bcdHID ) ; hid -> country = hdesc -> bCountryCode ; for ( n = 0 ; n < hdesc -> bNumDescriptors ; n ++ ) { if ( hdesc -> desc [ n ] . bDescriptorType == HID_DT_REPORT ) { rsize = le16_to_cpu ( hdesc -> desc [ n ] . wDescriptorLength ) ; if ( rsize > HID_MAX_DESCRIPTOR_SIZE ) { dbg_hid ( ""weird size of report descriptor (%u)\\n"" , rsize ) ; return - EINVAL ; } } } rdesc = kmalloc ( rsize , GFP_KERNEL ) ; if ( ! rdesc ) return - ENOMEM ; hid_set_idle ( dev , interface -> desc . bInterfaceNumber , 0 , 0 ) ; ret = hid_get_class_descriptor ( dev , interface -> desc . bInterfaceNumber , HID_DT_REPORT , rdesc , rsize ) ; if ( ret < 0 ) { dbg_hid ( ""reading report descriptor failed\\n"" ) ; kfree ( rdesc ) ; goto err ; } ret = hid_parse_report ( hid , rdesc , rsize ) ; kfree ( rdesc ) ; if ( ret ) { dbg_hid ( ""parsing report descriptor failed\\n"" ) ; goto err ; } hid -> quirks |= quirks ; return 0 ; err : return ret ; }",690,-6.91789964323555,-0.01002594151193558
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int usbhid_parse ( struct hid_device * hid ) { struct usb_interface * intf = to_usb_interface ( hid -> dev . parent ) ; struct usb_host_interface * interface = intf -> cur_altsetting ; struct usb_device * dev = interface_to_usbdev ( intf ) ; struct hid_descriptor * hdesc ; u32 quirks = 0 ; unsigned int rsize = 0 ; char * rdesc ; int ret , n ; quirks = usbhid_lookup_quirk ( le16_to_cpu ( dev -> descriptor . idVendor ) , le16_to_cpu ( dev -> descriptor . idProduct ) ) ; if ( quirks & HID_QUIRK_IGNORE ) return - ENODEV ; if ( interface -> desc . bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT ) { if ( interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_KEYBOARD || interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_MOUSE ) quirks |= HID_QUIRK_NOGET ; } if ( usb_get_extra_descriptor ( interface , HID_DT_HID , & hdesc ) && ( ! interface -> desc . bNumEndpoints || usb_get_extra_descriptor ( & interface -> endpoint [ 0 ] , HID_DT_HID , & hdesc ) ) ) { dbg_hid ( ""class descriptor not present\\n"" ) ; return - ENODEV ; } hid -> version = le16_to_cpu ( hdesc -> bcdHID ) ; hid -> country = hdesc -> bCountryCode ; for ( n = 0 ; n < hdesc -> bNumDescriptors ; n ++ ) if ( hdesc -> desc [ n ] . bDescriptorType == HID_DT_REPORT ) rsize = le16_to_cpu ( hdesc -> desc [ n ] . wDescriptorLength ) ; if ( ! rsize || rsize > HID_MAX_DESCRIPTOR_SIZE ) { dbg_hid ( ""weird size of report descriptor (%u)\\n"" , rsize ) ; return - EINVAL ; } rdesc = kmalloc ( rsize , GFP_KERNEL ) ; if ( ! rdesc ) return - ENOMEM ; hid_set_idle ( dev , interface -> desc . bInterfaceNumber , 0 , 0 ) ; ret = hid_get_class_descriptor ( dev , interface -> desc . bInterfaceNumber , HID_DT_REPORT , rdesc , rsize ) ; if ( ret < 0 ) { dbg_hid ( ""reading report descriptor failed\\n"" ) ; kfree ( rdesc ) ; goto err ; } ret = hid_parse_report ( hid , rdesc , rsize ) ; kfree ( rdesc ) ; if ( ret ) { dbg_hid ( ""parsing report descriptor failed\\n"" ) ; goto err ; } hid -> quirks |= quirks ; return 0 ; err : return ret ; }
Fixed code:","
static int usbhid_parse ( struct hid_device * hid ) { struct usb_interface * intf = to_usb_interface ( hid -> dev . parent ) ; struct usb_host_interface * interface = intf -> cur_altsetting ; struct usb_device * dev = interface_to_usbdev ( intf ) ; struct hid_descriptor * hdesc ; u32 quirks = 0 ; unsigned int rsize = 0 ; char * rdesc ; int ret , n ; quirks = usbhid_lookup_quirk ( le16_to_cpu ( dev -> descriptor . idVendor ) , le16_to_cpu ( dev -> descriptor . idProduct ) ) ; if ( quirks & HID_QUIRK_IGNORE ) return - ENODEV ; if ( interface -> desc . bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT ) { if ( interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_KEYBOARD || interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_MOUSE ) quirks |= HID_QUIRK_NOGET ; } if ( usb_get_extra_descriptor ( interface , HID_DT_HID , & hdesc ) && ( ! interface -> desc . bNumEndpoints || usb_get_extra_descriptor ( & interface -> endpoint [ 0 ] , HID_DT_HID , & hdesc ) ) ) { dbg_hid ( ""class descriptor not present\\n"" ) ; return - ENODEV ; } hid -> version = le16_to_cpu ( hdesc -> bcdHID ) ; hid -> country = hdesc -> bCountryCode ; for ( n = 0 ; n < hdesc -> bNumDescriptors ; n ++ ) { if ( n > HID_MAX_DESCRIPTOR_SIZE - 1 ) break ; if ( hdesc -> desc [ n ] . bDescriptorType == HID_DT_REPORT ) rsize = le16_to_cpu ( hdesc -> desc [ n ] . wDescriptorLength ) ; } if ( ! rsize || rsize > HID_MAX_DESCRIPTOR_SIZE ) { dbg_hid ( ""weird size of report descriptor (%u)\\n"" , rsize ) ; return - EINVAL ; } rdesc = kmalloc ( rsize , GFP_KERNEL ) ; if ( ! rdesc ) return - ENOMEM ; hid_set_idle ( dev , interface -> desc . bInterfaceNumber , 0 , 0 ) ; ret = hid_get_class_descriptor ( dev , interface -> desc . bInterfaceNumber , HID_DT_REPORT , rdesc , rsize ) ; if ( ret < 0 ) { dbg_hid ( ""reading report descriptor failed\\n"" ) ; kfree ( rdesc ) ; goto err ; } ret = hid_parse_report ( hid , rdesc , rsize ) ; kfree ( rdesc ) ; if ( ret ) { dbg_hid ( ""parsing report descriptor failed\\n"" ) ; goto err ; } hid -> quirks |= quirks ; return 0 ; err : return ret ; }",711,-13.85813236202266,-0.01949104410973651
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int usbhid_parse ( struct hid_device * hid ) { struct usb_interface * intf = to_usb_interface ( hid -> dev . parent ) ; struct usb_host_interface * interface = intf -> cur_altsetting ; struct usb_device * dev = interface_to_usbdev ( intf ) ; struct hid_descriptor * hdesc ; u32 quirks = 0 ; unsigned int rsize = 0 ; char * rdesc ; int ret , n ; quirks = usbhid_lookup_quirk ( le16_to_cpu ( dev -> descriptor . idVendor ) , le16_to_cpu ( dev -> descriptor . idProduct ) ) ; if ( quirks & HID_QUIRK_IGNORE ) return - ENODEV ; if ( interface -> desc . bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT ) { if ( interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_KEYBOARD || interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_MOUSE ) quirks |= HID_QUIRK_NOGET ; } if ( usb_get_extra_descriptor ( interface , HID_DT_HID , & hdesc ) && ( ! interface -> desc . bNumEndpoints || usb_get_extra_descriptor ( & interface -> endpoint [ 0 ] , HID_DT_HID , & hdesc ) ) ) { dbg_hid ( ""class descriptor not present\\n"" ) ; return - ENODEV ; } hid -> version = le16_to_cpu ( hdesc -> bcdHID ) ; hid -> country = hdesc -> bCountryCode ; for ( n = 0 ; n < hdesc -> bNumDescriptors ; n ++ ) if ( hdesc -> desc [ n ] . bDescriptorType == HID_DT_REPORT ) rsize = le16_to_cpu ( hdesc -> desc [ n ] . wDescriptorLength ) ; if ( ! rsize || rsize > HID_MAX_DESCRIPTOR_SIZE ) { dbg_hid ( ""weird size of report descriptor (%u)\\n"" , rsize ) ; return - EINVAL ; } rdesc = kmalloc ( rsize , GFP_KERNEL ) ; if ( ! rdesc ) return - ENOMEM ; hid_set_idle ( dev , interface -> desc . bInterfaceNumber , 0 , 0 ) ; ret = hid_get_class_descriptor ( dev , interface -> desc . bInterfaceNumber , HID_DT_REPORT , rdesc , rsize ) ; if ( ret < 0 ) { dbg_hid ( ""reading report descriptor failed\\n"" ) ; kfree ( rdesc ) ; goto err ; } ret = hid_parse_report ( hid , rdesc , rsize ) ; kfree ( rdesc ) ; if ( ret ) { dbg_hid ( ""parsing report descriptor failed\\n"" ) ; goto err ; } hid -> quirks |= quirks ; return 0 ; err : return ret ; }
Fixed code:","
static int usbhid_parse ( struct hid_device * hid ) { struct usb_interface * intf = to_usb_interface ( hid -> dev . parent ) ; struct usb_host_interface * interface = intf -> cur_altsetting ; struct usb_device * dev = interface_to_usbdev ( intf ) ; struct hid_descriptor * hdesc ; u32 quirks = 0 ; unsigned int rsize = 0 ; char * rdesc ; int ret , n ; quirks = usbhid_lookup_quirk ( le16_to_cpu ( dev -> descriptor . idVendor ) , le16_to_cpu ( dev -> descriptor . idProduct ) ) ; if ( quirks & HID_QUIRK_IGNORE ) return - ENODEV ; if ( interface -> desc . bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT ) { if ( interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_KEYBOARD || interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_MOUSE ) quirks |= HID_QUIRK_NOGET ; } if ( usb_get_extra_descriptor ( interface , HID_DT_HID , & hdesc ) && ( ! interface -> desc . bNumEndpoints || usb_get_extra_descriptor ( & interface -> endpoint [ 0 ] , HID_DT_HID , & hdesc ) ) ) { dbg_hid ( ""class descriptor not present\\n"" ) ; return - ENODEV ; } hid -> version = le16_to_cpu ( hdesc -> bcdHID ) ; hid -> country = hdesc -> bCountryCode ; 
//Adding a check to make sure the index is not out of bounds. 
if (n < hdesc->bNumDescriptors) { 
  for ( n = 0 ; n < hdesc -> bNumDescriptors ; n ++ ) 
      if ( hdesc -> desc [ n ] . bDescriptorType == HID_DT_REPORT ) rsize = le16_to_cpu ( hdesc -> desc [ n ] . wDescriptorLength ) ; 
}
 else { 
    return -EINVAL; 
 } 
if ( ! rsize || rsize > HID_MAX_DESCRIPTOR_SIZE ) { dbg_hid ( ""weird size of report descriptor (%u)\\n"" , rsize ) ; return - EINVAL ; } rdesc = kmalloc ( rsize , GFP_KERNEL ) ; if ( ! rdesc ) return - ENOMEM ; hid_set_idle ( dev , interface -> desc . bInterfaceNumber , 0 , 0 ) ; ret = hid_get_class_descriptor ( dev , interface -> desc . bInterfaceNumber , HID_DT_REPORT , rdesc , rsize ) ; if ( ret < 0 ) { dbg_hid ( ""reading report descriptor failed\\n"" ) ; kfree ( rdesc ) ; goto err ; } ret = hid_parse_report ( hid , rdesc , rsize ) ; kfree ( rdesc ) ; if ( ret ) { dbg_hid ( ""parsing report descriptor failed\\n"" ) ; goto err ; } hid -> quirks |= quirks ; return 0 ; err : return ret ; }",749,-46.22251896257528,-0.061712308361248705
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int usbhid_parse ( struct hid_device * hid ) { struct usb_interface * intf = to_usb_interface ( hid -> dev . parent ) ; struct usb_host_interface * interface = intf -> cur_altsetting ; struct usb_device * dev = interface_to_usbdev ( intf ) ; struct hid_descriptor * hdesc ; u32 quirks = 0 ; unsigned int rsize = 0 ; char * rdesc ; int ret , n ; quirks = usbhid_lookup_quirk ( le16_to_cpu ( dev -> descriptor . idVendor ) , le16_to_cpu ( dev -> descriptor . idProduct ) ) ; if ( quirks & HID_QUIRK_IGNORE ) return - ENODEV ; if ( interface -> desc . bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT ) { if ( interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_KEYBOARD || interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_MOUSE ) quirks |= HID_QUIRK_NOGET ; } if ( usb_get_extra_descriptor ( interface , HID_DT_HID , & hdesc ) && ( ! interface -> desc . bNumEndpoints || usb_get_extra_descriptor ( & interface -> endpoint [ 0 ] , HID_DT_HID , & hdesc ) ) ) { dbg_hid ( ""class descriptor not present\\n"" ) ; return - ENODEV ; } hid -> version = le16_to_cpu ( hdesc -> bcdHID ) ; hid -> country = hdesc -> bCountryCode ; for ( n = 0 ; n < hdesc -> bNumDescriptors ; n ++ ) if ( hdesc -> desc [ n ] . bDescriptorType == HID_DT_REPORT ) rsize = le16_to_cpu ( hdesc -> desc [ n ] . wDescriptorLength ) ; if ( ! rsize || rsize > HID_MAX_DESCRIPTOR_SIZE ) { dbg_hid ( ""weird size of report descriptor (%u)\\n"" , rsize ) ; return - EINVAL ; } rdesc = kmalloc ( rsize , GFP_KERNEL ) ; if ( ! rdesc ) return - ENOMEM ; hid_set_idle ( dev , interface -> desc . bInterfaceNumber , 0 , 0 ) ; ret = hid_get_class_descriptor ( dev , interface -> desc . bInterfaceNumber , HID_DT_REPORT , rdesc , rsize ) ; if ( ret < 0 ) { dbg_hid ( ""reading report descriptor failed\\n"" ) ; kfree ( rdesc ) ; goto err ; } ret = hid_parse_report ( hid , rdesc , rsize ) ; kfree ( rdesc ) ; if ( ret ) { dbg_hid ( ""parsing report descriptor failed\\n"" ) ; goto err ; } hid -> quirks |= quirks ; return 0 ; err : return ret ; }
Fixed code:","
static int usbhid_parse ( struct hid_device * hid ) { struct usb_interface * intf = to_usb_interface ( hid -> dev . parent ) ; struct usb_host_interface * interface = intf -> cur_altsetting ; struct usb_device * dev = interface_to_usbdev ( intf ) ; struct hid_descriptor * hdesc ; u32 quirks = 0 ; unsigned int rsize = 0 ; char * rdesc ; int ret , n ; quirks = usbhid_lookup_quirk ( le16_to_cpu ( dev -> descriptor . idVendor ) , le16_to_cpu ( dev -> descriptor . idProduct ) ) ; if ( quirks & HID_QUIRK_IGNORE ) return - ENODEV ; if ( interface -> desc . bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT ) { if ( interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_KEYBOARD || interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_MOUSE ) quirks |= HID_QUIRK_NOGET ; } if ( usb_get_extra_descriptor ( interface , HID_DT_HID , & hdesc ) && ( ! interface -> desc . bNumEndpoints || usb_get_extra_descriptor ( & interface -> endpoint [ 0 ] , HID_DT_HID , & hdesc ) ) ) { dbg_hid ( ""class descriptor not present\\n"" ) ; return - ENODEV ; } hid -> version = le16_to_cpu ( hdesc -> bcdHID ) ; hid -> country = hdesc -> bCountryCode ; for ( n = 0 ; n < hdesc -> bNumDescriptors ; n ++ ) if ( n < HID_MAX_DESCRIPTOR_SIZE && hdesc -> desc [ n ] . bDescriptorType == HID_DT_REPORT ) rsize = le16_to_cpu ( hdesc -> desc [ n ] . wDescriptorLength ) ; if ( ! rsize || rsize > HID_MAX_DESCRIPTOR_SIZE ) { dbg_hid ( ""weird size of report descriptor (%u)\\n"" , rsize ) ; return - EINVAL ; } rdesc = kmalloc ( rsize , GFP_KERNEL ) ; if ( ! rdesc ) return - ENOMEM ; hid_set_idle ( dev , interface -> desc . bInterfaceNumber , 0 , 0 ) ; ret = hid_get_class_descriptor ( dev , interface -> desc . bInterfaceNumber , HID_DT_REPORT , rdesc , rsize ) ; if ( ret < 0 ) { dbg_hid ( ""reading report descriptor failed\\n"" ) ; kfree ( rdesc ) ; goto err ; } ret = hid_parse_report ( hid , rdesc , rsize ) ; kfree ( rdesc ) ; if ( ret ) { dbg_hid ( ""parsing report descriptor failed\\n"" ) ; goto err ; } hid -> quirks |= quirks ; return 0 ; err : return ret ; }",703,-5.518314898686728,-0.007849665574234322
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int usbhid_parse ( struct hid_device * hid ) { struct usb_interface * intf = to_usb_interface ( hid -> dev . parent ) ; struct usb_host_interface * interface = intf -> cur_altsetting ; struct usb_device * dev = interface_to_usbdev ( intf ) ; struct hid_descriptor * hdesc ; u32 quirks = 0 ; unsigned int rsize = 0 ; char * rdesc ; int ret , n ; quirks = usbhid_lookup_quirk ( le16_to_cpu ( dev -> descriptor . idVendor ) , le16_to_cpu ( dev -> descriptor . idProduct ) ) ; if ( quirks & HID_QUIRK_IGNORE ) return - ENODEV ; if ( interface -> desc . bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT ) { if ( interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_KEYBOARD || interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_MOUSE ) quirks |= HID_QUIRK_NOGET ; } if ( usb_get_extra_descriptor ( interface , HID_DT_HID , & hdesc ) && ( ! interface -> desc . bNumEndpoints || usb_get_extra_descriptor ( & interface -> endpoint [ 0 ] , HID_DT_HID , & hdesc ) ) ) { dbg_hid ( ""class descriptor not present\\n"" ) ; return - ENODEV ; } hid -> version = le16_to_cpu ( hdesc -> bcdHID ) ; hid -> country = hdesc -> bCountryCode ; for ( n = 0 ; n < hdesc -> bNumDescriptors ; n ++ ) if ( hdesc -> desc [ n ] . bDescriptorType == HID_DT_REPORT ) rsize = le16_to_cpu ( hdesc -> desc [ n ] . wDescriptorLength ) ; if ( ! rsize || rsize > HID_MAX_DESCRIPTOR_SIZE ) { dbg_hid ( ""weird size of report descriptor (%u)\\n"" , rsize ) ; return - EINVAL ; } rdesc = kmalloc ( rsize , GFP_KERNEL ) ; if ( ! rdesc ) return - ENOMEM ; hid_set_idle ( dev , interface -> desc . bInterfaceNumber , 0 , 0 ) ; ret = hid_get_class_descriptor ( dev , interface -> desc . bInterfaceNumber , HID_DT_REPORT , rdesc , rsize ) ; if ( ret < 0 ) { dbg_hid ( ""reading report descriptor failed\\n"" ) ; kfree ( rdesc ) ; goto err ; } ret = hid_parse_report ( hid , rdesc , rsize ) ; kfree ( rdesc ) ; if ( ret ) { dbg_hid ( ""parsing report descriptor failed\\n"" ) ; goto err ; } hid -> quirks |= quirks ; return 0 ; err : return ret ; }
Fixed code:","
static int usbhid_parse ( struct hid_device * hid ) { struct usb_interface * intf = to_usb_interface ( hid -> dev . parent ) ; struct usb_host_interface * interface = intf -> cur_altsetting ; struct usb_device * dev = interface_to_usbdev ( intf ) ; struct hid_descriptor * hdesc ; u32 quirks = 0 ; unsigned int rsize = 0 ; char * rdesc ; int ret , n ; quirks = usbhid_lookup_quirk ( le16_to_cpu ( dev -> descriptor . idVendor ) , le16_to_cpu ( dev -> descriptor . idProduct ) ) ; if ( quirks & HID_QUIRK_IGNORE ) return - ENODEV ; if ( interface -> desc . bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT ) { if ( interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_KEYBOARD || interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_MOUSE ) quirks |= HID_QUIRK_NOGET ; } if ( usb_get_extra_descriptor ( interface , HID_DT_HID , & hdesc ) && ( ! interface -> desc . bNumEndpoints || usb_get_extra_descriptor ( & interface -> endpoint [ 0 ] , HID_DT_HID , & hdesc ) ) ) { dbg_hid ( ""class descriptor not present\\n"" ) ; return - ENODEV ; } if (hdesc == NULL) { dbg_hid(“hdesc is NULL. Aborting\\n""); return - EINVAL; } hid -> version = le16_to_cpu ( hdesc -> bcdHID ) ; hid -> country = hdesc -> bCountryCode ; for ( n = 0 ; n < hdesc -> bNumDescriptors ; n ++ ) if ( hdesc -> desc [ n ] . bDescriptorType == HID_DT_REPORT ) rsize = le16_to_cpu ( hdesc -> desc [ n ] . wDescriptorLength ) ; if ( ! rsize || rsize > HID_MAX_DESCRIPTOR_SIZE ) { dbg_hid ( ""weird size of report descriptor (%u)\\n"" , rsize ) ; return - EINVAL ; } rdesc = kmalloc ( rsize , GFP_KERNEL ) ; if ( ! rdesc ) return - ENOMEM ; hid_set_idle ( dev , interface -> desc . bInterfaceNumber , 0 , 0 ) ; ret = hid_get_class_descriptor ( dev , interface -> desc . bInterfaceNumber , HID_DT_REPORT , rdesc , rsize ) ; if ( ret < 0 ) { dbg_hid ( ""reading report descriptor failed\\n"" ) ; kfree ( rdesc ) ; goto err ; } ret = hid_parse_report ( hid , rdesc , rsize ) ; kfree ( rdesc ) ; if ( ret ) { dbg_hid ( ""parsing report descriptor failed\\n"" ) ; goto err ; } hid -> quirks |= quirks ; return 0 ; err : return ret ; }",722,-28.305150204478927,-0.03920380914747774
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int usbhid_parse ( struct hid_device * hid ) { struct usb_interface * intf = to_usb_interface ( hid -> dev . parent ) ; struct usb_host_interface * interface = intf -> cur_altsetting ; struct usb_device * dev = interface_to_usbdev ( intf ) ; struct hid_descriptor * hdesc ; u32 quirks = 0 ; unsigned int rsize = 0 ; char * rdesc ; int ret , n ; quirks = usbhid_lookup_quirk ( le16_to_cpu ( dev -> descriptor . idVendor ) , le16_to_cpu ( dev -> descriptor . idProduct ) ) ; if ( quirks & HID_QUIRK_IGNORE ) return - ENODEV ; if ( interface -> desc . bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT ) { if ( interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_KEYBOARD || interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_MOUSE ) quirks |= HID_QUIRK_NOGET ; } if ( usb_get_extra_descriptor ( interface , HID_DT_HID , & hdesc ) && ( ! interface -> desc . bNumEndpoints || usb_get_extra_descriptor ( & interface -> endpoint [ 0 ] , HID_DT_HID , & hdesc ) ) ) { dbg_hid ( ""class descriptor not present\\n"" ) ; return - ENODEV ; } hid -> version = le16_to_cpu ( hdesc -> bcdHID ) ; hid -> country = hdesc -> bCountryCode ; for ( n = 0 ; n < hdesc -> bNumDescriptors ; n ++ ) if ( hdesc -> desc [ n ] . bDescriptorType == HID_DT_REPORT ) rsize = le16_to_cpu ( hdesc -> desc [ n ] . wDescriptorLength ) ; if ( ! rsize || rsize > HID_MAX_DESCRIPTOR_SIZE ) { dbg_hid ( ""weird size of report descriptor (%u)\\n"" , rsize ) ; return - EINVAL ; } rdesc = kmalloc ( rsize , GFP_KERNEL ) ; if ( ! rdesc ) return - ENOMEM ; hid_set_idle ( dev , interface -> desc . bInterfaceNumber , 0 , 0 ) ; ret = hid_get_class_descriptor ( dev , interface -> desc . bInterfaceNumber , HID_DT_REPORT , rdesc , rsize ) ; if ( ret < 0 ) { dbg_hid ( ""reading report descriptor failed\\n"" ) ; kfree ( rdesc ) ; goto err ; } ret = hid_parse_report ( hid , rdesc , rsize ) ; kfree ( rdesc ) ; if ( ret ) { dbg_hid ( ""parsing report descriptor failed\\n"" ) ; goto err ; } hid -> quirks |= quirks ; return 0 ; err : return ret ; }
Fixed code:","
static int usbhid_parse ( struct hid_device * hid ) { 
  struct usb_interface * intf = to_usb_interface ( hid -> dev . parent ) ;
  struct usb_host_interface * interface = intf -> cur_altsetting ;
  struct usb_device * dev = interface_to_usbdev ( intf ) ;
  struct hid_descriptor * hdesc ;
  u32 quirks = 0 ;
  unsigned int rsize = 0 ;
  char * rdesc ;
  int ret , n ;
  
  quirks = usbhid_lookup_quirk ( le16_to_cpu ( dev -> descriptor . idVendor ) , le16_to_cpu ( dev -> descriptor . idProduct ) ) ;
  if ( quirks & HID_QUIRK_IGNORE ) return - ENODEV ;
  if ( interface -> desc . bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT ) {
    if ( interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_KEYBOARD || interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_MOUSE ) quirks |= HID_QUIRK_NOGET ;
  }
  if ( usb_get_extra_descriptor ( interface , HID_DT_HID , & hdesc ) && ( ! interface -> desc . bNumEndpoints || usb_get_extra_descriptor ( & interface -> endpoint [ 0 ] , HID_DT_HID , & hdesc ) ) ) {
    dbg_hid ( ""class descriptor not present\\n"" ) ;
    return - ENODEV ;
  }
  if ( hdesc != NULL && hdesc -> bNumDescriptors > 0 ) {
    hid -> version = le16_to_cpu ( hdesc -> bcdHID ) ;
    hid -> country = hdesc -> bCountryCode ;
    for ( n = 0 ; n < hdesc -> bNumDescriptors ; n ++ )
      if ( hdesc -> desc [ n ] . bDescriptorType == HID_DT_REPORT )
        rsize = le16_to_cpu ( hdesc -> desc [ n ] . wDescriptorLength ) ;
  
    if ( ! rsize || rsize > HID_MAX_DESCRIPTOR_SIZE ) {
      dbg_hid ( ""weird size of report descriptor (%u)\\n"" , rsize ) ;
      return - EINVAL ;
    }
  
    rdesc = kmalloc ( rsize , GFP_KERNEL ) ;
    if ( ! rdesc ) return - ENOMEM ;
    hid_set_idle ( dev , interface -> desc . bInterfaceNumber , 0 , 0 ) ;
    ret = hid_get_class_descriptor ( dev , interface -> desc . bInterfaceNumber , HID_DT_REPORT , rdesc , rsize ) ;
    if ( ret < 0 ) {
      dbg_hid ( ""reading report descriptor failed\\n"" ) ;
      kfree ( rdesc ) ;
      goto err ;
    }
    ret = hid_parse_report ( hid , rdesc , rsize ) ;
    kfree ( rdesc ) ;
    if ( ret ) {
      dbg_hid ( ""parsing report descriptor failed\\n"" ) ;
      goto err ;
    }
    hid -> quirks |= quirks ;
    return 0 ;
  } else {
    return - ENODEV ;
  }
  err :
  return ret ;
}",825,-38.300755349980086,-0.04642515799997586
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int usbhid_parse ( struct hid_device * hid ) { struct usb_interface * intf = to_usb_interface ( hid -> dev . parent ) ; struct usb_host_interface * interface = intf -> cur_altsetting ; struct usb_device * dev = interface_to_usbdev ( intf ) ; struct hid_descriptor * hdesc ; u32 quirks = 0 ; unsigned int rsize = 0 ; char * rdesc ; int ret , n ; quirks = usbhid_lookup_quirk ( le16_to_cpu ( dev -> descriptor . idVendor ) , le16_to_cpu ( dev -> descriptor . idProduct ) ) ; if ( quirks & HID_QUIRK_IGNORE ) return - ENODEV ; if ( interface -> desc . bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT ) { if ( interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_KEYBOARD || interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_MOUSE ) quirks |= HID_QUIRK_NOGET ; } if ( usb_get_extra_descriptor ( interface , HID_DT_HID , & hdesc ) && ( ! interface -> desc . bNumEndpoints || usb_get_extra_descriptor ( & interface -> endpoint [ 0 ] , HID_DT_HID , & hdesc ) ) ) { dbg_hid ( ""class descriptor not present\\n"" ) ; return - ENODEV ; } hid -> version = le16_to_cpu ( hdesc -> bcdHID ) ; hid -> country = hdesc -> bCountryCode ; for ( n = 0 ; n < hdesc -> bNumDescriptors ; n ++ ) if ( hdesc -> desc [ n ] . bDescriptorType == HID_DT_REPORT ) rsize = le16_to_cpu ( hdesc -> desc [ n ] . wDescriptorLength ) ; if ( ! rsize || rsize > HID_MAX_DESCRIPTOR_SIZE ) { dbg_hid ( ""weird size of report descriptor (%u)\\n"" , rsize ) ; return - EINVAL ; } rdesc = kmalloc ( rsize , GFP_KERNEL ) ; if ( ! rdesc ) return - ENOMEM ; hid_set_idle ( dev , interface -> desc . bInterfaceNumber , 0 , 0 ) ; ret = hid_get_class_descriptor ( dev , interface -> desc . bInterfaceNumber , HID_DT_REPORT , rdesc , rsize ) ; if ( ret < 0 ) { dbg_hid ( ""reading report descriptor failed\\n"" ) ; kfree ( rdesc ) ; goto err ; } ret = hid_parse_report ( hid , rdesc , rsize ) ; kfree ( rdesc ) ; if ( ret ) { dbg_hid ( ""parsing report descriptor failed\\n"" ) ; goto err ; } hid -> quirks |= quirks ; return 0 ; err : return ret ; }
Fixed code:","
static int usbhid_parse ( struct hid_device * hid ) { struct usb_interface * intf = to_usb_interface ( hid -> dev . parent ) ; struct usb_host_interface * interface = intf -> cur_altsetting ; struct usb_device * dev = interface_to_usbdev ( intf ) ; struct hid_descriptor * hdesc ; u32 quirks = 0 ; unsigned int rsize = 0 ; char * rdesc ; int ret , n ; quirks = usbhid_lookup_quirk ( le16_to_cpu ( dev -> descriptor . idVendor ) , le16_to_cpu ( dev -> descriptor . idProduct ) ) ; if ( quirks & HID_QUIRK_IGNORE ) return - ENODEV ; if ( interface -> desc . bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT ) { if ( interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_KEYBOARD || interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_MOUSE ) quirks |= HID_QUIRK_NOGET ; } if ( usb_get_extra_descriptor ( interface , HID_DT_HID , & hdesc ) && ( ! interface -> desc . bNumEndpoints || usb_get_extra_descriptor ( & interface -> endpoint [ 0 ] , HID_DT_HID , & hdesc ) ) ) { dbg_hid ( ""class descriptor not present\\n"" ) ; return - ENODEV ; } hid -> version = le16_to_cpu ( hdesc -> bcdHID ) ; hid -> country = hdesc -> bCountryCode ; for ( n = 0 ; n < hdesc -> bNumDescriptors ; n ++ ) { //added boundary check if (n >= HID_MAX_DESCRIPTORS) break; if ( hdesc -> desc [ n ] . bDescriptorType == HID_DT_REPORT ) rsize = le16_to_cpu ( hdesc -> desc [ n ] . wDescriptorLength ) ; } if ( ! rsize || rsize > HID_MAX_DESCRIPTOR_SIZE ) { dbg_hid ( ""weird size of report descriptor (%u)\\n"" , rsize ) ; return - EINVAL ; } rdesc = kmalloc ( rsize , GFP_KERNEL ) ; if ( ! rdesc ) return - ENOMEM ; hid_set_idle ( dev , interface -> desc . bInterfaceNumber , 0 , 0 ) ; ret = hid_get_class_descriptor ( dev , interface -> desc . bInterfaceNumber , HID_DT_REPORT , rdesc , rsize ) ; if ( ret < 0 ) { dbg_hid ( ""reading report descriptor failed\\n"" ) ; kfree ( rdesc ) ; goto err ; } ret = hid_parse_report ( hid , rdesc , rsize ) ; kfree ( rdesc ) ; if ( ret ) { dbg_hid ( ""parsing report descriptor failed\\n"" ) ; goto err ; } hid -> quirks |= quirks ; return 0 ; err : return ret ; }",712,-14.88890773643636,-0.020911387270275788
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int usbhid_parse ( struct hid_device * hid ) { struct usb_interface * intf = to_usb_interface ( hid -> dev . parent ) ; struct usb_host_interface * interface = intf -> cur_altsetting ; struct usb_device * dev = interface_to_usbdev ( intf ) ; struct hid_descriptor * hdesc ; u32 quirks = 0 ; unsigned int rsize = 0 ; char * rdesc ; int ret , n ; quirks = usbhid_lookup_quirk ( le16_to_cpu ( dev -> descriptor . idVendor ) , le16_to_cpu ( dev -> descriptor . idProduct ) ) ; if ( quirks & HID_QUIRK_IGNORE ) return - ENODEV ; if ( interface -> desc . bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT ) { if ( interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_KEYBOARD || interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_MOUSE ) quirks |= HID_QUIRK_NOGET ; } if ( usb_get_extra_descriptor ( interface , HID_DT_HID , & hdesc ) && ( ! interface -> desc . bNumEndpoints || usb_get_extra_descriptor ( & interface -> endpoint [ 0 ] , HID_DT_HID , & hdesc ) ) ) { dbg_hid ( ""class descriptor not present\\n"" ) ; return - ENODEV ; } hid -> version = le16_to_cpu ( hdesc -> bcdHID ) ; hid -> country = hdesc -> bCountryCode ; for ( n = 0 ; n < hdesc -> bNumDescriptors ; n ++ ) if ( hdesc -> desc [ n ] . bDescriptorType == HID_DT_REPORT ) rsize = le16_to_cpu ( hdesc -> desc [ n ] . wDescriptorLength ) ; if ( ! rsize || rsize > HID_MAX_DESCRIPTOR_SIZE ) { dbg_hid ( ""weird size of report descriptor (%u)\\n"" , rsize ) ; return - EINVAL ; } rdesc = kmalloc ( rsize , GFP_KERNEL ) ; if ( ! rdesc ) return - ENOMEM ; hid_set_idle ( dev , interface -> desc . bInterfaceNumber , 0 , 0 ) ; ret = hid_get_class_descriptor ( dev , interface -> desc . bInterfaceNumber , HID_DT_REPORT , rdesc , rsize ) ; if ( ret < 0 ) { dbg_hid ( ""reading report descriptor failed\\n"" ) ; kfree ( rdesc ) ; goto err ; } ret = hid_parse_report ( hid , rdesc , rsize ) ; kfree ( rdesc ) ; if ( ret ) { dbg_hid ( ""parsing report descriptor failed\\n"" ) ; goto err ; } hid -> quirks |= quirks ; return 0 ; err : return ret ; }
Fixed code:","
static int usbhid_parse ( struct hid_device * hid ) { struct usb_interface * intf = to_usb_interface ( hid -> dev . parent ) ; struct usb_host_interface * interface = intf -> cur_altsetting ; struct usb_device * dev = interface_to_usbdev ( intf ) ; struct hid_descriptor * hdesc ; u32 quirks = 0 ; unsigned int rsize = 0 ; char * rdesc ; int ret , n ; quirks = usbhid_lookup_quirk ( le16_to_cpu ( dev -> descriptor . idVendor ) , le16_to_cpu ( dev -> descriptor . idProduct ) ) ; if ( quirks & HID_QUIRK_IGNORE ) return - ENODEV ; if ( interface -> desc . bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT ) { if ( interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_KEYBOARD || interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_MOUSE ) quirks |= HID_QUIRK_NOGET ; } if ( usb_get_extra_descriptor ( interface , HID_DT_HID , & hdesc ) && ( ! interface -> desc . bNumEndpoints || usb_get_extra_descriptor ( & interface -> endpoint [ 0 ] , HID_DT_HID , & hdesc ) ) ) { dbg_hid ( ""class descriptor not present\\n"" ) ; return - ENODEV ; } if (hdesc == NULL) {dbg_hid(""HID descriptor not present\\n""); return -ENODEV;} hid -> version = le16_to_cpu ( hdesc -> bcdHID ) ; hid -> country = hdesc -> bCountryCode ; for ( n = 0 ; n < hdesc -> bNumDescriptors ; n ++ ) if ( hdesc -> desc [ n ] . bDescriptorType == HID_DT_REPORT ) rsize = le16_to_cpu ( hdesc -> desc [ n ] . wDescriptorLength ) ; if ( ! rsize || rsize > HID_MAX_DESCRIPTOR_SIZE ) { dbg_hid ( ""weird size of report descriptor (%u)\\n"" , rsize ) ; return - EINVAL ; } rdesc = kmalloc ( rsize , GFP_KERNEL ) ; if ( ! rdesc ) return - ENOMEM ; hid_set_idle ( dev , interface -> desc . bInterfaceNumber , 0 , 0 ) ; ret = hid_get_class_descriptor ( dev , interface -> desc . bInterfaceNumber , HID_DT_REPORT , rdesc , rsize ) ; if ( ret < 0 ) { dbg_hid ( ""reading report descriptor failed\\n"" ) ; kfree ( rdesc ) ; goto err ; } ret = hid_parse_report ( hid , rdesc , rsize ) ; kfree ( rdesc ) ; if ( ret ) { dbg_hid ( ""parsing report descriptor failed\\n"" ) ; goto err ; } hid -> quirks |= quirks ; return 0 ; err : return ret ; }",717,-14.377447846685223,-0.020052228516994734
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int usbhid_parse ( struct hid_device * hid ) { struct usb_interface * intf = to_usb_interface ( hid -> dev . parent ) ; struct usb_host_interface * interface = intf -> cur_altsetting ; struct usb_device * dev = interface_to_usbdev ( intf ) ; struct hid_descriptor * hdesc ; u32 quirks = 0 ; unsigned int rsize = 0 ; char * rdesc ; int ret , n ; quirks = usbhid_lookup_quirk ( le16_to_cpu ( dev -> descriptor . idVendor ) , le16_to_cpu ( dev -> descriptor . idProduct ) ) ; if ( quirks & HID_QUIRK_IGNORE ) return - ENODEV ; if ( interface -> desc . bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT ) { if ( interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_KEYBOARD || interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_MOUSE ) quirks |= HID_QUIRK_NOGET ; } if ( usb_get_extra_descriptor ( interface , HID_DT_HID , & hdesc ) && ( ! interface -> desc . bNumEndpoints || usb_get_extra_descriptor ( & interface -> endpoint [ 0 ] , HID_DT_HID , & hdesc ) ) ) { dbg_hid ( ""class descriptor not present\\n"" ) ; return - ENODEV ; } hid -> version = le16_to_cpu ( hdesc -> bcdHID ) ; hid -> country = hdesc -> bCountryCode ; for ( n = 0 ; n < hdesc -> bNumDescriptors ; n ++ ) if ( hdesc -> desc [ n ] . bDescriptorType == HID_DT_REPORT ) rsize = le16_to_cpu ( hdesc -> desc [ n ] . wDescriptorLength ) ; if ( ! rsize || rsize > HID_MAX_DESCRIPTOR_SIZE ) { dbg_hid ( ""weird size of report descriptor (%u)\\n"" , rsize ) ; return - EINVAL ; } rdesc = kmalloc ( rsize , GFP_KERNEL ) ; if ( ! rdesc ) return - ENOMEM ; hid_set_idle ( dev , interface -> desc . bInterfaceNumber , 0 , 0 ) ; ret = hid_get_class_descriptor ( dev , interface -> desc . bInterfaceNumber , HID_DT_REPORT , rdesc , rsize ) ; if ( ret < 0 ) { dbg_hid ( ""reading report descriptor failed\\n"" ) ; kfree ( rdesc ) ; goto err ; } ret = hid_parse_report ( hid , rdesc , rsize ) ; kfree ( rdesc ) ; if ( ret ) { dbg_hid ( ""parsing report descriptor failed\\n"" ) ; goto err ; } hid -> quirks |= quirks ; return 0 ; err : return ret ; }
Fixed code:","
static int usbhid_parse ( struct hid_device * hid ) { struct usb_interface * intf = to_usb_interface ( hid -> dev . parent ) ; struct usb_host_interface * interface = intf -> cur_altsetting ; struct usb_device * dev = interface_to_usbdev ( intf ) ; struct hid_descriptor * hdesc ; u32 quirks = 0 ; unsigned int rsize = 0 ; char * rdesc ; int ret , n ; quirks = usbhid_lookup_quirk ( le16_to_cpu ( dev -> descriptor . idVendor ) , le16_to_cpu ( dev -> descriptor . idProduct ) ) ; if ( quirks & HID_QUIRK_IGNORE ) return - ENODEV ; if ( interface -> desc . bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT ) { if ( interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_KEYBOARD || interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_MOUSE ) quirks |= HID_QUIRK_NOGET ; } if ( usb_get_extra_descriptor ( interface , HID_DT_HID , & hdesc ) && ( ! interface -> desc . bNumEndpoints || usb_get_extra_descriptor ( & interface -> endpoint [ 0 ] , HID_DT_HID , & hdesc ) ) ) { dbg_hid ( ""class descriptor not present\\n"" ) ; return - ENODEV ; } hid -> version = le16_to_cpu ( hdesc -> bcdHID ) ; hid -> country = hdesc -> bCountryCode ; for ( n = 0 ; n < hdesc -> bNumDescriptors ; n ++ ) if ( hdesc -> desc [ n ] . bDescriptorType == HID_DT_REPORT ) { 
  rsize = le16_to_cpu ( hdesc -> desc [ n ] . wDescriptorLength ) ; 
  if (rsize > HID_MAX_DESCRIPTOR_SIZE ) { 
    dbg_hid ( ""weird size of report descriptor (%u)\\n"" , rsize ) ; 
    return - EINVAL ; 
  } 
} 
 
if ( ! rsize || rsize > HID_MAX_DESCRIPTOR_SIZE ) { 
  dbg_hid ( ""weird size of report descriptor (%u)\\n"" , rsize ) ; 
  return - EINVAL ; 
} 
 
rdesc = kmalloc ( rsize , GFP_KERNEL ) ; 
if ( ! rdesc ) return - ENOMEM ; 
 
hid_set_idle ( dev , interface -> desc . bInterfaceNumber , 0 , 0 ) ; 
ret = hid_get_class_descriptor ( dev , interface -> desc . bInterfaceNumber , HID_DT_REPORT , rdesc , rsize ) ; 
if ( ret < 0 ) { 
  dbg_hid ( ""reading report descriptor failed\\n"" ) ; 
  kfree ( rdesc ) ; 
  goto err ; 
} 
 
ret = hid_parse_report ( hid , rdesc , rsize ) ; 
kfree ( rdesc ) ; 
if ( ret ) { 
  dbg_hid ( ""parsing report descriptor failed\\n"" ) ; 
  goto err ; 
} 
 
hid -> quirks |= quirks ; 
return 0 ; 
 
err : 
return ret ; 
}",823,-24.800031071599683,-0.030133695105224404
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int usbhid_parse ( struct hid_device * hid ) { struct usb_interface * intf = to_usb_interface ( hid -> dev . parent ) ; struct usb_host_interface * interface = intf -> cur_altsetting ; struct usb_device * dev = interface_to_usbdev ( intf ) ; struct hid_descriptor * hdesc ; u32 quirks = 0 ; unsigned int rsize = 0 ; char * rdesc ; int ret , n ; quirks = usbhid_lookup_quirk ( le16_to_cpu ( dev -> descriptor . idVendor ) , le16_to_cpu ( dev -> descriptor . idProduct ) ) ; if ( quirks & HID_QUIRK_IGNORE ) return - ENODEV ; if ( interface -> desc . bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT ) { if ( interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_KEYBOARD || interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_MOUSE ) quirks |= HID_QUIRK_NOGET ; } if ( usb_get_extra_descriptor ( interface , HID_DT_HID , & hdesc ) && ( ! interface -> desc . bNumEndpoints || usb_get_extra_descriptor ( & interface -> endpoint [ 0 ] , HID_DT_HID , & hdesc ) ) ) { dbg_hid ( ""class descriptor not present\\n"" ) ; return - ENODEV ; } hid -> version = le16_to_cpu ( hdesc -> bcdHID ) ; hid -> country = hdesc -> bCountryCode ; for ( n = 0 ; n < hdesc -> bNumDescriptors ; n ++ ) if ( hdesc -> desc [ n ] . bDescriptorType == HID_DT_REPORT ) rsize = le16_to_cpu ( hdesc -> desc [ n ] . wDescriptorLength ) ; if ( ! rsize || rsize > HID_MAX_DESCRIPTOR_SIZE ) { dbg_hid ( ""weird size of report descriptor (%u)\\n"" , rsize ) ; return - EINVAL ; } rdesc = kmalloc ( rsize , GFP_KERNEL ) ; if ( ! rdesc ) return - ENOMEM ; hid_set_idle ( dev , interface -> desc . bInterfaceNumber , 0 , 0 ) ; ret = hid_get_class_descriptor ( dev , interface -> desc . bInterfaceNumber , HID_DT_REPORT , rdesc , rsize ) ; if ( ret < 0 ) { dbg_hid ( ""reading report descriptor failed\\n"" ) ; kfree ( rdesc ) ; goto err ; } ret = hid_parse_report ( hid , rdesc , rsize ) ; kfree ( rdesc ) ; if ( ret ) { dbg_hid ( ""parsing report descriptor failed\\n"" ) ; goto err ; } hid -> quirks |= quirks ; return 0 ; err : return ret ; }
Fixed code:","
static int usbhid_parse ( struct hid_device * hid ) { struct usb_interface * intf = to_usb_interface ( hid -> dev . parent ) ; struct usb_host_interface * interface = intf -> cur_altsetting ; struct usb_device * dev = interface_to_usbdev ( intf ) ; struct hid_descriptor * hdesc ; u32 quirks = 0 ; unsigned int rsize = 0 ; char * rdesc ; int ret , n ; quirks = usbhid_lookup_quirk ( le16_to_cpu ( dev -> descriptor . idVendor ) , le16_to_cpu ( dev -> descriptor . idProduct ) ) ; if ( quirks & HID_QUIRK_IGNORE ) return - ENODEV ; if ( interface -> desc . bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT ) { if ( interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_KEYBOARD || interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_MOUSE ) quirks |= HID_QUIRK_NOGET ; } if ( usb_get_extra_descriptor ( interface , HID_DT_HID , & hdesc ) && ( ! interface -> desc . bNumEndpoints || usb_get_extra_descriptor ( & interface -> endpoint [ 0 ] , HID_DT_HID , & hdesc ) ) ) { dbg_hid ( ""class descriptor not present\\n"" ) ; return - ENODEV ; } if (hdesc == NULL) { dbg_hid(""Null descriptor present\\n""); return - EINVAL; } hid -> version = le16_to_cpu ( hdesc -> bcdHID ) ; hid -> country = hdesc -> bCountryCode ; for ( n = 0 ; n < hdesc -> bNumDescriptors ; n ++ ) if ( hdesc -> desc [ n ] . bDescriptorType == HID_DT_REPORT ) rsize = le16_to_cpu ( hdesc -> desc [ n ] . wDescriptorLength ) ; if ( ! rsize || rsize > HID_MAX_DESCRIPTOR_SIZE ) { dbg_hid ( ""weird size of report descriptor (%u)\\n"" , rsize ) ; return - EINVAL ; } rdesc = kmalloc ( rsize , GFP_KERNEL ) ; if ( ! rdesc ) return - ENOMEM ; hid_set_idle ( dev , interface -> desc . bInterfaceNumber , 0 , 0 ) ; ret = hid_get_class_descriptor ( dev , interface -> desc . bInterfaceNumber , HID_DT_REPORT , rdesc , rsize ) ; if ( ret < 0 ) { dbg_hid ( ""reading report descriptor failed\\n"" ) ; kfree ( rdesc ) ; goto err ; } ret = hid_parse_report ( hid , rdesc , rsize ) ; kfree ( rdesc ) ; if ( ret ) { dbg_hid ( ""parsing report descriptor failed\\n"" ) ; goto err ; } hid -> quirks |= quirks ; return 0 ; err : return ret ; }",716,-19.030025655533922,-0.02657824812225408
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int usbhid_parse ( struct hid_device * hid ) { struct usb_interface * intf = to_usb_interface ( hid -> dev . parent ) ; struct usb_host_interface * interface = intf -> cur_altsetting ; struct usb_device * dev = interface_to_usbdev ( intf ) ; struct hid_descriptor * hdesc ; u32 quirks = 0 ; unsigned int rsize = 0 ; char * rdesc ; int ret , n ; quirks = usbhid_lookup_quirk ( le16_to_cpu ( dev -> descriptor . idVendor ) , le16_to_cpu ( dev -> descriptor . idProduct ) ) ; if ( quirks & HID_QUIRK_IGNORE ) return - ENODEV ; if ( interface -> desc . bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT ) { if ( interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_KEYBOARD || interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_MOUSE ) quirks |= HID_QUIRK_NOGET ; } if ( usb_get_extra_descriptor ( interface , HID_DT_HID , & hdesc ) && ( ! interface -> desc . bNumEndpoints || usb_get_extra_descriptor ( & interface -> endpoint [ 0 ] , HID_DT_HID , & hdesc ) ) ) { dbg_hid ( ""class descriptor not present\\n"" ) ; return - ENODEV ; } hid -> version = le16_to_cpu ( hdesc -> bcdHID ) ; hid -> country = hdesc -> bCountryCode ; for ( n = 0 ; n < hdesc -> bNumDescriptors ; n ++ ) if ( hdesc -> desc [ n ] . bDescriptorType == HID_DT_REPORT ) rsize = le16_to_cpu ( hdesc -> desc [ n ] . wDescriptorLength ) ; if ( ! rsize || rsize > HID_MAX_DESCRIPTOR_SIZE ) { dbg_hid ( ""weird size of report descriptor (%u)\\n"" , rsize ) ; return - EINVAL ; } rdesc = kmalloc ( rsize , GFP_KERNEL ) ; if ( ! rdesc ) return - ENOMEM ; hid_set_idle ( dev , interface -> desc . bInterfaceNumber , 0 , 0 ) ; ret = hid_get_class_descriptor ( dev , interface -> desc . bInterfaceNumber , HID_DT_REPORT , rdesc , rsize ) ; if ( ret < 0 ) { dbg_hid ( ""reading report descriptor failed\\n"" ) ; kfree ( rdesc ) ; goto err ; } ret = hid_parse_report ( hid , rdesc , rsize ) ; kfree ( rdesc ) ; if ( ret ) { dbg_hid ( ""parsing report descriptor failed\\n"" ) ; goto err ; } hid -> quirks |= quirks ; return 0 ; err : return ret ; }
Fixed code:","
static int usbhid_parse ( struct hid_device * hid ) { struct usb_interface * intf = to_usb_interface ( hid -> dev . parent ) ; struct usb_host_interface * interface = intf -> cur_altsetting ; struct usb_device * dev = interface_to_usbdev ( intf ) ; struct hid_descriptor * hdesc ; u32 quirks = 0 ; unsigned int rsize = 0 ; char * rdesc ; int ret , n ; quirks = usbhid_lookup_quirk ( le16_to_cpu ( dev -> descriptor . idVendor ) , le16_to_cpu ( dev -> descriptor . idProduct ) ) ; if ( quirks & HID_QUIRK_IGNORE ) return - ENODEV ; if ( interface -> desc . bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT ) { if ( interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_KEYBOARD || interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_MOUSE ) quirks |= HID_QUIRK_NOGET ; } if ( usb_get_extra_descriptor ( interface , HID_DT_HID , & hdesc ) && ( ! interface -> desc . bNumEndpoints || usb_get_extra_descriptor ( & interface -> endpoint [ 0 ] , HID_DT_HID , & hdesc ) ) ) { dbg_hid ( ""class descriptor not present\\n"" ) ; return - ENODEV ; } hid -> version = le16_to_cpu ( hdesc -> bcdHID ) ; hid -> country = hdesc -> bCountryCode ; for ( n = 0 ; n < hdesc -> bNumDescriptors ; n ++ ) { if ( n > HID_MAX_DESCRIPTOR || hdesc -> desc [ n ] . bDescriptorType > HID_DT_REPORT) return - EINVAL; if ( hdesc -> desc [ n ] . bDescriptorType == HID_DT_REPORT ) rsize = le16_to_cpu ( hdesc -> desc [ n ] . wDescriptorLength ) ; } if ( ! rsize || rsize > HID_MAX_DESCRIPTOR_SIZE ) { dbg_hid ( ""weird size of report descriptor (%u)\\n"" , rsize ) ; return - EINVAL ; } rdesc = kmalloc ( rsize , GFP_KERNEL ) ; if ( ! rdesc ) return - ENOMEM ; hid_set_idle ( dev , interface -> desc . bInterfaceNumber , 0 , 0 ) ; ret = hid_get_class_descriptor ( dev , interface -> desc . bInterfaceNumber , HID_DT_REPORT , rdesc , rsize ) ; if ( ret < 0 ) { dbg_hid ( ""reading report descriptor failed\\n"" ) ; kfree ( rdesc ) ; goto err ; } ret = hid_parse_report ( hid , rdesc , rsize ) ; kfree ( rdesc ) ; if ( ret ) { dbg_hid ( ""parsing report descriptor failed\\n"" ) ; goto err ; } hid -> quirks |= quirks ; return 0 ; err : return ret ; }",733,-19.203353286063233,-0.026198299162432787
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int usbhid_parse ( struct hid_device * hid ) { struct usb_interface * intf = to_usb_interface ( hid -> dev . parent ) ; struct usb_host_interface * interface = intf -> cur_altsetting ; struct usb_device * dev = interface_to_usbdev ( intf ) ; struct hid_descriptor * hdesc ; u32 quirks = 0 ; unsigned int rsize = 0 ; char * rdesc ; int ret , n ; quirks = usbhid_lookup_quirk ( le16_to_cpu ( dev -> descriptor . idVendor ) , le16_to_cpu ( dev -> descriptor . idProduct ) ) ; if ( quirks & HID_QUIRK_IGNORE ) return - ENODEV ; if ( interface -> desc . bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT ) { if ( interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_KEYBOARD || interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_MOUSE ) quirks |= HID_QUIRK_NOGET ; } if ( usb_get_extra_descriptor ( interface , HID_DT_HID , & hdesc ) && ( ! interface -> desc . bNumEndpoints || usb_get_extra_descriptor ( & interface -> endpoint [ 0 ] , HID_DT_HID , & hdesc ) ) ) { dbg_hid ( ""class descriptor not present\\n"" ) ; return - ENODEV ; } hid -> version = le16_to_cpu ( hdesc -> bcdHID ) ; hid -> country = hdesc -> bCountryCode ; for ( n = 0 ; n < hdesc -> bNumDescriptors ; n ++ ) if ( hdesc -> desc [ n ] . bDescriptorType == HID_DT_REPORT ) rsize = le16_to_cpu ( hdesc -> desc [ n ] . wDescriptorLength ) ; if ( ! rsize || rsize > HID_MAX_DESCRIPTOR_SIZE ) { dbg_hid ( ""weird size of report descriptor (%u)\\n"" , rsize ) ; return - EINVAL ; } rdesc = kmalloc ( rsize , GFP_KERNEL ) ; if ( ! rdesc ) return - ENOMEM ; hid_set_idle ( dev , interface -> desc . bInterfaceNumber , 0 , 0 ) ; ret = hid_get_class_descriptor ( dev , interface -> desc . bInterfaceNumber , HID_DT_REPORT , rdesc , rsize ) ; if ( ret < 0 ) { dbg_hid ( ""reading report descriptor failed\\n"" ) ; kfree ( rdesc ) ; goto err ; } ret = hid_parse_report ( hid , rdesc , rsize ) ; kfree ( rdesc ) ; if ( ret ) { dbg_hid ( ""parsing report descriptor failed\\n"" ) ; goto err ; } hid -> quirks |= quirks ; return 0 ; err : return ret ; }
Fixed code:","
static int usbhid_parse ( struct hid_device * hid ) { struct usb_interface * intf = to_usb_interface ( hid -> dev . parent ) ; struct usb_host_interface * interface = intf -> cur_altsetting ; struct usb_device * dev = interface_to_usbdev ( intf ) ; struct hid_descriptor * hdesc ; u32 quirks = 0 ; unsigned int rsize = 0 ; char * rdesc ; int ret , n ; quirks = usbhid_lookup_quirk ( le16_to_cpu ( dev -> descriptor . idVendor ) , le16_to_cpu ( dev -> descriptor . idProduct ) ) ; if ( quirks & HID_QUIRK_IGNORE ) return - ENODEV ; if ( interface -> desc . bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT ) { if ( interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_KEYBOARD || interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_MOUSE ) quirks |= HID_QUIRK_NOGET ; } if ( usb_get_extra_descriptor ( interface , HID_DT_HID , & hdesc ) && ( ! interface -> desc . bNumEndpoints || usb_get_extra_descriptor ( & interface -> endpoint [ 0 ] , HID_DT_HID , & hdesc ) ) ) { dbg_hid ( ""class descriptor not present\\n"" ) ; return - ENODEV ; } hid -> version = le16_to_cpu ( hdesc -> bcdHID ) ; hid -> country = hdesc -> bCountryCode ; for ( n = 0 ; n < hdesc -> bNumDescriptors ; n ++ ) if ( hdesc -> desc [ n ] . bDescriptorType == HID_DT_REPORT ) {
    rsize = le16_to_cpu ( hdesc -> desc [ n ] . wDescriptorLength ) ; 
    if ( rsize >= HID_MAX_DESCRIPTOR_SIZE ) { 
      dbg_hid ( ""weird size of report descriptor (%u)\\n"" , rsize ) ; 
      return - EINVAL ; 
    } 
  } 
  rdesc = kmalloc ( rsize , GFP_KERNEL ) ; 
  if ( ! rdesc ) return - ENOMEM ; 
  hid_set_idle ( dev , interface -> desc . bInterfaceNumber , 0 , 0 ) ; 
  ret = hid_get_class_descriptor ( dev , interface -> desc . bInterfaceNumber , HID_DT_REPORT , rdesc , rsize ) ; 
  if ( ret < 0 ) { 
    dbg_hid ( ""reading report descriptor failed\\n"" ) ; 
    kfree ( rdesc ) ; 
    goto err ; 
  } 
  ret = hid_parse_report ( hid , rdesc , rsize ) ; 
  kfree ( rdesc ) ; 
  if ( ret ) { 
    dbg_hid ( ""parsing report descriptor failed\\n"" ) ; 
    goto err ; 
  } 
  hid -> quirks |= quirks ; 
  return 0 ; 
err : 
  return ret ; 
}",763,-22.602204495719988,-0.029622810610380062
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int usbhid_parse ( struct hid_device * hid ) { struct usb_interface * intf = to_usb_interface ( hid -> dev . parent ) ; struct usb_host_interface * interface = intf -> cur_altsetting ; struct usb_device * dev = interface_to_usbdev ( intf ) ; struct hid_descriptor * hdesc ; u32 quirks = 0 ; unsigned int rsize = 0 ; char * rdesc ; int ret , n ; quirks = usbhid_lookup_quirk ( le16_to_cpu ( dev -> descriptor . idVendor ) , le16_to_cpu ( dev -> descriptor . idProduct ) ) ; if ( quirks & HID_QUIRK_IGNORE ) return - ENODEV ; if ( interface -> desc . bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT ) { if ( interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_KEYBOARD || interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_MOUSE ) quirks |= HID_QUIRK_NOGET ; } if ( usb_get_extra_descriptor ( interface , HID_DT_HID , & hdesc ) && ( ! interface -> desc . bNumEndpoints || usb_get_extra_descriptor ( & interface -> endpoint [ 0 ] , HID_DT_HID , & hdesc ) ) ) { dbg_hid ( ""class descriptor not present\\n"" ) ; return - ENODEV ; } hid -> version = le16_to_cpu ( hdesc -> bcdHID ) ; hid -> country = hdesc -> bCountryCode ; for ( n = 0 ; n < hdesc -> bNumDescriptors ; n ++ ) if ( hdesc -> desc [ n ] . bDescriptorType == HID_DT_REPORT ) rsize = le16_to_cpu ( hdesc -> desc [ n ] . wDescriptorLength ) ; if ( ! rsize || rsize > HID_MAX_DESCRIPTOR_SIZE ) { dbg_hid ( ""weird size of report descriptor (%u)\\n"" , rsize ) ; return - EINVAL ; } rdesc = kmalloc ( rsize , GFP_KERNEL ) ; if ( ! rdesc ) return - ENOMEM ; hid_set_idle ( dev , interface -> desc . bInterfaceNumber , 0 , 0 ) ; ret = hid_get_class_descriptor ( dev , interface -> desc . bInterfaceNumber , HID_DT_REPORT , rdesc , rsize ) ; if ( ret < 0 ) { dbg_hid ( ""reading report descriptor failed\\n"" ) ; kfree ( rdesc ) ; goto err ; } ret = hid_parse_report ( hid , rdesc , rsize ) ; kfree ( rdesc ) ; if ( ret ) { dbg_hid ( ""parsing report descriptor failed\\n"" ) ; goto err ; } hid -> quirks |= quirks ; return 0 ; err : return ret ; }
Fixed code:","
static int usbhid_parse ( struct hid_device * hid ) { struct usb_interface * intf = to_usb_interface ( hid -> dev . parent ) ; struct usb_host_interface * interface = intf -> cur_altsetting ; struct usb_device * dev = interface_to_usbdev ( intf ) ; struct hid_descriptor * hdesc ; u32 quirks = 0 ; unsigned int rsize = 0 ; char * rdesc ; int ret , n ; quirks = usbhid_lookup_quirk ( le16_to_cpu ( dev -> descriptor . idVendor ) , le16_to_cpu ( dev -> descriptor . idProduct ) ) ; if ( quirks & HID_QUIRK_IGNORE ) return - ENODEV ; if ( interface -> desc . bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT ) { if ( interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_KEYBOARD || interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_MOUSE ) quirks |= HID_QUIRK_NOGET ; } if ( usb_get_extra_descriptor ( interface , HID_DT_HID , & hdesc ) && ( ! interface -> desc . bNumEndpoints || usb_get_extra_descriptor ( & interface -> endpoint [ 0 ] , HID_DT_HID , & hdesc ) ) ) { dbg_hid ( ""class descriptor not present\\n"" ) ; return - ENODEV ; } hid -> version = le16_to_cpu ( hdesc -> bcdHID ) ; hid -> country = hdesc -> bCountryCode ; for ( n = 0 ; n < hdesc -> bNumDescriptors ; n ++ ) { if ( n >= HID_MAX_DESCRIPTOR_SIZE ) { dbg_hid ( ""out-of-bounds read\\n"" ) ; return - EINVAL ; }
if ( hdesc -> desc [ n ] . bDescriptorType == HID_DT_REPORT ) rsize = le16_to_cpu ( hdesc -> desc [ n ] . wDescriptorLength ) ; 
}
if ( ! rsize || rsize > HID_MAX_DESCRIPTOR_SIZE ) { dbg_hid ( ""weird size of report descriptor (%u)\\n"" , rsize ) ; return - EINVAL ; } 
rdesc = kmalloc ( rsize , GFP_KERNEL ) ; if ( ! rdesc ) return - ENOMEM ; hid_set_idle ( dev , interface -> desc . bInterfaceNumber , 0 , 0 ) ; ret = hid_get_class_descriptor ( dev , interface -> desc . bInterfaceNumber , HID_DT_REPORT , rdesc , rsize ) ; if ( ret < 0 ) { dbg_hid ( ""reading report descriptor failed\\n"" ) ; kfree ( rdesc ) ; goto err ; } ret = hid_parse_report ( hid , rdesc , rsize ) ; kfree ( rdesc ) ; if ( ret ) { dbg_hid ( ""parsing report descriptor failed\\n"" ) ; goto err ; } hid -> quirks |= quirks ; return 0 ; err : return ret ; }",739,-23.54654899948406,-0.03186271853786747
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int usbhid_parse ( struct hid_device * hid ) { struct usb_interface * intf = to_usb_interface ( hid -> dev . parent ) ; struct usb_host_interface * interface = intf -> cur_altsetting ; struct usb_device * dev = interface_to_usbdev ( intf ) ; struct hid_descriptor * hdesc ; u32 quirks = 0 ; unsigned int rsize = 0 ; char * rdesc ; int ret , n ; quirks = usbhid_lookup_quirk ( le16_to_cpu ( dev -> descriptor . idVendor ) , le16_to_cpu ( dev -> descriptor . idProduct ) ) ; if ( quirks & HID_QUIRK_IGNORE ) return - ENODEV ; if ( interface -> desc . bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT ) { if ( interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_KEYBOARD || interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_MOUSE ) quirks |= HID_QUIRK_NOGET ; } if ( usb_get_extra_descriptor ( interface , HID_DT_HID , & hdesc ) && ( ! interface -> desc . bNumEndpoints || usb_get_extra_descriptor ( & interface -> endpoint [ 0 ] , HID_DT_HID , & hdesc ) ) ) { dbg_hid ( ""class descriptor not present\\n"" ) ; return - ENODEV ; } hid -> version = le16_to_cpu ( hdesc -> bcdHID ) ; hid -> country = hdesc -> bCountryCode ; for ( n = 0 ; n < hdesc -> bNumDescriptors ; n ++ ) if ( hdesc -> desc [ n ] . bDescriptorType == HID_DT_REPORT ) rsize = le16_to_cpu ( hdesc -> desc [ n ] . wDescriptorLength ) ; if ( ! rsize || rsize > HID_MAX_DESCRIPTOR_SIZE ) { dbg_hid ( ""weird size of report descriptor (%u)\\n"" , rsize ) ; return - EINVAL ; } rdesc = kmalloc ( rsize , GFP_KERNEL ) ; if ( ! rdesc ) return - ENOMEM ; hid_set_idle ( dev , interface -> desc . bInterfaceNumber , 0 , 0 ) ; ret = hid_get_class_descriptor ( dev , interface -> desc . bInterfaceNumber , HID_DT_REPORT , rdesc , rsize ) ; if ( ret < 0 ) { dbg_hid ( ""reading report descriptor failed\\n"" ) ; kfree ( rdesc ) ; goto err ; } ret = hid_parse_report ( hid , rdesc , rsize ) ; kfree ( rdesc ) ; if ( ret ) { dbg_hid ( ""parsing report descriptor failed\\n"" ) ; goto err ; } hid -> quirks |= quirks ; return 0 ; err : return ret ; }
Fixed code:","

static int usbhid_parse ( struct hid_device * hid ) { struct usb_interface * intf = to_usb_interface ( hid -> dev . parent ) ; struct usb_host_interface * interface = intf -> cur_altsetting ; struct usb_device * dev = interface_to_usbdev ( intf ) ; struct hid_descriptor * hdesc ; u32 quirks = 0 ; unsigned int rsize = 0 ; char * rdesc ; int ret , n ; quirks = usbhid_lookup_quirk ( le16_to_cpu ( dev -> descriptor . idVendor ) , le16_to_cpu ( dev -> descriptor . idProduct ) ) ; if ( quirks & HID_QUIRK_IGNORE ) return - ENODEV ; if ( interface -> desc . bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT ) { if ( interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_KEYBOARD || interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_MOUSE ) quirks |= HID_QUIRK_NOGET ; } if ( usb_get_extra_descriptor ( interface , HID_DT_HID , & hdesc ) && ( ! interface -> desc . bNumEndpoints || usb_get_extra_descriptor ( & interface -> endpoint [ 0 ] , HID_DT_HID , & hdesc ) ) ) { dbg_hid ( ""class descriptor not present\\n"" ) ; return - ENODEV ; } hid -> version = le16_to_cpu ( hdesc -> bcdHID ) ; hid -> country = hdesc -> bCountryCode ; for ( n = 0 ; n < hdesc -> bNumDescriptors ; n ++ ) if ( hdesc -> desc [ n ] . bDescriptorType == HID_DT_REPORT ) { rsize = le16_to_cpu ( hdesc -> desc [ n ] . wDescriptorLength ) ; 
 
if ( rsize == 0 || rsize > HID_MAX_DESCRIPTOR_SIZE ) { dbg_hid ( ""weird size of report descriptor (%u)\\n"" , rsize ) ; return - EINVAL ; } } rdesc = kmalloc ( rsize , GFP_KERNEL ) ; if ( ! rdesc ) return - ENOMEM ; hid_set_idle ( dev , interface -> desc . bInterfaceNumber , 0 , 0 ) ; ret = hid_get_class_descriptor ( dev , interface -> desc . bInterfaceNumber , HID_DT_REPORT , rdesc , rsize ) ; if ( ret < 0 ) { dbg_hid ( ""reading report descriptor failed\\n"" ) ; kfree ( rdesc ) ; goto err ; } ret = hid_parse_report ( hid , rdesc , rsize ) ; kfree ( rdesc ) ; if ( ret ) { dbg_hid ( ""parsing report descriptor failed\\n"" ) ; goto err ; } hid -> quirks |= quirks ; return 0 ; 
err : return ret ; }",700,-24.774694552655635,-0.03539242078950805
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int usbhid_parse ( struct hid_device * hid ) { struct usb_interface * intf = to_usb_interface ( hid -> dev . parent ) ; struct usb_host_interface * interface = intf -> cur_altsetting ; struct usb_device * dev = interface_to_usbdev ( intf ) ; struct hid_descriptor * hdesc ; u32 quirks = 0 ; unsigned int rsize = 0 ; char * rdesc ; int ret , n ; quirks = usbhid_lookup_quirk ( le16_to_cpu ( dev -> descriptor . idVendor ) , le16_to_cpu ( dev -> descriptor . idProduct ) ) ; if ( quirks & HID_QUIRK_IGNORE ) return - ENODEV ; if ( interface -> desc . bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT ) { if ( interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_KEYBOARD || interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_MOUSE ) quirks |= HID_QUIRK_NOGET ; } if ( usb_get_extra_descriptor ( interface , HID_DT_HID , & hdesc ) && ( ! interface -> desc . bNumEndpoints || usb_get_extra_descriptor ( & interface -> endpoint [ 0 ] , HID_DT_HID , & hdesc ) ) ) { dbg_hid ( ""class descriptor not present\\n"" ) ; return - ENODEV ; } hid -> version = le16_to_cpu ( hdesc -> bcdHID ) ; hid -> country = hdesc -> bCountryCode ; for ( n = 0 ; n < hdesc -> bNumDescriptors ; n ++ ) if ( hdesc -> desc [ n ] . bDescriptorType == HID_DT_REPORT ) rsize = le16_to_cpu ( hdesc -> desc [ n ] . wDescriptorLength ) ; if ( ! rsize || rsize > HID_MAX_DESCRIPTOR_SIZE ) { dbg_hid ( ""weird size of report descriptor (%u)\\n"" , rsize ) ; return - EINVAL ; } rdesc = kmalloc ( rsize , GFP_KERNEL ) ; if ( ! rdesc ) return - ENOMEM ; hid_set_idle ( dev , interface -> desc . bInterfaceNumber , 0 , 0 ) ; ret = hid_get_class_descriptor ( dev , interface -> desc . bInterfaceNumber , HID_DT_REPORT , rdesc , rsize ) ; if ( ret < 0 ) { dbg_hid ( ""reading report descriptor failed\\n"" ) ; kfree ( rdesc ) ; goto err ; } ret = hid_parse_report ( hid , rdesc , rsize ) ; kfree ( rdesc ) ; if ( ret ) { dbg_hid ( ""parsing report descriptor failed\\n"" ) ; goto err ; } hid -> quirks |= quirks ; return 0 ; err : return ret ; }
Fixed code:","
static int usbhid_parse ( struct hid_device * hid ) { struct usb_interface * intf = to_usb_interface ( hid -> dev . parent ) ; struct usb_host_interface * interface = intf -> cur_altsetting ; struct usb_device * dev = interface_to_usbdev ( intf ) ; struct hid_descriptor * hdesc ; u32 quirks = 0 ; unsigned int rsize = 0 ; char * rdesc ; int ret , n ; quirks = usbhid_lookup_quirk ( le16_to_cpu ( dev -> descriptor . idVendor ) , le16_to_cpu ( dev -> descriptor . idProduct ) ) ; if ( quirks & HID_QUIRK_IGNORE ) return - ENODEV ; if ( interface -> desc . bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT ) { if ( interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_KEYBOARD || interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_MOUSE ) quirks |= HID_QUIRK_NOGET ; } if ( usb_get_extra_descriptor ( interface , HID_DT_HID , & hdesc ) && ( ! interface -> desc . bNumEndpoints || usb_get_extra_descriptor ( & interface -> endpoint [ 0 ] , HID_DT_HID , & hdesc ) ) ) { dbg_hid ( ""class descriptor not present\\n"" ) ; return - ENODEV ; } if(hdesc != NULL) { hid -> version = le16_to_cpu ( hdesc -> bcdHID ) ; hid -> country = hdesc -> bCountryCode ; for ( n = 0 ; n < hdesc -> bNumDescriptors ; n ++ ) if ( hdesc -> desc [ n ] . bDescriptorType == HID_DT_REPORT ) rsize = le16_to_cpu ( hdesc -> desc [ n ] . wDescriptorLength ) ; if ( ! rsize || rsize > HID_MAX_DESCRIPTOR_SIZE ) { dbg_hid ( ""weird size of report descriptor (%u)\\n"" , rsize ) ; return - EINVAL ; } rdesc = kmalloc ( rsize , GFP_KERNEL ) ; if ( ! rdesc ) return - ENOMEM ; hid_set_idle ( dev , interface -> desc . bInterfaceNumber , 0 , 0 ) ; ret = hid_get_class_descriptor ( dev , interface -> desc . bInterfaceNumber , HID_DT_REPORT , rdesc , rsize ) ; if ( ret < 0 ) { dbg_hid ( ""reading report descriptor failed\\n"" ) ; kfree ( rdesc ) ; goto err ; } ret = hid_parse_report ( hid , rdesc , rsize ) ; kfree ( rdesc ) ; if ( ret ) { dbg_hid ( ""parsing report descriptor failed\\n"" ) ; goto err ; } hid -> quirks |= quirks ; } else { return - ENODEV ; } return 0 ; err : return ret ; }",708,-11.116028571738303,-0.015700605327313988
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int usbhid_parse ( struct hid_device * hid ) { struct usb_interface * intf = to_usb_interface ( hid -> dev . parent ) ; struct usb_host_interface * interface = intf -> cur_altsetting ; struct usb_device * dev = interface_to_usbdev ( intf ) ; struct hid_descriptor * hdesc ; u32 quirks = 0 ; unsigned int rsize = 0 ; char * rdesc ; int ret , n ; quirks = usbhid_lookup_quirk ( le16_to_cpu ( dev -> descriptor . idVendor ) , le16_to_cpu ( dev -> descriptor . idProduct ) ) ; if ( quirks & HID_QUIRK_IGNORE ) return - ENODEV ; if ( interface -> desc . bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT ) { if ( interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_KEYBOARD || interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_MOUSE ) quirks |= HID_QUIRK_NOGET ; } if ( usb_get_extra_descriptor ( interface , HID_DT_HID , & hdesc ) && ( ! interface -> desc . bNumEndpoints || usb_get_extra_descriptor ( & interface -> endpoint [ 0 ] , HID_DT_HID , & hdesc ) ) ) { dbg_hid ( ""class descriptor not present\\n"" ) ; return - ENODEV ; } hid -> version = le16_to_cpu ( hdesc -> bcdHID ) ; hid -> country = hdesc -> bCountryCode ; for ( n = 0 ; n < hdesc -> bNumDescriptors ; n ++ ) if ( hdesc -> desc [ n ] . bDescriptorType == HID_DT_REPORT ) rsize = le16_to_cpu ( hdesc -> desc [ n ] . wDescriptorLength ) ; if ( ! rsize || rsize > HID_MAX_DESCRIPTOR_SIZE ) { dbg_hid ( ""weird size of report descriptor (%u)\\n"" , rsize ) ; return - EINVAL ; } rdesc = kmalloc ( rsize , GFP_KERNEL ) ; if ( ! rdesc ) return - ENOMEM ; hid_set_idle ( dev , interface -> desc . bInterfaceNumber , 0 , 0 ) ; ret = hid_get_class_descriptor ( dev , interface -> desc . bInterfaceNumber , HID_DT_REPORT , rdesc , rsize ) ; if ( ret < 0 ) { dbg_hid ( ""reading report descriptor failed\\n"" ) ; kfree ( rdesc ) ; goto err ; } ret = hid_parse_report ( hid , rdesc , rsize ) ; kfree ( rdesc ) ; if ( ret ) { dbg_hid ( ""parsing report descriptor failed\\n"" ) ; goto err ; } hid -> quirks |= quirks ; return 0 ; err : return ret ; }
Fixed code:","
static int usbhid_parse ( struct hid_device * hid ) { struct usb_interface * intf = to_usb_interface ( hid -> dev . parent ) ; struct usb_host_interface * interface = intf -> cur_altsetting ; struct usb_device * dev = interface_to_usbdev ( intf ) ; struct hid_descriptor * hdesc ; u32 quirks = 0 ; unsigned int rsize = 0 ; char * rdesc ; int ret , n ; quirks = usbhid_lookup_quirk ( le16_to_cpu ( dev -> descriptor . idVendor ) , le16_to_cpu ( dev -> descriptor . idProduct ) ) ; if ( quirks & HID_QUIRK_IGNORE ) return - ENODEV ; if ( interface -> desc . bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT ) { if ( interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_KEYBOARD || interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_MOUSE ) quirks |= HID_QUIRK_NOGET ; } if ( usb_get_extra_descriptor ( interface , HID_DT_HID , & hdesc ) && ( ! interface -> desc . bNumEndpoints || usb_get_extra_descriptor ( & interface -> endpoint [ 0 ] , HID_DT_HID , & hdesc ) ) ) { dbg_hid ( ""class descriptor not present\\n"" ) ; return - ENODEV ; } hid -> version = le16_to_cpu ( hdesc -> bcdHID ) ; hid -> country = hdesc -> bCountryCode ; for ( n = 0 ; n < hdesc -> bNumDescriptors ; n ++ ) { if ( n > HID_MAX_DESCRIPTOR_SIZE ) { dbg_hid ( ""maximum descriptor size exceeded\\n"" ) ; return - EINVAL ; } else if ( hdesc -> desc [ n ] . bDescriptorType == HID_DT_REPORT ) { rsize = le16_to_cpu ( hdesc -> desc [ n ] . wDescriptorLength ) ; } } if ( ! rsize || rsize > HID_MAX_DESCRIPTOR_SIZE ) { dbg_hid ( ""weird size of report descriptor (%u)\\n"" , rsize ) ; return - EINVAL ; } rdesc = kmalloc ( rsize , GFP_KERNEL ) ; if ( ! rdesc ) return - ENOMEM ; hid_set_idle ( dev , interface -> desc . bInterfaceNumber , 0 , 0 ) ; ret = hid_get_class_descriptor ( dev , interface -> desc . bInterfaceNumber , HID_DT_REPORT , rdesc , rsize ) ; if ( ret < 0 ) { dbg_hid ( ""reading report descriptor failed\\n"" ) ; kfree ( rdesc ) ; goto err ; } ret = hid_parse_report ( hid , rdesc , rsize ) ; kfree ( rdesc ) ; if ( ret ) { dbg_hid ( ""parsing report descriptor failed\\n"" ) ; goto err ; } hid -> quirks |= quirks ; return 0 ; err : return ret ; }",733,-15.723082017528283,-0.021450316531416484
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int usbhid_parse ( struct hid_device * hid ) { struct usb_interface * intf = to_usb_interface ( hid -> dev . parent ) ; struct usb_host_interface * interface = intf -> cur_altsetting ; struct usb_device * dev = interface_to_usbdev ( intf ) ; struct hid_descriptor * hdesc ; u32 quirks = 0 ; unsigned int rsize = 0 ; char * rdesc ; int ret , n ; quirks = usbhid_lookup_quirk ( le16_to_cpu ( dev -> descriptor . idVendor ) , le16_to_cpu ( dev -> descriptor . idProduct ) ) ; if ( quirks & HID_QUIRK_IGNORE ) return - ENODEV ; if ( interface -> desc . bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT ) { if ( interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_KEYBOARD || interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_MOUSE ) quirks |= HID_QUIRK_NOGET ; } if ( usb_get_extra_descriptor ( interface , HID_DT_HID , & hdesc ) && ( ! interface -> desc . bNumEndpoints || usb_get_extra_descriptor ( & interface -> endpoint [ 0 ] , HID_DT_HID , & hdesc ) ) ) { dbg_hid ( ""class descriptor not present\\n"" ) ; return - ENODEV ; } hid -> version = le16_to_cpu ( hdesc -> bcdHID ) ; hid -> country = hdesc -> bCountryCode ; for ( n = 0 ; n < hdesc -> bNumDescriptors ; n ++ ) if ( hdesc -> desc [ n ] . bDescriptorType == HID_DT_REPORT ) rsize = le16_to_cpu ( hdesc -> desc [ n ] . wDescriptorLength ) ; if ( ! rsize || rsize > HID_MAX_DESCRIPTOR_SIZE ) { dbg_hid ( ""weird size of report descriptor (%u)\\n"" , rsize ) ; return - EINVAL ; } rdesc = kmalloc ( rsize , GFP_KERNEL ) ; if ( ! rdesc ) return - ENOMEM ; hid_set_idle ( dev , interface -> desc . bInterfaceNumber , 0 , 0 ) ; ret = hid_get_class_descriptor ( dev , interface -> desc . bInterfaceNumber , HID_DT_REPORT , rdesc , rsize ) ; if ( ret < 0 ) { dbg_hid ( ""reading report descriptor failed\\n"" ) ; kfree ( rdesc ) ; goto err ; } ret = hid_parse_report ( hid , rdesc , rsize ) ; kfree ( rdesc ) ; if ( ret ) { dbg_hid ( ""parsing report descriptor failed\\n"" ) ; goto err ; } hid -> quirks |= quirks ; return 0 ; err : return ret ; }
Fixed code:","
static int usbhid_parse ( struct hid_device * hid ) { struct usb_interface * intf = to_usb_interface ( hid -> dev . parent ) ; struct usb_host_interface * interface = intf -> cur_altsetting ; struct usb_device * dev = interface_to_usbdev ( intf ) ; struct hid_descriptor * hdesc ; u32 quirks = 0 ; unsigned int rsize = 0 ; char * rdesc ; int ret , n ; quirks = usbhid_lookup_quirk ( le16_to_cpu ( dev -> descriptor . idVendor ) , le16_to_cpu ( dev -> descriptor . idProduct ) ) ; if ( quirks & HID_QUIRK_IGNORE ) return - ENODEV ; if ( interface -> desc . bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT ) { if ( interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_KEYBOARD || interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_MOUSE ) quirks |= HID_QUIRK_NOGET ; } if ( ! usb_get_extra_descriptor ( interface , HID_DT_HID , & hdesc ) && ( interface -> desc . bNumEndpoints && ! usb_get_extra_descriptor ( & interface -> endpoint [ 0 ] , HID_DT_HID , & hdesc ) ) ) { dbg_hid ( ""class descriptor not present\\n"" ) ; return - ENODEV ; } hid -> version = le16_to_cpu ( hdesc -> bcdHID ) ; hid -> country = hdesc -> bCountryCode ; for ( n = 0 ; n < hdesc -> bNumDescriptors ; n ++ ) if ( hdesc -> desc [ n ] . bDescriptorType == HID_DT_REPORT ) rsize = le16_to_cpu ( hdesc -> desc [ n ] . wDescriptorLength ) ; if ( ! rsize || rsize > HID_MAX_DESCRIPTOR_SIZE ) { dbg_hid ( ""weird size of report descriptor (%u)\\n"" , rsize ) ; return - EINVAL ; } if ( rsize > 0 ) { rdesc = kmalloc ( rsize , GFP_KERNEL ) ; if ( ! rdesc ) return - ENOMEM ; } else { return - EINVAL ; } hid_set_idle ( dev , interface -> desc . bInterfaceNumber , 0 , 0 ) ; ret = hid_get_class_descriptor ( dev , interface -> desc . bInterfaceNumber , HID_DT_REPORT , rdesc , rsize ) ; if ( ret < 0 ) { dbg_hid ( ""reading report descriptor failed\\n"" ) ; kfree ( rdesc ) ; goto err ; } ret = hid_parse_report ( hid , rdesc , rsize ) ; kfree ( rdesc ) ; if ( ret ) { dbg_hid ( ""parsing report descriptor failed\\n"" ) ; goto err ; } hid -> quirks |= quirks ; return 0 ; err : return ret ; }",709,-15.794357359245465,-0.022276949730952702
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int usbhid_parse ( struct hid_device * hid ) { struct usb_interface * intf = to_usb_interface ( hid -> dev . parent ) ; struct usb_host_interface * interface = intf -> cur_altsetting ; struct usb_device * dev = interface_to_usbdev ( intf ) ; struct hid_descriptor * hdesc ; u32 quirks = 0 ; unsigned int rsize = 0 ; char * rdesc ; int ret , n ; quirks = usbhid_lookup_quirk ( le16_to_cpu ( dev -> descriptor . idVendor ) , le16_to_cpu ( dev -> descriptor . idProduct ) ) ; if ( quirks & HID_QUIRK_IGNORE ) return - ENODEV ; if ( interface -> desc . bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT ) { if ( interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_KEYBOARD || interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_MOUSE ) quirks |= HID_QUIRK_NOGET ; } if ( usb_get_extra_descriptor ( interface , HID_DT_HID , & hdesc ) && ( ! interface -> desc . bNumEndpoints || usb_get_extra_descriptor ( & interface -> endpoint [ 0 ] , HID_DT_HID , & hdesc ) ) ) { dbg_hid ( ""class descriptor not present\\n"" ) ; return - ENODEV ; } hid -> version = le16_to_cpu ( hdesc -> bcdHID ) ; hid -> country = hdesc -> bCountryCode ; for ( n = 0 ; n < hdesc -> bNumDescriptors ; n ++ ) if ( hdesc -> desc [ n ] . bDescriptorType == HID_DT_REPORT ) rsize = le16_to_cpu ( hdesc -> desc [ n ] . wDescriptorLength ) ; if ( ! rsize || rsize > HID_MAX_DESCRIPTOR_SIZE ) { dbg_hid ( ""weird size of report descriptor (%u)\\n"" , rsize ) ; return - EINVAL ; } rdesc = kmalloc ( rsize , GFP_KERNEL ) ; if ( ! rdesc ) return - ENOMEM ; hid_set_idle ( dev , interface -> desc . bInterfaceNumber , 0 , 0 ) ; ret = hid_get_class_descriptor ( dev , interface -> desc . bInterfaceNumber , HID_DT_REPORT , rdesc , rsize ) ; if ( ret < 0 ) { dbg_hid ( ""reading report descriptor failed\\n"" ) ; kfree ( rdesc ) ; goto err ; } ret = hid_parse_report ( hid , rdesc , rsize ) ; kfree ( rdesc ) ; if ( ret ) { dbg_hid ( ""parsing report descriptor failed\\n"" ) ; goto err ; } hid -> quirks |= quirks ; return 0 ; err : return ret ; }
Fixed code:","

static int usbhid_parse ( struct hid_device * hid ) { struct usb_interface * intf = to_usb_interface ( hid -> dev . parent ) ; struct usb_host_interface * interface = intf -> cur_altsetting ; struct usb_device * dev = interface_to_usbdev ( intf ) ; struct hid_descriptor * hdesc ; u32 quirks = 0 ; unsigned int rsize = 0 ; char * rdesc ; int ret , n ; quirks = usbhid_lookup_quirk ( le16_to_cpu ( dev -> descriptor . idVendor ) , le16_to_cpu ( dev -> descriptor . idProduct ) ) ; if ( quirks & HID_QUIRK_IGNORE ) return - ENODEV ; if ( interface -> desc . bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT ) { if ( interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_KEYBOARD || interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_MOUSE ) quirks |= HID_QUIRK_NOGET ; } if ( usb_get_extra_descriptor ( interface , HID_DT_HID , & hdesc ) && ( ! interface -> desc . bNumEndpoints || usb_get_extra_descriptor ( & interface -> endpoint [ 0 ] , HID_DT_HID , & hdesc ) ) ) { dbg_hid ( ""class descriptor not present\\n"" ) ; return - ENODEV ; } if (hdesc == NULL) { dbg_hid(""error: hdesc is null\\n""); return -EINVAL; } hid -> version = le16_to_cpu ( hdesc -> bcdHID ) ; hid -> country = hdesc -> bCountryCode ; for ( n = 0 ; n < hdesc -> bNumDescriptors ; n ++ ) if ( hdesc -> desc [ n ] . bDescriptorType == HID_DT_REPORT ) rsize = le16_to_cpu ( hdesc -> desc [ n ] . wDescriptorLength ) ; if ( ! rsize || rsize > HID_MAX_DESCRIPTOR_SIZE ) { dbg_hid ( ""weird size of report descriptor (%u)\\n"" , rsize ) ; return - EINVAL ; } rdesc = kmalloc ( rsize , GFP_KERNEL ) ; if ( ! rdesc ) return - ENOMEM ; hid_set_idle ( dev , interface -> desc . bInterfaceNumber , 0 , 0 ) ; ret = hid_get_class_descriptor ( dev , interface -> desc . bInterfaceNumber , HID_DT_REPORT , rdesc , rsize ) ; if ( ret < 0 ) { dbg_hid ( ""reading report descriptor failed\\n"" ) ; kfree ( rdesc ) ; goto err ; } ret = hid_parse_report ( hid , rdesc , rsize ) ; kfree ( rdesc ) ; if ( ret ) { dbg_hid ( ""parsing report descriptor failed\\n"" ) ; goto err ; } hid -> quirks |= quirks ; return 0 ; err : return ret ; }",720,-14.457076245765542,-0.020079272563563254
