Original code,Plausible Program,Total Tokens,Sum Entropy,Mean Entropy
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev1_t_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto , int depth _U_ ) { const struct ikev1_pl_t * p ; struct ikev1_pl_t t ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; ND_PRINT ( ( ndo , ""%s:"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; p = ( const struct ikev1_pl_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; switch ( proto ) { case 1 : idstr = STR_OR_ID ( t . t_id , ikev1_p_map ) ; map = oakley_t_map ; nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ; break ; case 2 : idstr = STR_OR_ID ( t . t_id , ah_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 3 : idstr = STR_OR_ID ( t . t_id , esp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 4 : idstr = STR_OR_ID ( t . t_id , ipcomp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; default : idstr = NULL ; map = NULL ; nmap = 0 ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%d id=%s "" , t . t_no , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%d id=%d "" , t . t_no , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev1_t_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto , int depth _U_ ) { const struct ikev1_pl_t * p ; struct ikev1_pl_t t ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; ND_PRINT ( ( ndo , ""%s:"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; if (item_len < sizeof(struct ikev1_pl_t)) { return NULL; } p = ( const struct ikev1_pl_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; switch ( proto ) { case 1 : idstr = STR_OR_ID ( t . t_id , ikev1_p_map ) ; map = oakley_t_map ; nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ; break ; case 2 : idstr = STR_OR_ID ( t . t_id , ah_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 3 : idstr = STR_OR_ID ( t . t_id , esp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 4 : idstr = STR_OR_ID ( t . t_id , ipcomp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; default : idstr = NULL ; map = NULL ; nmap = 0 ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%d id=%s "" , t . t_no , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%d id=%d "" , t . t_no , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else if (cp + sizeof(struct isakmp_gen) <= ep2) { cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } else {break;} } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }",792,-19.11385152735159,-0.024133650918373217
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev1_t_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto , int depth _U_ ) { const struct ikev1_pl_t * p ; struct ikev1_pl_t t ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; ND_PRINT ( ( ndo , ""%s:"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; p = ( const struct ikev1_pl_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; switch ( proto ) { case 1 : idstr = STR_OR_ID ( t . t_id , ikev1_p_map ) ; map = oakley_t_map ; nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ; break ; case 2 : idstr = STR_OR_ID ( t . t_id , ah_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 3 : idstr = STR_OR_ID ( t . t_id , esp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 4 : idstr = STR_OR_ID ( t . t_id , ipcomp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; default : idstr = NULL ; map = NULL ; nmap = 0 ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%d id=%s "" , t . t_no , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%d id=%d "" , t . t_no , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev1_t_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto , int depth _U_ ) { const struct ikev1_pl_t * p ; struct ikev1_pl_t t ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; ND_PRINT ( ( ndo , ""%s:"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; 

if (item_len < sizeof(struct ikev1_pl_t)) {
   ND_PRINT((ndo, "" [|%s]"", NPSTR(ISAKMP_NPTYPE_T)));
   return NULL;
}

p = ( const struct ikev1_pl_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; switch ( proto ) { case 1 : idstr = STR_OR_ID ( t . t_id , ikev1_p_map ) ; map = oakley_t_map ; nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ; break ; case 2 : idstr = STR_OR_ID ( t . t_id , ah_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 3 : idstr = STR_OR_ID ( t . t_id , esp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 4 : idstr = STR_OR_ID ( t . t_id , ipcomp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; default : idstr = NULL ; map = NULL ; nmap = 0 ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%d id=%s "" , t . t_no , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%d id=%d "" , t . t_no , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }",806,-15.829547664883446,-0.019639637301344225
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev1_t_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto , int depth _U_ ) { const struct ikev1_pl_t * p ; struct ikev1_pl_t t ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; ND_PRINT ( ( ndo , ""%s:"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; p = ( const struct ikev1_pl_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; switch ( proto ) { case 1 : idstr = STR_OR_ID ( t . t_id , ikev1_p_map ) ; map = oakley_t_map ; nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ; break ; case 2 : idstr = STR_OR_ID ( t . t_id , ah_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 3 : idstr = STR_OR_ID ( t . t_id , esp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 4 : idstr = STR_OR_ID ( t . t_id , ipcomp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; default : idstr = NULL ; map = NULL ; nmap = 0 ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%d id=%s "" , t . t_no , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%d id=%d "" , t . t_no , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev1_t_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto , int depth _U_ ) { const struct ikev1_pl_t * p ; struct ikev1_pl_t t ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; ND_PRINT ( ( ndo , ""%s:"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; p = ( const struct ikev1_pl_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; switch ( proto ) { case 1 : idstr = STR_OR_ID ( t . t_id , ikev1_p_map ) ; map = oakley_t_map ; nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ; break ; case 2 : idstr = STR_OR_ID ( t . t_id , ah_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 3 : idstr = STR_OR_ID ( t . t_id , esp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 4 : idstr = STR_OR_ID ( t . t_id , ipcomp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; default : idstr = NULL ; map = NULL ; nmap = 0 ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%d id=%s "" , t . t_no , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%d id=%d "" , t . t_no , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && ep2 - cp >= 0 ) { // Fixed if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }",750,-17.99150685578706,-0.02398867580771608
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev1_t_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto , int depth _U_ ) { const struct ikev1_pl_t * p ; struct ikev1_pl_t t ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; ND_PRINT ( ( ndo , ""%s:"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; p = ( const struct ikev1_pl_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; switch ( proto ) { case 1 : idstr = STR_OR_ID ( t . t_id , ikev1_p_map ) ; map = oakley_t_map ; nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ; break ; case 2 : idstr = STR_OR_ID ( t . t_id , ah_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 3 : idstr = STR_OR_ID ( t . t_id , esp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 4 : idstr = STR_OR_ID ( t . t_id , ipcomp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; default : idstr = NULL ; map = NULL ; nmap = 0 ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%d id=%s "" , t . t_no , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%d id=%d "" , t . t_no , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }
Fixed code:","

static const u_char * ikev1_t_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto , int depth _U_ ) { const struct ikev1_pl_t * p ; struct ikev1_pl_t t ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; ND_PRINT ( ( ndo , ""%s:"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; p = ( const struct ikev1_pl_t * ) ext ; ND_TCHECK ( * p ) ;  // Verify that memory read is within bounds
  UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; switch ( proto ) { case 1 : idstr = STR_OR_ID ( t . t_id , ikev1_p_map ) ; map = oakley_t_map ; nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ; break ; case 2 : idstr = STR_OR_ID ( t . t_id , ah_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 3 : idstr = STR_OR_ID ( t . t_id , esp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 4 : idstr = STR_OR_ID ( t . t_id , ipcomp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; default : idstr = NULL ; map = NULL ; nmap = 0 ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%d id=%s "" , t . t_no , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%d id=%d "" , t . t_no , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; 

// Add check to prevent reading beyond the specified item_len 
if (ep2 < (cp + item_len)) {
  ep2 = (cp + item_len);
}

while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }",804,-64.86123936663576,-0.08067318329183552
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev1_t_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto , int depth _U_ ) { const struct ikev1_pl_t * p ; struct ikev1_pl_t t ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; ND_PRINT ( ( ndo , ""%s:"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; p = ( const struct ikev1_pl_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; switch ( proto ) { case 1 : idstr = STR_OR_ID ( t . t_id , ikev1_p_map ) ; map = oakley_t_map ; nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ; break ; case 2 : idstr = STR_OR_ID ( t . t_id , ah_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 3 : idstr = STR_OR_ID ( t . t_id , esp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 4 : idstr = STR_OR_ID ( t . t_id , ipcomp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; default : idstr = NULL ; map = NULL ; nmap = 0 ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%d id=%s "" , t . t_no , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%d id=%d "" , t . t_no , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }
Fixed code:","

static const u_char * ikev1_t_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto , int depth _U_ ) { const struct ikev1_pl_t * p ; struct ikev1_pl_t t ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; ND_PRINT ( ( ndo , ""%s:"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; p = ( const struct ikev1_pl_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; switch ( proto ) { case 1 : idstr = STR_OR_ID ( t . t_id , ikev1_p_map ) ; map = oakley_t_map ; nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ; break ; case 2 : idstr = STR_OR_ID ( t . t_id , ah_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 3 : idstr = STR_OR_ID ( t . t_id , esp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 4 : idstr = STR_OR_ID ( t . t_id , ipcomp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; default : idstr = NULL ; map = NULL ; nmap = 0 ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%d id=%s "" , t . t_no , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%d id=%d "" , t . t_no , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { 
  //Add check to ensure cp + length is not beyond the ep2
  if (cp + length > ep2) {
    ND_PRINT((ndo, ""..."")); 
    break;
  }
  if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } 
  if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }",802,-46.414637795875215,-0.05787361321181448
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev1_t_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto , int depth _U_ ) { const struct ikev1_pl_t * p ; struct ikev1_pl_t t ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; ND_PRINT ( ( ndo , ""%s:"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; p = ( const struct ikev1_pl_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; switch ( proto ) { case 1 : idstr = STR_OR_ID ( t . t_id , ikev1_p_map ) ; map = oakley_t_map ; nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ; break ; case 2 : idstr = STR_OR_ID ( t . t_id , ah_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 3 : idstr = STR_OR_ID ( t . t_id , esp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 4 : idstr = STR_OR_ID ( t . t_id , ipcomp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; default : idstr = NULL ; map = NULL ; nmap = 0 ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%d id=%s "" , t . t_no , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%d id=%d "" , t . t_no , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev1_t_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto , int depth _U_ ) { const struct ikev1_pl_t * p ; struct ikev1_pl_t t ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; ND_PRINT ( ( ndo , ""%s:"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; if (item_len < sizeof ( struct ikev1_pl_t )) { ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; } p = ( const struct ikev1_pl_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; switch ( proto ) { case 1 : idstr = STR_OR_ID ( t . t_id , ikev1_p_map ) ; map = oakley_t_map ; nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ; break ; case 2 : idstr = STR_OR_ID ( t . t_id , ah_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 3 : idstr = STR_OR_ID ( t . t_id , esp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 4 : idstr = STR_OR_ID ( t . t_id , ipcomp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; default : idstr = NULL ; map = NULL ; nmap = 0 ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%d id=%s "" , t . t_no , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%d id=%d "" , t . t_no , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( cp + sizeof(struct isakmp_gen) > ep2 ) { ND_PRINT ( ( ndo , ""..."" ) ) ; break; } if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }",813,-17.760509800821154,-0.021845645511465134
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev1_t_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto , int depth _U_ ) { const struct ikev1_pl_t * p ; struct ikev1_pl_t t ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; ND_PRINT ( ( ndo , ""%s:"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; p = ( const struct ikev1_pl_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; switch ( proto ) { case 1 : idstr = STR_OR_ID ( t . t_id , ikev1_p_map ) ; map = oakley_t_map ; nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ; break ; case 2 : idstr = STR_OR_ID ( t . t_id , ah_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 3 : idstr = STR_OR_ID ( t . t_id , esp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 4 : idstr = STR_OR_ID ( t . t_id , ipcomp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; default : idstr = NULL ; map = NULL ; nmap = 0 ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%d id=%s "" , t . t_no , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%d id=%d "" , t . t_no , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev1_t_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto , int depth _U_ ) { const struct ikev1_pl_t * p ; struct ikev1_pl_t t ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; ND_PRINT ( ( ndo , ""%s:"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; p = ( const struct ikev1_pl_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; switch ( proto ) { case 1 : idstr = STR_OR_ID ( t . t_id , ikev1_p_map ) ; map = oakley_t_map ; nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ; break ; case 2 : idstr = STR_OR_ID ( t . t_id , ah_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 3 : idstr = STR_OR_ID ( t . t_id , esp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 4 : idstr = STR_OR_ID ( t . t_id , ipcomp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; default : idstr = NULL ; map = NULL ; nmap = 0 ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%d id=%s "" , t . t_no , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%d id=%d "" , t . t_no , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp + sizeof(struct isakmp_gen) < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }",756,-8.341455317262707,-0.0110336710545803
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev1_t_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto , int depth _U_ ) { const struct ikev1_pl_t * p ; struct ikev1_pl_t t ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; ND_PRINT ( ( ndo , ""%s:"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; p = ( const struct ikev1_pl_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; switch ( proto ) { case 1 : idstr = STR_OR_ID ( t . t_id , ikev1_p_map ) ; map = oakley_t_map ; nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ; break ; case 2 : idstr = STR_OR_ID ( t . t_id , ah_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 3 : idstr = STR_OR_ID ( t . t_id , esp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 4 : idstr = STR_OR_ID ( t . t_id , ipcomp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; default : idstr = NULL ; map = NULL ; nmap = 0 ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%d id=%s "" , t . t_no , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%d id=%d "" , t . t_no , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev1_t_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto , int depth _U_ ) { const struct ikev1_pl_t * p ; struct ikev1_pl_t t ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; ND_PRINT ( ( ndo , ""%s:"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; p = ( const struct ikev1_pl_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; switch ( proto ) { case 1 : idstr = STR_OR_ID ( t . t_id , ikev1_p_map ) ; map = oakley_t_map ; nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ; break ; case 2 : idstr = STR_OR_ID ( t . t_id , ah_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 3 : idstr = STR_OR_ID ( t . t_id , esp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 4 : idstr = STR_OR_ID ( t . t_id , ipcomp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; default : idstr = NULL ; map = NULL ; nmap = 0 ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%d id=%s "" , t . t_no , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%d id=%d "" , t . t_no , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 && (ep2 - cp) > 0) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }",755,-7.3341463947577035,-0.009714101185109542
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev1_t_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto , int depth _U_ ) { const struct ikev1_pl_t * p ; struct ikev1_pl_t t ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; ND_PRINT ( ( ndo , ""%s:"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; p = ( const struct ikev1_pl_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; switch ( proto ) { case 1 : idstr = STR_OR_ID ( t . t_id , ikev1_p_map ) ; map = oakley_t_map ; nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ; break ; case 2 : idstr = STR_OR_ID ( t . t_id , ah_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 3 : idstr = STR_OR_ID ( t . t_id , esp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 4 : idstr = STR_OR_ID ( t . t_id , ipcomp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; default : idstr = NULL ; map = NULL ; nmap = 0 ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%d id=%s "" , t . t_no , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%d id=%d "" , t . t_no , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }
Fixed code:","

static const u_char * ikev1_t_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto , int depth _U_ ) { const struct ikev1_pl_t * p ; struct ikev1_pl_t t ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; ND_PRINT ( ( ndo , ""%s:"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; p = ( const struct ikev1_pl_t * ) ext ; if(item_len >= sizeof(t)) { ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; } else {
  ND_PRINT((ndo, ""Malformed packet detected: Length of item is smaller than size of t""));
  return NULL;
} switch ( proto ) { case 1 : idstr = STR_OR_ID ( t . t_id , ikev1_p_map ) ; map = oakley_t_map ; nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ; break ; case 2 : idstr = STR_OR_ID ( t . t_id , ah_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 3 : idstr = STR_OR_ID ( t . t_id , esp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 4 : idstr = STR_OR_ID ( t . t_id , ipcomp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; default : idstr = NULL ; map = NULL ; nmap = 0 ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%d id=%s "" , t . t_no , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%d id=%d "" , t . t_no , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; if ( cp > ep2 ) {
  ND_PRINT((ndo, ""Malformed packet detected: Attempted to read past end of item""));
  return NULL;
} } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }",836,-55.28646339386995,-0.06613213324625593
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev1_t_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto , int depth _U_ ) { const struct ikev1_pl_t * p ; struct ikev1_pl_t t ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; ND_PRINT ( ( ndo , ""%s:"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; p = ( const struct ikev1_pl_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; switch ( proto ) { case 1 : idstr = STR_OR_ID ( t . t_id , ikev1_p_map ) ; map = oakley_t_map ; nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ; break ; case 2 : idstr = STR_OR_ID ( t . t_id , ah_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 3 : idstr = STR_OR_ID ( t . t_id , esp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 4 : idstr = STR_OR_ID ( t . t_id , ipcomp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; default : idstr = NULL ; map = NULL ; nmap = 0 ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%d id=%s "" , t . t_no , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%d id=%d "" , t . t_no , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev1_t_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto , int depth _U_ ) { const struct ikev1_pl_t * p ; struct ikev1_pl_t t ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; ND_PRINT ( ( ndo , ""%s:"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; if (item_len < sizeof(struct ikev1_pl_t)) { goto trunc; } p = ( const struct ikev1_pl_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; switch ( proto ) { case 1 : idstr = STR_OR_ID ( t . t_id , ikev1_p_map ) ; map = oakley_t_map ; nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ; break ; case 2 : idstr = STR_OR_ID ( t . t_id , ah_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 3 : idstr = STR_OR_ID ( t . t_id , esp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 4 : idstr = STR_OR_ID ( t . t_id , ipcomp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; default : idstr = NULL ; map = NULL ; nmap = 0 ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%d id=%s "" , t . t_no , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%d id=%d "" , t . t_no , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 && ep2 - cp >= sizeof(struct isakmp_gen) ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }",784,-13.662502172578897,-0.017426660934411857
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev1_t_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto , int depth _U_ ) { const struct ikev1_pl_t * p ; struct ikev1_pl_t t ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; ND_PRINT ( ( ndo , ""%s:"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; p = ( const struct ikev1_pl_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; switch ( proto ) { case 1 : idstr = STR_OR_ID ( t . t_id , ikev1_p_map ) ; map = oakley_t_map ; nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ; break ; case 2 : idstr = STR_OR_ID ( t . t_id , ah_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 3 : idstr = STR_OR_ID ( t . t_id , esp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 4 : idstr = STR_OR_ID ( t . t_id , ipcomp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; default : idstr = NULL ; map = NULL ; nmap = 0 ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%d id=%s "" , t . t_no , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%d id=%d "" , t . t_no , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev1_t_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto , int depth _U_ ) { const struct ikev1_pl_t * p ; struct ikev1_pl_t t ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; ND_PRINT ( ( ndo , ""%s:"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; p = ( const struct ikev1_pl_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; switch ( proto ) { case 1 : idstr = STR_OR_ID ( t . t_id , ikev1_p_map ) ; map = oakley_t_map ; nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ; break ; case 2 : idstr = STR_OR_ID ( t . t_id , ah_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 3 : idstr = STR_OR_ID ( t . t_id , esp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 4 : idstr = STR_OR_ID ( t . t_id , ipcomp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; default : idstr = NULL ; map = NULL ; nmap = 0 ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%d id=%s "" , t . t_no , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%d id=%d "" , t . t_no , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp <= ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }
The changed code fixes the vulnerability by replacing ""<"" with ""<="" when comparing cp and ep2. This prevents the code from reading past the bounds of the allocated memory.",781,-31.822865527491295,-0.04074630669333072
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev1_t_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto , int depth _U_ ) { const struct ikev1_pl_t * p ; struct ikev1_pl_t t ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; ND_PRINT ( ( ndo , ""%s:"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; p = ( const struct ikev1_pl_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; switch ( proto ) { case 1 : idstr = STR_OR_ID ( t . t_id , ikev1_p_map ) ; map = oakley_t_map ; nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ; break ; case 2 : idstr = STR_OR_ID ( t . t_id , ah_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 3 : idstr = STR_OR_ID ( t . t_id , esp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 4 : idstr = STR_OR_ID ( t . t_id , ipcomp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; default : idstr = NULL ; map = NULL ; nmap = 0 ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%d id=%s "" , t . t_no , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%d id=%d "" , t . t_no , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev1_t_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto , int depth _U_ ) { const struct ikev1_pl_t * p ; struct ikev1_pl_t t ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; ND_PRINT ( ( ndo , ""%s:"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; 
 
//added check to prevent out of bounds read
if (ext + item_len > ep) {
ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ;
 return NULL ;
 } 
p = ( const struct ikev1_pl_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; switch ( proto ) { case 1 : idstr = STR_OR_ID ( t . t_id , ikev1_p_map ) ; map = oakley_t_map ; nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ; break ; case 2 : idstr = STR_OR_ID ( t . t_id , ah_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 3 : idstr = STR_OR_ID ( t . t_id , esp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 4 : idstr = STR_OR_ID ( t . t_id , ipcomp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; default : idstr = NULL ; map = NULL ; nmap = 0 ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%d id=%s "" , t . t_no , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%d id=%d "" , t . t_no , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }",810,-39.01699191065965,-0.048169125815629196
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev1_t_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto , int depth _U_ ) { const struct ikev1_pl_t * p ; struct ikev1_pl_t t ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; ND_PRINT ( ( ndo , ""%s:"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; p = ( const struct ikev1_pl_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; switch ( proto ) { case 1 : idstr = STR_OR_ID ( t . t_id , ikev1_p_map ) ; map = oakley_t_map ; nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ; break ; case 2 : idstr = STR_OR_ID ( t . t_id , ah_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 3 : idstr = STR_OR_ID ( t . t_id , esp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 4 : idstr = STR_OR_ID ( t . t_id , ipcomp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; default : idstr = NULL ; map = NULL ; nmap = 0 ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%d id=%s "" , t . t_no , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%d id=%d "" , t . t_no , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev1_t_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto , int depth _U_ ) { const struct ikev1_pl_t * p ; struct ikev1_pl_t t ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; ND_PRINT ( ( ndo , ""%s:"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; p = ( const struct ikev1_pl_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; switch ( proto ) { case 1 : idstr = STR_OR_ID ( t . t_id , ikev1_p_map ) ; map = oakley_t_map ; nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ; break ; case 2 : idstr = STR_OR_ID ( t . t_id , ah_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 3 : idstr = STR_OR_ID ( t . t_id , esp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 4 : idstr = STR_OR_ID ( t . t_id , ipcomp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; default : idstr = NULL ; map = NULL ; nmap = 0 ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%d id=%s "" , t . t_no , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%d id=%d "" , t . t_no , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 && cp < ep + sizeof(struct ikev1_pl_t) ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }",763,-10.099926151953493,-0.013237124707671681
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev1_t_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto , int depth _U_ ) { const struct ikev1_pl_t * p ; struct ikev1_pl_t t ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; ND_PRINT ( ( ndo , ""%s:"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; p = ( const struct ikev1_pl_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; switch ( proto ) { case 1 : idstr = STR_OR_ID ( t . t_id , ikev1_p_map ) ; map = oakley_t_map ; nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ; break ; case 2 : idstr = STR_OR_ID ( t . t_id , ah_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 3 : idstr = STR_OR_ID ( t . t_id , esp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 4 : idstr = STR_OR_ID ( t . t_id , ipcomp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; default : idstr = NULL ; map = NULL ; nmap = 0 ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%d id=%s "" , t . t_no , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%d id=%d "" , t . t_no , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev1_t_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto , int depth _U_ ) { const struct ikev1_pl_t * p ; struct ikev1_pl_t t ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; ND_PRINT ( ( ndo , ""%s:"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; p = ( const struct ikev1_pl_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; switch ( proto ) { case 1 : idstr = STR_OR_ID ( t . t_id , ikev1_p_map ) ; map = oakley_t_map ; nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ; break ; case 2 : idstr = STR_OR_ID ( t . t_id , ah_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 3 : idstr = STR_OR_ID ( t . t_id , esp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 4 : idstr = STR_OR_ID ( t . t_id , ipcomp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; default : idstr = NULL ; map = NULL ; nmap = 0 ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%d id=%s "" , t . t_no , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%d id=%d "" , t . t_no , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp + sizeof(struct isakmp_gen) < ep && cp + sizeof(struct isakmp_gen) < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }
The vulnerability was fixed by adding ""+ sizeof(struct isakmp_gen)"" to the while loop so that it checks if cp plus the size of the struct isakmp_gen is less than ep and ep2. This makes sure that cp is within bounds and prevents out-of-bounds reads.",830,-48.73212247796434,-0.05871340057586065
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev1_t_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto , int depth _U_ ) { const struct ikev1_pl_t * p ; struct ikev1_pl_t t ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; ND_PRINT ( ( ndo , ""%s:"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; p = ( const struct ikev1_pl_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; switch ( proto ) { case 1 : idstr = STR_OR_ID ( t . t_id , ikev1_p_map ) ; map = oakley_t_map ; nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ; break ; case 2 : idstr = STR_OR_ID ( t . t_id , ah_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 3 : idstr = STR_OR_ID ( t . t_id , esp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 4 : idstr = STR_OR_ID ( t . t_id , ipcomp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; default : idstr = NULL ; map = NULL ; nmap = 0 ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%d id=%s "" , t . t_no , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%d id=%d "" , t . t_no , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev1_t_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto , int depth _U_ ) { const struct ikev1_pl_t * p ; struct ikev1_pl_t t ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; 

//Added the check to ensure item_len is not too large
if (item_len > sizeof(struct ikev1_pl_t)) {
    return NULL;
}

ND_PRINT ( ( ndo , ""%s:"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; p = ( const struct ikev1_pl_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; switch ( proto ) { case 1 : idstr = STR_OR_ID ( t . t_id , ikev1_p_map ) ; map = oakley_t_map ; nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ; break ; case 2 : idstr = STR_OR_ID ( t . t_id , ah_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 3 : idstr = STR_OR_ID ( t . t_id , esp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 4 : idstr = STR_OR_ID ( t . t_id , ipcomp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; default : idstr = NULL ; map = NULL ; nmap = 0 ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%d id=%s "" , t . t_no , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%d id=%d "" , t . t_no , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }",791,-29.69891362469939,-0.03754603492376661
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev1_t_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto , int depth _U_ ) { const struct ikev1_pl_t * p ; struct ikev1_pl_t t ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; ND_PRINT ( ( ndo , ""%s:"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; p = ( const struct ikev1_pl_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; switch ( proto ) { case 1 : idstr = STR_OR_ID ( t . t_id , ikev1_p_map ) ; map = oakley_t_map ; nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ; break ; case 2 : idstr = STR_OR_ID ( t . t_id , ah_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 3 : idstr = STR_OR_ID ( t . t_id , esp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 4 : idstr = STR_OR_ID ( t . t_id , ipcomp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; default : idstr = NULL ; map = NULL ; nmap = 0 ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%d id=%s "" , t . t_no , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%d id=%d "" , t . t_no , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev1_t_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto , int depth _U_ ) { const struct ikev1_pl_t * p ; struct ikev1_pl_t t ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; ND_PRINT ( ( ndo , ""%s:"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; p = ( const struct ikev1_pl_t * ) ext ; ND_TCHECK ( * p ) ; if (item_len < sizeof(struct ikev1_pl_t)) {ND_PRINT((ndo, "" [length %u < %zu]"", item_len, sizeof(struct ikev1_pl_t))); goto trunc; } UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; switch ( proto ) { case 1 : idstr = STR_OR_ID ( t . t_id , ikev1_p_map ) ; map = oakley_t_map ; nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ; break ; case 2 : idstr = STR_OR_ID ( t . t_id , ah_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 3 : idstr = STR_OR_ID ( t . t_id , esp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 4 : idstr = STR_OR_ID ( t . t_id , ipcomp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; default : idstr = NULL ; map = NULL ; nmap = 0 ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%d id=%s "" , t . t_no , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%d id=%d "" , t . t_no , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ep2, map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }",786,-28.926345594180557,-0.03680196640480987
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev1_t_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto , int depth _U_ ) { const struct ikev1_pl_t * p ; struct ikev1_pl_t t ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; ND_PRINT ( ( ndo , ""%s:"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; p = ( const struct ikev1_pl_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; switch ( proto ) { case 1 : idstr = STR_OR_ID ( t . t_id , ikev1_p_map ) ; map = oakley_t_map ; nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ; break ; case 2 : idstr = STR_OR_ID ( t . t_id , ah_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 3 : idstr = STR_OR_ID ( t . t_id , esp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 4 : idstr = STR_OR_ID ( t . t_id , ipcomp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; default : idstr = NULL ; map = NULL ; nmap = 0 ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%d id=%s "" , t . t_no , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%d id=%d "" , t . t_no , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev1_t_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto , int depth _U_ ) { const struct ikev1_pl_t * p ; struct ikev1_pl_t t ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; ND_PRINT ( ( ndo , ""%s:"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; p = ( const struct ikev1_pl_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; switch ( proto ) { case 1 : idstr = STR_OR_ID ( t . t_id , ikev1_p_map ) ; map = oakley_t_map ; nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ; break ; case 2 : idstr = STR_OR_ID ( t . t_id , ah_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 3 : idstr = STR_OR_ID ( t . t_id , esp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 4 : idstr = STR_OR_ID ( t . t_id , ipcomp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; default : idstr = NULL ; map = NULL ; nmap = 0 ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%d id=%s "" , t . t_no , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%d id=%d "" , t . t_no , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 && ep2 <= ep + item_len ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }",755,-8.9516651168553,-0.011856510088550067
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev1_t_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto , int depth _U_ ) { const struct ikev1_pl_t * p ; struct ikev1_pl_t t ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; ND_PRINT ( ( ndo , ""%s:"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; p = ( const struct ikev1_pl_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; switch ( proto ) { case 1 : idstr = STR_OR_ID ( t . t_id , ikev1_p_map ) ; map = oakley_t_map ; nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ; break ; case 2 : idstr = STR_OR_ID ( t . t_id , ah_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 3 : idstr = STR_OR_ID ( t . t_id , esp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 4 : idstr = STR_OR_ID ( t . t_id , ipcomp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; default : idstr = NULL ; map = NULL ; nmap = 0 ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%d id=%s "" , t . t_no , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%d id=%d "" , t . t_no , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev1_t_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto , int depth _U_ ) { const struct ikev1_pl_t * p ; struct ikev1_pl_t t ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; ND_PRINT ( ( ndo , ""%s:"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; p = ( const struct ikev1_pl_t * ) ext ; if (item_len < sizeof(struct ikev1_pl_t)) { ND_PRINT( (ndo , ""Truncated packet"")); return NULL; } ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; switch ( proto ) { case 1 : idstr = STR_OR_ID ( t . t_id , ikev1_p_map ) ; map = oakley_t_map ; nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ; break ; case 2 : idstr = STR_OR_ID ( t . t_id , ah_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 3 : idstr = STR_OR_ID ( t . t_id , esp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 4 : idstr = STR_OR_ID ( t . t_id , ipcomp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; default : idstr = NULL ; map = NULL ; nmap = 0 ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%d id=%s "" , t . t_no , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%d id=%d "" , t . t_no , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }",785,-17.322155050803886,-0.022066439555164186
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev1_t_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto , int depth _U_ ) { const struct ikev1_pl_t * p ; struct ikev1_pl_t t ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; ND_PRINT ( ( ndo , ""%s:"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; p = ( const struct ikev1_pl_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; switch ( proto ) { case 1 : idstr = STR_OR_ID ( t . t_id , ikev1_p_map ) ; map = oakley_t_map ; nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ; break ; case 2 : idstr = STR_OR_ID ( t . t_id , ah_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 3 : idstr = STR_OR_ID ( t . t_id , esp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 4 : idstr = STR_OR_ID ( t . t_id , ipcomp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; default : idstr = NULL ; map = NULL ; nmap = 0 ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%d id=%s "" , t . t_no , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%d id=%d "" , t . t_no , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev1_t_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto , int depth _U_ ) { const struct ikev1_pl_t * p ; struct ikev1_pl_t t ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; ND_PRINT ( ( ndo , ""%s:"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; p = ( const struct ikev1_pl_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; switch ( proto ) { case 1 : idstr = STR_OR_ID ( t . t_id , ikev1_p_map ) ; map = oakley_t_map ; nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ; break ; case 2 : idstr = STR_OR_ID ( t . t_id , ah_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 3 : idstr = STR_OR_ID ( t . t_id , esp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 4 : idstr = STR_OR_ID ( t . t_id , ipcomp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; default : idstr = NULL ; map = NULL ; nmap = 0 ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%d id=%s "" , t . t_no , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%d id=%d "" , t . t_no , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 && item_len > 0) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; item_len--; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }",757,-8.041184465835395,-0.010622436546678196
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev1_t_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto , int depth _U_ ) { const struct ikev1_pl_t * p ; struct ikev1_pl_t t ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; ND_PRINT ( ( ndo , ""%s:"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; p = ( const struct ikev1_pl_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; switch ( proto ) { case 1 : idstr = STR_OR_ID ( t . t_id , ikev1_p_map ) ; map = oakley_t_map ; nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ; break ; case 2 : idstr = STR_OR_ID ( t . t_id , ah_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 3 : idstr = STR_OR_ID ( t . t_id , esp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 4 : idstr = STR_OR_ID ( t . t_id , ipcomp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; default : idstr = NULL ; map = NULL ; nmap = 0 ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%d id=%s "" , t . t_no , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%d id=%d "" , t . t_no , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev1_t_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto , int depth _U_ ) { const struct ikev1_pl_t * p ; struct ikev1_pl_t t ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; ND_PRINT ( ( ndo , ""%s:"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; if (ep - ext < sizeof(struct ikev1_pl_t)) { ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ); return NULL; } p = ( const struct ikev1_pl_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; switch ( proto ) { case 1 : idstr = STR_OR_ID ( t . t_id , ikev1_p_map ) ; map = oakley_t_map ; nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ; break ; case 2 : idstr = STR_OR_ID ( t . t_id , ah_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 3 : idstr = STR_OR_ID ( t . t_id , esp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 4 : idstr = STR_OR_ID ( t . t_id , ipcomp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; default : idstr = NULL ; map = NULL ; nmap = 0 ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%d id=%s "" , t . t_no , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%d id=%d "" , t . t_no , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }",798,-16.87942770757639,-0.02115216504708821
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev1_t_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto , int depth _U_ ) { const struct ikev1_pl_t * p ; struct ikev1_pl_t t ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; ND_PRINT ( ( ndo , ""%s:"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; p = ( const struct ikev1_pl_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; switch ( proto ) { case 1 : idstr = STR_OR_ID ( t . t_id , ikev1_p_map ) ; map = oakley_t_map ; nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ; break ; case 2 : idstr = STR_OR_ID ( t . t_id , ah_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 3 : idstr = STR_OR_ID ( t . t_id , esp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 4 : idstr = STR_OR_ID ( t . t_id , ipcomp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; default : idstr = NULL ; map = NULL ; nmap = 0 ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%d id=%s "" , t . t_no , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%d id=%d "" , t . t_no , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev1_t_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto , int depth _U_ ) { const struct ikev1_pl_t * p ; struct ikev1_pl_t t ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; ND_PRINT ( ( ndo , ""%s:"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; p = ( const struct ikev1_pl_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; switch ( proto ) { case 1 : idstr = STR_OR_ID ( t . t_id , ikev1_p_map ) ; map = oakley_t_map ; nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ; break ; case 2 : idstr = STR_OR_ID ( t . t_id , ah_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 3 : idstr = STR_OR_ID ( t . t_id , esp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 4 : idstr = STR_OR_ID ( t . t_id , ipcomp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; default : idstr = NULL ; map = NULL ; nmap = 0 ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%d id=%s "" , t . t_no , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%d id=%d "" , t . t_no , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp + sizeof(struct isakmp_gen) <= ep && cp < ep2 ) { struct isakmp_gen gen; UNALIGNED_MEMCPY(&gen, cp, sizeof(gen)); if (map && nmap) { cp = ikev1_attrmap_print(ndo, cp, (ep < ep2) ? ep : ep2, map, nmap); } else if (cp + gen.len <= ep) { cp = ikev1_attr_print(ndo, cp, (ep < ep2) ? ep : ep2); } else { break; } } if (ep < ep2) ND_PRINT((ndo, ""..."")); return cp; trunc: ND_PRINT((ndo, "" [|%s]"", NPSTR(ISAKMP_NPTYPE_T))); return NULL; }",791,-20.772387507523,-0.026260919731381796
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev1_t_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto , int depth _U_ ) { const struct ikev1_pl_t * p ; struct ikev1_pl_t t ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; ND_PRINT ( ( ndo , ""%s:"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; p = ( const struct ikev1_pl_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; switch ( proto ) { case 1 : idstr = STR_OR_ID ( t . t_id , ikev1_p_map ) ; map = oakley_t_map ; nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ; break ; case 2 : idstr = STR_OR_ID ( t . t_id , ah_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 3 : idstr = STR_OR_ID ( t . t_id , esp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 4 : idstr = STR_OR_ID ( t . t_id , ipcomp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; default : idstr = NULL ; map = NULL ; nmap = 0 ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%d id=%s "" , t . t_no , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%d id=%d "" , t . t_no , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev1_t_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto , int depth _U_ ) { const struct ikev1_pl_t * p ; struct ikev1_pl_t t ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; ND_PRINT ( ( ndo , ""%s:"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; 

//Add null pointer check to prevent Out-of-bounds Read
if (ext == NULL) {
 return NULL;
}

p = ( const struct ikev1_pl_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; switch ( proto ) { case 1 : idstr = STR_OR_ID ( t . t_id , ikev1_p_map ) ; map = oakley_t_map ; nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ; break ; case 2 : idstr = STR_OR_ID ( t . t_id , ah_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 3 : idstr = STR_OR_ID ( t . t_id , esp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 4 : idstr = STR_OR_ID ( t . t_id , ipcomp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; default : idstr = NULL ; map = NULL ; nmap = 0 ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%d id=%s "" , t . t_no , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%d id=%d "" , t . t_no , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; 

//Add null pointer check to prevent Out-of-bounds Read
if (cp >= ep || cp >= ep2) {
 return NULL;
}

while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }",817,-28.977326821253552,-0.035467964285500066
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev1_t_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto , int depth _U_ ) { const struct ikev1_pl_t * p ; struct ikev1_pl_t t ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; ND_PRINT ( ( ndo , ""%s:"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; p = ( const struct ikev1_pl_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; switch ( proto ) { case 1 : idstr = STR_OR_ID ( t . t_id , ikev1_p_map ) ; map = oakley_t_map ; nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ; break ; case 2 : idstr = STR_OR_ID ( t . t_id , ah_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 3 : idstr = STR_OR_ID ( t . t_id , esp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 4 : idstr = STR_OR_ID ( t . t_id , ipcomp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; default : idstr = NULL ; map = NULL ; nmap = 0 ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%d id=%s "" , t . t_no , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%d id=%d "" , t . t_no , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev1_t_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep , 
uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto , int depth _U_ ) { 
const struct ikev1_pl_t * p ; struct ikev1_pl_t t ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; 
const u_char * ep2 ; 

ND_PRINT ( ( ndo , ""%s:"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; p = ( const struct ikev1_pl_t * ) ext ; 

ND_TCHECK_LEN ( * p , item_len ) ; //added

UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; switch ( proto ) { case 1 : idstr = STR_OR_ID ( t . t_id , ikev1_p_map ) ; map = oakley_t_map ; nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ; break ; case 2 : idstr = STR_OR_ID ( t . t_id , ah_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 3 : idstr = STR_OR_ID ( t . t_id , esp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 4 : idstr = STR_OR_ID ( t . t_id , ipcomp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; default : idstr = NULL ; map = NULL ; nmap = 0 ; break ; } 

if ( idstr ) ND_PRINT ( ( ndo , "" #%d id=%s "" , t . t_no , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%d id=%d "" , t . t_no , t . t_id ) ) ; 

cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; 

while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , 

( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } 

if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; 

return cp ; 

trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }",791,-52.28219484297603,-0.06609632723511509
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev1_t_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto , int depth _U_ ) { const struct ikev1_pl_t * p ; struct ikev1_pl_t t ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; ND_PRINT ( ( ndo , ""%s:"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; p = ( const struct ikev1_pl_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; switch ( proto ) { case 1 : idstr = STR_OR_ID ( t . t_id , ikev1_p_map ) ; map = oakley_t_map ; nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ; break ; case 2 : idstr = STR_OR_ID ( t . t_id , ah_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 3 : idstr = STR_OR_ID ( t . t_id , esp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 4 : idstr = STR_OR_ID ( t . t_id , ipcomp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; default : idstr = NULL ; map = NULL ; nmap = 0 ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%d id=%s "" , t . t_no , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%d id=%d "" , t . t_no , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev1_t_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto , int depth _U_ ) { const struct ikev1_pl_t * p ; struct ikev1_pl_t t ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; ND_PRINT ( ( ndo , ""%s:"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; p = ( const struct ikev1_pl_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; switch ( proto ) { case 1 : idstr = STR_OR_ID ( t . t_id , ikev1_p_map ) ; map = oakley_t_map ; nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ; break ; case 2 : idstr = STR_OR_ID ( t . t_id , ah_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 3 : idstr = STR_OR_ID ( t . t_id , esp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 4 : idstr = STR_OR_ID ( t . t_id , ipcomp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; default : idstr = NULL ; map = NULL ; nmap = 0 ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%d id=%s "" , t . t_no , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%d id=%d "" , t . t_no , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { if ( ( cp + sizeof ( struct isakmp_attribute ) ) < ( ep < ep2 ) ? ep : ep2 ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else { break; } } else { if ( ( cp + sizeof ( struct isakmp_attribute ) ) < ( ep < ep2 ) ? ep : ep2 ) { cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } else { break; } } } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }",818,-19.96538607226962,-0.024407562435537433
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev1_t_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto , int depth _U_ ) { const struct ikev1_pl_t * p ; struct ikev1_pl_t t ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; ND_PRINT ( ( ndo , ""%s:"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; p = ( const struct ikev1_pl_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; switch ( proto ) { case 1 : idstr = STR_OR_ID ( t . t_id , ikev1_p_map ) ; map = oakley_t_map ; nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ; break ; case 2 : idstr = STR_OR_ID ( t . t_id , ah_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 3 : idstr = STR_OR_ID ( t . t_id , esp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 4 : idstr = STR_OR_ID ( t . t_id , ipcomp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; default : idstr = NULL ; map = NULL ; nmap = 0 ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%d id=%s "" , t . t_no , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%d id=%d "" , t . t_no , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev1_t_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto , int depth _U_ ) { const struct ikev1_pl_t * p ; struct ikev1_pl_t t ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; ND_PRINT ( ( ndo , ""%s:"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; p = ( const struct ikev1_pl_t * ) ext ; if ( ( ( u_char * ) ext + sizeof ( t ) ) > ep ) goto trunc; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; switch ( proto ) { case 1 : idstr = STR_OR_ID ( t . t_id , ikev1_p_map ) ; map = oakley_t_map ; nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ; break ; case 2 : idstr = STR_OR_ID ( t . t_id , ah_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 3 : idstr = STR_OR_ID ( t . t_id , esp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 4 : idstr = STR_OR_ID ( t . t_id , ipcomp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; default : idstr = NULL ; map = NULL ; nmap = 0 ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%d id=%s "" , t . t_no , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%d id=%d "" , t . t_no , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { if ( cp > ep ) goto trunc; cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else { if ( cp > ep ) goto trunc; cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }",788,-26.107077944625555,-0.033130809574397915
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev1_t_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto , int depth _U_ ) { const struct ikev1_pl_t * p ; struct ikev1_pl_t t ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; ND_PRINT ( ( ndo , ""%s:"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; p = ( const struct ikev1_pl_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; switch ( proto ) { case 1 : idstr = STR_OR_ID ( t . t_id , ikev1_p_map ) ; map = oakley_t_map ; nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ; break ; case 2 : idstr = STR_OR_ID ( t . t_id , ah_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 3 : idstr = STR_OR_ID ( t . t_id , esp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 4 : idstr = STR_OR_ID ( t . t_id , ipcomp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; default : idstr = NULL ; map = NULL ; nmap = 0 ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%d id=%s "" , t . t_no , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%d id=%d "" , t . t_no , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev1_t_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto , int depth _U_ ) { const struct ikev1_pl_t * p ; struct ikev1_pl_t t ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; ND_PRINT ( ( ndo , ""%s:"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; p = ( const struct ikev1_pl_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; switch ( proto ) { case 1 : if (t.t_id > sizeof(ikev1_p_map)) { return NULL; } idstr = STR_OR_ID ( t . t_id , ikev1_p_map ) ; map = oakley_t_map ; nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ; break ; case 2 : if (t.t_id > sizeof(ah_p_map)) { return NULL; } idstr = STR_OR_ID ( t . t_id , ah_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 3 : if (t.t_id > sizeof(esp_p_map)) { return NULL; } idstr = STR_OR_ID ( t . t_id , esp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 4 : if (t.t_id > sizeof(ipcomp_p_map)) { return NULL; } idstr = STR_OR_ID ( t . t_id , ipcomp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; default : idstr = NULL ; map = NULL ; nmap = 0 ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%d id=%s "" , t . t_no , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%d id=%d "" , t . t_no , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }",833,-12.376731313121283,-0.014858020784059163
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev1_t_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto , int depth _U_ ) { const struct ikev1_pl_t * p ; struct ikev1_pl_t t ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; ND_PRINT ( ( ndo , ""%s:"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; p = ( const struct ikev1_pl_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; switch ( proto ) { case 1 : idstr = STR_OR_ID ( t . t_id , ikev1_p_map ) ; map = oakley_t_map ; nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ; break ; case 2 : idstr = STR_OR_ID ( t . t_id , ah_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 3 : idstr = STR_OR_ID ( t . t_id , esp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 4 : idstr = STR_OR_ID ( t . t_id , ipcomp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; default : idstr = NULL ; map = NULL ; nmap = 0 ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%d id=%s "" , t . t_no , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%d id=%d "" , t . t_no , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev1_t_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto , int depth _U_ ) { const struct ikev1_pl_t * p ; struct ikev1_pl_t t ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; ND_PRINT ( ( ndo , ""%s:"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; p = ( const struct ikev1_pl_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; switch ( proto ) { case 1 : idstr = STR_OR_ID ( t . t_id , ikev1_p_map ) ; map = oakley_t_map ; nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ; break ; case 2 : idstr = STR_OR_ID ( t . t_id , ah_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 3 : idstr = STR_OR_ID ( t . t_id , esp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 4 : idstr = STR_OR_ID ( t . t_id , ipcomp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; default : idstr = NULL ; map = NULL ; nmap = 0 ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%d id=%s "" , t . t_no , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%d id=%d "" , t . t_no , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep2  && cp < ep ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep2 < ep ) ? ep2 : ep , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep2 < ep ) ? ep2 : ep ) ; } if ( ep2 < ep ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }",747,-13.856968270712398,-0.01855015832759357
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev1_t_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto , int depth _U_ ) { const struct ikev1_pl_t * p ; struct ikev1_pl_t t ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; ND_PRINT ( ( ndo , ""%s:"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; p = ( const struct ikev1_pl_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; switch ( proto ) { case 1 : idstr = STR_OR_ID ( t . t_id , ikev1_p_map ) ; map = oakley_t_map ; nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ; break ; case 2 : idstr = STR_OR_ID ( t . t_id , ah_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 3 : idstr = STR_OR_ID ( t . t_id , esp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 4 : idstr = STR_OR_ID ( t . t_id , ipcomp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; default : idstr = NULL ; map = NULL ; nmap = 0 ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%d id=%s "" , t . t_no , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%d id=%d "" , t . t_no , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev1_t_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto , int depth _U_ ) { const struct ikev1_pl_t * p ; struct ikev1_pl_t t ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; ND_PRINT ( ( ndo , ""%s:"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; p = ( const struct ikev1_pl_t * ) ext ; if (item_len > sizeof(*p)) { ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; switch ( proto ) { case 1 : idstr = STR_OR_ID ( t . t_id , ikev1_p_map ) ; map = oakley_t_map ; nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ; break ; case 2 : idstr = STR_OR_ID ( t . t_id , ah_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 3 : idstr = STR_OR_ID ( t . t_id , esp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 4 : idstr = STR_OR_ID ( t . t_id , ipcomp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; default : idstr = NULL ; map = NULL ; nmap = 0 ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%d id=%s "" , t . t_no , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%d id=%d "" , t . t_no , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while (cp < ep && (cp + sizeof(struct isakmp_gen) <= ep2)) { const struct isakmp_gen *gen = (const struct isakmp_gen*) cp; ND_TCHECK2(*gen, sizeof(struct isakmp_gen)); uint16_t len = EXTRACT_16BITS(&gen->len); if (map && nmap) { cp = ikev1_attrmap_print(ndo, cp, (ep < ep2) ? ep : ep2, map, nmap); } else if (len > 0) { cp = ikev1_attr_print(ndo, cp, (ep < ep2) ? ep : ep2); } else { cp += sizeof(struct isakmp_gen); } } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }",844,-52.98136430256435,-0.06277412832057387
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev1_t_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto , int depth _U_ ) { const struct ikev1_pl_t * p ; struct ikev1_pl_t t ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; ND_PRINT ( ( ndo , ""%s:"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; p = ( const struct ikev1_pl_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; switch ( proto ) { case 1 : idstr = STR_OR_ID ( t . t_id , ikev1_p_map ) ; map = oakley_t_map ; nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ; break ; case 2 : idstr = STR_OR_ID ( t . t_id , ah_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 3 : idstr = STR_OR_ID ( t . t_id , esp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 4 : idstr = STR_OR_ID ( t . t_id , ipcomp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; default : idstr = NULL ; map = NULL ; nmap = 0 ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%d id=%s "" , t . t_no , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%d id=%d "" , t . t_no , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev1_t_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto , int depth _U_ ) { const struct ikev1_pl_t * p ; struct ikev1_pl_t t ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; uint32_t tlen ; const u_char * ep2 ; ND_PRINT ( ( ndo , ""%s:"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; p = ( const struct ikev1_pl_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; tlen = EXTRACT_BE_U_4(p->t_len); switch ( proto ) { case 1 : idstr = STR_OR_ID ( t . t_id , ikev1_p_map ) ; map = oakley_t_map ; nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ; break ; case 2 : idstr = STR_OR_ID ( t . t_id , ah_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 3 : idstr = STR_OR_ID ( t . t_id , esp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 4 : idstr = STR_OR_ID ( t . t_id , ipcomp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; default : idstr = NULL ; map = NULL ; nmap = 0 ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%d id=%s "" , t . t_no , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%d id=%d "" , t . t_no , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 && (cp+tlen)<=item_len) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }

The code has been modified to fix the vulnerability by adding a condition to the while loop which checks the value of cp+tlen against item_len. This ensures that the loop does not step out of bounds when reading data from tlen.",835,-85.43850599463744,-0.10232156406543406
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev1_t_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto , int depth _U_ ) { const struct ikev1_pl_t * p ; struct ikev1_pl_t t ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; ND_PRINT ( ( ndo , ""%s:"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; p = ( const struct ikev1_pl_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; switch ( proto ) { case 1 : idstr = STR_OR_ID ( t . t_id , ikev1_p_map ) ; map = oakley_t_map ; nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ; break ; case 2 : idstr = STR_OR_ID ( t . t_id , ah_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 3 : idstr = STR_OR_ID ( t . t_id , esp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 4 : idstr = STR_OR_ID ( t . t_id , ipcomp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; default : idstr = NULL ; map = NULL ; nmap = 0 ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%d id=%s "" , t . t_no , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%d id=%d "" , t . t_no , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }
Fixed code:","

static const u_char * ikev1_t_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto , int depth _U_ ) { const struct ikev1_pl_t * p ; struct ikev1_pl_t t ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; ND_PRINT ( ( ndo , ""%s:"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; p = ( const struct ikev1_pl_t * ) ext ; if (item_len < sizeof(struct ikev1_pl_t)) { ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL; } ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; switch ( proto ) { case 1 : idstr = STR_OR_ID ( t . t_id , ikev1_p_map ) ; map = oakley_t_map ; nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ; break ; case 2 : idstr = STR_OR_ID ( t . t_id , ah_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 3 : idstr = STR_OR_ID ( t . t_id , esp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 4 : idstr = STR_OR_ID ( t . t_id , ipcomp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; default : idstr = NULL ; map = NULL ; nmap = 0 ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%d id=%s "" , t . t_no , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%d id=%d "" , t . t_no , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }",800,-10.13064241660391,-0.012663303020754888
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev1_t_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto , int depth _U_ ) { const struct ikev1_pl_t * p ; struct ikev1_pl_t t ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; ND_PRINT ( ( ndo , ""%s:"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; p = ( const struct ikev1_pl_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; switch ( proto ) { case 1 : idstr = STR_OR_ID ( t . t_id , ikev1_p_map ) ; map = oakley_t_map ; nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ; break ; case 2 : idstr = STR_OR_ID ( t . t_id , ah_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 3 : idstr = STR_OR_ID ( t . t_id , esp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 4 : idstr = STR_OR_ID ( t . t_id , ipcomp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; default : idstr = NULL ; map = NULL ; nmap = 0 ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%d id=%s "" , t . t_no , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%d id=%d "" , t . t_no , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev1_t_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto , int depth _U_ ) { const struct ikev1_pl_t * p ; struct ikev1_pl_t t ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; ND_PRINT ( ( ndo , ""%s:"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; p = ( const struct ikev1_pl_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; switch ( proto ) { case 1 : idstr = STR_OR_ID ( t . t_id , ikev1_p_map ) ; map = oakley_t_map ; nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ; break ; case 2 : idstr = STR_OR_ID ( t . t_id , ah_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 3 : idstr = STR_OR_ID ( t . t_id , esp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 4 : idstr = STR_OR_ID ( t . t_id , ipcomp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; default : idstr = NULL ; map = NULL ; nmap = 0 ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%d id=%s "" , t . t_no , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%d id=%d "" , t . t_no , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp + 4 < ep2 ) { /* Added 'cp + 4 < ep2' to check for out-of-bounds read */ if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }",769,-25.370772989843793,-0.032991902457534195
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev1_t_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto , int depth _U_ ) { const struct ikev1_pl_t * p ; struct ikev1_pl_t t ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; ND_PRINT ( ( ndo , ""%s:"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; p = ( const struct ikev1_pl_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; switch ( proto ) { case 1 : idstr = STR_OR_ID ( t . t_id , ikev1_p_map ) ; map = oakley_t_map ; nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ; break ; case 2 : idstr = STR_OR_ID ( t . t_id , ah_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 3 : idstr = STR_OR_ID ( t . t_id , esp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 4 : idstr = STR_OR_ID ( t . t_id , ipcomp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; default : idstr = NULL ; map = NULL ; nmap = 0 ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%d id=%s "" , t . t_no , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%d id=%d "" , t . t_no , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }
Fixed code:"," 
static const u_char * ikev1_t_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto , int depth _U_ ) { const struct ikev1_pl_t * p ; struct ikev1_pl_t t ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; ND_PRINT ( ( ndo , ""%s:"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; 

//CWE-125 Vulnerability Fix: Validate 'ext' pointer to avoid out-of-bounds read.
if (ext == NULL) {
    ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ;
    return NULL ;
}

p = ( const struct ikev1_pl_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; switch ( proto ) { case 1 : idstr = STR_OR_ID ( t . t_id , ikev1_p_map ) ; map = oakley_t_map ; nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ; break ; case 2 : idstr = STR_OR_ID ( t . t_id , ah_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 3 : idstr = STR_OR_ID ( t . t_id , esp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 4 : idstr = STR_OR_ID ( t . t_id , ipcomp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; default : idstr = NULL ; map = NULL ; nmap = 0 ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%d id=%s "" , t . t_no , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%d id=%d "" , t . t_no , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }",824,-42.06737257196189,-0.051052636616458605
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev1_t_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto , int depth _U_ ) { const struct ikev1_pl_t * p ; struct ikev1_pl_t t ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; ND_PRINT ( ( ndo , ""%s:"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; p = ( const struct ikev1_pl_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; switch ( proto ) { case 1 : idstr = STR_OR_ID ( t . t_id , ikev1_p_map ) ; map = oakley_t_map ; nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ; break ; case 2 : idstr = STR_OR_ID ( t . t_id , ah_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 3 : idstr = STR_OR_ID ( t . t_id , esp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 4 : idstr = STR_OR_ID ( t . t_id , ipcomp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; default : idstr = NULL ; map = NULL ; nmap = 0 ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%d id=%s "" , t . t_no , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%d id=%d "" , t . t_no , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev1_t_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto , int depth _U_ ) { const struct ikev1_pl_t * p ; struct ikev1_pl_t t ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; ND_PRINT ( ( ndo , ""%s:"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; p = ( const struct ikev1_pl_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; switch ( proto ) { case 1 : idstr = STR_OR_ID ( t . t_id , ikev1_p_map ) ; map = oakley_t_map ; nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ; break ; case 2 : idstr = STR_OR_ID ( t . t_id , ah_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 3 : idstr = STR_OR_ID ( t . t_id , esp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 4 : idstr = STR_OR_ID ( t . t_id , ipcomp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; default : idstr = NULL ; map = NULL ; nmap = 0 ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%d id=%s "" , t . t_no , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%d id=%d "" , t . t_no , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 && (ep2-cp) > 0) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }
The vulnerability is fixed by adding a check for buffer size before advancing the pointer:
while (cp < ep && cp < ep2 && (ep2-cp) > 0) {
This ensures that the pointer will never point outside the bounds of the buffer.",810,-53.306926486493964,-0.06581102035369625
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev1_t_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto , int depth _U_ ) { const struct ikev1_pl_t * p ; struct ikev1_pl_t t ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; ND_PRINT ( ( ndo , ""%s:"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; p = ( const struct ikev1_pl_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; switch ( proto ) { case 1 : idstr = STR_OR_ID ( t . t_id , ikev1_p_map ) ; map = oakley_t_map ; nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ; break ; case 2 : idstr = STR_OR_ID ( t . t_id , ah_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 3 : idstr = STR_OR_ID ( t . t_id , esp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 4 : idstr = STR_OR_ID ( t . t_id , ipcomp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; default : idstr = NULL ; map = NULL ; nmap = 0 ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%d id=%s "" , t . t_no , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%d id=%d "" , t . t_no , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev1_t_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto , int depth _U_ ) { 
    
const struct ikev1_pl_t * p ; 
struct ikev1_pl_t t ; 
const u_char * cp ; 
const char * idstr ; 
const struct attrmap * map ; 
size_t nmap ; 
const u_char * ep2 ; 

ND_PRINT ( ( ndo , ""%s:"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; 

if (item_len <= sizeof(struct ikev1_pl_t)) {
    return NULL;
}

p = ( const struct ikev1_pl_t * ) ext ; 
ND_TCHECK ( * p ) ; 
UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; 

switch ( proto ) { 
    case 1 : 
        idstr = STR_OR_ID ( t . t_id , ikev1_p_map ) ; 
        map = oakley_t_map ; 
        nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ; 
        break ; 
    case 2 : 
        idstr = STR_OR_ID ( t . t_id , ah_p_map ) ; 
        map = ipsec_t_map ; 
        nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; 
        break ; 
    case 3 : 
        idstr = STR_OR_ID ( t . t_id , esp_p_map ) ; 
        map = ipsec_t_map ; 
        nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; 
        break ; 
    case 4 : 
        idstr = STR_OR_ID ( t . t_id , ipcomp_p_map ) ; 
        map = ipsec_t_map ; 
        nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; 
        break ; 
    default : 
        idstr = NULL ; 
        map = NULL ; 
        nmap = 0 ; 
        break ; 
} 

if ( idstr ) 
    ND_PRINT ( ( ndo , "" #%d id=%s "" , t . t_no , idstr ) ) ; 
else 
    ND_PRINT ( ( ndo , "" #%d id=%d "" , t . t_no , t . t_id ) ) ; 

cp = ( const u_char * ) ( p + 1 ) ; 
ep2 = ( const u_char * ) p + item_len ; 

while ( cp < ep && cp < ep2 ) { 
    if ( map && nmap ) { 
        if (ep2 - cp >= sizeof(struct isakmp_attribute)) {
            cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ;
        }
        else {
            break;
        }
    } else {
        if (ep2 - cp >= sizeof(struct isakmp_attribute)) {
            cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ;
        }
        else {
            break;
        }
    } 
} 

if ( ep < ep2 ) 
    ND_PRINT ( ( ndo , ""..."" ) ) ; 
return cp ; 

trunc : 
    ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; 
    return NULL ; 
",1000,-39.353055019659344,-0.03935305501965934
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev1_t_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto , int depth _U_ ) { const struct ikev1_pl_t * p ; struct ikev1_pl_t t ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; ND_PRINT ( ( ndo , ""%s:"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; p = ( const struct ikev1_pl_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; switch ( proto ) { case 1 : idstr = STR_OR_ID ( t . t_id , ikev1_p_map ) ; map = oakley_t_map ; nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ; break ; case 2 : idstr = STR_OR_ID ( t . t_id , ah_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 3 : idstr = STR_OR_ID ( t . t_id , esp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 4 : idstr = STR_OR_ID ( t . t_id , ipcomp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; default : idstr = NULL ; map = NULL ; nmap = 0 ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%d id=%s "" , t . t_no , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%d id=%d "" , t . t_no , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev1_t_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto , int depth _U_ ) { const struct ikev1_pl_t * p ; struct ikev1_pl_t t ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; ND_PRINT ( ( ndo , ""%s:"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; p = ( const struct ikev1_pl_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; switch ( proto ) { case 1 : idstr = STR_OR_ID ( t . t_id , ikev1_p_map ) ; map = oakley_t_map ; nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ; break ; case 2 : idstr = STR_OR_ID ( t . t_id , ah_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 3 : idstr = STR_OR_ID ( t . t_id , esp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 4 : idstr = STR_OR_ID ( t . t_id , ipcomp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; default : idstr = NULL ; map = NULL ; nmap = 0 ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%d id=%s "" , t . t_no , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%d id=%d "" , t . t_no , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 && (ep2 - cp) > 0 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }",755,-8.26050123717704,-0.010941061241294093
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev1_t_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto , int depth _U_ ) { const struct ikev1_pl_t * p ; struct ikev1_pl_t t ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; ND_PRINT ( ( ndo , ""%s:"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; p = ( const struct ikev1_pl_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; switch ( proto ) { case 1 : idstr = STR_OR_ID ( t . t_id , ikev1_p_map ) ; map = oakley_t_map ; nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ; break ; case 2 : idstr = STR_OR_ID ( t . t_id , ah_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 3 : idstr = STR_OR_ID ( t . t_id , esp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 4 : idstr = STR_OR_ID ( t . t_id , ipcomp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; default : idstr = NULL ; map = NULL ; nmap = 0 ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%d id=%s "" , t . t_no , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%d id=%d "" , t . t_no , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev1_t_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto , int depth _U_ ) { const struct ikev1_pl_t * p ; struct ikev1_pl_t t ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; ND_PRINT ( ( ndo , ""%s:"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; if (item_len < sizeof(*p)) { ND_PRINT( (ndo, "" [ Invalid length (%u) ]"", item_len) ); return NULL; } p = ( const struct ikev1_pl_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; switch ( proto ) { case 1 : idstr = STR_OR_ID ( t . t_id , ikev1_p_map ) ; map = oakley_t_map ; nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ; break ; case 2 : idstr = STR_OR_ID ( t . t_id , ah_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 3 : idstr = STR_OR_ID ( t . t_id , esp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 4 : idstr = STR_OR_ID ( t . t_id , ipcomp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; default : idstr = NULL ; map = NULL ; nmap = 0 ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%d id=%s "" , t . t_no , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%d id=%d "" , t . t_no , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 && (cp + 3) < ep && (cp + 3) < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }
The vulnerability of the code has been fixed by adding an additional check to make sure that the cp + 3 is within the bounds of ep and ep2 before executing the if statement. This prevents an out-of-bounds read if the item_len is not properly checked.",858,-75.74791959562408,-0.08828428857298844
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev1_t_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto , int depth _U_ ) { const struct ikev1_pl_t * p ; struct ikev1_pl_t t ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; ND_PRINT ( ( ndo , ""%s:"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; p = ( const struct ikev1_pl_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; switch ( proto ) { case 1 : idstr = STR_OR_ID ( t . t_id , ikev1_p_map ) ; map = oakley_t_map ; nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ; break ; case 2 : idstr = STR_OR_ID ( t . t_id , ah_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 3 : idstr = STR_OR_ID ( t . t_id , esp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 4 : idstr = STR_OR_ID ( t . t_id , ipcomp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; default : idstr = NULL ; map = NULL ; nmap = 0 ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%d id=%s "" , t . t_no , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%d id=%d "" , t . t_no , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev1_t_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto , int depth _U_ ) { const struct ikev1_pl_t * p ; struct ikev1_pl_t t ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; ND_PRINT ( ( ndo , ""%s:"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; p = ( const struct ikev1_pl_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; switch ( proto ) { case 1 : idstr = STR_OR_ID ( t . t_id , ikev1_p_map ) ; map = oakley_t_map ; nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ; break ; case 2 : idstr = STR_OR_ID ( t . t_id , ah_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 3 : idstr = STR_OR_ID ( t . t_id , esp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 4 : idstr = STR_OR_ID ( t . t_id , ipcomp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; default : idstr = NULL ; map = NULL ; nmap = 0 ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%d id=%s "" , t . t_no , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%d id=%d "" , t . t_no , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 && cp < ( ep + ndo->ndo_snapend)) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }",760,-13.145278238372546,-0.017296418734700718
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev1_t_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto , int depth _U_ ) { const struct ikev1_pl_t * p ; struct ikev1_pl_t t ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; ND_PRINT ( ( ndo , ""%s:"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; p = ( const struct ikev1_pl_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; switch ( proto ) { case 1 : idstr = STR_OR_ID ( t . t_id , ikev1_p_map ) ; map = oakley_t_map ; nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ; break ; case 2 : idstr = STR_OR_ID ( t . t_id , ah_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 3 : idstr = STR_OR_ID ( t . t_id , esp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 4 : idstr = STR_OR_ID ( t . t_id , ipcomp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; default : idstr = NULL ; map = NULL ; nmap = 0 ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%d id=%s "" , t . t_no , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%d id=%d "" , t . t_no , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }
Fixed code:","

static const u_char * ikev1_t_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto , int depth _U_ ) { const struct ikev1_pl_t * p ; struct ikev1_pl_t t ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; ND_PRINT ( ( ndo , ""%s:"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; p = ( const struct ikev1_pl_t * ) ext ; if (item_len < sizeof ( t )) { ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; } ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; switch ( proto ) { case 1 : idstr = STR_OR_ID ( t . t_id , ikev1_p_map ) ; map = oakley_t_map ; nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ; break ; case 2 : idstr = STR_OR_ID ( t . t_id , ah_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 3 : idstr = STR_OR_ID ( t . t_id , esp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 4 : idstr = STR_OR_ID ( t . t_id , ipcomp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; default : idstr = NULL ; map = NULL ; nmap = 0 ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%d id=%s "" , t . t_no , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%d id=%d "" , t . t_no , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; if (cp > ep2) { ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; } } else { cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; if (cp > ep2) { ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; } } } 
if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }",880,-22.884223788037627,-0.026004799759133668
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev1_t_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto , int depth _U_ ) { const struct ikev1_pl_t * p ; struct ikev1_pl_t t ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; ND_PRINT ( ( ndo , ""%s:"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; p = ( const struct ikev1_pl_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; switch ( proto ) { case 1 : idstr = STR_OR_ID ( t . t_id , ikev1_p_map ) ; map = oakley_t_map ; nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ; break ; case 2 : idstr = STR_OR_ID ( t . t_id , ah_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 3 : idstr = STR_OR_ID ( t . t_id , esp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 4 : idstr = STR_OR_ID ( t . t_id , ipcomp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; default : idstr = NULL ; map = NULL ; nmap = 0 ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%d id=%s "" , t . t_no , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%d id=%d "" , t . t_no , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev1_t_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto , int depth _U_ ) { 
  const struct ikev1_pl_t * p ; 
  struct ikev1_pl_t t ; 
  const u_char * cp ; 
  const char * idstr ; 
  const struct attrmap * map ; 
  size_t nmap ; 
  const u_char * ep2 ; 
  
  ND_PRINT ( ( ndo , ""%s:"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; 
  p = ( const struct ikev1_pl_t * ) ext ; 
  ND_TCHECK_LEN ( * p , item_len ) ; 
  UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; 
  
  switch ( proto ) { 
    case 1 : 
      idstr = STR_OR_ID ( t . t_id , ikev1_p_map ) ; 
      map = oakley_t_map ; 
      nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ; 
      break ; 
    case 2 : 
      idstr = STR_OR_ID ( t . t_id , ah_p_map ) ; 
      map = ipsec_t_map ; 
      nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; 
      break ; 
    case 3 : 
      idstr = STR_OR_ID ( t . t_id , esp_p_map ) ; 
      map = ipsec_t_map ; 
      nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; 
      break ; 
    case 4 : 
      idstr = STR_OR_ID ( t . t_id , ipcomp_p_map ) ; 
      map = ipsec_t_map ; 
      nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; 
      break ; 
    default : 
      idstr = NULL ; 
      map = NULL ; 
      nmap = 0 ; 
      break ; 
  } 
  
  if ( idstr ) 
    ND_PRINT ( ( ndo , "" #%d id=%s "" , t . t_no , idstr ) ) ; 
  else 
    ND_PRINT ( ( ndo , "" #%d id=%d "" , t . t_no , t . t_id ) ) ; 
  
  cp = ( const u_char * ) ( p + 1 ) ; 
  ep2 = ( const u_char * ) p + item_len ; 
  
  while ( cp < ep && cp < ep2 ) { 
    if ( map && nmap ) {
      if ( ep2 - cp < map->len )
        break;
        
      cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; 
    } else 
      cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; 
  } 
  
  if ( ep < ep2 ) 
    ND_PRINT ( ( ndo , ""..."" ) ) ; 
  
  return cp ; 
  
trunc : 
  ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; 
  return NULL ; 
}",957,-36.376933922715196,-0.03801142520659895
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev1_t_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto , int depth _U_ ) { const struct ikev1_pl_t * p ; struct ikev1_pl_t t ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; ND_PRINT ( ( ndo , ""%s:"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; p = ( const struct ikev1_pl_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; switch ( proto ) { case 1 : idstr = STR_OR_ID ( t . t_id , ikev1_p_map ) ; map = oakley_t_map ; nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ; break ; case 2 : idstr = STR_OR_ID ( t . t_id , ah_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 3 : idstr = STR_OR_ID ( t . t_id , esp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 4 : idstr = STR_OR_ID ( t . t_id , ipcomp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; default : idstr = NULL ; map = NULL ; nmap = 0 ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%d id=%s "" , t . t_no , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%d id=%d "" , t . t_no , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev1_t_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto , int depth _U_ ) { const struct ikev1_pl_t * p ; struct ikev1_pl_t t ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; ND_PRINT ( ( ndo , ""%s:"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; p = ( const struct ikev1_pl_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; switch ( proto ) { case 1 : idstr = STR_OR_ID ( t . t_id , ikev1_p_map ) ; map = oakley_t_map ; nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ; break ; case 2 : idstr = STR_OR_ID ( t . t_id , ah_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 3 : idstr = STR_OR_ID ( t . t_id , esp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 4 : idstr = STR_OR_ID ( t . t_id , ipcomp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; default : idstr = NULL ; map = NULL ; nmap = 0 ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%d id=%s "" , t . t_no , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%d id=%d "" , t . t_no , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 && cp < ep+item_len) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }",754,-8.439376502068,-0.011192807031920425
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev1_t_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto , int depth _U_ ) { const struct ikev1_pl_t * p ; struct ikev1_pl_t t ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; ND_PRINT ( ( ndo , ""%s:"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; p = ( const struct ikev1_pl_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; switch ( proto ) { case 1 : idstr = STR_OR_ID ( t . t_id , ikev1_p_map ) ; map = oakley_t_map ; nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ; break ; case 2 : idstr = STR_OR_ID ( t . t_id , ah_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 3 : idstr = STR_OR_ID ( t . t_id , esp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 4 : idstr = STR_OR_ID ( t . t_id , ipcomp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; default : idstr = NULL ; map = NULL ; nmap = 0 ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%d id=%s "" , t . t_no , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%d id=%d "" , t . t_no , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }
Fixed code:","

static const u_char * ikev1_t_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto , int depth _U_ ) { const struct ikev1_pl_t * p ; struct ikev1_pl_t t ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; ND_PRINT ( ( ndo , ""%s:"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; p = ( const struct ikev1_pl_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; switch ( proto ) { case 1 : idstr = STR_OR_ID ( t . t_id , ikev1_p_map ) ; map = oakley_t_map ; nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ; break ; case 2 : idstr = STR_OR_ID ( t . t_id , ah_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 3 : idstr = STR_OR_ID ( t . t_id , esp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 4 : idstr = STR_OR_ID ( t . t_id , ipcomp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; default : idstr = NULL ; map = NULL ; nmap = 0 ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%d id=%s "" , t . t_no , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%d id=%d "" , t . t_no , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; 

// Added check for ep2 to ensure that cp does not exceed ep2
if (cp + item_len <= ep2) {
  while ( cp < ep && cp < ep2 ) { 
    if ( map && nmap ) { 
      cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; 
    } else 
      cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; 
  } 
  if ( ep < ep2 ) 
    ND_PRINT ( ( ndo , ""..."" ) ) ; 
  return cp ;
}

ND_PRINT ( ( ndo , ""..."" ) ) ; 
return NULL ;
trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; 
return NULL ; 
}",833,-48.50048674073619,-0.058223873638338766
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev1_t_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto , int depth _U_ ) { const struct ikev1_pl_t * p ; struct ikev1_pl_t t ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; ND_PRINT ( ( ndo , ""%s:"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; p = ( const struct ikev1_pl_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; switch ( proto ) { case 1 : idstr = STR_OR_ID ( t . t_id , ikev1_p_map ) ; map = oakley_t_map ; nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ; break ; case 2 : idstr = STR_OR_ID ( t . t_id , ah_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 3 : idstr = STR_OR_ID ( t . t_id , esp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 4 : idstr = STR_OR_ID ( t . t_id , ipcomp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; default : idstr = NULL ; map = NULL ; nmap = 0 ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%d id=%s "" , t . t_no , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%d id=%d "" , t . t_no , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev1_t_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto , int depth _U_ ) { const struct ikev1_pl_t * p ; struct ikev1_pl_t t ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; ND_PRINT ( ( ndo , ""%s:"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; p = ( const struct ikev1_pl_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; switch ( proto ) { case 1 : idstr = STR_OR_ID ( t . t_id , ikev1_p_map ) ; map = oakley_t_map ; nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ; break ; case 2 : idstr = STR_OR_ID ( t . t_id , ah_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 3 : idstr = STR_OR_ID ( t . t_id , esp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 4 : idstr = STR_OR_ID ( t . t_id , ipcomp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; default : idstr = NULL ; map = NULL ; nmap = 0 ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%d id=%s "" , t . t_no , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%d id=%d "" , t . t_no , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 && cp < ext + item_len ) { if ( map && nmap && cp < ext + item_len ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }",762,-20.711270537394203,-0.027180145062197115
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev1_t_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto , int depth _U_ ) { const struct ikev1_pl_t * p ; struct ikev1_pl_t t ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; ND_PRINT ( ( ndo , ""%s:"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; p = ( const struct ikev1_pl_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; switch ( proto ) { case 1 : idstr = STR_OR_ID ( t . t_id , ikev1_p_map ) ; map = oakley_t_map ; nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ; break ; case 2 : idstr = STR_OR_ID ( t . t_id , ah_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 3 : idstr = STR_OR_ID ( t . t_id , esp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 4 : idstr = STR_OR_ID ( t . t_id , ipcomp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; default : idstr = NULL ; map = NULL ; nmap = 0 ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%d id=%s "" , t . t_no , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%d id=%d "" , t . t_no , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }
Fixed code:","

static const u_char * ikev1_t_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto , int depth _U_ ) { const struct ikev1_pl_t * p ; struct ikev1_pl_t t ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; const u_char * ep3 ; ND_PRINT ( ( ndo , ""%s:"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; p = ( const struct ikev1_pl_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; switch ( proto ) { case 1 : idstr = STR_OR_ID ( t . t_id , ikev1_p_map ) ; map = oakley_t_map ; nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ; break ; case 2 : idstr = STR_OR_ID ( t . t_id , ah_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 3 : idstr = STR_OR_ID ( t . t_id , esp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 4 : idstr = STR_OR_ID ( t . t_id , ipcomp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; default : idstr = NULL ; map = NULL ; nmap = 0 ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%d id=%s "" , t . t_no , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%d id=%d "" , t . t_no , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; ep3 = ep2; if (ep2 > ep) { ep2 = ep; } while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep3 > ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }",776,-18.59982156536799,-0.02396884222341236
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev1_t_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto , int depth _U_ ) { const struct ikev1_pl_t * p ; struct ikev1_pl_t t ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; ND_PRINT ( ( ndo , ""%s:"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; p = ( const struct ikev1_pl_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; switch ( proto ) { case 1 : idstr = STR_OR_ID ( t . t_id , ikev1_p_map ) ; map = oakley_t_map ; nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ; break ; case 2 : idstr = STR_OR_ID ( t . t_id , ah_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 3 : idstr = STR_OR_ID ( t . t_id , esp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 4 : idstr = STR_OR_ID ( t . t_id , ipcomp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; default : idstr = NULL ; map = NULL ; nmap = 0 ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%d id=%s "" , t . t_no , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%d id=%d "" , t . t_no , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev1_t_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto , int depth _U_ ) { const struct ikev1_pl_t * p ; struct ikev1_pl_t t ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; ND_PRINT ( ( ndo , ""%s:"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; p = ( const struct ikev1_pl_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; switch ( proto ) { case 1 : idstr = STR_OR_ID ( t . t_id , ikev1_p_map ) ; map = oakley_t_map ; nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ; break ; case 2 : idstr = STR_OR_ID ( t . t_id , ah_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 3 : idstr = STR_OR_ID ( t . t_id , esp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 4 : idstr = STR_OR_ID ( t . t_id , ipcomp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; default : idstr = NULL ; map = NULL ; nmap = 0 ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%d id=%s "" , t . t_no , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%d id=%d "" , t . t_no , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len > ep ? ep : p + item_len; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }",756,-13.105867794256406,-0.01733580396065662
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev1_t_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto , int depth _U_ ) { const struct ikev1_pl_t * p ; struct ikev1_pl_t t ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; ND_PRINT ( ( ndo , ""%s:"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; p = ( const struct ikev1_pl_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; switch ( proto ) { case 1 : idstr = STR_OR_ID ( t . t_id , ikev1_p_map ) ; map = oakley_t_map ; nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ; break ; case 2 : idstr = STR_OR_ID ( t . t_id , ah_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 3 : idstr = STR_OR_ID ( t . t_id , esp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 4 : idstr = STR_OR_ID ( t . t_id , ipcomp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; default : idstr = NULL ; map = NULL ; nmap = 0 ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%d id=%s "" , t . t_no , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%d id=%d "" , t . t_no , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev1_t_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto , int depth _U_ ) { const struct ikev1_pl_t * p ; struct ikev1_pl_t t ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; const u_char * end_ep; ND_PRINT ( ( ndo , ""%s:"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; p = ( const struct ikev1_pl_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; end_ep = ep + item_len; switch ( proto ) { case 1 : idstr = STR_OR_ID ( t . t_id , ikev1_p_map ) ; map = oakley_t_map ; nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ; break ; case 2 : idstr = STR_OR_ID ( t . t_id , ah_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 3 : idstr = STR_OR_ID ( t . t_id , esp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 4 : idstr = STR_OR_ID ( t . t_id , ipcomp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; default : idstr = NULL ; map = NULL ; nmap = 0 ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%d id=%s "" , t . t_no , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%d id=%d "" , t . t_no , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 && cp < end_ep) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 && ep < end_ep) ? ep : (ep2<end_ep) ? ep2 : end_ep, map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 && ep < end_ep) ? ep : (ep2<end_ep) ? ep2 : end_ep ) ; } if ( ep < ep2 && ep < end_ep) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }",815,-24.51779010337377,-0.03008317804094941
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev1_t_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto , int depth _U_ ) { const struct ikev1_pl_t * p ; struct ikev1_pl_t t ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; ND_PRINT ( ( ndo , ""%s:"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; p = ( const struct ikev1_pl_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; switch ( proto ) { case 1 : idstr = STR_OR_ID ( t . t_id , ikev1_p_map ) ; map = oakley_t_map ; nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ; break ; case 2 : idstr = STR_OR_ID ( t . t_id , ah_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 3 : idstr = STR_OR_ID ( t . t_id , esp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 4 : idstr = STR_OR_ID ( t . t_id , ipcomp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; default : idstr = NULL ; map = NULL ; nmap = 0 ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%d id=%s "" , t . t_no , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%d id=%d "" , t . t_no , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev1_t_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto , int depth _U_ ) { const struct ikev1_pl_t * p ; struct ikev1_pl_t t ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; ND_PRINT ( ( ndo , ""%s:"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; p = ( const struct ikev1_pl_t * ) ext ; ND_TCHECK_LEN( * p , item_len ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; switch ( proto ) { case 1 : idstr = STR_OR_ID ( t . t_id , ikev1_p_map ) ; map = oakley_t_map ; nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ; break ; case 2 : idstr = STR_OR_ID ( t . t_id , ah_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 3 : idstr = STR_OR_ID ( t . t_id , esp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 4 : idstr = STR_OR_ID ( t . t_id , ipcomp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; default : idstr = NULL ; map = NULL ; nmap = 0 ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%d id=%s "" , t . t_no , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%d id=%d "" , t . t_no , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap && cp + 1 <= ep2 ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else { cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }",762,-20.87981501873447,-0.02740133204558329
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev1_t_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto , int depth _U_ ) { const struct ikev1_pl_t * p ; struct ikev1_pl_t t ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; ND_PRINT ( ( ndo , ""%s:"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; p = ( const struct ikev1_pl_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; switch ( proto ) { case 1 : idstr = STR_OR_ID ( t . t_id , ikev1_p_map ) ; map = oakley_t_map ; nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ; break ; case 2 : idstr = STR_OR_ID ( t . t_id , ah_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 3 : idstr = STR_OR_ID ( t . t_id , esp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 4 : idstr = STR_OR_ID ( t . t_id , ipcomp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; default : idstr = NULL ; map = NULL ; nmap = 0 ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%d id=%s "" , t . t_no , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%d id=%d "" , t . t_no , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev1_t_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto , int depth _U_ ) { const struct ikev1_pl_t * p ; struct ikev1_pl_t t ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; ND_PRINT ( ( ndo , ""%s:"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; p = ( const struct ikev1_pl_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; switch ( proto ) { case 1 : idstr = STR_OR_ID ( t . t_id , ikev1_p_map ) ; map = oakley_t_map ; nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ; break ; case 2 : idstr = STR_OR_ID ( t . t_id , ah_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 3 : idstr = STR_OR_ID ( t . t_id , esp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 4 : idstr = STR_OR_ID ( t . t_id , ipcomp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; default : idstr = NULL ; map = NULL ; nmap = 0 ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%d id=%s "" , t . t_no , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%d id=%d "" , t . t_no , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { if ( ep2 - cp > 0 ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else { break; } } else { if ( ep2 - cp > 0 ) { cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } else { break; } } } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }",780,-12.472525075204448,-0.015990416763082625
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev1_t_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto , int depth _U_ ) { const struct ikev1_pl_t * p ; struct ikev1_pl_t t ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; ND_PRINT ( ( ndo , ""%s:"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; p = ( const struct ikev1_pl_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; switch ( proto ) { case 1 : idstr = STR_OR_ID ( t . t_id , ikev1_p_map ) ; map = oakley_t_map ; nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ; break ; case 2 : idstr = STR_OR_ID ( t . t_id , ah_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 3 : idstr = STR_OR_ID ( t . t_id , esp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 4 : idstr = STR_OR_ID ( t . t_id , ipcomp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; default : idstr = NULL ; map = NULL ; nmap = 0 ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%d id=%s "" , t . t_no , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%d id=%d "" , t . t_no , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }
Fixed code:","

static const u_char * ikev1_t_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto , int depth _U_ ) { const struct ikev1_pl_t * p ; struct ikev1_pl_t t ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; ND_PRINT ( ( ndo , ""%s:"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; if (item_len < sizeof(*p)) { ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL; } p = ( const struct ikev1_pl_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; switch ( proto ) { case 1 : idstr = STR_OR_ID ( t . t_id , ikev1_p_map ) ; map = oakley_t_map ; nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ; break ; case 2 : idstr = STR_OR_ID ( t . t_id , ah_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 3 : idstr = STR_OR_ID ( t . t_id , esp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 4 : idstr = STR_OR_ID ( t . t_id , ipcomp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; default : idstr = NULL ; map = NULL ; nmap = 0 ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%d id=%s "" , t . t_no , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%d id=%d "" , t . t_no , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; if (cp > ep2) { ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL; } } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }",834,-14.73659401918827,-0.017669777001424785
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev1_t_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto , int depth _U_ ) { const struct ikev1_pl_t * p ; struct ikev1_pl_t t ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; ND_PRINT ( ( ndo , ""%s:"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; p = ( const struct ikev1_pl_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; switch ( proto ) { case 1 : idstr = STR_OR_ID ( t . t_id , ikev1_p_map ) ; map = oakley_t_map ; nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ; break ; case 2 : idstr = STR_OR_ID ( t . t_id , ah_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 3 : idstr = STR_OR_ID ( t . t_id , esp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 4 : idstr = STR_OR_ID ( t . t_id , ipcomp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; default : idstr = NULL ; map = NULL ; nmap = 0 ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%d id=%s "" , t . t_no , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%d id=%d "" , t . t_no , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev1_t_print (netdissect_options * ndo, u_char tpay _U_, const struct isakmp_gen * ext, u_int item_len, const u_char * ep, uint32_t phase _U_, uint32_t doi _U_, uint32_t proto, int depth _U_) { 
    const struct ikev1_pl_t * p;
    struct ikev1_pl_t t;
    const u_char * cp;
    const char * idstr;
    const struct attrmap * map;
    size_t nmap;
    const u_char * ep2;
    ND_PRINT((ndo, ""%s:"", NPSTR(ISAKMP_NPTYPE_T)));
    p = (const struct ikev1_pl_t *) ext;
    ND_TCHECK(*p);
    UNALIGNED_MEMCPY(&t, ext, sizeof(t));
    switch (proto) {
        case 1:
            idstr = STR_OR_ID(t.t_id, ikev1_p_map);
            map = oakley_t_map;
            nmap = sizeof(oakley_t_map) / sizeof(oakley_t_map[0]);
            break;
        case 2:
            idstr = STR_OR_ID(t.t_id, ah_p_map);
            map = ipsec_t_map;
            nmap = sizeof(ipsec_t_map) / sizeof(ipsec_t_map[0]);
            break;
        case 3:
            idstr = STR_OR_ID(t.t_id, esp_p_map);
            map = ipsec_t_map;
            nmap = sizeof(ipsec_t_map) / sizeof(ipsec_t_map[0]);
            break;
        case 4:
            idstr = STR_OR_ID(t.t_id, ipcomp_p_map);
            map = ipsec_t_map;
            nmap = sizeof(ipsec_t_map) / sizeof(ipsec_t_map[0]);
            break;
        default:
            idstr = NULL;
            map = NULL;
            nmap = 0;
            break;
    }
    if (idstr)
        ND_PRINT((ndo, "" #%d id=%s "", t.t_no, idstr));
    else
        ND_PRINT((ndo, "" #%d id=%d "", t.t_no, t.t_id));
    cp = (const u_char *) (p + 1);
    ep2 = (const u_char *) p + item_len;
    while (cp < ep && cp < ep2 && (ep2 - cp) >= sizeof(struct isakmp_gen)) {
        if (map && nmap) {
            cp = ikev1_attrmap_print(ndo, cp, (ep < ep2) ? ep : ep2, map, nmap);
        } else
            cp = ikev1_attr_print(ndo, cp, (ep < ep2) ? ep : ep2);
    }
    if (ep < ep2)
        ND_PRINT((ndo, ""...""));
    return cp;
trunc: ND_PRINT((ndo, "" [|%s]"", NPSTR(ISAKMP_NPTYPE_T)));
    return NULL;
}",835,-29.19382699314435,-0.0349626670576579
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev1_t_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto , int depth _U_ ) { const struct ikev1_pl_t * p ; struct ikev1_pl_t t ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; ND_PRINT ( ( ndo , ""%s:"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; p = ( const struct ikev1_pl_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; switch ( proto ) { case 1 : idstr = STR_OR_ID ( t . t_id , ikev1_p_map ) ; map = oakley_t_map ; nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ; break ; case 2 : idstr = STR_OR_ID ( t . t_id , ah_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 3 : idstr = STR_OR_ID ( t . t_id , esp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 4 : idstr = STR_OR_ID ( t . t_id , ipcomp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; default : idstr = NULL ; map = NULL ; nmap = 0 ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%d id=%s "" , t . t_no , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%d id=%d "" , t . t_no , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev1_t_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto , int depth _U_ ) { const struct ikev1_pl_t * p ; struct ikev1_pl_t t ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; ND_PRINT ( ( ndo , ""%s:"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; p = ( const struct ikev1_pl_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; switch ( proto ) { case 1 : idstr = STR_OR_ID ( t . t_id , ikev1_p_map ) ; map = oakley_t_map ; nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ; break ; case 2 : idstr = STR_OR_ID ( t . t_id , ah_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 3 : idstr = STR_OR_ID ( t . t_id , esp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 4 : idstr = STR_OR_ID ( t . t_id , ipcomp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; default : idstr = NULL ; map = NULL ; nmap = 0 ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%d id=%s "" , t . t_no , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%d id=%d "" , t . t_no , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 && cp < (ep + item_len)) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }",755,-7.842087156228503,-0.010386870405600667
