Original code,Plausible Program,Total Tokens,Sum Entropy,Mean Entropy
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static PyObject * decode_unicode_with_escapes ( struct compiling * c , const node * n , const char * s , size_t len ) { PyObject * u ; char * buf ; char * p ; const char * end ; if ( len > SIZE_MAX / 6 ) return NULL ; u = PyBytes_FromStringAndSize ( ( char * ) NULL , len * 6 ) ; if ( u == NULL ) return NULL ; p = buf = PyBytes_AsString ( u ) ; end = s + len ; while ( s < end ) { if ( * s == '\\\\' ) { * p ++ = * s ++ ; if ( * s & 0x80 ) { strcpy ( p , ""u005c"" ) ; p += 5 ; } } if ( * s & 0x80 ) { PyObject * w ; int kind ; void * data ; Py_ssize_t len , i ; w = decode_utf8 ( c , & s , end ) ; if ( w == NULL ) { Py_DECREF ( u ) ; return NULL ; } kind = PyUnicode_KIND ( w ) ; data = PyUnicode_DATA ( w ) ; len = PyUnicode_GET_LENGTH ( w ) ; for ( i = 0 ; i < len ; i ++ ) { Py_UCS4 chr = PyUnicode_READ ( kind , data , i ) ; sprintf ( p , ""\\\\U%08x"" , chr ) ; p += 10 ; } assert ( p - buf <= Py_SIZE ( u ) ) ; Py_DECREF ( w ) ; } else { * p ++ = * s ++ ; } } len = p - buf ; s = buf ; return PyUnicode_DecodeUnicodeEscape ( s , len , NULL ) ; }
Fixed code:","
static PyObject * decode_unicode_with_escapes ( struct compiling * c , const node * n , const char * s , size_t len ) { PyObject * u ; char * buf ; char * p ; const char * end ; if ( len > SIZE_MAX / 6 ) return NULL ; u = PyBytes_FromStringAndSize ( ( char * ) NULL , len * 6 ) ; if ( u == NULL ) return NULL ; p = buf = PyBytes_AsString ( u ) ; end = s + len ; while ( s < end ) { if ( * s == '\\\\' ) { * p ++ = * s ++ ; if ( s >= end ) { Py_DECREF ( u ) ; return NULL ; } if ( * s & 0x80 ) { strcpy ( p , ""u005c"" ) ; p += 5 ; } } if ( * s & 0x80 ) { PyObject * w ; int kind ; void * data ; Py_ssize_t len , i ; w = decode_utf8 ( c , & s , end ) ; if ( w == NULL ) { Py_DECREF ( u ) ; return NULL ; } kind = PyUnicode_KIND ( w ) ; data = PyUnicode_DATA ( w ) ; len = PyUnicode_GET_LENGTH ( w ) ; for ( i = 0 ; i < len ; i ++ ) { Py_UCS4 chr = PyUnicode_READ ( kind , data , i ) ; sprintf ( p , ""\\\\U%08x"" , chr ) ; p += 10 ; } assert ( p - buf <= Py_SIZE ( u ) ) ; Py_DECREF ( w ) ; } else { * p ++ = * s ++ ; } } len = p - buf ; s = buf ; return PyUnicode_DecodeUnicodeEscape ( s , len , NULL ) ; } 

The fix for the vulnerability is to add a check to make sure that the pointer 's' is not out of bounds. An if statement has been added to check if 's' is not beyond the end of the string and if it is, it will return NULL and free the memory.",483,-47.84752304008269,-0.09906319469996416
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static PyObject * decode_unicode_with_escapes ( struct compiling * c , const node * n , const char * s , size_t len ) { PyObject * u ; char * buf ; char * p ; const char * end ; if ( len > SIZE_MAX / 6 ) return NULL ; u = PyBytes_FromStringAndSize ( ( char * ) NULL , len * 6 ) ; if ( u == NULL ) return NULL ; p = buf = PyBytes_AsString ( u ) ; end = s + len ; while ( s < end ) { if ( * s == '\\\\' ) { * p ++ = * s ++ ; if ( * s & 0x80 ) { strcpy ( p , ""u005c"" ) ; p += 5 ; } } if ( * s & 0x80 ) { PyObject * w ; int kind ; void * data ; Py_ssize_t len , i ; w = decode_utf8 ( c , & s , end ) ; if ( w == NULL ) { Py_DECREF ( u ) ; return NULL ; } kind = PyUnicode_KIND ( w ) ; data = PyUnicode_DATA ( w ) ; len = PyUnicode_GET_LENGTH ( w ) ; for ( i = 0 ; i < len ; i ++ ) { Py_UCS4 chr = PyUnicode_READ ( kind , data , i ) ; sprintf ( p , ""\\\\U%08x"" , chr ) ; p += 10 ; } assert ( p - buf <= Py_SIZE ( u ) ) ; Py_DECREF ( w ) ; } else { * p ++ = * s ++ ; } } len = p - buf ; s = buf ; return PyUnicode_DecodeUnicodeEscape ( s , len , NULL ) ; }
Fixed code:","
static PyObject * decode_unicode_with_escapes ( struct compiling * c , const node * n , const char * s , size_t len ) { PyObject * u ; char * buf ; char * p ; const char * end ; if ( len > SIZE_MAX / 6 ) return NULL ; u = PyBytes_FromStringAndSize ( ( char * ) NULL , len * 6 ) ; if ( u == NULL ) return NULL ; p = buf = PyBytes_AsString ( u ) ; end = s + len ; while ( s < end ) { if ( * s == '\\\\' ) { * p ++ = * s ++ ; if ( * s & 0x80 ) { strcpy ( p , ""u005c"" ) ; p += 5 ; } } if ( * s & 0x80 ) { PyObject * w ; int kind ; void * data ; Py_ssize_t len , i ; w = decode_utf8 ( c , & s , end ) ; if ( w == NULL ) { Py_DECREF ( u ) ; return NULL ; } kind = PyUnicode_KIND ( w ) ; data = PyUnicode_DATA ( w ) ; len = PyUnicode_GET_LENGTH ( w ) ; if (len > SIZE_MAX / 10) { Py_DECREF ( w ) ; return NULL ; } for ( i = 0 ; i < len ; i ++ ) { Py_UCS4 chr = PyUnicode_READ ( kind , data , i ) ; sprintf ( p , ""\\\\U%08x"" , chr ) ; p += 10 ; } assert ( p - buf <= Py_SIZE ( u ) ) ; Py_DECREF ( w ) ; } else { * p ++ = * s ++ ; } } len = p - buf ; s = buf ; return PyUnicode_DecodeUnicodeEscape ( s , len , NULL ) ; }

The vulnerability in the original code is a potential out-of-bounds read when calculating the length of the unicode string. This can cause the string to be read beyond the allocated length and crash the program. To fix this vulnerability, a check to ensure that the length of the unicode string does not exceed the maximum buffer size has been added. This check is performed before the loop that iterates over the unicode string is executed, so that the loop can be terminated before any out-of-bounds reads occur.",535,-94.04860263810052,-0.17579178063196357
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static PyObject * decode_unicode_with_escapes ( struct compiling * c , const node * n , const char * s , size_t len ) { PyObject * u ; char * buf ; char * p ; const char * end ; if ( len > SIZE_MAX / 6 ) return NULL ; u = PyBytes_FromStringAndSize ( ( char * ) NULL , len * 6 ) ; if ( u == NULL ) return NULL ; p = buf = PyBytes_AsString ( u ) ; end = s + len ; while ( s < end ) { if ( * s == '\\\\' ) { * p ++ = * s ++ ; if ( * s & 0x80 ) { strcpy ( p , ""u005c"" ) ; p += 5 ; } } if ( * s & 0x80 ) { PyObject * w ; int kind ; void * data ; Py_ssize_t len , i ; w = decode_utf8 ( c , & s , end ) ; if ( w == NULL ) { Py_DECREF ( u ) ; return NULL ; } kind = PyUnicode_KIND ( w ) ; data = PyUnicode_DATA ( w ) ; len = PyUnicode_GET_LENGTH ( w ) ; for ( i = 0 ; i < len ; i ++ ) { Py_UCS4 chr = PyUnicode_READ ( kind , data , i ) ; sprintf ( p , ""\\\\U%08x"" , chr ) ; p += 10 ; } assert ( p - buf <= Py_SIZE ( u ) ) ; Py_DECREF ( w ) ; } else { * p ++ = * s ++ ; } } len = p - buf ; s = buf ; return PyUnicode_DecodeUnicodeEscape ( s , len , NULL ) ; }
Fixed code:","
static PyObject * decode_unicode_with_escapes ( struct compiling * c , const node * n , const char * s , size_t len ) { PyObject * u ; char * buf ; char * p ; const char * end ; if ( len > SIZE_MAX / 6 ) return NULL ; u = PyBytes_FromStringAndSize ( ( char * ) NULL , len * 6 ) ; if ( u == NULL ) return NULL ; p = buf = PyBytes_AsString ( u ) ; end = s + len ; while ( s < end && s < end + len ) { if ( * s == '\\\\' ) { * p ++ = * s ++ ; if ( * s & 0x80 ) { strcpy ( p , ""u005c"" ) ; p += 5 ; } } if ( * s & 0x80 ) { PyObject * w ; int kind ; void * data ; Py_ssize_t len , i ; w = decode_utf8 ( c , & s , end ) ; if ( w == NULL ) { Py_DECREF ( u ) ; return NULL ; } kind = PyUnicode_KIND ( w ) ; data = PyUnicode_DATA ( w ) ; len = PyUnicode_GET_LENGTH ( w ) ; for ( i = 0 ; i < len ; i ++ ) { Py_UCS4 chr = PyUnicode_READ ( kind , data , i ) ; sprintf ( p , ""\\\\U%08x"" , chr ) ; p += 10 ; } assert ( p - buf <= Py_SIZE ( u ) ) ; Py_DECREF ( w ) ; } else { * p ++ = * s ++ ; } } len = p - buf ; s = buf ; return PyUnicode_DecodeUnicodeEscape ( s , len , NULL ) ; }",408,-7.502696053868801,-0.0183889609163451
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static PyObject * decode_unicode_with_escapes ( struct compiling * c , const node * n , const char * s , size_t len ) { PyObject * u ; char * buf ; char * p ; const char * end ; if ( len > SIZE_MAX / 6 ) return NULL ; u = PyBytes_FromStringAndSize ( ( char * ) NULL , len * 6 ) ; if ( u == NULL ) return NULL ; p = buf = PyBytes_AsString ( u ) ; end = s + len ; while ( s < end ) { if ( * s == '\\\\' ) { * p ++ = * s ++ ; if ( * s & 0x80 ) { strcpy ( p , ""u005c"" ) ; p += 5 ; } } if ( * s & 0x80 ) { PyObject * w ; int kind ; void * data ; Py_ssize_t len , i ; w = decode_utf8 ( c , & s , end ) ; if ( w == NULL ) { Py_DECREF ( u ) ; return NULL ; } kind = PyUnicode_KIND ( w ) ; data = PyUnicode_DATA ( w ) ; len = PyUnicode_GET_LENGTH ( w ) ; for ( i = 0 ; i < len ; i ++ ) { Py_UCS4 chr = PyUnicode_READ ( kind , data , i ) ; sprintf ( p , ""\\\\U%08x"" , chr ) ; p += 10 ; } assert ( p - buf <= Py_SIZE ( u ) ) ; Py_DECREF ( w ) ; } else { * p ++ = * s ++ ; } } len = p - buf ; s = buf ; return PyUnicode_DecodeUnicodeEscape ( s , len , NULL ) ; }
Fixed code:","
static PyObject * decode_unicode_with_escapes ( struct compiling * c , const node * n , const char * s , size_t len ) { PyObject * u ; char * buf ; char * p ; const char * end ; if ( len > SIZE_MAX / 6 ) return NULL ; u = PyBytes_FromStringAndSize ( ( char * ) NULL , len * 6 ) ; if ( u == NULL ) return NULL ; p = buf = PyBytes_AsString ( u ) ; end = s + len ; while ( s < end ) { if ( * s == '\\\\' ) { * p ++ = * s ++ ; if ( * s & 0x80 ) { strcpy ( p , ""u005c"" ) ; p += 5 ; } } if ( * s & 0x80 ) { PyObject * w ; int kind ; void * data ; Py_ssize_t len , i ; if(s+1 == end){ // Added line to check for out-of-bounds read Py_DECREF ( u ) ; return NULL ; } w = decode_utf8 ( c , & s , end ) ; if ( w == NULL ) { Py_DECREF ( u ) ; return NULL ; } kind = PyUnicode_KIND ( w ) ; data = PyUnicode_DATA ( w ) ; len = PyUnicode_GET_LENGTH ( w ) ; for ( i = 0 ; i < len ; i ++ ) { Py_UCS4 chr = PyUnicode_READ ( kind , data , i ) ; sprintf ( p , ""\\\\U%08x"" , chr ) ; p += 10 ; } assert ( p - buf <= Py_SIZE ( u ) ) ; Py_DECREF ( w ) ; } else { * p ++ = * s ++ ; } } len = p - buf ; s = buf ; return PyUnicode_DecodeUnicodeEscape ( s , len , NULL ) ; }",435,-24.515376684175706,-0.05635718777971427
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static PyObject * decode_unicode_with_escapes ( struct compiling * c , const node * n , const char * s , size_t len ) { PyObject * u ; char * buf ; char * p ; const char * end ; if ( len > SIZE_MAX / 6 ) return NULL ; u = PyBytes_FromStringAndSize ( ( char * ) NULL , len * 6 ) ; if ( u == NULL ) return NULL ; p = buf = PyBytes_AsString ( u ) ; end = s + len ; while ( s < end ) { if ( * s == '\\\\' ) { * p ++ = * s ++ ; if ( * s & 0x80 ) { strcpy ( p , ""u005c"" ) ; p += 5 ; } } if ( * s & 0x80 ) { PyObject * w ; int kind ; void * data ; Py_ssize_t len , i ; w = decode_utf8 ( c , & s , end ) ; if ( w == NULL ) { Py_DECREF ( u ) ; return NULL ; } kind = PyUnicode_KIND ( w ) ; data = PyUnicode_DATA ( w ) ; len = PyUnicode_GET_LENGTH ( w ) ; for ( i = 0 ; i < len ; i ++ ) { Py_UCS4 chr = PyUnicode_READ ( kind , data , i ) ; sprintf ( p , ""\\\\U%08x"" , chr ) ; p += 10 ; } assert ( p - buf <= Py_SIZE ( u ) ) ; Py_DECREF ( w ) ; } else { * p ++ = * s ++ ; } } len = p - buf ; s = buf ; return PyUnicode_DecodeUnicodeEscape ( s , len , NULL ) ; }
Fixed code:","
static PyObject * decode_unicode_with_escapes ( struct compiling * c , const node * n , const char * s , size_t len ) { PyObject * u ; char * buf ; char * p ; const char * end ; if ( len > SIZE_MAX / 6 ) return NULL ; u = PyBytes_FromStringAndSize ( ( char * ) NULL , len * 6 ) ; if ( u == NULL ) return NULL ; p = buf = PyBytes_AsString ( u ) ; end = s + len ; while ( s < end ) { if ( s >= end ) { Py_DECREF ( u ) ; return NULL ; } if ( * s == '\\\\' ) { * p ++ = * s ++ ; if ( * s & 0x80 ) { strcpy ( p , ""u005c"" ) ; p += 5 ; } } if ( * s & 0x80 ) { PyObject * w ; int kind ; void * data ; Py_ssize_t len , i ; w = decode_utf8 ( c , & s , end ) ; if ( w == NULL ) { Py_DECREF ( u ) ; return NULL ; } kind = PyUnicode_KIND ( w ) ; data = PyUnicode_DATA ( w ) ; len = PyUnicode_GET_LENGTH ( w ) ; for ( i = 0 ; i < len ; i ++ ) { Py_UCS4 chr = PyUnicode_READ ( kind , data , i ) ; sprintf ( p , ""\\\\U%08x"" , chr ) ; p += 10 ; } assert ( p - buf <= Py_SIZE ( u ) ) ; Py_DECREF ( w ) ; } else { * p ++ = * s ++ ; } } len = p - buf ; s = buf ; return PyUnicode_DecodeUnicodeEscape ( s , len , NULL ) ; }",421,-5.339387513516608,-0.012682630673436125
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static PyObject * decode_unicode_with_escapes ( struct compiling * c , const node * n , const char * s , size_t len ) { PyObject * u ; char * buf ; char * p ; const char * end ; if ( len > SIZE_MAX / 6 ) return NULL ; u = PyBytes_FromStringAndSize ( ( char * ) NULL , len * 6 ) ; if ( u == NULL ) return NULL ; p = buf = PyBytes_AsString ( u ) ; end = s + len ; while ( s < end ) { if ( * s == '\\\\' ) { * p ++ = * s ++ ; if ( * s & 0x80 ) { strcpy ( p , ""u005c"" ) ; p += 5 ; } } if ( * s & 0x80 ) { PyObject * w ; int kind ; void * data ; Py_ssize_t len , i ; w = decode_utf8 ( c , & s , end ) ; if ( w == NULL ) { Py_DECREF ( u ) ; return NULL ; } kind = PyUnicode_KIND ( w ) ; data = PyUnicode_DATA ( w ) ; len = PyUnicode_GET_LENGTH ( w ) ; for ( i = 0 ; i < len ; i ++ ) { Py_UCS4 chr = PyUnicode_READ ( kind , data , i ) ; sprintf ( p , ""\\\\U%08x"" , chr ) ; p += 10 ; } assert ( p - buf <= Py_SIZE ( u ) ) ; Py_DECREF ( w ) ; } else { * p ++ = * s ++ ; } } len = p - buf ; s = buf ; return PyUnicode_DecodeUnicodeEscape ( s , len , NULL ) ; }
Fixed code:","
static PyObject * decode_unicode_with_escapes ( struct compiling * c , const node * n , const char * s , size_t len ) { PyObject * u ; char * buf ; char * p ; const char * end ; if ( len > SIZE_MAX / 6 ) return NULL ; u = PyBytes_FromStringAndSize ( ( char * ) NULL , len * 6 ) ; if ( u == NULL ) return NULL ; p = buf = PyBytes_AsString ( u ) ; end = s + len ; while ( s < end ) { if ( * s == '\\\\' ) { * p ++ = * s ++ ; if ( * s & 0x80 ) { strcpy ( p , ""u005c"" ) ; p += 5 ; } else if ( * s == 'U' || * s == 'u' ) { s++; if ( end - s < 8 || !isxdigit(*s++) || !isxdigit(*s++) || !isxdigit(*s++) || !isxdigit(*s++) || !isxdigit(*s++) || !isxdigit(*s++) || !isxdigit(*s++) || !isxdigit(*s++) ) { Py_DECREF(u); return NULL; } } } if ( * s & 0x80 ) { PyObject * w ; int kind ; void * data ; Py_ssize_t len , i ; w = decode_utf8 ( c , & s , end ) ; if ( w == NULL ) { Py_DECREF ( u ) ; return NULL ; } kind = PyUnicode_KIND ( w ) ; data = PyUnicode_DATA ( w ) ; len = PyUnicode_GET_LENGTH ( w ) ; for ( i = 0 ; i < len ; i ++ ) { Py_UCS4 chr = PyUnicode_READ ( kind , data , i ) ; sprintf ( p , ""\\\\U%08x"" , chr ) ; p += 10 ; } assert ( p - buf <= Py_SIZE ( u ) ) ; Py_DECREF ( w ) ; } else { * p ++ = * s ++ ; } } len = p - buf ; s = buf ; return PyUnicode_DecodeUnicodeEscape ( s , len , NULL ) ; }",507,-29.683628259134707,-0.05854759025470357
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static PyObject * decode_unicode_with_escapes ( struct compiling * c , const node * n , const char * s , size_t len ) { PyObject * u ; char * buf ; char * p ; const char * end ; if ( len > SIZE_MAX / 6 ) return NULL ; u = PyBytes_FromStringAndSize ( ( char * ) NULL , len * 6 ) ; if ( u == NULL ) return NULL ; p = buf = PyBytes_AsString ( u ) ; end = s + len ; while ( s < end ) { if ( * s == '\\\\' ) { * p ++ = * s ++ ; if ( * s & 0x80 ) { strcpy ( p , ""u005c"" ) ; p += 5 ; } } if ( * s & 0x80 ) { PyObject * w ; int kind ; void * data ; Py_ssize_t len , i ; w = decode_utf8 ( c , & s , end ) ; if ( w == NULL ) { Py_DECREF ( u ) ; return NULL ; } kind = PyUnicode_KIND ( w ) ; data = PyUnicode_DATA ( w ) ; len = PyUnicode_GET_LENGTH ( w ) ; for ( i = 0 ; i < len ; i ++ ) { Py_UCS4 chr = PyUnicode_READ ( kind , data , i ) ; sprintf ( p , ""\\\\U%08x"" , chr ) ; p += 10 ; } assert ( p - buf <= Py_SIZE ( u ) ) ; Py_DECREF ( w ) ; } else { * p ++ = * s ++ ; } } len = p - buf ; s = buf ; return PyUnicode_DecodeUnicodeEscape ( s , len , NULL ) ; }
Fixed code:","
static PyObject * decode_unicode_with_escapes ( struct compiling * c , const node * n , const char * s , size_t len ) { PyObject * u ; char * buf ; char * p ; const char * end ; if ( len > SIZE_MAX / 6 ) return NULL ; u = PyBytes_FromStringAndSize ( ( char * ) NULL , len * 6 ) ; if ( u == NULL ) return NULL ; p = buf = PyBytes_AsString ( u ) ; end = s + len ; while ( s < end ) { if ( * s == '\\\\' ) { * p ++ = * s ++ ; if ( * s & 0x80 ) { strcpy ( p , ""u005c"" ) ; p += 5 ; } } if ( * s & 0x80 ) { PyObject * w ; int kind ; void * data ; Py_ssize_t len , i ; w = decode_utf8 ( c , & s , end ) ; if ( w == NULL ) { Py_DECREF ( u ) ; return NULL ; } kind = PyUnicode_KIND ( w ) ; data = PyUnicode_DATA ( w ) ; len = PyUnicode_GET_LENGTH ( w ) ; for ( i = 0 ; i < len ; i ++ ) { //Checking for out of bounds read if (i >= len) break; Py_UCS4 chr = PyUnicode_READ ( kind , data , i ) ; sprintf ( p , ""\\\\U%08x"" , chr ) ; p += 10 ; } assert ( p - buf <= Py_SIZE ( u ) ) ; Py_DECREF ( w ) ; } else { * p ++ = * s ++ ; } } len = p - buf ; s = buf ; return PyUnicode_DecodeUnicodeEscape ( s , len , NULL ) ; }",418,-17.920620147755745,-0.042872297004200345
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static PyObject * decode_unicode_with_escapes ( struct compiling * c , const node * n , const char * s , size_t len ) { PyObject * u ; char * buf ; char * p ; const char * end ; if ( len > SIZE_MAX / 6 ) return NULL ; u = PyBytes_FromStringAndSize ( ( char * ) NULL , len * 6 ) ; if ( u == NULL ) return NULL ; p = buf = PyBytes_AsString ( u ) ; end = s + len ; while ( s < end ) { if ( * s == '\\\\' ) { * p ++ = * s ++ ; if ( * s & 0x80 ) { strcpy ( p , ""u005c"" ) ; p += 5 ; } } if ( * s & 0x80 ) { PyObject * w ; int kind ; void * data ; Py_ssize_t len , i ; w = decode_utf8 ( c , & s , end ) ; if ( w == NULL ) { Py_DECREF ( u ) ; return NULL ; } kind = PyUnicode_KIND ( w ) ; data = PyUnicode_DATA ( w ) ; len = PyUnicode_GET_LENGTH ( w ) ; for ( i = 0 ; i < len ; i ++ ) { Py_UCS4 chr = PyUnicode_READ ( kind , data , i ) ; sprintf ( p , ""\\\\U%08x"" , chr ) ; p += 10 ; } assert ( p - buf <= Py_SIZE ( u ) ) ; Py_DECREF ( w ) ; } else { * p ++ = * s ++ ; } } len = p - buf ; s = buf ; return PyUnicode_DecodeUnicodeEscape ( s , len , NULL ) ; }
Fixed code:","
static PyObject * decode_unicode_with_escapes ( struct compiling * c , const node * n , const char * s , size_t len ) { 
PyObject * u ; 
char * buf ; 
char * p ; 
const char * end ; 
if ( len > SIZE_MAX / 6 ) return NULL ; 
u = PyBytes_FromStringAndSize ( ( char * ) NULL , len * 6 ) ; 
if ( u == NULL ) return NULL ; 
p = buf = PyBytes_AsString ( u ) ; 
end = s + len ; 
while ( s < end ) { 
if ( end - s < 2 || * s != '\\\\' ) { 
* p ++ = * s ++ ; 
if ( * s & 0x80 ) { 
strcpy ( p , ""u005c"" ) ; 
p += 5 ; 
} 
} else { 
PyObject * w ; 
int kind ; 
void * data ; 
Py_ssize_t len , i ; 
w = decode_utf8 ( c , & s , end ) ; 
if ( w == NULL ) { 
Py_DECREF ( u ) ; 
return NULL ; 
} 
kind = PyUnicode_KIND ( w ) ; 
data = PyUnicode_DATA ( w ) ; 
len = PyUnicode_GET_LENGTH ( w ) ; 
for ( i = 0 ; i < len ; i ++ ) { 
Py_UCS4 chr = PyUnicode_READ ( kind , data , i ) ; 
sprintf ( p , ""\\\\U%08x"" , chr ) ; 
p += 10 ; 
} 
assert ( p - buf <= Py_SIZE ( u ) ) ; 
Py_DECREF ( w ) ; 
} 
} 
len = p - buf ; 
s = buf ; 
return PyUnicode_DecodeUnicodeEscape ( s , len , NULL ) ; 
}",473,-20.1874719131142,-0.04267964463660508
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static PyObject * decode_unicode_with_escapes ( struct compiling * c , const node * n , const char * s , size_t len ) { PyObject * u ; char * buf ; char * p ; const char * end ; if ( len > SIZE_MAX / 6 ) return NULL ; u = PyBytes_FromStringAndSize ( ( char * ) NULL , len * 6 ) ; if ( u == NULL ) return NULL ; p = buf = PyBytes_AsString ( u ) ; end = s + len ; while ( s < end ) { if ( * s == '\\\\' ) { * p ++ = * s ++ ; if ( * s & 0x80 ) { strcpy ( p , ""u005c"" ) ; p += 5 ; } } if ( * s & 0x80 ) { PyObject * w ; int kind ; void * data ; Py_ssize_t len , i ; w = decode_utf8 ( c , & s , end ) ; if ( w == NULL ) { Py_DECREF ( u ) ; return NULL ; } kind = PyUnicode_KIND ( w ) ; data = PyUnicode_DATA ( w ) ; len = PyUnicode_GET_LENGTH ( w ) ; for ( i = 0 ; i < len ; i ++ ) { Py_UCS4 chr = PyUnicode_READ ( kind , data , i ) ; sprintf ( p , ""\\\\U%08x"" , chr ) ; p += 10 ; } assert ( p - buf <= Py_SIZE ( u ) ) ; Py_DECREF ( w ) ; } else { * p ++ = * s ++ ; } } len = p - buf ; s = buf ; return PyUnicode_DecodeUnicodeEscape ( s , len , NULL ) ; }
Fixed code:","
static PyObject * decode_unicode_with_escapes ( struct compiling * c , const node * n , const char * s , size_t len ) { PyObject * u ; char * buf ; char * p ; const char * end ; if ( len > SIZE_MAX / 6 ) return NULL ; u = PyBytes_FromStringAndSize ( ( char * ) NULL , len * 6 ) ; if ( u == NULL ) return NULL ; p = buf = PyBytes_AsString ( u ) ; end = s + len ; while ( s < end && p - buf <= Py_SIZE ( u ) ) { if ( * s == '\\\\' ) { * p ++ = * s ++ ; if ( * s & 0x80 ) { strcpy ( p , ""u005c"" ) ; p += 5 ; } } if ( * s & 0x80 ) { PyObject * w ; int kind ; void * data ; Py_ssize_t len , i ; w = decode_utf8 ( c , & s , end ) ; if ( w == NULL ) { Py_DECREF ( u ) ; return NULL ; } kind = PyUnicode_KIND ( w ) ; data = PyUnicode_DATA ( w ) ; len = PyUnicode_GET_LENGTH ( w ) ; for ( i = 0 ; i < len ; i ++ ) { Py_UCS4 chr = PyUnicode_READ ( kind , data , i ) ; sprintf ( p , ""\\\\U%08x"" , chr ) ; p += 10 ; } Py_DECREF ( w ) ; } else { * p ++ = * s ++ ; } } len = p - buf ; s = buf ; return PyUnicode_DecodeUnicodeEscape ( s , len , NULL ) ; }",399,-6.694178514813593,-0.016777389761437576
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static PyObject * decode_unicode_with_escapes ( struct compiling * c , const node * n , const char * s , size_t len ) { PyObject * u ; char * buf ; char * p ; const char * end ; if ( len > SIZE_MAX / 6 ) return NULL ; u = PyBytes_FromStringAndSize ( ( char * ) NULL , len * 6 ) ; if ( u == NULL ) return NULL ; p = buf = PyBytes_AsString ( u ) ; end = s + len ; while ( s < end ) { if ( * s == '\\\\' ) { * p ++ = * s ++ ; if ( * s & 0x80 ) { strcpy ( p , ""u005c"" ) ; p += 5 ; } } if ( * s & 0x80 ) { PyObject * w ; int kind ; void * data ; Py_ssize_t len , i ; w = decode_utf8 ( c , & s , end ) ; if ( w == NULL ) { Py_DECREF ( u ) ; return NULL ; } kind = PyUnicode_KIND ( w ) ; data = PyUnicode_DATA ( w ) ; len = PyUnicode_GET_LENGTH ( w ) ; for ( i = 0 ; i < len ; i ++ ) { Py_UCS4 chr = PyUnicode_READ ( kind , data , i ) ; sprintf ( p , ""\\\\U%08x"" , chr ) ; p += 10 ; } assert ( p - buf <= Py_SIZE ( u ) ) ; Py_DECREF ( w ) ; } else { * p ++ = * s ++ ; } } len = p - buf ; s = buf ; return PyUnicode_DecodeUnicodeEscape ( s , len , NULL ) ; }
Fixed code:","
static PyObject * decode_unicode_with_escapes ( struct compiling * c , const node * n , const char * s , size_t len ) { PyObject * u ; char * buf ; char * p ; const char * end ; if ( len > SIZE_MAX / 6 ) return NULL ; u = PyBytes_FromStringAndSize ( ( char * ) NULL , len * 6 ) ; if ( u == NULL ) return NULL ; p = buf = PyBytes_AsString ( u ) ; end = s + len ; while ( s < end ) { if ( * s == '\\\\' ) { * p ++ = * s ++ ; if ( * s & 0x80 ) { strcpy ( p , ""u005c"" ) ; p += 5 ; } } if ( * s & 0x80 ) { PyObject * w ; int kind ; void * data ; Py_ssize_t len , i ; w = decode_utf8 ( c , & s , end ) ; if ( w == NULL ) { Py_DECREF ( u ) ; return NULL ; } kind = PyUnicode_KIND ( w ) ; data = PyUnicode_DATA ( w ) ; len = PyUnicode_GET_LENGTH ( w ) ; for ( i = 0 ; i < len ; i ++ ) { if(i >= len) break; Py_UCS4 chr = PyUnicode_READ ( kind , data , i ) ; sprintf ( p , ""\\\\U%08x"" , chr ) ; p += 10 ; } assert ( p - buf <= Py_SIZE ( u ) ) ; Py_DECREF ( w ) ; } else { * p ++ = * s ++ ; } } len = p - buf ; s = buf ; return PyUnicode_DecodeUnicodeEscape ( s , len , NULL ) ; }",410,-10.621977670576044,-0.025907262611161084
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static PyObject * decode_unicode_with_escapes ( struct compiling * c , const node * n , const char * s , size_t len ) { PyObject * u ; char * buf ; char * p ; const char * end ; if ( len > SIZE_MAX / 6 ) return NULL ; u = PyBytes_FromStringAndSize ( ( char * ) NULL , len * 6 ) ; if ( u == NULL ) return NULL ; p = buf = PyBytes_AsString ( u ) ; end = s + len ; while ( s < end ) { if ( * s == '\\\\' ) { * p ++ = * s ++ ; if ( * s & 0x80 ) { strcpy ( p , ""u005c"" ) ; p += 5 ; } } if ( * s & 0x80 ) { PyObject * w ; int kind ; void * data ; Py_ssize_t len , i ; w = decode_utf8 ( c , & s , end ) ; if ( w == NULL ) { Py_DECREF ( u ) ; return NULL ; } kind = PyUnicode_KIND ( w ) ; data = PyUnicode_DATA ( w ) ; len = PyUnicode_GET_LENGTH ( w ) ; for ( i = 0 ; i < len ; i ++ ) { Py_UCS4 chr = PyUnicode_READ ( kind , data , i ) ; sprintf ( p , ""\\\\U%08x"" , chr ) ; p += 10 ; } assert ( p - buf <= Py_SIZE ( u ) ) ; Py_DECREF ( w ) ; } else { * p ++ = * s ++ ; } } len = p - buf ; s = buf ; return PyUnicode_DecodeUnicodeEscape ( s , len , NULL ) ; }
Fixed code:","
static PyObject * decode_unicode_with_escapes ( struct compiling * c , const node * n , const char * s , size_t len ) { PyObject * u ; char * buf ; char * p ; const char * end ; if ( len > SIZE_MAX / 6 ) return NULL ; u = PyBytes_FromStringAndSize ( ( char * ) NULL , len * 6 ) ; if ( u == NULL ) return NULL ; p = buf = PyBytes_AsString ( u ) ; end = s + len ; while ( s < end ) { if ( * s == '\\\\' ) { * p ++ = * s ++ ; if ( * s & 0x80 ) { strcpy ( p , ""u005c"" ) ; p += 5 ; } } if ( * s & 0x80 ) { PyObject * w ; int kind ; void * data ; Py_ssize_t len , i ; size_t s_len = end - s; // add this line to prevent out-of-bounds read w = decode_utf8 ( c , & s , end ) ; if ( w == NULL ) { Py_DECREF ( u ) ; return NULL ; } kind = PyUnicode_KIND ( w ) ; data = PyUnicode_DATA ( w ) ; len = PyUnicode_GET_LENGTH ( w ) ; for ( i = 0 ; i < len ; i ++ ) { Py_UCS4 chr = PyUnicode_READ ( kind , data , i ) ; sprintf ( p , ""\\\\U%08x"" , chr ) ; p += 10 ; } assert ( p - buf <= Py_SIZE ( u ) ) ; Py_DECREF ( w ) ; } else { // add this line to prevent out-of-bounds read if (s < end) { * p ++ = * s ++ ; } } } len = p - buf ; s = buf ; return PyUnicode_DecodeUnicodeEscape ( s , len , NULL ) ; }",447,-28.08643560883865,-0.06283318928151822
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static PyObject * decode_unicode_with_escapes ( struct compiling * c , const node * n , const char * s , size_t len ) { PyObject * u ; char * buf ; char * p ; const char * end ; if ( len > SIZE_MAX / 6 ) return NULL ; u = PyBytes_FromStringAndSize ( ( char * ) NULL , len * 6 ) ; if ( u == NULL ) return NULL ; p = buf = PyBytes_AsString ( u ) ; end = s + len ; while ( s < end ) { if ( * s == '\\\\' ) { * p ++ = * s ++ ; if ( * s & 0x80 ) { strcpy ( p , ""u005c"" ) ; p += 5 ; } } if ( * s & 0x80 ) { PyObject * w ; int kind ; void * data ; Py_ssize_t len , i ; w = decode_utf8 ( c , & s , end ) ; if ( w == NULL ) { Py_DECREF ( u ) ; return NULL ; } kind = PyUnicode_KIND ( w ) ; data = PyUnicode_DATA ( w ) ; len = PyUnicode_GET_LENGTH ( w ) ; for ( i = 0 ; i < len ; i ++ ) { Py_UCS4 chr = PyUnicode_READ ( kind , data , i ) ; sprintf ( p , ""\\\\U%08x"" , chr ) ; p += 10 ; } assert ( p - buf <= Py_SIZE ( u ) ) ; Py_DECREF ( w ) ; } else { * p ++ = * s ++ ; } } len = p - buf ; s = buf ; return PyUnicode_DecodeUnicodeEscape ( s , len , NULL ) ; }
Fixed code:","
static PyObject * decode_unicode_with_escapes ( struct compiling * c , const node * n , const char * s , size_t len ) { PyObject * u ; char * buf ; char * p ; const char * end ; if ( len > SIZE_MAX / 6 ) return NULL ; u = PyBytes_FromStringAndSize ( ( char * ) NULL , len * 6 ) ; if ( u == NULL ) return NULL ; p = buf = PyBytes_AsString ( u ) ; end = s + len ; while ( s < end ) { if ( * s == '\\\\' ) { * p ++ = * s ++ ; if ( * s & 0x80 ) { strcpy ( p , ""u005c"" ) ; p += 5 ; } } if ( * s & 0x80 ) { PyObject * w ; int kind ; void * data ; Py_ssize_t len , i ; w = decode_utf8 ( c , & s , end ) ; if ( w == NULL ) { Py_DECREF ( u ) ; return NULL ; } kind = PyUnicode_KIND ( w ) ; data = PyUnicode_DATA ( w ) ; len = PyUnicode_GET_LENGTH ( w ) ; //Added a boundary check to prevent out-of-bounds read if (len > len * 6) { Py_DECREF ( u ) ; return NULL ; } for ( i = 0 ; i < len ; i ++ ) { Py_UCS4 chr = PyUnicode_READ ( kind , data , i ) ; sprintf ( p , ""\\\\U%08x"" , chr ) ; p += 10 ; } assert ( p - buf <= Py_SIZE ( u ) ) ; Py_DECREF ( w ) ; } else { * p ++ = * s ++ ; } } len = p - buf ; s = buf ; return PyUnicode_DecodeUnicodeEscape ( s , len , NULL ) ; }",437,-25.78186260614226,-0.05899739726806009
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static PyObject * decode_unicode_with_escapes ( struct compiling * c , const node * n , const char * s , size_t len ) { PyObject * u ; char * buf ; char * p ; const char * end ; if ( len > SIZE_MAX / 6 ) return NULL ; u = PyBytes_FromStringAndSize ( ( char * ) NULL , len * 6 ) ; if ( u == NULL ) return NULL ; p = buf = PyBytes_AsString ( u ) ; end = s + len ; while ( s < end ) { if ( * s == '\\\\' ) { * p ++ = * s ++ ; if ( * s & 0x80 ) { strcpy ( p , ""u005c"" ) ; p += 5 ; } } if ( * s & 0x80 ) { PyObject * w ; int kind ; void * data ; Py_ssize_t len , i ; w = decode_utf8 ( c , & s , end ) ; if ( w == NULL ) { Py_DECREF ( u ) ; return NULL ; } kind = PyUnicode_KIND ( w ) ; data = PyUnicode_DATA ( w ) ; len = PyUnicode_GET_LENGTH ( w ) ; for ( i = 0 ; i < len ; i ++ ) { Py_UCS4 chr = PyUnicode_READ ( kind , data , i ) ; sprintf ( p , ""\\\\U%08x"" , chr ) ; p += 10 ; } assert ( p - buf <= Py_SIZE ( u ) ) ; Py_DECREF ( w ) ; } else { * p ++ = * s ++ ; } } len = p - buf ; s = buf ; return PyUnicode_DecodeUnicodeEscape ( s , len , NULL ) ; }
Fixed code:","
static PyObject * decode_unicode_with_escapes ( struct compiling * c , const node * n , const char * s , size_t len ) { PyObject * u ; char * buf ; char * p ; const char * end ; if ( len > SIZE_MAX / 6 ) return NULL ; u = PyBytes_FromStringAndSize ( ( char * ) NULL , len * 6 ) ; if ( u == NULL ) return NULL ; p = buf = PyBytes_AsString ( u ) ; end = s + len ; while ( s < end && p < buf+len*6 ) { if ( * s == '\\\\' ) { * p ++ = * s ++ ; if ( * s & 0x80 ) { strncpy ( p , ""u005c"" , 5 ) ; p += 5 ; } } if ( * s & 0x80 ) { PyObject * w ; int kind ; void * data ; Py_ssize_t i ; w = decode_utf8 ( c , & s , end ) ; if ( w == NULL ) { Py_DECREF ( u ) ; return NULL ; } kind = PyUnicode_KIND ( w ) ; data = PyUnicode_DATA ( w ) ; for ( i = 0 ; i < PyUnicode_GET_LENGTH ( w ) && p < buf+len*6; i ++ ) { Py_UCS4 chr = PyUnicode_READ ( kind , data , i ) ; snprintf ( p , 10 , ""\\\\U%08x"" , chr ) ; p += 10 ; } assert ( p - buf <= Py_SIZE ( u ) ) ; Py_DECREF ( w ) ; } else { * p ++ = * s ++ ; } } len = p - buf ; s = buf ; return PyUnicode_DecodeUnicodeEscape ( s , len , NULL ) ; }",416,-18.217170147245366,-0.04379127439241674
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static PyObject * decode_unicode_with_escapes ( struct compiling * c , const node * n , const char * s , size_t len ) { PyObject * u ; char * buf ; char * p ; const char * end ; if ( len > SIZE_MAX / 6 ) return NULL ; u = PyBytes_FromStringAndSize ( ( char * ) NULL , len * 6 ) ; if ( u == NULL ) return NULL ; p = buf = PyBytes_AsString ( u ) ; end = s + len ; while ( s < end ) { if ( * s == '\\\\' ) { * p ++ = * s ++ ; if ( * s & 0x80 ) { strcpy ( p , ""u005c"" ) ; p += 5 ; } } if ( * s & 0x80 ) { PyObject * w ; int kind ; void * data ; Py_ssize_t len , i ; w = decode_utf8 ( c , & s , end ) ; if ( w == NULL ) { Py_DECREF ( u ) ; return NULL ; } kind = PyUnicode_KIND ( w ) ; data = PyUnicode_DATA ( w ) ; len = PyUnicode_GET_LENGTH ( w ) ; for ( i = 0 ; i < len ; i ++ ) { Py_UCS4 chr = PyUnicode_READ ( kind , data , i ) ; sprintf ( p , ""\\\\U%08x"" , chr ) ; p += 10 ; } assert ( p - buf <= Py_SIZE ( u ) ) ; Py_DECREF ( w ) ; } else { * p ++ = * s ++ ; } } len = p - buf ; s = buf ; return PyUnicode_DecodeUnicodeEscape ( s , len , NULL ) ; }
Fixed code:","
static PyObject * decode_unicode_with_escapes ( struct compiling * c , const node * n , const char * s , size_t len ) { PyObject * u ; char * buf ; char * p ; const char * end ; if ( len > SIZE_MAX / 6 ) return NULL ; u = PyBytes_FromStringAndSize ( ( char * ) NULL , len * 6 ) ; if ( u == NULL ) return NULL ; p = buf = PyBytes_AsString ( u ) ; end = s + len ; while ( s < end ) { if ( * s == '\\\\' ) { * p ++ = * s ++ ; if ( * s & 0x80 ) { strcpy ( p , ""u005c"" ) ; p += 5 ; if (p - buf > Py_SIZE(u)) { Py_DECREF ( u ) ; return NULL ; } } } if ( * s & 0x80 ) { PyObject * w ; int kind ; void * data ; Py_ssize_t len , i ; w = decode_utf8 ( c , & s , end ) ; if ( w == NULL ) { Py_DECREF ( u ) ; return NULL ; } kind = PyUnicode_KIND ( w ) ; data = PyUnicode_DATA ( w ) ; len = PyUnicode_GET_LENGTH ( w ) ; for ( i = 0 ; i < len ; i ++ ) { Py_UCS4 chr = PyUnicode_READ ( kind , data , i ) ; sprintf ( p , ""\\\\U%08x"" , chr ) ; p += 10 ; if (p - buf > Py_SIZE(u)) { Py_DECREF ( u ) ; return NULL ; } } assert ( p - buf <= Py_SIZE ( u ) ) ; Py_DECREF ( w ) ; } else { * p ++ = * s ++ ; } } len = p - buf ; s = buf ; return PyUnicode_DecodeUnicodeEscape ( s , len , NULL ) ; }

The vulnerability in the original code is that there is no check to make sure the string buffer p is not overflowing when dealing with unicode characters. To fix this, the code was modified to add an additional check to make sure p does not overflow Py_SIZE(u) before adding the characters to the buffer. This ensures that p will not be able to overrun the buffer and thus prevents the vulnerability.",535,-95.59645419946479,-0.17868496112049492
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static PyObject * decode_unicode_with_escapes ( struct compiling * c , const node * n , const char * s , size_t len ) { PyObject * u ; char * buf ; char * p ; const char * end ; if ( len > SIZE_MAX / 6 ) return NULL ; u = PyBytes_FromStringAndSize ( ( char * ) NULL , len * 6 ) ; if ( u == NULL ) return NULL ; p = buf = PyBytes_AsString ( u ) ; end = s + len ; while ( s < end ) { if ( * s == '\\\\' ) { * p ++ = * s ++ ; if ( * s & 0x80 ) { strcpy ( p , ""u005c"" ) ; p += 5 ; } } if ( * s & 0x80 ) { PyObject * w ; int kind ; void * data ; Py_ssize_t len , i ; w = decode_utf8 ( c , & s , end ) ; if ( w == NULL ) { Py_DECREF ( u ) ; return NULL ; } kind = PyUnicode_KIND ( w ) ; data = PyUnicode_DATA ( w ) ; len = PyUnicode_GET_LENGTH ( w ) ; for ( i = 0 ; i < len ; i ++ ) { Py_UCS4 chr = PyUnicode_READ ( kind , data , i ) ; sprintf ( p , ""\\\\U%08x"" , chr ) ; p += 10 ; } assert ( p - buf <= Py_SIZE ( u ) ) ; Py_DECREF ( w ) ; } else { * p ++ = * s ++ ; } } len = p - buf ; s = buf ; return PyUnicode_DecodeUnicodeEscape ( s , len , NULL ) ; }
Fixed code:","
static PyObject * decode_unicode_with_escapes ( struct compiling * c , const node * n , const char * s , size_t len ) { PyObject * u ; char * buf ; char * p ; const char * end ; if ( len > SIZE_MAX / 6 ) return NULL ; u = PyBytes_FromStringAndSize ( ( char * ) NULL , len * 6 ) ; if ( u == NULL ) return NULL ; p = buf = PyBytes_AsString ( u ) ; end = s + len ; while ( s < end ) { if ( s >= end ) { Py_DECREF ( u ) ; return NULL ; } if ( * s == '\\\\' ) { * p ++ = * s ++ ; if ( * s & 0x80 ) { strcpy ( p , ""u005c"" ) ; p += 5 ; } } if ( * s & 0x80 ) { PyObject * w ; int kind ; void * data ; Py_ssize_t len , i ; w = decode_utf8 ( c , & s , end ) ; if ( w == NULL ) { Py_DECREF ( u ) ; return NULL ; } kind = PyUnicode_KIND ( w ) ; data = PyUnicode_DATA ( w ) ; len = PyUnicode_GET_LENGTH ( w ) ; for ( i = 0 ; i < len ; i ++ ) { Py_UCS4 chr = PyUnicode_READ ( kind , data , i ) ; sprintf ( p , ""\\\\U%08x"" , chr ) ; p += 10 ; } assert ( p - buf <= Py_SIZE ( u ) ) ; Py_DECREF ( w ) ; } else { * p ++ = * s ++ ; } } len = p - buf ; s = buf ; return PyUnicode_DecodeUnicodeEscape ( s , len , NULL ) ; }",421,-5.339387513516608,-0.012682630673436125
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static PyObject * decode_unicode_with_escapes ( struct compiling * c , const node * n , const char * s , size_t len ) { PyObject * u ; char * buf ; char * p ; const char * end ; if ( len > SIZE_MAX / 6 ) return NULL ; u = PyBytes_FromStringAndSize ( ( char * ) NULL , len * 6 ) ; if ( u == NULL ) return NULL ; p = buf = PyBytes_AsString ( u ) ; end = s + len ; while ( s < end ) { if ( * s == '\\\\' ) { * p ++ = * s ++ ; if ( * s & 0x80 ) { strcpy ( p , ""u005c"" ) ; p += 5 ; } } if ( * s & 0x80 ) { PyObject * w ; int kind ; void * data ; Py_ssize_t len , i ; w = decode_utf8 ( c , & s , end ) ; if ( w == NULL ) { Py_DECREF ( u ) ; return NULL ; } kind = PyUnicode_KIND ( w ) ; data = PyUnicode_DATA ( w ) ; len = PyUnicode_GET_LENGTH ( w ) ; for ( i = 0 ; i < len ; i ++ ) { Py_UCS4 chr = PyUnicode_READ ( kind , data , i ) ; sprintf ( p , ""\\\\U%08x"" , chr ) ; p += 10 ; } assert ( p - buf <= Py_SIZE ( u ) ) ; Py_DECREF ( w ) ; } else { * p ++ = * s ++ ; } } len = p - buf ; s = buf ; return PyUnicode_DecodeUnicodeEscape ( s , len , NULL ) ; }
Fixed code:","
static PyObject * decode_unicode_with_escapes ( struct compiling * c , const node * n , const char * s , size_t len ) { PyObject * u ; char * buf ; char * p ; const char * end ; if ( len > SIZE_MAX / 6 ) return NULL ; u = PyBytes_FromStringAndSize ( ( char * ) NULL , len * 6 ) ; if ( u == NULL ) return NULL ; p = buf = PyBytes_AsString ( u ) ; end = s + len ; while ( s < end ) { if ( * s == '\\\\' ) { * p ++ = * s ++ ; if ( * s & 0x80 ) { strcpy ( p , ""u005c"" ) ; p += 5 ; } } if ( * s & 0x80 ) { PyObject * w ; int kind ; void * data ; Py_ssize_t len , i ; w = decode_utf8 ( c , & s , end ) ; if ( w == NULL ) { Py_DECREF ( u ) ; return NULL ; } kind = PyUnicode_KIND ( w ) ; data = PyUnicode_DATA ( w ) ; len = PyUnicode_GET_LENGTH ( w ) ; if(len > SIZE_MAX / 10) { Py_DECREF ( u ) ; return NULL ; } for ( i = 0 ; i < len ; i ++ ) { Py_UCS4 chr = PyUnicode_READ ( kind , data , i ) ; sprintf ( p , ""\\\\U%08x"" , chr ) ; p += 10 ; } assert ( p - buf <= Py_SIZE ( u ) ) ; Py_DECREF ( w ) ; } else { * p ++ = * s ++ ; } } len = p - buf ; s = buf ; return PyUnicode_DecodeUnicodeEscape ( s , len , NULL ) ; }
The fixed code is now protected against CWE-125: Out-of-bounds Read by adding an additional check for the length of the Unicode string being decoded. If the length is greater than SIZE_MAX/10, then the function will return NULL instead of attempting to decode the string, which would cause an out-of-bounds read.",501,-45.178357582912426,-0.09017636244094297
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static PyObject * decode_unicode_with_escapes ( struct compiling * c , const node * n , const char * s , size_t len ) { PyObject * u ; char * buf ; char * p ; const char * end ; if ( len > SIZE_MAX / 6 ) return NULL ; u = PyBytes_FromStringAndSize ( ( char * ) NULL , len * 6 ) ; if ( u == NULL ) return NULL ; p = buf = PyBytes_AsString ( u ) ; end = s + len ; while ( s < end ) { if ( * s == '\\\\' ) { * p ++ = * s ++ ; if ( * s & 0x80 ) { strcpy ( p , ""u005c"" ) ; p += 5 ; } } if ( * s & 0x80 ) { PyObject * w ; int kind ; void * data ; Py_ssize_t len , i ; w = decode_utf8 ( c , & s , end ) ; if ( w == NULL ) { Py_DECREF ( u ) ; return NULL ; } kind = PyUnicode_KIND ( w ) ; data = PyUnicode_DATA ( w ) ; len = PyUnicode_GET_LENGTH ( w ) ; for ( i = 0 ; i < len ; i ++ ) { Py_UCS4 chr = PyUnicode_READ ( kind , data , i ) ; sprintf ( p , ""\\\\U%08x"" , chr ) ; p += 10 ; } assert ( p - buf <= Py_SIZE ( u ) ) ; Py_DECREF ( w ) ; } else { * p ++ = * s ++ ; } } len = p - buf ; s = buf ; return PyUnicode_DecodeUnicodeEscape ( s , len , NULL ) ; }
Fixed code:","
static PyObject * decode_unicode_with_escapes ( struct compiling * c , const node * n , const char * s , size_t len ) { PyObject * u ; char * buf ; char * p ; const char * end ; char * end_buf; if ( len > SIZE_MAX / 6 ) return NULL ; u = PyBytes_FromStringAndSize ( ( char * ) NULL , len * 6 ) ; if ( u == NULL ) return NULL ; p = buf = PyBytes_AsString ( u ) ; end = s + len ; end_buf = buf + Py_SIZE(u); while ( s < end && p < end_buf ) { if ( * s == '\\\\' ) { * p ++ = * s ++ ; if ( * s & 0x80 ) { strcpy ( p , ""u005c"" ) ; p += 5 ; } } if ( * s & 0x80 ) { PyObject * w ; int kind ; void * data ; Py_ssize_t len , i ; w = decode_utf8 ( c , & s , end ) ; if ( w == NULL ) { Py_DECREF ( u ) ; return NULL ; } kind = PyUnicode_KIND ( w ) ; data = PyUnicode_DATA ( w ) ; len = PyUnicode_GET_LENGTH ( w ) ; for ( i = 0 ; i < len && p < end_buf ; i ++ ) { Py_UCS4 chr = PyUnicode_READ ( kind , data , i ) ; sprintf ( p , ""\\\\U%08x"" , chr ) ; p += 10 ; } Py_DECREF ( w ) ; } else { * p ++ = * s ++ ; } } len = p - buf ; s = buf ; return PyUnicode_DecodeUnicodeEscape ( s , len , NULL ) ; }",418,-22.21684220781991,-0.05315034021009547
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static PyObject * decode_unicode_with_escapes ( struct compiling * c , const node * n , const char * s , size_t len ) { PyObject * u ; char * buf ; char * p ; const char * end ; if ( len > SIZE_MAX / 6 ) return NULL ; u = PyBytes_FromStringAndSize ( ( char * ) NULL , len * 6 ) ; if ( u == NULL ) return NULL ; p = buf = PyBytes_AsString ( u ) ; end = s + len ; while ( s < end ) { if ( * s == '\\\\' ) { * p ++ = * s ++ ; if ( * s & 0x80 ) { strcpy ( p , ""u005c"" ) ; p += 5 ; } } if ( * s & 0x80 ) { PyObject * w ; int kind ; void * data ; Py_ssize_t len , i ; w = decode_utf8 ( c , & s , end ) ; if ( w == NULL ) { Py_DECREF ( u ) ; return NULL ; } kind = PyUnicode_KIND ( w ) ; data = PyUnicode_DATA ( w ) ; len = PyUnicode_GET_LENGTH ( w ) ; for ( i = 0 ; i < len ; i ++ ) { Py_UCS4 chr = PyUnicode_READ ( kind , data , i ) ; sprintf ( p , ""\\\\U%08x"" , chr ) ; p += 10 ; } assert ( p - buf <= Py_SIZE ( u ) ) ; Py_DECREF ( w ) ; } else { * p ++ = * s ++ ; } } len = p - buf ; s = buf ; return PyUnicode_DecodeUnicodeEscape ( s , len , NULL ) ; }
Fixed code:","
static PyObject * decode_unicode_with_escapes ( struct compiling * c , const node * n , const char * s , size_t len ) { PyObject * u ; char * buf ; char * p ; const char * end ; if ( len > SIZE_MAX / 6 ) return NULL ; u = PyBytes_FromStringAndSize ( ( char * ) NULL , len * 6 ) ; if ( u == NULL ) return NULL ; p = buf = PyBytes_AsString ( u ) ; end = s + len ; while ( s < end ) { if ( s + 1 < end && * s == '\\\\' ) { * p ++ = * s ++ ; if ( * s & 0x80 ) { strcpy ( p , ""u005c"" ) ; p += 5 ; } } if ( s + 1 < end && * s & 0x80 ) { PyObject * w ; int kind ; void * data ; Py_ssize_t len , i ; w = decode_utf8 ( c , & s , end ) ; if ( w == NULL ) { Py_DECREF ( u ) ; return NULL ; } kind = PyUnicode_KIND ( w ) ; data = PyUnicode_DATA ( w ) ; len = PyUnicode_GET_LENGTH ( w ) ; for ( i = 0 ; i < len ; i ++ ) { Py_UCS4 chr = PyUnicode_READ ( kind , data , i ) ; sprintf ( p , ""\\\\U%08x"" , chr ) ; p += 10 ; } assert ( p - buf <= Py_SIZE ( u ) ) ; Py_DECREF ( w ) ; } else { * p ++ = * s ++ ; } } len = p - buf ; s = buf ; return PyUnicode_DecodeUnicodeEscape ( s , len , NULL ) ; }

The vulnerability in the original code is that it does not check if there are enough bytes remaining to read from before trying to do so. This can lead to out-of-bounds reads and potential memory corruption. 

To fix this vulnerability, we can add a check which checks if there are enough bytes remaining to read from. This is done by adding an additional check to each of the if statements which checks if s + 1 < end. If this is true, then there are enough bytes remaining to read and the code can continue. If not, then the code will not try to read from out of bounds memory.",543,-100.27356625662574,-0.18466586787592218
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static PyObject * decode_unicode_with_escapes ( struct compiling * c , const node * n , const char * s , size_t len ) { PyObject * u ; char * buf ; char * p ; const char * end ; if ( len > SIZE_MAX / 6 ) return NULL ; u = PyBytes_FromStringAndSize ( ( char * ) NULL , len * 6 ) ; if ( u == NULL ) return NULL ; p = buf = PyBytes_AsString ( u ) ; end = s + len ; while ( s < end ) { if ( * s == '\\\\' ) { * p ++ = * s ++ ; if ( * s & 0x80 ) { strcpy ( p , ""u005c"" ) ; p += 5 ; } } if ( * s & 0x80 ) { PyObject * w ; int kind ; void * data ; Py_ssize_t len , i ; w = decode_utf8 ( c , & s , end ) ; if ( w == NULL ) { Py_DECREF ( u ) ; return NULL ; } kind = PyUnicode_KIND ( w ) ; data = PyUnicode_DATA ( w ) ; len = PyUnicode_GET_LENGTH ( w ) ; for ( i = 0 ; i < len ; i ++ ) { Py_UCS4 chr = PyUnicode_READ ( kind , data , i ) ; sprintf ( p , ""\\\\U%08x"" , chr ) ; p += 10 ; } assert ( p - buf <= Py_SIZE ( u ) ) ; Py_DECREF ( w ) ; } else { * p ++ = * s ++ ; } } len = p - buf ; s = buf ; return PyUnicode_DecodeUnicodeEscape ( s , len , NULL ) ; }
Fixed code:","
static PyObject * decode_unicode_with_escapes ( struct compiling * c , const node * n , const char * s , size_t len ) { PyObject * u ; char * buf ; char * p ; const char * end ; if ( len > SIZE_MAX / 6 ) return NULL ; u = PyBytes_FromStringAndSize ( ( char * ) NULL , len * 6 ) ; if ( u == NULL ) return NULL ; p = buf = PyBytes_AsString ( u ) ; end = s + len ; while ( s < end ) { if ( * s == '\\\\' ) { * p ++ = * s ++ ; if ( * s & 0x80 ) { strcpy ( p , ""u005c"" ) ; p += 5 ; } } if ( * s & 0x80 ) { PyObject * w ; int kind ; void * data ; Py_ssize_t len , i ; w = decode_utf8 ( c , & s , end ) ; if ( w == NULL ) { Py_DECREF ( u ) ; return NULL ; } kind = PyUnicode_KIND ( w ) ; data = PyUnicode_DATA ( w ) ; len = PyUnicode_GET_LENGTH ( w ) ; if (len > 0) { for ( i = 0 ; i < len ; i ++ ) { Py_UCS4 chr = PyUnicode_READ ( kind , data , i ) ; sprintf ( p , ""\\\\U%08x"" , chr ) ; p += 10 ; } } else { Py_DECREF(w); break; } assert ( p - buf <= Py_SIZE ( u ) ) ; Py_DECREF ( w ) ; } else { * p ++ = * s ++ ; } } len = p - buf ; s = buf ; return PyUnicode_DecodeUnicodeEscape ( s , len , NULL ) ; }",422,-14.190076739676327,-0.033625774264635845
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static PyObject * decode_unicode_with_escapes ( struct compiling * c , const node * n , const char * s , size_t len ) { PyObject * u ; char * buf ; char * p ; const char * end ; if ( len > SIZE_MAX / 6 ) return NULL ; u = PyBytes_FromStringAndSize ( ( char * ) NULL , len * 6 ) ; if ( u == NULL ) return NULL ; p = buf = PyBytes_AsString ( u ) ; end = s + len ; while ( s < end ) { if ( * s == '\\\\' ) { * p ++ = * s ++ ; if ( * s & 0x80 ) { strcpy ( p , ""u005c"" ) ; p += 5 ; } } if ( * s & 0x80 ) { PyObject * w ; int kind ; void * data ; Py_ssize_t len , i ; w = decode_utf8 ( c , & s , end ) ; if ( w == NULL ) { Py_DECREF ( u ) ; return NULL ; } kind = PyUnicode_KIND ( w ) ; data = PyUnicode_DATA ( w ) ; len = PyUnicode_GET_LENGTH ( w ) ; for ( i = 0 ; i < len ; i ++ ) { Py_UCS4 chr = PyUnicode_READ ( kind , data , i ) ; sprintf ( p , ""\\\\U%08x"" , chr ) ; p += 10 ; } assert ( p - buf <= Py_SIZE ( u ) ) ; Py_DECREF ( w ) ; } else { * p ++ = * s ++ ; } } len = p - buf ; s = buf ; return PyUnicode_DecodeUnicodeEscape ( s , len , NULL ) ; }
Fixed code:","
static PyObject * decode_unicode_with_escapes ( struct compiling * c , const node * n , const char * s , size_t len ) { PyObject * u ; char * buf ; char * p ; const char * end ; Py_ssize_t i ; if ( len > SIZE_MAX / 6 ) return NULL ; u = PyBytes_FromStringAndSize ( ( char * ) NULL , len * 6 ) ; if ( u == NULL ) return NULL ; p = buf = PyBytes_AsString ( u ) ; end = s + len ; i = 0 ; while ( s < end ) { if ( * s == '\\\\' ) { * p ++ = * s ++ ; if ( * s & 0x80 ) { strcpy ( p , ""u005c"" ) ; p += 5 ; } } if ( * s & 0x80 ) { PyObject * w ; int kind ; void * data ; Py_ssize_t len ; w = decode_utf8 ( c , & s , end ) ; if ( w == NULL ) { Py_DECREF ( u ) ; return NULL ; } kind = PyUnicode_KIND ( w ) ; data = PyUnicode_DATA ( w ) ; len = PyUnicode_GET_LENGTH ( w ) ; i += len ; if ( i > Py_SIZE ( u ) ) { Py_DECREF ( w ) ; Py_DECREF ( u ) ; return NULL ; } for ( ; len > 0 ; len -- ) { Py_UCS4 chr = PyUnicode_READ ( kind , data , len - 1 ) ; sprintf ( p , ""\\\\U%08x"" , chr ) ; p += 10 ; } Py_DECREF ( w ) ; } else { * p ++ = * s ++ ; } } len = p - buf ; s = buf ; return PyUnicode_DecodeUnicodeEscape ( s , len , NULL ) ; }",433,-22.96653857076447,-0.05304050478236598
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static PyObject * decode_unicode_with_escapes ( struct compiling * c , const node * n , const char * s , size_t len ) { PyObject * u ; char * buf ; char * p ; const char * end ; if ( len > SIZE_MAX / 6 ) return NULL ; u = PyBytes_FromStringAndSize ( ( char * ) NULL , len * 6 ) ; if ( u == NULL ) return NULL ; p = buf = PyBytes_AsString ( u ) ; end = s + len ; while ( s < end ) { if ( * s == '\\\\' ) { * p ++ = * s ++ ; if ( * s & 0x80 ) { strcpy ( p , ""u005c"" ) ; p += 5 ; } } if ( * s & 0x80 ) { PyObject * w ; int kind ; void * data ; Py_ssize_t len , i ; w = decode_utf8 ( c , & s , end ) ; if ( w == NULL ) { Py_DECREF ( u ) ; return NULL ; } kind = PyUnicode_KIND ( w ) ; data = PyUnicode_DATA ( w ) ; len = PyUnicode_GET_LENGTH ( w ) ; for ( i = 0 ; i < len ; i ++ ) { Py_UCS4 chr = PyUnicode_READ ( kind , data , i ) ; sprintf ( p , ""\\\\U%08x"" , chr ) ; p += 10 ; } assert ( p - buf <= Py_SIZE ( u ) ) ; Py_DECREF ( w ) ; } else { * p ++ = * s ++ ; } } len = p - buf ; s = buf ; return PyUnicode_DecodeUnicodeEscape ( s , len , NULL ) ; }
Fixed code:","
static PyObject * decode_unicode_with_escapes ( struct compiling * c , const node * n , const char * s , size_t len ) { PyObject * u ; char * buf ; char * p ; const char * end ; if ( len > SIZE_MAX / 6 ) return NULL ; u = PyBytes_FromStringAndSize ( ( char * ) NULL , len * 6 ) ; if ( u == NULL ) return NULL ; p = buf = PyBytes_AsString ( u ) ; end = s + len ; while ( s < end ) { if ( * s == '\\\\' ) { * p ++ = * s ++ ; if ( * s & 0x80 ) { strcpy ( p , ""\\u005c"" ) ; p += 5 ; } } if ( * s & 0x80 ) { PyObject * w ; int kind ; void * data ; Py_ssize_t len , i ; w = decode_utf8 ( c , & s , end ) ; if ( w == NULL ) { Py_DECREF ( u ) ; return NULL ; } kind = PyUnicode_KIND ( w ) ; data = PyUnicode_DATA ( w ) ; len = PyUnicode_GET_LENGTH ( w ) ; for ( i = 0 ; i < len ; i ++ ) { Py_UCS4 chr = PyUnicode_READ ( kind , data , i ) ; if (chr > 0xFFFF) { sprintf ( p , ""\\U%08x"" , chr ) ; p += 10 ; } else { sprintf ( p , ""\\u%04x"" , chr ) ; p += 6 ; } } assert ( p - buf <= Py_SIZE ( u ) ) ; Py_DECREF ( w ) ; } else { * p ++ = * s ++ ; } } len = p - buf ; s = buf ; return PyUnicode_DecodeUnicodeEscape ( s , len , NULL ) ; }",438,-12.221353947414533,-0.027902634583138203
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static PyObject * decode_unicode_with_escapes ( struct compiling * c , const node * n , const char * s , size_t len ) { PyObject * u ; char * buf ; char * p ; const char * end ; if ( len > SIZE_MAX / 6 ) return NULL ; u = PyBytes_FromStringAndSize ( ( char * ) NULL , len * 6 ) ; if ( u == NULL ) return NULL ; p = buf = PyBytes_AsString ( u ) ; end = s + len ; while ( s < end ) { if ( * s == '\\\\' ) { * p ++ = * s ++ ; if ( * s & 0x80 ) { strcpy ( p , ""u005c"" ) ; p += 5 ; } } if ( * s & 0x80 ) { PyObject * w ; int kind ; void * data ; Py_ssize_t len , i ; w = decode_utf8 ( c , & s , end ) ; if ( w == NULL ) { Py_DECREF ( u ) ; return NULL ; } kind = PyUnicode_KIND ( w ) ; data = PyUnicode_DATA ( w ) ; len = PyUnicode_GET_LENGTH ( w ) ; for ( i = 0 ; i < len ; i ++ ) { Py_UCS4 chr = PyUnicode_READ ( kind , data , i ) ; sprintf ( p , ""\\\\U%08x"" , chr ) ; p += 10 ; } assert ( p - buf <= Py_SIZE ( u ) ) ; Py_DECREF ( w ) ; } else { * p ++ = * s ++ ; } } len = p - buf ; s = buf ; return PyUnicode_DecodeUnicodeEscape ( s , len , NULL ) ; }
Fixed code:","
static PyObject * decode_unicode_with_escapes ( struct compiling * c , const node * n , const char * s , size_t len ) { PyObject * u ; char * buf ; char * p ; const char * end ; if ( len > SIZE_MAX / 6 ) return NULL ; u = PyBytes_FromStringAndSize ( ( char * ) NULL , len * 6 ) ; if ( u == NULL ) return NULL ; p = buf = PyBytes_AsString ( u ) ; end = s + len ; while ( s < end ) { if ( * s == '\\\\' ) { * p ++ = * s ++ ; if ( * s & 0x80 ) { strcpy ( p , ""u005c"" ) ; p += 5 ; s++; } } if ( * s & 0x80 && s < end) { PyObject * w ; int kind ; void * data ; Py_ssize_t len , i ; w = decode_utf8 ( c , & s , end ) ; if ( w == NULL ) { Py_DECREF ( u ) ; return NULL ; } kind = PyUnicode_KIND ( w ) ; data = PyUnicode_DATA ( w ) ; len = PyUnicode_GET_LENGTH ( w ) ; for ( i = 0 ; i < len ; i ++ ) { Py_UCS4 chr = PyUnicode_READ ( kind , data , i ) ; sprintf ( p , ""\\\\U%08x"" , chr ) ; p += 10 ; } assert ( p - buf <= Py_SIZE ( u ) ) ; Py_DECREF ( w ) ; } else { * p ++ = * s ++ ; } } len = p - buf ; s = buf ; return PyUnicode_DecodeUnicodeEscape ( s , len , NULL ) ; }

The vulnerability can be fixed by adding an additional check to ensure that the pointer s is not out of bounds before attempting to dereference it. This can be done by adding an additional if statement before the if (*s & 0x80) statement to check if s < end. This ensures that s is not pointing to an out of bounds address before attempting to dereference it.",486,-56.900073400670124,-0.11707834033059696
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static PyObject * decode_unicode_with_escapes ( struct compiling * c , const node * n , const char * s , size_t len ) { PyObject * u ; char * buf ; char * p ; const char * end ; if ( len > SIZE_MAX / 6 ) return NULL ; u = PyBytes_FromStringAndSize ( ( char * ) NULL , len * 6 ) ; if ( u == NULL ) return NULL ; p = buf = PyBytes_AsString ( u ) ; end = s + len ; while ( s < end ) { if ( * s == '\\\\' ) { * p ++ = * s ++ ; if ( * s & 0x80 ) { strcpy ( p , ""u005c"" ) ; p += 5 ; } } if ( * s & 0x80 ) { PyObject * w ; int kind ; void * data ; Py_ssize_t len , i ; w = decode_utf8 ( c , & s , end ) ; if ( w == NULL ) { Py_DECREF ( u ) ; return NULL ; } kind = PyUnicode_KIND ( w ) ; data = PyUnicode_DATA ( w ) ; len = PyUnicode_GET_LENGTH ( w ) ; for ( i = 0 ; i < len ; i ++ ) { Py_UCS4 chr = PyUnicode_READ ( kind , data , i ) ; sprintf ( p , ""\\\\U%08x"" , chr ) ; p += 10 ; } assert ( p - buf <= Py_SIZE ( u ) ) ; Py_DECREF ( w ) ; } else { * p ++ = * s ++ ; } } len = p - buf ; s = buf ; return PyUnicode_DecodeUnicodeEscape ( s , len , NULL ) ; }
Fixed code:","
static PyObject * decode_unicode_with_escapes ( struct compiling * c , const node * n , const char * s , size_t len ) { PyObject * u ; char * buf ; char * p ; const char * end ; if ( len > SIZE_MAX / 6 ) return NULL ; u = PyBytes_FromStringAndSize ( ( char * ) NULL , len * 6 ) ; if ( u == NULL ) return NULL ; p = buf = PyBytes_AsString ( u ) ; end = s + len ; while ( s < end && p < buf + Py_SIZE(u) ) { if ( * s == '\\\\' ) { * p ++ = * s ++ ; if ( * s & 0x80 ) { strcpy ( p , ""u005c"" ) ; p += 5 ; } } if ( * s & 0x80 ) { PyObject * w ; int kind ; void * data ; Py_ssize_t len , i ; w = decode_utf8 ( c , & s , end ) ; if ( w == NULL ) { Py_DECREF ( u ) ; return NULL ; } kind = PyUnicode_KIND ( w ) ; data = PyUnicode_DATA ( w ) ; len = PyUnicode_GET_LENGTH ( w ) ; for ( i = 0 ; i < len ; i ++ ) { Py_UCS4 chr = PyUnicode_READ ( kind , data , i ) ; sprintf ( p , ""\\\\U%08x"" , chr ) ; p += 10 ; } Py_DECREF ( w ) ; } else { * p ++ = * s ++ ; } } len = p - buf ; s = buf ; return PyUnicode_DecodeUnicodeEscape ( s , len , NULL ) ; }",399,-7.889672942324878,-0.019773616396804205
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static PyObject * decode_unicode_with_escapes ( struct compiling * c , const node * n , const char * s , size_t len ) { PyObject * u ; char * buf ; char * p ; const char * end ; if ( len > SIZE_MAX / 6 ) return NULL ; u = PyBytes_FromStringAndSize ( ( char * ) NULL , len * 6 ) ; if ( u == NULL ) return NULL ; p = buf = PyBytes_AsString ( u ) ; end = s + len ; while ( s < end ) { if ( * s == '\\\\' ) { * p ++ = * s ++ ; if ( * s & 0x80 ) { strcpy ( p , ""u005c"" ) ; p += 5 ; } } if ( * s & 0x80 ) { PyObject * w ; int kind ; void * data ; Py_ssize_t len , i ; w = decode_utf8 ( c , & s , end ) ; if ( w == NULL ) { Py_DECREF ( u ) ; return NULL ; } kind = PyUnicode_KIND ( w ) ; data = PyUnicode_DATA ( w ) ; len = PyUnicode_GET_LENGTH ( w ) ; for ( i = 0 ; i < len ; i ++ ) { Py_UCS4 chr = PyUnicode_READ ( kind , data , i ) ; sprintf ( p , ""\\\\U%08x"" , chr ) ; p += 10 ; } assert ( p - buf <= Py_SIZE ( u ) ) ; Py_DECREF ( w ) ; } else { * p ++ = * s ++ ; } } len = p - buf ; s = buf ; return PyUnicode_DecodeUnicodeEscape ( s , len , NULL ) ; }
Fixed code:","
static PyObject * decode_unicode_with_escapes ( struct compiling * c , const node * n , const char * s , size_t len ) {
  PyObject * u ; char * buf ; char * p ; const char * end ; 
  if ( len > SIZE_MAX / 6 ) return NULL ; 
  u = PyBytes_FromStringAndSize ( ( char * ) NULL , len * 6 ) ; 
  if ( u == NULL ) return NULL ; 
  p = buf = PyBytes_AsString ( u ) ; 
  end = s + len ; 
  while ( s < end ) { 
    if ( * s == '\\\\' ) { 
      * p ++ = * s ++ ; 
      if ( * s & 0x80 ) { 
        strcpy ( p , ""u005c"" ) ; 
        p += 5 ; 
      } 
    } 
    //Check for out of bounds
    if(s >= end) {
       break;
    }
    if ( * s & 0x80 ) { 
      PyObject * w ; int kind ; void * data ; Py_ssize_t len , i ; 
      w = decode_utf8 ( c , & s , end ) ; 
      if ( w == NULL ) { 
        Py_DECREF ( u ) ; 
        return NULL ; 
      } 
      kind = PyUnicode_KIND ( w ) ; 
      data = PyUnicode_DATA ( w ) ; 
      len = PyUnicode_GET_LENGTH ( w ) ; 
      for ( i = 0 ; i < len ; i ++ ) { 
        Py_UCS4 chr = PyUnicode_READ ( kind , data , i ) ; 
        sprintf ( p , ""\\\\U%08x"" , chr ) ; 
        p += 10 ; 
      } 
      assert ( p - buf <= Py_SIZE ( u ) ) ; 
      Py_DECREF ( w ) ; 
    } else { 
      * p ++ = * s ++ ; 
    } 
  } 
  len = p - buf ; 
  s = buf ; 
  return PyUnicode_DecodeUnicodeEscape ( s , len , NULL ) ; 
}",541,-33.881236514325245,-0.06262705455512985
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static PyObject * decode_unicode_with_escapes ( struct compiling * c , const node * n , const char * s , size_t len ) { PyObject * u ; char * buf ; char * p ; const char * end ; if ( len > SIZE_MAX / 6 ) return NULL ; u = PyBytes_FromStringAndSize ( ( char * ) NULL , len * 6 ) ; if ( u == NULL ) return NULL ; p = buf = PyBytes_AsString ( u ) ; end = s + len ; while ( s < end ) { if ( * s == '\\\\' ) { * p ++ = * s ++ ; if ( * s & 0x80 ) { strcpy ( p , ""u005c"" ) ; p += 5 ; } } if ( * s & 0x80 ) { PyObject * w ; int kind ; void * data ; Py_ssize_t len , i ; w = decode_utf8 ( c , & s , end ) ; if ( w == NULL ) { Py_DECREF ( u ) ; return NULL ; } kind = PyUnicode_KIND ( w ) ; data = PyUnicode_DATA ( w ) ; len = PyUnicode_GET_LENGTH ( w ) ; for ( i = 0 ; i < len ; i ++ ) { Py_UCS4 chr = PyUnicode_READ ( kind , data , i ) ; sprintf ( p , ""\\\\U%08x"" , chr ) ; p += 10 ; } assert ( p - buf <= Py_SIZE ( u ) ) ; Py_DECREF ( w ) ; } else { * p ++ = * s ++ ; } } len = p - buf ; s = buf ; return PyUnicode_DecodeUnicodeEscape ( s , len , NULL ) ; }
Fixed code:","
static PyObject * decode_unicode_with_escapes ( struct compiling * c , const node * n , const char * s , size_t len ) { PyObject * u ; char * buf ; char * p ; const char * end ; if ( len > SIZE_MAX / 6 ) return NULL ; u = PyBytes_FromStringAndSize ( ( char * ) NULL , len * 6 ) ; if ( u == NULL ) return NULL ; p = buf = PyBytes_AsString ( u ) ; end = s + len ; while ( s < end ) { if ( s >= end ) { break ; } if ( * s == '\\\\' ) { * p ++ = * s ++ ; if ( * s & 0x80 ) { strcpy ( p , ""u005c"" ) ; p += 5 ; } } if ( * s & 0x80 ) { PyObject * w ; int kind ; void * data ; Py_ssize_t len , i ; w = decode_utf8 ( c , & s , end ) ; if ( w == NULL ) { Py_DECREF ( u ) ; return NULL ; } kind = PyUnicode_KIND ( w ) ; data = PyUnicode_DATA ( w ) ; len = PyUnicode_GET_LENGTH ( w ) ; for ( i = 0 ; i < len ; i ++ ) { Py_UCS4 chr = PyUnicode_READ ( kind , data , i ) ; sprintf ( p , ""\\\\U%08x"" , chr ) ; p += 10 ; } assert ( p - buf <= Py_SIZE ( u ) ) ; Py_DECREF ( w ) ; } else { * p ++ = * s ++ ; } } len = p - buf ; s = buf ; return PyUnicode_DecodeUnicodeEscape ( s , len , NULL ) ; }",412,-6.216017151359612,-0.01508742027029032
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static PyObject * decode_unicode_with_escapes ( struct compiling * c , const node * n , const char * s , size_t len ) { PyObject * u ; char * buf ; char * p ; const char * end ; if ( len > SIZE_MAX / 6 ) return NULL ; u = PyBytes_FromStringAndSize ( ( char * ) NULL , len * 6 ) ; if ( u == NULL ) return NULL ; p = buf = PyBytes_AsString ( u ) ; end = s + len ; while ( s < end ) { if ( * s == '\\\\' ) { * p ++ = * s ++ ; if ( * s & 0x80 ) { strcpy ( p , ""u005c"" ) ; p += 5 ; } } if ( * s & 0x80 ) { PyObject * w ; int kind ; void * data ; Py_ssize_t len , i ; w = decode_utf8 ( c , & s , end ) ; if ( w == NULL ) { Py_DECREF ( u ) ; return NULL ; } kind = PyUnicode_KIND ( w ) ; data = PyUnicode_DATA ( w ) ; len = PyUnicode_GET_LENGTH ( w ) ; for ( i = 0 ; i < len ; i ++ ) { Py_UCS4 chr = PyUnicode_READ ( kind , data , i ) ; sprintf ( p , ""\\\\U%08x"" , chr ) ; p += 10 ; } assert ( p - buf <= Py_SIZE ( u ) ) ; Py_DECREF ( w ) ; } else { * p ++ = * s ++ ; } } len = p - buf ; s = buf ; return PyUnicode_DecodeUnicodeEscape ( s , len , NULL ) ; }
Fixed code:","
static PyObject * decode_unicode_with_escapes ( struct compiling * c , const node * n , const char * s , size_t len ) { PyObject * u ; char * buf ; char * p ; const char * end ; if ( len > SIZE_MAX / 6 ) return NULL ; u = PyBytes_FromStringAndSize ( ( char * ) NULL , len * 6 ) ; if ( u == NULL ) return NULL ; p = buf = PyBytes_AsString ( u ) ; end = s + len ; while ( s < end ) { if ( s + 1 >= end ) { Py_DECREF ( u ) ; return NULL ; } if ( * s == '\\\\' ) { * p ++ = * s ++ ; if ( * s & 0x80 ) { strcpy ( p , ""u005c"" ) ; p += 5 ; } } if ( * s & 0x80 ) { PyObject * w ; int kind ; void * data ; Py_ssize_t len , i ; w = decode_utf8 ( c , & s , end ) ; if ( w == NULL ) { Py_DECREF ( u ) ; return NULL ; } kind = PyUnicode_KIND ( w ) ; data = PyUnicode_DATA ( w ) ; len = PyUnicode_GET_LENGTH ( w ) ; for ( i = 0 ; i < len ; i ++ ) { Py_UCS4 chr = PyUnicode_READ ( kind , data , i ) ; sprintf ( p , ""\\\\U%08x"" , chr ) ; p += 10 ; } assert ( p - buf <= Py_SIZE ( u ) ) ; Py_DECREF ( w ) ; } else { * p ++ = * s ++ ; } } len = p - buf ; s = buf ; return PyUnicode_DecodeUnicodeEscape ( s , len , NULL ) ; }

The vulnerability has been fixed by adding a check to ensure that the pointer is not pointing past the end of the string. This is done by adding a check to make sure that the pointer is not more than one character away from the end of the string before attempting to read the character. This prevents the out-of-bounds read.",493,-37.6202272689293,-0.07630877742176329
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static PyObject * decode_unicode_with_escapes ( struct compiling * c , const node * n , const char * s , size_t len ) { PyObject * u ; char * buf ; char * p ; const char * end ; if ( len > SIZE_MAX / 6 ) return NULL ; u = PyBytes_FromStringAndSize ( ( char * ) NULL , len * 6 ) ; if ( u == NULL ) return NULL ; p = buf = PyBytes_AsString ( u ) ; end = s + len ; while ( s < end ) { if ( * s == '\\\\' ) { * p ++ = * s ++ ; if ( * s & 0x80 ) { strcpy ( p , ""u005c"" ) ; p += 5 ; } } if ( * s & 0x80 ) { PyObject * w ; int kind ; void * data ; Py_ssize_t len , i ; w = decode_utf8 ( c , & s , end ) ; if ( w == NULL ) { Py_DECREF ( u ) ; return NULL ; } kind = PyUnicode_KIND ( w ) ; data = PyUnicode_DATA ( w ) ; len = PyUnicode_GET_LENGTH ( w ) ; for ( i = 0 ; i < len ; i ++ ) { Py_UCS4 chr = PyUnicode_READ ( kind , data , i ) ; sprintf ( p , ""\\\\U%08x"" , chr ) ; p += 10 ; } assert ( p - buf <= Py_SIZE ( u ) ) ; Py_DECREF ( w ) ; } else { * p ++ = * s ++ ; } } len = p - buf ; s = buf ; return PyUnicode_DecodeUnicodeEscape ( s , len , NULL ) ; }
Fixed code:","
static PyObject * decode_unicode_with_escapes ( struct compiling * c , const node * n , const char * s , size_t len ) { PyObject * u ; char * buf ; char * p ; const char * end ; if ( len > SIZE_MAX / 6 ) return NULL ; u = PyBytes_FromStringAndSize ( ( char * ) NULL , len * 6 ) ; if ( u == NULL ) return NULL ; p = buf = PyBytes_AsString ( u ) ; end = s + len ; while ( s < end ) { if ( * s == '\\\\' ) { * p ++ = * s ++ ; if ( * s & 0x80 ) { strcpy ( p , ""u005c"" ) ; p += 5 ; } } if ( s >= end ) { break; } if ( * s & 0x80 ) { PyObject * w ; int kind ; void * data ; Py_ssize_t len , i ; w = decode_utf8 ( c , & s , end ) ; if ( w == NULL ) { Py_DECREF ( u ) ; return NULL ; } kind = PyUnicode_KIND ( w ) ; data = PyUnicode_DATA ( w ) ; len = PyUnicode_GET_LENGTH ( w ) ; for ( i = 0 ; i < len ; i ++ ) { Py_UCS4 chr = PyUnicode_READ ( kind , data , i ) ; sprintf ( p , ""\\\\U%08x"" , chr ) ; p += 10 ; } assert ( p - buf <= Py_SIZE ( u ) ) ; Py_DECREF ( w ) ; } else { * p ++ = * s ++ ; } } len = p - buf ; s = buf ; return PyUnicode_DecodeUnicodeEscape ( s , len , NULL ) ; }",412,-6.810397690461352,-0.01653009148170231
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static PyObject * decode_unicode_with_escapes ( struct compiling * c , const node * n , const char * s , size_t len ) { PyObject * u ; char * buf ; char * p ; const char * end ; if ( len > SIZE_MAX / 6 ) return NULL ; u = PyBytes_FromStringAndSize ( ( char * ) NULL , len * 6 ) ; if ( u == NULL ) return NULL ; p = buf = PyBytes_AsString ( u ) ; end = s + len ; while ( s < end ) { if ( * s == '\\\\' ) { * p ++ = * s ++ ; if ( * s & 0x80 ) { strcpy ( p , ""u005c"" ) ; p += 5 ; } } if ( * s & 0x80 ) { PyObject * w ; int kind ; void * data ; Py_ssize_t len , i ; w = decode_utf8 ( c , & s , end ) ; if ( w == NULL ) { Py_DECREF ( u ) ; return NULL ; } kind = PyUnicode_KIND ( w ) ; data = PyUnicode_DATA ( w ) ; len = PyUnicode_GET_LENGTH ( w ) ; for ( i = 0 ; i < len ; i ++ ) { Py_UCS4 chr = PyUnicode_READ ( kind , data , i ) ; sprintf ( p , ""\\\\U%08x"" , chr ) ; p += 10 ; } assert ( p - buf <= Py_SIZE ( u ) ) ; Py_DECREF ( w ) ; } else { * p ++ = * s ++ ; } } len = p - buf ; s = buf ; return PyUnicode_DecodeUnicodeEscape ( s , len , NULL ) ; }
Fixed code:","
static PyObject * decode_unicode_with_escapes ( struct compiling * c , const node * n , const char * s , size_t len ) { PyObject * u ; char * buf ; char * p ; const char * end ; if ( len > SIZE_MAX / 6 ) return NULL ; u = PyBytes_FromStringAndSize ( ( char * ) NULL , len * 6 ) ; if ( u == NULL ) return NULL ; p = buf = PyBytes_AsString ( u ) ; end = s + len ; while ( s < end && p < end) { if ( * s == '\\\\' ) { * p ++ = * s ++ ; if ( * s & 0x80 ) { strcpy ( p , ""u005c"" ) ; p += 5 ; } } if ( * s & 0x80 ) { PyObject * w ; int kind ; void * data ; Py_ssize_t len , i ; w = decode_utf8 ( c , & s , end ) ; if ( w == NULL ) { Py_DECREF ( u ) ; return NULL ; } kind = PyUnicode_KIND ( w ) ; data = PyUnicode_DATA ( w ) ; len = PyUnicode_GET_LENGTH ( w ) ; for ( i = 0 ; i < len ; i ++ ) { Py_UCS4 chr = PyUnicode_READ ( kind , data , i ) ; sprintf ( p , ""\\\\U%08x"" , chr ) ; p += 10 ; } assert ( p - buf <= Py_SIZE ( u ) ) ; Py_DECREF ( w ) ; } else { * p ++ = * s ++ ; } } len = p - buf ; s = buf ; return PyUnicode_DecodeUnicodeEscape ( s , len , NULL ) ; }",406,-8.493241220969756,-0.020919313352142255
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static PyObject * decode_unicode_with_escapes ( struct compiling * c , const node * n , const char * s , size_t len ) { PyObject * u ; char * buf ; char * p ; const char * end ; if ( len > SIZE_MAX / 6 ) return NULL ; u = PyBytes_FromStringAndSize ( ( char * ) NULL , len * 6 ) ; if ( u == NULL ) return NULL ; p = buf = PyBytes_AsString ( u ) ; end = s + len ; while ( s < end ) { if ( * s == '\\\\' ) { * p ++ = * s ++ ; if ( * s & 0x80 ) { strcpy ( p , ""u005c"" ) ; p += 5 ; } } if ( * s & 0x80 ) { PyObject * w ; int kind ; void * data ; Py_ssize_t len , i ; w = decode_utf8 ( c , & s , end ) ; if ( w == NULL ) { Py_DECREF ( u ) ; return NULL ; } kind = PyUnicode_KIND ( w ) ; data = PyUnicode_DATA ( w ) ; len = PyUnicode_GET_LENGTH ( w ) ; for ( i = 0 ; i < len ; i ++ ) { Py_UCS4 chr = PyUnicode_READ ( kind , data , i ) ; sprintf ( p , ""\\\\U%08x"" , chr ) ; p += 10 ; } assert ( p - buf <= Py_SIZE ( u ) ) ; Py_DECREF ( w ) ; } else { * p ++ = * s ++ ; } } len = p - buf ; s = buf ; return PyUnicode_DecodeUnicodeEscape ( s , len , NULL ) ; }
Fixed code:","
static PyObject * decode_unicode_with_escapes ( struct compiling * c , const node * n , const char * s , size_t len ) { PyObject * u ; char * buf ; char * p ; const char * end ; if ( len > SIZE_MAX / 6 ) return NULL ; u = PyBytes_FromStringAndSize ( ( char * ) NULL , len * 6 ) ; if ( u == NULL ) return NULL ; p = buf = PyBytes_AsString ( u ) ; end = s + len ; while ( s < end ) { // Added this if statement to prevent out-of-bounds reads if (s >= end) break; if ( * s == '\\\\' ) { * p ++ = * s ++ ; if ( * s & 0x80 ) { strcpy ( p , ""u005c"" ) ; p += 5 ; } } if ( * s & 0x80 ) { PyObject * w ; int kind ; void * data ; Py_ssize_t len , i ; w = decode_utf8 ( c , & s , end ) ; if ( w == NULL ) { Py_DECREF ( u ) ; return NULL ; } kind = PyUnicode_KIND ( w ) ; data = PyUnicode_DATA ( w ) ; len = PyUnicode_GET_LENGTH ( w ) ; for ( i = 0 ; i < len ; i ++ ) { Py_UCS4 chr = PyUnicode_READ ( kind , data , i ) ; sprintf ( p , ""\\\\U%08x"" , chr ) ; p += 10 ; } assert ( p - buf <= Py_SIZE ( u ) ) ; Py_DECREF ( w ) ; } else { * p ++ = * s ++ ; } } len = p - buf ; s = buf ; return PyUnicode_DecodeUnicodeEscape ( s , len , NULL ) ; }",424,-17.987373520212383,-0.042423050755217885
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static PyObject * decode_unicode_with_escapes ( struct compiling * c , const node * n , const char * s , size_t len ) { PyObject * u ; char * buf ; char * p ; const char * end ; if ( len > SIZE_MAX / 6 ) return NULL ; u = PyBytes_FromStringAndSize ( ( char * ) NULL , len * 6 ) ; if ( u == NULL ) return NULL ; p = buf = PyBytes_AsString ( u ) ; end = s + len ; while ( s < end ) { if ( * s == '\\\\' ) { * p ++ = * s ++ ; if ( * s & 0x80 ) { strcpy ( p , ""u005c"" ) ; p += 5 ; } } if ( * s & 0x80 ) { PyObject * w ; int kind ; void * data ; Py_ssize_t len , i ; w = decode_utf8 ( c , & s , end ) ; if ( w == NULL ) { Py_DECREF ( u ) ; return NULL ; } kind = PyUnicode_KIND ( w ) ; data = PyUnicode_DATA ( w ) ; len = PyUnicode_GET_LENGTH ( w ) ; for ( i = 0 ; i < len ; i ++ ) { Py_UCS4 chr = PyUnicode_READ ( kind , data , i ) ; sprintf ( p , ""\\\\U%08x"" , chr ) ; p += 10 ; } assert ( p - buf <= Py_SIZE ( u ) ) ; Py_DECREF ( w ) ; } else { * p ++ = * s ++ ; } } len = p - buf ; s = buf ; return PyUnicode_DecodeUnicodeEscape ( s , len , NULL ) ; }
Fixed code:","
static PyObject * decode_unicode_with_escapes ( struct compiling * c , const node * n , const char * s , size_t len ) { PyObject * u ; char * buf ; char * p ; const char * end ; if ( len > SIZE_MAX / 6 ) return NULL ; u = PyBytes_FromStringAndSize ( ( char * ) NULL , len * 6 ) ; if ( u == NULL ) return NULL ; p = buf = PyBytes_AsString ( u ) ; end = s + len ; while ( s < end ) { if ( * s == '\\\\' ) { * p ++ = * s ++ ; if ( * s & 0x80 ) { strcpy ( p , ""u005c"" ) ; p += 5 ; } } if ( s + 1 < end && * s & 0x80 ) { PyObject * w ; int kind ; void * data ; Py_ssize_t len , i ; w = decode_utf8 ( c , & s , end ) ; if ( w == NULL ) { Py_DECREF ( u ) ; return NULL ; } kind = PyUnicode_KIND ( w ) ; data = PyUnicode_DATA ( w ) ; len = PyUnicode_GET_LENGTH ( w ) ; for ( i = 0 ; i < len ; i ++ ) { Py_UCS4 chr = PyUnicode_READ ( kind , data , i ) ; sprintf ( p , ""\\\\U%08x"" , chr ) ; p += 10 ; } assert ( p - buf <= Py_SIZE ( u ) ) ; Py_DECREF ( w ) ; } else { * p ++ = * s ++ ; } } len = p - buf ; s = buf ; return PyUnicode_DecodeUnicodeEscape ( s , len , NULL ) ; }
The code was modified to check that the pointer is within the bounds of the buffer before proceeding with the decode_utf8() function, preventing out-of-bounds reads. The condition ""s + 1 < end"" was added to the if statement.",461,-44.6074001635133,-0.09676225631998546
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static PyObject * decode_unicode_with_escapes ( struct compiling * c , const node * n , const char * s , size_t len ) { PyObject * u ; char * buf ; char * p ; const char * end ; if ( len > SIZE_MAX / 6 ) return NULL ; u = PyBytes_FromStringAndSize ( ( char * ) NULL , len * 6 ) ; if ( u == NULL ) return NULL ; p = buf = PyBytes_AsString ( u ) ; end = s + len ; while ( s < end ) { if ( * s == '\\\\' ) { * p ++ = * s ++ ; if ( * s & 0x80 ) { strcpy ( p , ""u005c"" ) ; p += 5 ; } } if ( * s & 0x80 ) { PyObject * w ; int kind ; void * data ; Py_ssize_t len , i ; w = decode_utf8 ( c , & s , end ) ; if ( w == NULL ) { Py_DECREF ( u ) ; return NULL ; } kind = PyUnicode_KIND ( w ) ; data = PyUnicode_DATA ( w ) ; len = PyUnicode_GET_LENGTH ( w ) ; for ( i = 0 ; i < len ; i ++ ) { Py_UCS4 chr = PyUnicode_READ ( kind , data , i ) ; sprintf ( p , ""\\\\U%08x"" , chr ) ; p += 10 ; } assert ( p - buf <= Py_SIZE ( u ) ) ; Py_DECREF ( w ) ; } else { * p ++ = * s ++ ; } } len = p - buf ; s = buf ; return PyUnicode_DecodeUnicodeEscape ( s , len , NULL ) ; }
Fixed code:","
static PyObject * decode_unicode_with_escapes ( struct compiling * c , const node * n , const char * s , size_t len ) { PyObject * u ; char * buf ; char * p ; const char * end ; if ( len > SIZE_MAX / 6 ) return NULL ; u = PyBytes_FromStringAndSize ( ( char * ) NULL , len * 6 ) ; if ( u == NULL ) return NULL ; p = buf = PyBytes_AsString ( u ) ; end = s + len ; while ( s < end ) { if ( * s == '\\\\' ) { * p ++ = * s ++ ; if ( * s & 0x80 ) { strcpy ( p , ""u005c"" ) ; p += 5 ; } } if ( * s & 0x80 ) { PyObject * w ; int kind ; void * data ; Py_ssize_t len , i ; w = decode_utf8 ( c , & s , end ) ; if ( w == NULL ) { Py_DECREF ( u ) ; return NULL ; } kind = PyUnicode_KIND ( w ) ; data = PyUnicode_DATA ( w ) ; len = PyUnicode_GET_LENGTH ( w ) ; if ( len > SIZE_MAX / 10 ) { Py_DECREF ( w ) ; Py_DECREF ( u ) ; return NULL ; } for ( i = 0 ; i < len ; i ++ ) { Py_UCS4 chr = PyUnicode_READ ( kind , data , i ) ; sprintf ( p , ""\\\\U%08x"" , chr ) ; p += 10 ; } assert ( p - buf <= Py_SIZE ( u ) ) ; Py_DECREF ( w ) ; } else { * p ++ = * s ++ ; } } len = p - buf ; s = buf ; return PyUnicode_DecodeUnicodeEscape ( s , len , NULL ) ; }
The vulnerability is fixed by adding an additional check to ensure that the length of the string is not greater than SIZE_MAX/10 before it is read. This prevents an out-of-bounds read.",478,-28.414537788469865,-0.059444639724832354
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static PyObject * decode_unicode_with_escapes ( struct compiling * c , const node * n , const char * s , size_t len ) { PyObject * u ; char * buf ; char * p ; const char * end ; if ( len > SIZE_MAX / 6 ) return NULL ; u = PyBytes_FromStringAndSize ( ( char * ) NULL , len * 6 ) ; if ( u == NULL ) return NULL ; p = buf = PyBytes_AsString ( u ) ; end = s + len ; while ( s < end ) { if ( * s == '\\\\' ) { * p ++ = * s ++ ; if ( * s & 0x80 ) { strcpy ( p , ""u005c"" ) ; p += 5 ; } } if ( * s & 0x80 ) { PyObject * w ; int kind ; void * data ; Py_ssize_t len , i ; w = decode_utf8 ( c , & s , end ) ; if ( w == NULL ) { Py_DECREF ( u ) ; return NULL ; } kind = PyUnicode_KIND ( w ) ; data = PyUnicode_DATA ( w ) ; len = PyUnicode_GET_LENGTH ( w ) ; for ( i = 0 ; i < len ; i ++ ) { Py_UCS4 chr = PyUnicode_READ ( kind , data , i ) ; sprintf ( p , ""\\\\U%08x"" , chr ) ; p += 10 ; } assert ( p - buf <= Py_SIZE ( u ) ) ; Py_DECREF ( w ) ; } else { * p ++ = * s ++ ; } } len = p - buf ; s = buf ; return PyUnicode_DecodeUnicodeEscape ( s , len , NULL ) ; }
Fixed code:","
static PyObject * decode_unicode_with_escapes ( struct compiling * c , const node * n , const char * s , size_t len ) { PyObject * u ; char * buf ; char * p ; const char * end ; if ( len > SIZE_MAX / 6 ) return NULL ; u = PyBytes_FromStringAndSize ( ( char * ) NULL , len * 6 ) ; if ( u == NULL ) return NULL ; p = buf = PyBytes_AsString ( u ) ; end = s + len ; while ( s < end ) { if ( * s == '\\\\' ) { * p ++ = * s ++ ; if ( * s & 0x80 ) { strcpy ( p , ""u005c"" ) ; p += 5 ; } } else if ( * s & 0x80 ) { PyObject * w ; int kind ; void * data ; Py_ssize_t len , i ; w = decode_utf8 ( c , & s , end ) ; if ( w == NULL ) { Py_DECREF ( u ) ; return NULL ; } kind = PyUnicode_KIND ( w ) ; data = PyUnicode_DATA ( w ) ; len = PyUnicode_GET_LENGTH ( w ) ; for ( i = 0 ; i < len ; i ++ ) { Py_UCS4 chr = PyUnicode_READ ( kind , data , i ) ; sprintf ( p , ""\\\\U%08x"" , chr ) ; p += 10 ; } assert ( p - buf <= Py_SIZE ( u ) ) ; Py_DECREF ( w ) ; } else { * p ++ = * s ++ ; } } len = p - buf ; s = buf ; return PyUnicode_DecodeUnicodeEscape ( s , len , NULL ) ; }",403,-6.139143194614701,-0.015233605941971963
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static PyObject * decode_unicode_with_escapes ( struct compiling * c , const node * n , const char * s , size_t len ) { PyObject * u ; char * buf ; char * p ; const char * end ; if ( len > SIZE_MAX / 6 ) return NULL ; u = PyBytes_FromStringAndSize ( ( char * ) NULL , len * 6 ) ; if ( u == NULL ) return NULL ; p = buf = PyBytes_AsString ( u ) ; end = s + len ; while ( s < end ) { if ( * s == '\\\\' ) { * p ++ = * s ++ ; if ( * s & 0x80 ) { strcpy ( p , ""u005c"" ) ; p += 5 ; } } if ( * s & 0x80 ) { PyObject * w ; int kind ; void * data ; Py_ssize_t len , i ; w = decode_utf8 ( c , & s , end ) ; if ( w == NULL ) { Py_DECREF ( u ) ; return NULL ; } kind = PyUnicode_KIND ( w ) ; data = PyUnicode_DATA ( w ) ; len = PyUnicode_GET_LENGTH ( w ) ; for ( i = 0 ; i < len ; i ++ ) { Py_UCS4 chr = PyUnicode_READ ( kind , data , i ) ; sprintf ( p , ""\\\\U%08x"" , chr ) ; p += 10 ; } assert ( p - buf <= Py_SIZE ( u ) ) ; Py_DECREF ( w ) ; } else { * p ++ = * s ++ ; } } len = p - buf ; s = buf ; return PyUnicode_DecodeUnicodeEscape ( s , len , NULL ) ; }
Fixed code:","
static PyObject * decode_unicode_with_escapes ( struct compiling * c , const node * n , const char * s , size_t len ) { PyObject * u ; char * buf ; char * p ; const char * end ; if ( len > SIZE_MAX / 6 ) return NULL ; u = PyBytes_FromStringAndSize ( ( char * ) NULL , len * 6 ) ; if ( u == NULL ) return NULL ; p = buf = PyBytes_AsString ( u ) ; end = s + len ; while ( s < end ) { if ( * s == '\\\\' ) { * p ++ = * s ++ ; if ( * s & 0x80 ) { strcpy ( p , ""u005c"" ) ; p += 5 ; } } if ( * s & 0x80 ) { PyObject * w ; int kind ; void * data ; Py_ssize_t len , i ; w = decode_utf8 ( c , & s , end ) ; if ( w == NULL ) { Py_DECREF ( u ) ; return NULL ; } kind = PyUnicode_KIND ( w ) ; data = PyUnicode_DATA ( w ) ; len = PyUnicode_GET_LENGTH ( w ) ; for ( i = 0 ; i < len && i < Py_SIZE(u); i ++ ) { Py_UCS4 chr = PyUnicode_READ ( kind , data , i ) ; sprintf ( p , ""\\\\U%08x"" , chr ) ; p += 10 ; } Py_DECREF ( w ) ; } else { * p ++ = * s ++ ; } } len = p - buf ; s = buf ; return PyUnicode_DecodeUnicodeEscape ( s , len , NULL ) ; }",396,-9.521188002635801,-0.024043404047060103
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static PyObject * decode_unicode_with_escapes ( struct compiling * c , const node * n , const char * s , size_t len ) { PyObject * u ; char * buf ; char * p ; const char * end ; if ( len > SIZE_MAX / 6 ) return NULL ; u = PyBytes_FromStringAndSize ( ( char * ) NULL , len * 6 ) ; if ( u == NULL ) return NULL ; p = buf = PyBytes_AsString ( u ) ; end = s + len ; while ( s < end ) { if ( * s == '\\\\' ) { * p ++ = * s ++ ; if ( * s & 0x80 ) { strcpy ( p , ""u005c"" ) ; p += 5 ; } } if ( * s & 0x80 ) { PyObject * w ; int kind ; void * data ; Py_ssize_t len , i ; w = decode_utf8 ( c , & s , end ) ; if ( w == NULL ) { Py_DECREF ( u ) ; return NULL ; } kind = PyUnicode_KIND ( w ) ; data = PyUnicode_DATA ( w ) ; len = PyUnicode_GET_LENGTH ( w ) ; for ( i = 0 ; i < len ; i ++ ) { Py_UCS4 chr = PyUnicode_READ ( kind , data , i ) ; sprintf ( p , ""\\\\U%08x"" , chr ) ; p += 10 ; } assert ( p - buf <= Py_SIZE ( u ) ) ; Py_DECREF ( w ) ; } else { * p ++ = * s ++ ; } } len = p - buf ; s = buf ; return PyUnicode_DecodeUnicodeEscape ( s , len , NULL ) ; }
Fixed code:","
static PyObject * decode_unicode_with_escapes ( struct compiling * c , const node * n , const char * s , size_t len ) { PyObject * u ; char * buf ; char * p ; const char * end ; if ( len > SIZE_MAX / 6 ) return NULL ; u = PyBytes_FromStringAndSize ( ( char * ) NULL , len * 6 ) ; if ( u == NULL ) return NULL ; p = buf = PyBytes_AsString ( u ) ; end = s + len ; while ( s < end ) { if ( * s == '\\\\' ) { * p ++ = * s ++ ; if ( * s & 0x80 ) { strcpy ( p , ""u005c"" ) ; p += 5 ; } } if ( * s & 0x80 ) { PyObject * w ; int kind ; void * data ; Py_ssize_t len , i ; if ( s >= end ) break; // added line w = decode_utf8 ( c , & s , end ) ; if ( w == NULL ) { Py_DECREF ( u ) ; return NULL ; } kind = PyUnicode_KIND ( w ) ; data = PyUnicode_DATA ( w ) ; len = PyUnicode_GET_LENGTH ( w ) ; for ( i = 0 ; i < len ; i ++ ) { Py_UCS4 chr = PyUnicode_READ ( kind , data , i ) ; sprintf ( p , ""\\\\U%08x"" , chr ) ; p += 10 ; } assert ( p - buf <= Py_SIZE ( u ) ) ; Py_DECREF ( w ) ; } else { * p ++ = * s ++ ; } } len = p - buf ; s = buf ; return PyUnicode_DecodeUnicodeEscape ( s , len , NULL ) ; }",413,-16.356344471568665,-0.03960373964060209
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static PyObject * decode_unicode_with_escapes ( struct compiling * c , const node * n , const char * s , size_t len ) { PyObject * u ; char * buf ; char * p ; const char * end ; if ( len > SIZE_MAX / 6 ) return NULL ; u = PyBytes_FromStringAndSize ( ( char * ) NULL , len * 6 ) ; if ( u == NULL ) return NULL ; p = buf = PyBytes_AsString ( u ) ; end = s + len ; while ( s < end ) { if ( * s == '\\\\' ) { * p ++ = * s ++ ; if ( * s & 0x80 ) { strcpy ( p , ""u005c"" ) ; p += 5 ; } } if ( * s & 0x80 ) { PyObject * w ; int kind ; void * data ; Py_ssize_t len , i ; w = decode_utf8 ( c , & s , end ) ; if ( w == NULL ) { Py_DECREF ( u ) ; return NULL ; } kind = PyUnicode_KIND ( w ) ; data = PyUnicode_DATA ( w ) ; len = PyUnicode_GET_LENGTH ( w ) ; for ( i = 0 ; i < len ; i ++ ) { Py_UCS4 chr = PyUnicode_READ ( kind , data , i ) ; sprintf ( p , ""\\\\U%08x"" , chr ) ; p += 10 ; } assert ( p - buf <= Py_SIZE ( u ) ) ; Py_DECREF ( w ) ; } else { * p ++ = * s ++ ; } } len = p - buf ; s = buf ; return PyUnicode_DecodeUnicodeEscape ( s , len , NULL ) ; }
Fixed code:","

static PyObject * decode_unicode_with_escapes ( struct compiling * c , const node * n , const char * s , size_t len ) { PyObject * u ; char * buf ; char * p ; const char * end ; if ( len > SIZE_MAX / 6 ) return NULL ; u = PyBytes_FromStringAndSize ( ( char * ) NULL , len * 6 ) ; if ( u == NULL ) return NULL ; p = buf = PyBytes_AsString ( u ) ; end = s + len ; while ( s < end && s < (end-1) ) { if ( * s == '\\\\' ) { * p ++ = * s ++ ; if ( * s & 0x80 ) { strcpy ( p , ""u005c"" ) ; p += 5 ; } } if ( * s & 0x80 ) { PyObject * w ; int kind ; void * data ; Py_ssize_t len , i ; w = decode_utf8 ( c , & s , end ) ; if ( w == NULL ) { Py_DECREF ( u ) ; return NULL ; } kind = PyUnicode_KIND ( w ) ; data = PyUnicode_DATA ( w ) ; len = PyUnicode_GET_LENGTH ( w ) ; for ( i = 0 ; i < len ; i ++ ) { Py_UCS4 chr = PyUnicode_READ ( kind , data , i ) ; sprintf ( p , ""\\\\U%08x"" , chr ) ; p += 10 ; } assert ( p - buf <= Py_SIZE ( u ) ) ; Py_DECREF ( w ) ; } else { * p ++ = * s ++ ; } } len = p - buf ; s = buf ; return PyUnicode_DecodeUnicodeEscape ( s , len , NULL ) ; }",411,-9.464458667983111,-0.023027879970761826
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static PyObject * decode_unicode_with_escapes ( struct compiling * c , const node * n , const char * s , size_t len ) { PyObject * u ; char * buf ; char * p ; const char * end ; if ( len > SIZE_MAX / 6 ) return NULL ; u = PyBytes_FromStringAndSize ( ( char * ) NULL , len * 6 ) ; if ( u == NULL ) return NULL ; p = buf = PyBytes_AsString ( u ) ; end = s + len ; while ( s < end ) { if ( * s == '\\\\' ) { * p ++ = * s ++ ; if ( * s & 0x80 ) { strcpy ( p , ""u005c"" ) ; p += 5 ; } } if ( * s & 0x80 ) { PyObject * w ; int kind ; void * data ; Py_ssize_t len , i ; w = decode_utf8 ( c , & s , end ) ; if ( w == NULL ) { Py_DECREF ( u ) ; return NULL ; } kind = PyUnicode_KIND ( w ) ; data = PyUnicode_DATA ( w ) ; len = PyUnicode_GET_LENGTH ( w ) ; for ( i = 0 ; i < len ; i ++ ) { Py_UCS4 chr = PyUnicode_READ ( kind , data , i ) ; sprintf ( p , ""\\\\U%08x"" , chr ) ; p += 10 ; } assert ( p - buf <= Py_SIZE ( u ) ) ; Py_DECREF ( w ) ; } else { * p ++ = * s ++ ; } } len = p - buf ; s = buf ; return PyUnicode_DecodeUnicodeEscape ( s , len , NULL ) ; }
Fixed code:","
static PyObject * decode_unicode_with_escapes ( struct compiling * c , const node * n , const char * s , size_t len ) { PyObject * u ; char * buf ; char * p ; const char * end ; if ( len > SIZE_MAX / 6 ) return NULL ; u = PyBytes_FromStringAndSize ( ( char * ) NULL , len * 6 ) ; if ( u == NULL ) return NULL ; p = buf = PyBytes_AsString ( u ) ; end = s + len ; while ( s < end ) { if ( * s == '\\\\' ) { * p ++ = * s ++ ; if ( * s & 0x80 ) { strcpy ( p , ""u005c"" ) ; p += 5 ; } } if ( * s & 0x80 ) { PyObject * w ; int kind ; void * data ; Py_ssize_t len , i ; w = decode_utf8 ( c , & s , end ) ; if ( w == NULL ) { Py_DECREF ( u ) ; return NULL ; } kind = PyUnicode_KIND ( w ) ; data = PyUnicode_DATA ( w ) ; len = PyUnicode_GET_LENGTH ( w ) ; if (len > SIZE_MAX - (p - buf)) { Py_DECREF(u); return NULL; } for ( i = 0 ; i < len ; i ++ ) { Py_UCS4 chr = PyUnicode_READ ( kind , data , i ) ; sprintf ( p , ""\\\\U%08x"" , chr ) ; p += 10 ; } assert ( p - buf <= Py_SIZE ( u ) ) ; Py_DECREF ( w ) ; } else { * p ++ = * s ++ ; } } len = p - buf ; s = buf ; return PyUnicode_DecodeUnicodeEscape ( s , len , NULL ) ; }
The vulnerability is fixed by adding an additional check that ensures that the length of the string is not greater than the maximum size allowed. This check prevents out-of-bounds reads by ensuring that the length of the string is always within the allocated memory.",480,-38.24947780821948,-0.07968641210045725
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static PyObject * decode_unicode_with_escapes ( struct compiling * c , const node * n , const char * s , size_t len ) { PyObject * u ; char * buf ; char * p ; const char * end ; if ( len > SIZE_MAX / 6 ) return NULL ; u = PyBytes_FromStringAndSize ( ( char * ) NULL , len * 6 ) ; if ( u == NULL ) return NULL ; p = buf = PyBytes_AsString ( u ) ; end = s + len ; while ( s < end ) { if ( * s == '\\\\' ) { * p ++ = * s ++ ; if ( * s & 0x80 ) { strcpy ( p , ""u005c"" ) ; p += 5 ; } } if ( * s & 0x80 ) { PyObject * w ; int kind ; void * data ; Py_ssize_t len , i ; w = decode_utf8 ( c , & s , end ) ; if ( w == NULL ) { Py_DECREF ( u ) ; return NULL ; } kind = PyUnicode_KIND ( w ) ; data = PyUnicode_DATA ( w ) ; len = PyUnicode_GET_LENGTH ( w ) ; for ( i = 0 ; i < len ; i ++ ) { Py_UCS4 chr = PyUnicode_READ ( kind , data , i ) ; sprintf ( p , ""\\\\U%08x"" , chr ) ; p += 10 ; } assert ( p - buf <= Py_SIZE ( u ) ) ; Py_DECREF ( w ) ; } else { * p ++ = * s ++ ; } } len = p - buf ; s = buf ; return PyUnicode_DecodeUnicodeEscape ( s , len , NULL ) ; }
Fixed code:","
static PyObject * decode_unicode_with_escapes ( struct compiling * c , const node * n , const char * s , size_t len ) { PyObject * u ; char * buf ; char * p ; const char * end ; if ( len > SIZE_MAX / 6 ) return NULL ; u = PyBytes_FromStringAndSize ( ( char * ) NULL , len * 6 ) ; if ( u == NULL ) return NULL ; p = buf = PyBytes_AsString ( u ) ; end = s + len ; while ( s < end && s < (end-1)) { if ( * s == '\\\\' ) { * p ++ = * s ++ ; if ( * s & 0x80 ) { strcpy ( p , ""u005c"" ) ; p += 5 ; } } if ( * s & 0x80 ) { PyObject * w ; int kind ; void * data ; Py_ssize_t len , i ; w = decode_utf8 ( c , & s , end ) ; if ( w == NULL ) { Py_DECREF ( u ) ; return NULL ; } kind = PyUnicode_KIND ( w ) ; data = PyUnicode_DATA ( w ) ; len = PyUnicode_GET_LENGTH ( w ) ; for ( i = 0 ; i < len ; i ++ ) { Py_UCS4 chr = PyUnicode_READ ( kind , data , i ) ; sprintf ( p , ""\\\\U%08x"" , chr ) ; p += 10 ; } assert ( p - buf <= Py_SIZE ( u ) ) ; Py_DECREF ( w ) ; } else { * p ++ = * s ++ ; } } len = p - buf ; s = buf ; return PyUnicode_DecodeUnicodeEscape ( s , len , NULL ) ; }",409,-8.819607997632119,-0.021563833735041855
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static PyObject * decode_unicode_with_escapes ( struct compiling * c , const node * n , const char * s , size_t len ) { PyObject * u ; char * buf ; char * p ; const char * end ; if ( len > SIZE_MAX / 6 ) return NULL ; u = PyBytes_FromStringAndSize ( ( char * ) NULL , len * 6 ) ; if ( u == NULL ) return NULL ; p = buf = PyBytes_AsString ( u ) ; end = s + len ; while ( s < end ) { if ( * s == '\\\\' ) { * p ++ = * s ++ ; if ( * s & 0x80 ) { strcpy ( p , ""u005c"" ) ; p += 5 ; } } if ( * s & 0x80 ) { PyObject * w ; int kind ; void * data ; Py_ssize_t len , i ; w = decode_utf8 ( c , & s , end ) ; if ( w == NULL ) { Py_DECREF ( u ) ; return NULL ; } kind = PyUnicode_KIND ( w ) ; data = PyUnicode_DATA ( w ) ; len = PyUnicode_GET_LENGTH ( w ) ; for ( i = 0 ; i < len ; i ++ ) { Py_UCS4 chr = PyUnicode_READ ( kind , data , i ) ; sprintf ( p , ""\\\\U%08x"" , chr ) ; p += 10 ; } assert ( p - buf <= Py_SIZE ( u ) ) ; Py_DECREF ( w ) ; } else { * p ++ = * s ++ ; } } len = p - buf ; s = buf ; return PyUnicode_DecodeUnicodeEscape ( s , len , NULL ) ; }
Fixed code:","
static PyObject * decode_unicode_with_escapes ( struct compiling * c , const node * n , const char * s , size_t len ) { PyObject * u ; char * buf ; char * p ; const char * end ; if ( len > SIZE_MAX / 6 ) return NULL ; u = PyBytes_FromStringAndSize ( ( char * ) NULL , len * 6 ) ; if ( u == NULL ) return NULL ; p = buf = PyBytes_AsString ( u ) ; end = s + len ; while ( s < end ) { if ( s + 1 >= end ) { Py_DECREF ( u ) ; return NULL ; } if ( * s == '\\\\' ) { * p ++ = * s ++ ; if ( * s & 0x80 ) { strcpy ( p , ""u005c"" ) ; p += 5 ; } } if ( * s & 0x80 ) { PyObject * w ; int kind ; void * data ; Py_ssize_t len , i ; w = decode_utf8 ( c , & s , end ) ; if ( w == NULL ) { Py_DECREF ( u ) ; return NULL ; } kind = PyUnicode_KIND ( w ) ; data = PyUnicode_DATA ( w ) ; len = PyUnicode_GET_LENGTH ( w ) ; for ( i = 0 ; i < len ; i ++ ) { Py_UCS4 chr = PyUnicode_READ ( kind , data , i ) ; sprintf ( p , ""\\\\U%08x"" , chr ) ; p += 10 ; } assert ( p - buf <= Py_SIZE ( u ) ) ; Py_DECREF ( w ) ; } else { * p ++ = * s ++ ; } } len = p - buf ; s = buf ; return PyUnicode_DecodeUnicodeEscape ( s , len , NULL ) ; }",423,-5.512971335194536,-0.013033029161216398
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static PyObject * decode_unicode_with_escapes ( struct compiling * c , const node * n , const char * s , size_t len ) { PyObject * u ; char * buf ; char * p ; const char * end ; if ( len > SIZE_MAX / 6 ) return NULL ; u = PyBytes_FromStringAndSize ( ( char * ) NULL , len * 6 ) ; if ( u == NULL ) return NULL ; p = buf = PyBytes_AsString ( u ) ; end = s + len ; while ( s < end ) { if ( * s == '\\\\' ) { * p ++ = * s ++ ; if ( * s & 0x80 ) { strcpy ( p , ""u005c"" ) ; p += 5 ; } } if ( * s & 0x80 ) { PyObject * w ; int kind ; void * data ; Py_ssize_t len , i ; w = decode_utf8 ( c , & s , end ) ; if ( w == NULL ) { Py_DECREF ( u ) ; return NULL ; } kind = PyUnicode_KIND ( w ) ; data = PyUnicode_DATA ( w ) ; len = PyUnicode_GET_LENGTH ( w ) ; for ( i = 0 ; i < len ; i ++ ) { Py_UCS4 chr = PyUnicode_READ ( kind , data , i ) ; sprintf ( p , ""\\\\U%08x"" , chr ) ; p += 10 ; } assert ( p - buf <= Py_SIZE ( u ) ) ; Py_DECREF ( w ) ; } else { * p ++ = * s ++ ; } } len = p - buf ; s = buf ; return PyUnicode_DecodeUnicodeEscape ( s , len , NULL ) ; }
Fixed code:","

static PyObject * decode_unicode_with_escapes ( struct compiling * c , const node * n , const char * s , size_t len ) { PyObject * u ; char * buf ; char * p ; const char * end ; if ( len > SIZE_MAX / 6 ) return NULL ; u = PyBytes_FromStringAndSize ( ( char * ) NULL , len * 6 ) ; if ( u == NULL ) return NULL ; p = buf = PyBytes_AsString ( u ) ; end = s + len ; while ( s < end ) { if ( * s == '\\\\' ) { * p ++ = * s ++ ; if ( * s & 0x80 ) { strcpy ( p , ""u005c"" ) ; p += 5 ; if (s >= end) { Py_DECREF(u); return NULL; } } } if ( * s & 0x80 ) { PyObject * w ; int kind ; void * data ; Py_ssize_t len , i ; w = decode_utf8 ( c , & s , end ) ; if ( w == NULL ) { Py_DECREF ( u ) ; return NULL ; } kind = PyUnicode_KIND ( w ) ; data = PyUnicode_DATA ( w ) ; len = PyUnicode_GET_LENGTH ( w ) ; for ( i = 0 ; i < len ; i ++ ) { Py_UCS4 chr = PyUnicode_READ ( kind , data , i ) ; sprintf ( p , ""\\\\U%08x"" , chr ) ; p += 10 ; } assert ( p - buf <= Py_SIZE ( u ) ) ; Py_DECREF ( w ) ; } else { * p ++ = * s ++ ; } if (s > end) { Py_DECREF(u); return NULL; } } len = p - buf ; s = buf ; return PyUnicode_DecodeUnicodeEscape ( s , len , NULL ) ; }",439,-18.95801636391219,-0.043184547525995876
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static PyObject * decode_unicode_with_escapes ( struct compiling * c , const node * n , const char * s , size_t len ) { PyObject * u ; char * buf ; char * p ; const char * end ; if ( len > SIZE_MAX / 6 ) return NULL ; u = PyBytes_FromStringAndSize ( ( char * ) NULL , len * 6 ) ; if ( u == NULL ) return NULL ; p = buf = PyBytes_AsString ( u ) ; end = s + len ; while ( s < end ) { if ( * s == '\\\\' ) { * p ++ = * s ++ ; if ( * s & 0x80 ) { strcpy ( p , ""u005c"" ) ; p += 5 ; } } if ( * s & 0x80 ) { PyObject * w ; int kind ; void * data ; Py_ssize_t len , i ; w = decode_utf8 ( c , & s , end ) ; if ( w == NULL ) { Py_DECREF ( u ) ; return NULL ; } kind = PyUnicode_KIND ( w ) ; data = PyUnicode_DATA ( w ) ; len = PyUnicode_GET_LENGTH ( w ) ; for ( i = 0 ; i < len ; i ++ ) { Py_UCS4 chr = PyUnicode_READ ( kind , data , i ) ; sprintf ( p , ""\\\\U%08x"" , chr ) ; p += 10 ; } assert ( p - buf <= Py_SIZE ( u ) ) ; Py_DECREF ( w ) ; } else { * p ++ = * s ++ ; } } len = p - buf ; s = buf ; return PyUnicode_DecodeUnicodeEscape ( s , len , NULL ) ; }
Fixed code:","
static PyObject * decode_unicode_with_escapes ( struct compiling * c , const node * n , const char * s , size_t len ) { PyObject * u ; char * buf ; char * p ; const char * end ; if ( len > SIZE_MAX / 6 ) return NULL ; u = PyBytes_FromStringAndSize ( ( char * ) NULL , len * 6 ) ; if ( u == NULL ) return NULL ; p = buf = PyBytes_AsString ( u ) ; end = s + len ; while ( s < end ) { if ( s >= end ) { break ; } if ( * s == '\\\\' ) { * p ++ = * s ++ ; if ( * s & 0x80 ) { strcpy ( p , ""u005c"" ) ; p += 5 ; } } if ( s >= end ) { break ; } if ( * s & 0x80 ) { PyObject * w ; int kind ; void * data ; Py_ssize_t len , i ; w = decode_utf8 ( c , & s , end ) ; if ( w == NULL ) { Py_DECREF ( u ) ; return NULL ; } kind = PyUnicode_KIND ( w ) ; data = PyUnicode_DATA ( w ) ; len = PyUnicode_GET_LENGTH ( w ) ; for ( i = 0 ; i < len ; i ++ ) { Py_UCS4 chr = PyUnicode_READ ( kind , data , i ) ; sprintf ( p , ""\\\\U%08x"" , chr ) ; p += 10 ; } assert ( p - buf <= Py_SIZE ( u ) ) ; Py_DECREF ( w ) ; } else { * p ++ = * s ++ ; } } len = p - buf ; s = buf ; return PyUnicode_DecodeUnicodeEscape ( s , len , NULL ) ; }

The vulnerability has been fixed by adding an if statement that checks if the pointer s is greater than or equal to the end pointer. If it is, the loop will break to prevent accessing out of bounds memory.",466,-34.45740817401243,-0.07394293599573483
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static PyObject * decode_unicode_with_escapes ( struct compiling * c , const node * n , const char * s , size_t len ) { PyObject * u ; char * buf ; char * p ; const char * end ; if ( len > SIZE_MAX / 6 ) return NULL ; u = PyBytes_FromStringAndSize ( ( char * ) NULL , len * 6 ) ; if ( u == NULL ) return NULL ; p = buf = PyBytes_AsString ( u ) ; end = s + len ; while ( s < end ) { if ( * s == '\\\\' ) { * p ++ = * s ++ ; if ( * s & 0x80 ) { strcpy ( p , ""u005c"" ) ; p += 5 ; } } if ( * s & 0x80 ) { PyObject * w ; int kind ; void * data ; Py_ssize_t len , i ; w = decode_utf8 ( c , & s , end ) ; if ( w == NULL ) { Py_DECREF ( u ) ; return NULL ; } kind = PyUnicode_KIND ( w ) ; data = PyUnicode_DATA ( w ) ; len = PyUnicode_GET_LENGTH ( w ) ; for ( i = 0 ; i < len ; i ++ ) { Py_UCS4 chr = PyUnicode_READ ( kind , data , i ) ; sprintf ( p , ""\\\\U%08x"" , chr ) ; p += 10 ; } assert ( p - buf <= Py_SIZE ( u ) ) ; Py_DECREF ( w ) ; } else { * p ++ = * s ++ ; } } len = p - buf ; s = buf ; return PyUnicode_DecodeUnicodeEscape ( s , len , NULL ) ; }
Fixed code:","
static PyObject * decode_unicode_with_escapes ( struct compiling * c , const node * n , const char * s , size_t len ) { PyObject * u ; char * buf ; char * p ; const char * end ; if ( len > SIZE_MAX / 6 ) return NULL ; u = PyBytes_FromStringAndSize ( ( char * ) NULL , len * 6 ) ; if ( u == NULL ) return NULL ; p = buf = PyBytes_AsString ( u ) ; end = s + len ; while ( s < end && p < buf+Py_SIZE(u)) { if ( * s == '\\\\' ) { * p ++ = * s ++ ; if ( * s & 0x80 ) { strcpy ( p , ""u005c"" ) ; p += 5 ; } } if ( * s & 0x80 ) { PyObject * w ; int kind ; void * data ; Py_ssize_t len , i ; w = decode_utf8 ( c , & s , end ) ; if ( w == NULL ) { Py_DECREF ( u ) ; return NULL ; } kind = PyUnicode_KIND ( w ) ; data = PyUnicode_DATA ( w ) ; len = PyUnicode_GET_LENGTH ( w ) ; for ( i = 0 ; i < len && p < buf+Py_SIZE(u); i ++ ) { Py_UCS4 chr = PyUnicode_READ ( kind , data , i ) ; sprintf ( p , ""\\\\U%08x"" , chr ) ; p += 10 ; } assert ( p - buf <= Py_SIZE ( u ) ) ; Py_DECREF ( w ) ; } else { * p ++ = * s ++ ; } } len = p - buf ; s = buf ; return PyUnicode_DecodeUnicodeEscape ( s , len , NULL ) ; }

The fixed code adds a check to ensure that the pointer 'p' does not read data beyond the buffer boundary by adding an additional condition to the while loop: p < buf+Py_SIZE(u). It also adds an additional check within the for loop to ensure that the pointer does not read beyond the buffer boundary by adding a condition: p < buf+Py_SIZE(u).",503,-56.677358176963295,-0.11267864448700457
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static PyObject * decode_unicode_with_escapes ( struct compiling * c , const node * n , const char * s , size_t len ) { PyObject * u ; char * buf ; char * p ; const char * end ; if ( len > SIZE_MAX / 6 ) return NULL ; u = PyBytes_FromStringAndSize ( ( char * ) NULL , len * 6 ) ; if ( u == NULL ) return NULL ; p = buf = PyBytes_AsString ( u ) ; end = s + len ; while ( s < end ) { if ( * s == '\\\\' ) { * p ++ = * s ++ ; if ( * s & 0x80 ) { strcpy ( p , ""u005c"" ) ; p += 5 ; } } if ( * s & 0x80 ) { PyObject * w ; int kind ; void * data ; Py_ssize_t len , i ; w = decode_utf8 ( c , & s , end ) ; if ( w == NULL ) { Py_DECREF ( u ) ; return NULL ; } kind = PyUnicode_KIND ( w ) ; data = PyUnicode_DATA ( w ) ; len = PyUnicode_GET_LENGTH ( w ) ; for ( i = 0 ; i < len ; i ++ ) { Py_UCS4 chr = PyUnicode_READ ( kind , data , i ) ; sprintf ( p , ""\\\\U%08x"" , chr ) ; p += 10 ; } assert ( p - buf <= Py_SIZE ( u ) ) ; Py_DECREF ( w ) ; } else { * p ++ = * s ++ ; } } len = p - buf ; s = buf ; return PyUnicode_DecodeUnicodeEscape ( s , len , NULL ) ; }
Fixed code:","
static PyObject * decode_unicode_with_escapes ( struct compiling * c , const node * n , const char * s , size_t len ) { PyObject * u ; char * buf ; char * p ; const char * end ; if ( len > SIZE_MAX / 6 ) return NULL ; u = PyBytes_FromStringAndSize ( ( char * ) NULL , len * 6 ) ; if ( u == NULL ) return NULL ; p = buf = PyBytes_AsString ( u ) ; end = s + len ; while ( s < end ) { if ( * s == '\\\\' ) { * p ++ = * s ++ ; if ( * s & 0x80 ) { strcpy ( p , ""u005c"" ) ; p += 5 ; } } if ( * s & 0x80 ) { PyObject * w ; int kind ; void * data ; Py_ssize_t len , i ; w = decode_utf8 ( c , & s , end ) ; if ( w == NULL ) { Py_DECREF ( u ) ; return NULL ; } kind = PyUnicode_KIND ( w ) ; data = PyUnicode_DATA ( w ) ; len = PyUnicode_GET_LENGTH ( w ) ; for ( i = 0 ; i < len ; i ++ ) { if ( i > ( SIZE_MAX / 10 ) ) { Py_DECREF ( u ) ; return NULL ; } Py_UCS4 chr = PyUnicode_READ ( kind , data , i ) ; sprintf ( p , ""\\\\U%08x"" , chr ) ; p += 10 ; } assert ( p - buf <= Py_SIZE ( u ) ) ; Py_DECREF ( w ) ; } else { * p ++ = * s ++ ; } } len = p - buf ; s = buf ; return PyUnicode_DecodeUnicodeEscape ( s , len , NULL ) ; }",428,-14.002778949487226,-0.032716773246465485
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static PyObject * decode_unicode_with_escapes ( struct compiling * c , const node * n , const char * s , size_t len ) { PyObject * u ; char * buf ; char * p ; const char * end ; if ( len > SIZE_MAX / 6 ) return NULL ; u = PyBytes_FromStringAndSize ( ( char * ) NULL , len * 6 ) ; if ( u == NULL ) return NULL ; p = buf = PyBytes_AsString ( u ) ; end = s + len ; while ( s < end ) { if ( * s == '\\\\' ) { * p ++ = * s ++ ; if ( * s & 0x80 ) { strcpy ( p , ""u005c"" ) ; p += 5 ; } } if ( * s & 0x80 ) { PyObject * w ; int kind ; void * data ; Py_ssize_t len , i ; w = decode_utf8 ( c , & s , end ) ; if ( w == NULL ) { Py_DECREF ( u ) ; return NULL ; } kind = PyUnicode_KIND ( w ) ; data = PyUnicode_DATA ( w ) ; len = PyUnicode_GET_LENGTH ( w ) ; for ( i = 0 ; i < len ; i ++ ) { Py_UCS4 chr = PyUnicode_READ ( kind , data , i ) ; sprintf ( p , ""\\\\U%08x"" , chr ) ; p += 10 ; } assert ( p - buf <= Py_SIZE ( u ) ) ; Py_DECREF ( w ) ; } else { * p ++ = * s ++ ; } } len = p - buf ; s = buf ; return PyUnicode_DecodeUnicodeEscape ( s , len , NULL ) ; }
Fixed code:","
static PyObject * decode_unicode_with_escapes ( struct compiling * c , const node * n , const char * s , size_t len ) { PyObject * u ; char * buf ; char * p ; const char * end ; if ( len > SIZE_MAX / 6 ) return NULL ; u = PyBytes_FromStringAndSize ( ( char * ) NULL , len * 6 + 1 ) ; if ( u == NULL ) return NULL ; p = buf = PyBytes_AsString ( u ) ; end = s + len ; while ( s < end ) { if ( * s == '\\\\' ) { * p ++ = * s ++ ; if ( * s & 0x80 ) { strcpy ( p , ""u005c"" ) ; p += 5 ; } } if ( * s & 0x80 ) { PyObject * w ; int kind ; void * data ; Py_ssize_t len , i ; w = decode_utf8 ( c , & s , end ) ; if ( w == NULL ) { Py_DECREF ( u ) ; return NULL ; } kind = PyUnicode_KIND ( w ) ; data = PyUnicode_DATA ( w ) ; len = PyUnicode_GET_LENGTH ( w ) ; for ( i = 0 ; i < len ; i ++ ) { Py_UCS4 chr = PyUnicode_READ ( kind , data , i ) ; sprintf ( p , ""\\\\U%08x"" , chr ) ; p += 10 ; } assert ( p - buf <= Py_SIZE ( u ) + 1 ) ; Py_DECREF ( w ) ; } else { * p ++ = * s ++ ; } } len = p - buf ; s = buf ; * ( p + 1 ) = '\0' ; return PyUnicode_DecodeUnicodeEscape ( s , len , NULL ) ; }",418,-13.349159817026283,-0.03193578903594805
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static PyObject * decode_unicode_with_escapes ( struct compiling * c , const node * n , const char * s , size_t len ) { PyObject * u ; char * buf ; char * p ; const char * end ; if ( len > SIZE_MAX / 6 ) return NULL ; u = PyBytes_FromStringAndSize ( ( char * ) NULL , len * 6 ) ; if ( u == NULL ) return NULL ; p = buf = PyBytes_AsString ( u ) ; end = s + len ; while ( s < end ) { if ( * s == '\\\\' ) { * p ++ = * s ++ ; if ( * s & 0x80 ) { strcpy ( p , ""u005c"" ) ; p += 5 ; } } if ( * s & 0x80 ) { PyObject * w ; int kind ; void * data ; Py_ssize_t len , i ; w = decode_utf8 ( c , & s , end ) ; if ( w == NULL ) { Py_DECREF ( u ) ; return NULL ; } kind = PyUnicode_KIND ( w ) ; data = PyUnicode_DATA ( w ) ; len = PyUnicode_GET_LENGTH ( w ) ; for ( i = 0 ; i < len ; i ++ ) { Py_UCS4 chr = PyUnicode_READ ( kind , data , i ) ; sprintf ( p , ""\\\\U%08x"" , chr ) ; p += 10 ; } assert ( p - buf <= Py_SIZE ( u ) ) ; Py_DECREF ( w ) ; } else { * p ++ = * s ++ ; } } len = p - buf ; s = buf ; return PyUnicode_DecodeUnicodeEscape ( s , len , NULL ) ; }
Fixed code:","

static PyObject * decode_unicode_with_escapes ( struct compiling * c , const node * n , const char * s , size_t len ) { 
PyObject * u ; 
char * buf ; 
char * p ; 
const char * end ; 
if ( len > SIZE_MAX / 6 ) 
    return NULL ; 
u = PyBytes_FromStringAndSize ( ( char * ) NULL , len * 6 ) ; 
if ( u == NULL ) 
    return NULL ; 
p = buf = PyBytes_AsString ( u ) ; 
end = s + len ; 
while ( s < end ) { 
    if ( * s == '\\\\' ) { 
        * p ++ = * s ++ ; 
        if ( * s & 0x80 ) { 
            if (p - buf + 5 >= Py_SIZE(u)) {
                Py_DECREF ( u ) ; 
                return NULL;
            }
            strcpy ( p , ""u005c"" ) ; 
            p += 5 ; 
        } 
    } 
    if ( * s & 0x80 ) { 
        PyObject * w ; 
        int kind ; 
        void * data ; 
        Py_ssize_t len , i ; 
        w = decode_utf8 ( c , & s , end ) ; 
        if ( w == NULL ) { 
            Py_DECREF ( u ) ; 
            return NULL ; 
        } 
        kind = PyUnicode_KIND ( w ) ; 
        data = PyUnicode_DATA ( w ) ; 
        len = PyUnicode_GET_LENGTH ( w ) ; 
        if (p - buf + (len * 10) >= Py_SIZE(u)) {
            Py_DECREF ( u ) ; 
            return NULL;
        }
        for ( i = 0 ; i < len ; i ++ ) { 
            Py_UCS4 chr = PyUnicode_READ ( kind , data , i ) ; 
            sprintf ( p , ""\\\\U%08x"" , chr ) ; 
            p += 10 ; 
        } 
        assert ( p - buf <= Py_SIZE ( u ) ) ; 
        Py_DECREF ( w ) ; 
    } else { 
        * p ++ = * s ++ ; 
    } 
} 
len = p - buf ; 
s = buf ; 
return PyUnicode_DecodeUnicodeEscape ( s , len , NULL ) ; 
}",605,-30.578808371065552,-0.05054348491085215
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static PyObject * decode_unicode_with_escapes ( struct compiling * c , const node * n , const char * s , size_t len ) { PyObject * u ; char * buf ; char * p ; const char * end ; if ( len > SIZE_MAX / 6 ) return NULL ; u = PyBytes_FromStringAndSize ( ( char * ) NULL , len * 6 ) ; if ( u == NULL ) return NULL ; p = buf = PyBytes_AsString ( u ) ; end = s + len ; while ( s < end ) { if ( * s == '\\\\' ) { * p ++ = * s ++ ; if ( * s & 0x80 ) { strcpy ( p , ""u005c"" ) ; p += 5 ; } } if ( * s & 0x80 ) { PyObject * w ; int kind ; void * data ; Py_ssize_t len , i ; w = decode_utf8 ( c , & s , end ) ; if ( w == NULL ) { Py_DECREF ( u ) ; return NULL ; } kind = PyUnicode_KIND ( w ) ; data = PyUnicode_DATA ( w ) ; len = PyUnicode_GET_LENGTH ( w ) ; for ( i = 0 ; i < len ; i ++ ) { Py_UCS4 chr = PyUnicode_READ ( kind , data , i ) ; sprintf ( p , ""\\\\U%08x"" , chr ) ; p += 10 ; } assert ( p - buf <= Py_SIZE ( u ) ) ; Py_DECREF ( w ) ; } else { * p ++ = * s ++ ; } } len = p - buf ; s = buf ; return PyUnicode_DecodeUnicodeEscape ( s , len , NULL ) ; }
Fixed code:","
static PyObject * decode_unicode_with_escapes ( struct compiling * c , const node * n , const char * s , size_t len ) { PyObject * u ; char * buf ; char * p ; const char * end ; if ( len > SIZE_MAX / 6 ) return NULL ; u = PyBytes_FromStringAndSize ( ( char * ) NULL , len * 6 ) ; if ( u == NULL ) return NULL ; p = buf = PyBytes_AsString ( u ) ; end = s + len ; while ( s < end ) {  if ( s >= end ) break; if ( * s == '\\\\' ) { * p ++ = * s ++ ; if ( * s & 0x80 ) { strcpy ( p , ""u005c"" ) ; p += 5 ; } } if ( * s & 0x80 ) { PyObject * w ; int kind ; void * data ; Py_ssize_t len , i ; w = decode_utf8 ( c , & s , end ) ; if ( w == NULL ) { Py_DECREF ( u ) ; return NULL ; } kind = PyUnicode_KIND ( w ) ; data = PyUnicode_DATA ( w ) ; len = PyUnicode_GET_LENGTH ( w ) ; for ( i = 0 ; i < len ; i ++ ) { Py_UCS4 chr = PyUnicode_READ ( kind , data , i ) ; sprintf ( p , ""\\\\U%08x"" , chr ) ; p += 10 ; } assert ( p - buf <= Py_SIZE ( u ) ) ; Py_DECREF ( w ) ; } else { * p ++ = * s ++ ; } } len = p - buf ; s = buf ; return PyUnicode_DecodeUnicodeEscape ( s , len , NULL ) ; }",411,-11.550974551629974,-0.02810456095287098
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static PyObject * decode_unicode_with_escapes ( struct compiling * c , const node * n , const char * s , size_t len ) { PyObject * u ; char * buf ; char * p ; const char * end ; if ( len > SIZE_MAX / 6 ) return NULL ; u = PyBytes_FromStringAndSize ( ( char * ) NULL , len * 6 ) ; if ( u == NULL ) return NULL ; p = buf = PyBytes_AsString ( u ) ; end = s + len ; while ( s < end ) { if ( * s == '\\\\' ) { * p ++ = * s ++ ; if ( * s & 0x80 ) { strcpy ( p , ""u005c"" ) ; p += 5 ; } } if ( * s & 0x80 ) { PyObject * w ; int kind ; void * data ; Py_ssize_t len , i ; w = decode_utf8 ( c , & s , end ) ; if ( w == NULL ) { Py_DECREF ( u ) ; return NULL ; } kind = PyUnicode_KIND ( w ) ; data = PyUnicode_DATA ( w ) ; len = PyUnicode_GET_LENGTH ( w ) ; for ( i = 0 ; i < len ; i ++ ) { Py_UCS4 chr = PyUnicode_READ ( kind , data , i ) ; sprintf ( p , ""\\\\U%08x"" , chr ) ; p += 10 ; } assert ( p - buf <= Py_SIZE ( u ) ) ; Py_DECREF ( w ) ; } else { * p ++ = * s ++ ; } } len = p - buf ; s = buf ; return PyUnicode_DecodeUnicodeEscape ( s , len , NULL ) ; }
Fixed code:","
static PyObject * decode_unicode_with_escapes ( struct compiling * c , const node * n , const char * s , size_t len ) { PyObject * u ; char * buf ; char * p ; const char * end ; if ( len > SIZE_MAX / 6 ) return NULL ; u = PyBytes_FromStringAndSize ( ( char * ) NULL , len * 6 ) ; if ( u == NULL ) return NULL ; 

p = buf = PyBytes_AsString ( u ) ; end = s + len ; while ( s < end ) { if ( * s == '\\\\' && ( s + 1 ) < end ) { * p ++ = * s ++ ; if ( * s & 0x80 ) { strcpy ( p , ""u005c"" ) ; p += 5 ; } } if ( * s & 0x80 ) { PyObject * w ; int kind ; void * data ; Py_ssize_t len , i ; w = decode_utf8 ( c , & s , end ) ; if ( w == NULL ) { Py_DECREF ( u ) ; return NULL ; } kind = PyUnicode_KIND ( w ) ; data = PyUnicode_DATA ( w ) ; len = PyUnicode_GET_LENGTH ( w ) ; for ( i = 0 ; i < len ; i ++ ) { Py_UCS4 chr = PyUnicode_READ ( kind , data , i ) ; sprintf ( p , ""\\\\U%08x"" , chr ) ; p += 10 ; } assert ( p - buf <= Py_SIZE ( u ) ) ; Py_DECREF ( w ) ; } else { * p ++ = * s ++ ; } } len = p - buf ; s = buf ; return PyUnicode_DecodeUnicodeEscape ( s , len , NULL ) ; } 

The vulnerability was fixed by adding an additional check to ensure that the ""\"" character is not the last character in the stream (s + 1 < end). This ensures that the pointer never goes out of bounds when attempting to read the next character in the stream.",468,-58.97019834587744,-0.12600469732025094
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static PyObject * decode_unicode_with_escapes ( struct compiling * c , const node * n , const char * s , size_t len ) { PyObject * u ; char * buf ; char * p ; const char * end ; if ( len > SIZE_MAX / 6 ) return NULL ; u = PyBytes_FromStringAndSize ( ( char * ) NULL , len * 6 ) ; if ( u == NULL ) return NULL ; p = buf = PyBytes_AsString ( u ) ; end = s + len ; while ( s < end ) { if ( * s == '\\\\' ) { * p ++ = * s ++ ; if ( * s & 0x80 ) { strcpy ( p , ""u005c"" ) ; p += 5 ; } } if ( * s & 0x80 ) { PyObject * w ; int kind ; void * data ; Py_ssize_t len , i ; w = decode_utf8 ( c , & s , end ) ; if ( w == NULL ) { Py_DECREF ( u ) ; return NULL ; } kind = PyUnicode_KIND ( w ) ; data = PyUnicode_DATA ( w ) ; len = PyUnicode_GET_LENGTH ( w ) ; for ( i = 0 ; i < len ; i ++ ) { Py_UCS4 chr = PyUnicode_READ ( kind , data , i ) ; sprintf ( p , ""\\\\U%08x"" , chr ) ; p += 10 ; } assert ( p - buf <= Py_SIZE ( u ) ) ; Py_DECREF ( w ) ; } else { * p ++ = * s ++ ; } } len = p - buf ; s = buf ; return PyUnicode_DecodeUnicodeEscape ( s , len , NULL ) ; }
Fixed code:","
static PyObject * decode_unicode_with_escapes ( struct compiling * c , const node * n , const char * s , size_t len ) { PyObject * u ; char * buf ; char * p ; const char * end ; if ( len > SIZE_MAX / 6 ) return NULL ; u = PyBytes_FromStringAndSize ( ( char * ) NULL , len * 6 ) ; if ( u == NULL ) return NULL ; p = buf = PyBytes_AsString ( u ) ; end = s + len ; while ( s < end ) { if ( s + 1 < end ) { if ( * s == '\\\\' ) { * p ++ = * s ++ ; if ( * s & 0x80 ) { strcpy ( p , ""u005c"" ) ; p += 5 ; } } if ( * s & 0x80 ) { PyObject * w ; int kind ; void * data ; Py_ssize_t len , i ; w = decode_utf8 ( c , & s , end ) ; if ( w == NULL ) { Py_DECREF ( u ) ; return NULL ; } kind = PyUnicode_KIND ( w ) ; data = PyUnicode_DATA ( w ) ; len = PyUnicode_GET_LENGTH ( w ) ; for ( i = 0 ; i < len ; i ++ ) { Py_UCS4 chr = PyUnicode_READ ( kind , data , i ) ; sprintf ( p , ""\\\\U%08x"" , chr ) ; p += 10 ; } assert ( p - buf <= Py_SIZE ( u ) ) ; Py_DECREF ( w ) ; } else { * p ++ = * s ++ ; } } else { * p ++ = * s ++ ; } } len = p - buf ; s = buf ; return PyUnicode_DecodeUnicodeEscape ( s , len , NULL ) ; }",423,-9.64328094586402,-0.02279735448194804
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static PyObject * decode_unicode_with_escapes ( struct compiling * c , const node * n , const char * s , size_t len ) { PyObject * u ; char * buf ; char * p ; const char * end ; if ( len > SIZE_MAX / 6 ) return NULL ; u = PyBytes_FromStringAndSize ( ( char * ) NULL , len * 6 ) ; if ( u == NULL ) return NULL ; p = buf = PyBytes_AsString ( u ) ; end = s + len ; while ( s < end ) { if ( * s == '\\\\' ) { * p ++ = * s ++ ; if ( * s & 0x80 ) { strcpy ( p , ""u005c"" ) ; p += 5 ; } } if ( * s & 0x80 ) { PyObject * w ; int kind ; void * data ; Py_ssize_t len , i ; w = decode_utf8 ( c , & s , end ) ; if ( w == NULL ) { Py_DECREF ( u ) ; return NULL ; } kind = PyUnicode_KIND ( w ) ; data = PyUnicode_DATA ( w ) ; len = PyUnicode_GET_LENGTH ( w ) ; for ( i = 0 ; i < len ; i ++ ) { Py_UCS4 chr = PyUnicode_READ ( kind , data , i ) ; sprintf ( p , ""\\\\U%08x"" , chr ) ; p += 10 ; } assert ( p - buf <= Py_SIZE ( u ) ) ; Py_DECREF ( w ) ; } else { * p ++ = * s ++ ; } } len = p - buf ; s = buf ; return PyUnicode_DecodeUnicodeEscape ( s , len , NULL ) ; }
Fixed code:","
static PyObject * decode_unicode_with_escapes ( struct compiling * c , const node * n , const char * s , size_t len ) { PyObject * u ; char * buf ; char * p ; const char * end ; if ( len > SIZE_MAX / 6 ) return NULL ; u = PyBytes_FromStringAndSize ( ( char * ) NULL , len * 6 ) ; if ( u == NULL ) return NULL ; p = buf = PyBytes_AsString ( u ) ; end = s + len ; while ( s < end ) { if ( s + 1 < end && * s == '\\\\' ) { * p ++ = * s ++ ; if ( * s & 0x80 ) { strcpy ( p , ""u005c"" ) ; p += 5 ; } } if ( s + 1 < end && * s & 0x80 ) { PyObject * w ; int kind ; void * data ; Py_ssize_t len , i ; w = decode_utf8 ( c , & s , end ) ; if ( w == NULL ) { Py_DECREF ( u ) ; return NULL ; } kind = PyUnicode_KIND ( w ) ; data = PyUnicode_DATA ( w ) ; len = PyUnicode_GET_LENGTH ( w ) ; for ( i = 0 ; i < len ; i ++ ) { Py_UCS4 chr = PyUnicode_READ ( kind , data , i ) ; sprintf ( p , ""\\\\U%08x"" , chr ) ; p += 10 ; } assert ( p - buf <= Py_SIZE ( u ) ) ; Py_DECREF ( w ) ; } else { * p ++ = * s ++ ; } } len = p - buf ; s = buf ; return PyUnicode_DecodeUnicodeEscape ( s , len , NULL ) ; }",414,-5.937498288153182,-0.014341783304717831
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static PyObject * decode_unicode_with_escapes ( struct compiling * c , const node * n , const char * s , size_t len ) { PyObject * u ; char * buf ; char * p ; const char * end ; if ( len > SIZE_MAX / 6 ) return NULL ; u = PyBytes_FromStringAndSize ( ( char * ) NULL , len * 6 ) ; if ( u == NULL ) return NULL ; p = buf = PyBytes_AsString ( u ) ; end = s + len ; while ( s < end ) { if ( * s == '\\\\' ) { * p ++ = * s ++ ; if ( * s & 0x80 ) { strcpy ( p , ""u005c"" ) ; p += 5 ; } } if ( * s & 0x80 ) { PyObject * w ; int kind ; void * data ; Py_ssize_t len , i ; w = decode_utf8 ( c , & s , end ) ; if ( w == NULL ) { Py_DECREF ( u ) ; return NULL ; } kind = PyUnicode_KIND ( w ) ; data = PyUnicode_DATA ( w ) ; len = PyUnicode_GET_LENGTH ( w ) ; for ( i = 0 ; i < len ; i ++ ) { Py_UCS4 chr = PyUnicode_READ ( kind , data , i ) ; sprintf ( p , ""\\\\U%08x"" , chr ) ; p += 10 ; } assert ( p - buf <= Py_SIZE ( u ) ) ; Py_DECREF ( w ) ; } else { * p ++ = * s ++ ; } } len = p - buf ; s = buf ; return PyUnicode_DecodeUnicodeEscape ( s , len , NULL ) ; }
Fixed code:","
static PyObject * decode_unicode_with_escapes ( struct compiling * c , const node * n , const char * s , size_t len ) { PyObject * u ; char * buf ; char * p ; const char * end ; if ( len > SIZE_MAX / 6 ) return NULL ; u = PyBytes_FromStringAndSize ( ( char * ) NULL , len * 6 ) ; if ( u == NULL ) return NULL ; p = buf = PyBytes_AsString ( u ) ; end = s + len ; while ( s < end ) { if ( * s == '\\\\' ) { * p ++ = * s ++ ; if ( * s & 0x80 ) { strcpy ( p , ""u005c"" ) ; p += 5 ; } } if ( * s & 0x80 ) { PyObject * w ; int kind ; void * data ; Py_ssize_t len , i ; if ( ( s + 6 ) > end ) { Py_DECREF ( u ) ; return NULL ; } w = decode_utf8 ( c , & s , end ) ; if ( w == NULL ) { Py_DECREF ( u ) ; return NULL ; } kind = PyUnicode_KIND ( w ) ; data = PyUnicode_DATA ( w ) ; len = PyUnicode_GET_LENGTH ( w ) ; for ( i = 0 ; i < len ; i ++ ) { Py_UCS4 chr = PyUnicode_READ ( kind , data , i ) ; sprintf ( p , ""\\\\U%08x"" , chr ) ; p += 10 ; } assert ( p - buf <= Py_SIZE ( u ) ) ; Py_DECREF ( w ) ; } else { * p ++ = * s ++ ; } } len = p - buf ; s = buf ; return PyUnicode_DecodeUnicodeEscape ( s , len , NULL ) ; }
The vulnerability has been fixed by adding an if statement before the call to decode_utf8() to ensure that the pointer, s, is never incremented beyond the boundary of the buffer, end.",466,-42.34600290902799,-0.09087125087774246
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static PyObject * decode_unicode_with_escapes ( struct compiling * c , const node * n , const char * s , size_t len ) { PyObject * u ; char * buf ; char * p ; const char * end ; if ( len > SIZE_MAX / 6 ) return NULL ; u = PyBytes_FromStringAndSize ( ( char * ) NULL , len * 6 ) ; if ( u == NULL ) return NULL ; p = buf = PyBytes_AsString ( u ) ; end = s + len ; while ( s < end ) { if ( * s == '\\\\' ) { * p ++ = * s ++ ; if ( * s & 0x80 ) { strcpy ( p , ""u005c"" ) ; p += 5 ; } } if ( * s & 0x80 ) { PyObject * w ; int kind ; void * data ; Py_ssize_t len , i ; w = decode_utf8 ( c , & s , end ) ; if ( w == NULL ) { Py_DECREF ( u ) ; return NULL ; } kind = PyUnicode_KIND ( w ) ; data = PyUnicode_DATA ( w ) ; len = PyUnicode_GET_LENGTH ( w ) ; for ( i = 0 ; i < len ; i ++ ) { Py_UCS4 chr = PyUnicode_READ ( kind , data , i ) ; sprintf ( p , ""\\\\U%08x"" , chr ) ; p += 10 ; } assert ( p - buf <= Py_SIZE ( u ) ) ; Py_DECREF ( w ) ; } else { * p ++ = * s ++ ; } } len = p - buf ; s = buf ; return PyUnicode_DecodeUnicodeEscape ( s , len , NULL ) ; }
Fixed code:","
static PyObject * decode_unicode_with_escapes ( struct compiling * c , const node * n , const char * s , size_t len ) { PyObject * u ; char * buf ; char * p ; const char * end ; if ( len > SIZE_MAX / 6 ) return NULL ; u = PyBytes_FromStringAndSize ( ( char * ) NULL , len * 6 ) ; if ( u == NULL ) return NULL ; p = buf = PyBytes_AsString ( u ) ; end = s + len ; while ( s < end ) { if ( * s == '\\\\' ) { * p ++ = * s ++ ; if ( * s & 0x80 ) { strcpy ( p , ""u005c"" ) ; p += 5 ; } } if ( * s & 0x80 ) { PyObject * w ; int kind ; void * data ; Py_ssize_t len , i ; if ( s + 8 >= end ) { Py_DECREF ( u ) ; return NULL ; } w = decode_utf8 ( c , & s , end ) ; if ( w == NULL ) { Py_DECREF ( u ) ; return NULL ; } kind = PyUnicode_KIND ( w ) ; data = PyUnicode_DATA ( w ) ; len = PyUnicode_GET_LENGTH ( w ) ; for ( i = 0 ; i < len ; i ++ ) { Py_UCS4 chr = PyUnicode_READ ( kind , data , i ) ; sprintf ( p , ""\\\\U%08x"" , chr ) ; p += 10 ; } assert ( p - buf <= Py_SIZE ( u ) ) ; Py_DECREF ( w ) ; } else { * p ++ = * s ++ ; } } len = p - buf ; s = buf ; return PyUnicode_DecodeUnicodeEscape ( s , len , NULL ) ; }",423,-12.407670227986284,-0.029332553730464027
