Original code,Plausible Program,Total Tokens,Sum Entropy,Mean Entropy
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
void vrrp_print ( netdissect_options * ndo , register const u_char * bp , register u_int len , register const u_char * bp2 , int ttl ) { int version , type , auth_type = VRRP_AUTH_NONE ; const char * type_s ; ND_TCHECK ( bp [ 0 ] ) ; version = ( bp [ 0 ] & 0xf0 ) >> 4 ; type = bp [ 0 ] & 0x0f ; type_s = tok2str ( type2str , ""unknown type (%u)"" , type ) ; ND_PRINT ( ( ndo , ""VRRPv%u, %s"" , version , type_s ) ) ; if ( ttl != 255 ) ND_PRINT ( ( ndo , "", (ttl %u)"" , ttl ) ) ; if ( version < 2 || version > 3 || type != VRRP_TYPE_ADVERTISEMENT ) return ; ND_TCHECK ( bp [ 2 ] ) ; ND_PRINT ( ( ndo , "", vrid %u, prio %u"" , bp [ 1 ] , bp [ 2 ] ) ) ; ND_TCHECK ( bp [ 5 ] ) ; if ( version == 2 ) { auth_type = bp [ 4 ] ; ND_PRINT ( ( ndo , "", authtype %s"" , tok2str ( auth2str , NULL , auth_type ) ) ) ; ND_PRINT ( ( ndo , "", intvl %us, length %u"" , bp [ 5 ] , len ) ) ; } else { uint16_t intvl = ( bp [ 4 ] & 0x0f ) << 8 | bp [ 5 ] ; ND_PRINT ( ( ndo , "", intvl %ucs, length %u"" , intvl , len ) ) ; } if ( ndo -> ndo_vflag ) { int naddrs = bp [ 3 ] ; int i ; char c ; if ( version == 2 && ND_TTEST2 ( bp [ 0 ] , len ) ) { struct cksum_vec vec [ 1 ] ; vec [ 0 ] . ptr = bp ; vec [ 0 ] . len = len ; if ( in_cksum ( vec , 1 ) ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } if ( version == 3 && ND_TTEST2 ( bp [ 0 ] , len ) ) { uint16_t cksum = nextproto4_cksum ( ndo , ( const struct ip * ) bp2 , bp , len , len , IPPROTO_VRRP ) ; if ( cksum ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } ND_PRINT ( ( ndo , "", addrs"" ) ) ; if ( naddrs > 1 ) ND_PRINT ( ( ndo , ""(%d)"" , naddrs ) ) ; ND_PRINT ( ( ndo , "":"" ) ) ; c = ' ' ; bp += 8 ; for ( i = 0 ; i < naddrs ; i ++ ) { ND_TCHECK ( bp [ 3 ] ) ; ND_PRINT ( ( ndo , ""%c%s"" , c , ipaddr_string ( ndo , bp ) ) ) ; c = ',' ; bp += 4 ; } if ( version == 2 && auth_type == VRRP_AUTH_SIMPLE ) { ND_TCHECK ( bp [ 7 ] ) ; ND_PRINT ( ( ndo , "" auth \\"""" ) ) ; if ( fn_printn ( ndo , bp , 8 , ndo -> ndo_snapend ) ) { ND_PRINT ( ( ndo , ""\\"""" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""\\"""" ) ) ; } } return ; trunc : ND_PRINT ( ( ndo , ""[|vrrp]"" ) ) ; }
Fixed code:"," 
void vrrp_print ( netdissect_options * ndo , register const u_char * bp , register u_int len , register const u_char * bp2 , int ttl ) { int version , type , auth_type = VRRP_AUTH_NONE ; const char * type_s ; ND_TCHECK ( bp [ 0 ] ) ; version = ( bp [ 0 ] & 0xf0 ) >> 4 ; type = bp [ 0 ] & 0x0f ; type_s = tok2str ( type2str , ""unknown type (%u)"" , type ) ; ND_PRINT ( ( ndo , ""VRRPv%u, %s"" , version , type_s ) ) ; if ( ttl != 255 ) ND_PRINT ( ( ndo , "", (ttl %u)"" , ttl ) ) ; if ( version < 2 || version > 3 || type != VRRP_TYPE_ADVERTISEMENT ) return ; ND_TCHECK ( bp [ 2 ] ) ; ND_PRINT ( ( ndo , "", vrid %u, prio %u"" , bp [ 1 ] , bp [ 2 ] ) ) ; ND_TCHECK ( bp [ 5 ] ) ; if ( version == 2 ) { auth_type = bp [ 4 ] ; ND_PRINT ( ( ndo , "", authtype %s"" , tok2str ( auth2str , NULL , auth_type ) ) ) ; ND_PRINT ( ( ndo , "", intvl %us, length %u"" , bp [ 5 ] , len ) ) ; } else { uint16_t intvl = ( bp [ 4 ] & 0x0f ) << 8 | bp [ 5 ] ; ND_PRINT ( ( ndo , "", intvl %ucs, length %u"" , intvl , len ) ) ; } if ( ndo -> ndo_vflag ) { int naddrs = bp [ 3 ] ; int i ; char c ; if ( version == 2 && len > 7 ) { struct cksum_vec vec [ 1 ] ; vec [ 0 ] . ptr = bp ; vec [ 0 ] . len = len ; if ( in_cksum ( vec , 1 ) ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } if ( version == 3 && len > 7 ) { uint16_t cksum = nextproto4_cksum ( ndo , ( const struct ip * ) bp2 , bp , len , len , IPPROTO_VRRP ) ; if ( cksum ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } ND_PRINT ( ( ndo , "", addrs"" ) ) ; if ( naddrs > 1 ) ND_PRINT ( ( ndo , ""(%d)"" , naddrs ) ) ; ND_PRINT ( ( ndo , "":"" ) ) ; c = ' ' ; bp += 8 ; for ( i = 0 ; i < naddrs ; i ++ ) { ND_TCHECK_LEN ( bp , 3 ) ; ND_PRINT ( ( ndo , ""%c%s"" , c , ipaddr_string ( ndo , bp ) ) ) ; c = ',' ; bp += 4 ; } if ( version == 2 && auth_type == VRRP_AUTH_SIMPLE ) { ND_TCHECK_LEN ( bp , 7 ) ; ND_PRINT ( ( ndo , "" auth \\"""" ) ) ; if ( fn_printn ( ndo , bp , 8 , ndo -> ndo_snapend ) ) { ND_PRINT ( ( ndo , ""\\"""" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""\\"""" ) ) ; } } return ; trunc : ND_PRINT ( ( ndo , ""[|vrrp]"" ) ) ; }",916,-15.140465128057919,-0.0165288920611986
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
void vrrp_print ( netdissect_options * ndo , register const u_char * bp , register u_int len , register const u_char * bp2 , int ttl ) { int version , type , auth_type = VRRP_AUTH_NONE ; const char * type_s ; ND_TCHECK ( bp [ 0 ] ) ; version = ( bp [ 0 ] & 0xf0 ) >> 4 ; type = bp [ 0 ] & 0x0f ; type_s = tok2str ( type2str , ""unknown type (%u)"" , type ) ; ND_PRINT ( ( ndo , ""VRRPv%u, %s"" , version , type_s ) ) ; if ( ttl != 255 ) ND_PRINT ( ( ndo , "", (ttl %u)"" , ttl ) ) ; if ( version < 2 || version > 3 || type != VRRP_TYPE_ADVERTISEMENT ) return ; ND_TCHECK ( bp [ 2 ] ) ; ND_PRINT ( ( ndo , "", vrid %u, prio %u"" , bp [ 1 ] , bp [ 2 ] ) ) ; ND_TCHECK ( bp [ 5 ] ) ; if ( version == 2 ) { auth_type = bp [ 4 ] ; ND_PRINT ( ( ndo , "", authtype %s"" , tok2str ( auth2str , NULL , auth_type ) ) ) ; ND_PRINT ( ( ndo , "", intvl %us, length %u"" , bp [ 5 ] , len ) ) ; } else { uint16_t intvl = ( bp [ 4 ] & 0x0f ) << 8 | bp [ 5 ] ; ND_PRINT ( ( ndo , "", intvl %ucs, length %u"" , intvl , len ) ) ; } if ( ndo -> ndo_vflag ) { int naddrs = bp [ 3 ] ; int i ; char c ; if ( version == 2 && ND_TTEST2 ( bp [ 0 ] , len ) ) { struct cksum_vec vec [ 1 ] ; vec [ 0 ] . ptr = bp ; vec [ 0 ] . len = len ; if ( in_cksum ( vec , 1 ) ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } if ( version == 3 && ND_TTEST2 ( bp [ 0 ] , len ) ) { uint16_t cksum = nextproto4_cksum ( ndo , ( const struct ip * ) bp2 , bp , len , len , IPPROTO_VRRP ) ; if ( cksum ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } ND_PRINT ( ( ndo , "", addrs"" ) ) ; if ( naddrs > 1 ) ND_PRINT ( ( ndo , ""(%d)"" , naddrs ) ) ; ND_PRINT ( ( ndo , "":"" ) ) ; c = ' ' ; bp += 8 ; for ( i = 0 ; i < naddrs ; i ++ ) { ND_TCHECK ( bp [ 3 ] ) ; ND_PRINT ( ( ndo , ""%c%s"" , c , ipaddr_string ( ndo , bp ) ) ) ; c = ',' ; bp += 4 ; } if ( version == 2 && auth_type == VRRP_AUTH_SIMPLE ) { ND_TCHECK ( bp [ 7 ] ) ; ND_PRINT ( ( ndo , "" auth \\"""" ) ) ; if ( fn_printn ( ndo , bp , 8 , ndo -> ndo_snapend ) ) { ND_PRINT ( ( ndo , ""\\"""" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""\\"""" ) ) ; } } return ; trunc : ND_PRINT ( ( ndo , ""[|vrrp]"" ) ) ; }
Fixed code:","
void vrrp_print ( netdissect_options * ndo , register const u_char * bp , register u_int len , register const u_char * bp2 , int ttl ) { int version , type , auth_type = VRRP_AUTH_NONE ; const char * type_s ; if (len < 1) { ND_PRINT ( ( ndo , ""[|vrrp]"" ) ) ; return; } ND_TCHECK ( bp [ 0 ] ) ; version = ( bp [ 0 ] & 0xf0 ) >> 4 ; type = bp [ 0 ] & 0x0f ; type_s = tok2str ( type2str , ""unknown type (%u)"" , type ) ; ND_PRINT ( ( ndo , ""VRRPv%u, %s"" , version , type_s ) ) ; if ( ttl != 255 ) ND_PRINT ( ( ndo , "", (ttl %u)"" , ttl ) ) ; if ( version < 2 || version > 3 || type != VRRP_TYPE_ADVERTISEMENT ) return ; ND_TCHECK ( bp [ 2 ] ) ; ND_PRINT ( ( ndo , "", vrid %u, prio %u"" , bp [ 1 ] , bp [ 2 ] ) ) ; ND_TCHECK ( bp [ 5 ] ) ; if ( version == 2 ) { auth_type = bp [ 4 ] ; ND_PRINT ( ( ndo , "", authtype %s"" , tok2str ( auth2str , NULL , auth_type ) ) ) ; ND_PRINT ( ( ndo , "", intvl %us, length %u"" , bp [ 5 ] , len ) ) ; } else { uint16_t intvl = ( bp [ 4 ] & 0x0f ) << 8 | bp [ 5 ] ; ND_PRINT ( ( ndo , "", intvl %ucs, length %u"" , intvl , len ) ) ; } if ( ndo -> ndo_vflag ) { int naddrs = bp [ 3 ] ; int i ; char c ; if ( version == 2 && ND_TTEST2 ( bp [ 0 ] , len ) ) { struct cksum_vec vec [ 1 ] ; vec [ 0 ] . ptr = bp ; vec [ 0 ] . len = len ; if ( in_cksum ( vec , 1 ) ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } if ( version == 3 && ND_TTEST2 ( bp [ 0 ] , len ) ) { uint16_t cksum = nextproto4_cksum ( ndo , ( const struct ip * ) bp2 , bp , len , len , IPPROTO_VRRP ) ; if ( cksum ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } if (len < 8) { ND_PRINT ( ( ndo , ""[|vrrp]"" ) ) ; return; } ND_PRINT ( ( ndo , "", addrs"" ) ) ; if ( naddrs > 1 ) ND_PRINT ( ( ndo , ""(%d)"" , naddrs ) ) ; ND_PRINT ( ( ndo , "":"" ) ) ; c = ' ' ; bp += 8 ; for ( i = 0 ; i < naddrs ; i ++ ) { ND_TCHECK ( bp [ 3 ] ) ; ND_PRINT ( ( ndo , ""%c%s"" , c , ipaddr_string ( ndo , bp ) ) ) ; c = ',' ; bp += 4 ; } if ( version == 2 && auth_type == VRRP_AUTH_SIMPLE ) { ND_TCHECK ( bp [ 7 ] ) ; ND_PRINT ( ( ndo , "" auth \\"""" ) ) ; if ( fn_printn ( ndo , bp , 8 , ndo -> ndo_snapend ) ) { ND_PRINT ( ( ndo , ""\\"""" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""\\"""" ) ) ; } } return ; trunc : ND_PRINT ( ( ndo , ""[|vrrp]"" ) ) ; }",989,-10.437000786072042,-0.010553084717969709
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
void vrrp_print ( netdissect_options * ndo , register const u_char * bp , register u_int len , register const u_char * bp2 , int ttl ) { int version , type , auth_type = VRRP_AUTH_NONE ; const char * type_s ; ND_TCHECK ( bp [ 0 ] ) ; version = ( bp [ 0 ] & 0xf0 ) >> 4 ; type = bp [ 0 ] & 0x0f ; type_s = tok2str ( type2str , ""unknown type (%u)"" , type ) ; ND_PRINT ( ( ndo , ""VRRPv%u, %s"" , version , type_s ) ) ; if ( ttl != 255 ) ND_PRINT ( ( ndo , "", (ttl %u)"" , ttl ) ) ; if ( version < 2 || version > 3 || type != VRRP_TYPE_ADVERTISEMENT ) return ; ND_TCHECK ( bp [ 2 ] ) ; ND_PRINT ( ( ndo , "", vrid %u, prio %u"" , bp [ 1 ] , bp [ 2 ] ) ) ; ND_TCHECK ( bp [ 5 ] ) ; if ( version == 2 ) { auth_type = bp [ 4 ] ; ND_PRINT ( ( ndo , "", authtype %s"" , tok2str ( auth2str , NULL , auth_type ) ) ) ; ND_PRINT ( ( ndo , "", intvl %us, length %u"" , bp [ 5 ] , len ) ) ; } else { uint16_t intvl = ( bp [ 4 ] & 0x0f ) << 8 | bp [ 5 ] ; ND_PRINT ( ( ndo , "", intvl %ucs, length %u"" , intvl , len ) ) ; } if ( ndo -> ndo_vflag ) { int naddrs = bp [ 3 ] ; int i ; char c ; if ( version == 2 && ND_TTEST2 ( bp [ 0 ] , len ) ) { struct cksum_vec vec [ 1 ] ; vec [ 0 ] . ptr = bp ; vec [ 0 ] . len = len ; if ( in_cksum ( vec , 1 ) ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } if ( version == 3 && ND_TTEST2 ( bp [ 0 ] , len ) ) { uint16_t cksum = nextproto4_cksum ( ndo , ( const struct ip * ) bp2 , bp , len , len , IPPROTO_VRRP ) ; if ( cksum ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } ND_PRINT ( ( ndo , "", addrs"" ) ) ; if ( naddrs > 1 ) ND_PRINT ( ( ndo , ""(%d)"" , naddrs ) ) ; ND_PRINT ( ( ndo , "":"" ) ) ; c = ' ' ; bp += 8 ; for ( i = 0 ; i < naddrs ; i ++ ) { ND_TCHECK ( bp [ 3 ] ) ; ND_PRINT ( ( ndo , ""%c%s"" , c , ipaddr_string ( ndo , bp ) ) ) ; c = ',' ; bp += 4 ; } if ( version == 2 && auth_type == VRRP_AUTH_SIMPLE ) { ND_TCHECK ( bp [ 7 ] ) ; ND_PRINT ( ( ndo , "" auth \\"""" ) ) ; if ( fn_printn ( ndo , bp , 8 , ndo -> ndo_snapend ) ) { ND_PRINT ( ( ndo , ""\\"""" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""\\"""" ) ) ; } } return ; trunc : ND_PRINT ( ( ndo , ""[|vrrp]"" ) ) ; }
Fixed code:","
void vrrp_print ( netdissect_options * ndo , register const u_char * bp , register u_int len , register const u_char * bp2 , int ttl ) { int version , type , auth_type = VRRP_AUTH_NONE ; const char * type_s ; if (len < 8) return; ND_TCHECK ( bp [ 0 ] ) ; version = ( bp [ 0 ] & 0xf0 ) >> 4 ; type = bp [ 0 ] & 0x0f ; type_s = tok2str ( type2str , ""unknown type (%u)"" , type ) ; ND_PRINT ( ( ndo , ""VRRPv%u, %s"" , version , type_s ) ) ; if ( ttl != 255 ) ND_PRINT ( ( ndo , "", (ttl %u)"" , ttl ) ) ; if ( version < 2 || version > 3 || type != VRRP_TYPE_ADVERTISEMENT ) return ; ND_TCHECK ( bp [ 2 ] ) ; ND_PRINT ( ( ndo , "", vrid %u, prio %u"" , bp [ 1 ] , bp [ 2 ] ) ) ; ND_TCHECK ( bp [ 5 ] ) ; if ( version == 2 ) { auth_type = bp [ 4 ] ; ND_PRINT ( ( ndo , "", authtype %s"" , tok2str ( auth2str , NULL , auth_type ) ) ) ; ND_PRINT ( ( ndo , "", intvl %us, length %u"" , bp [ 5 ] , len ) ) ; } else { uint16_t intvl = ( bp [ 4 ] & 0x0f ) << 8 | bp [ 5 ] ; ND_PRINT ( ( ndo , "", intvl %ucs, length %u"" , intvl , len ) ) ; } if ( ndo -> ndo_vflag ) { int naddrs = bp [ 3 ] ; int i ; char c ; if ( version == 2 && (len - 8) < naddrs * 4) return; if ( version == 3 && (len - 8) < naddrs * 4) return; if ( version == 2 && ND_TTEST2 ( bp [ 0 ] , len ) ) { struct cksum_vec vec [ 1 ] ; vec [ 0 ] . ptr = bp ; vec [ 0 ] . len = len ; if ( in_cksum ( vec , 1 ) ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } if ( version == 3 && ND_TTEST2 ( bp [ 0 ] , len ) ) { uint16_t cksum = nextproto4_cksum ( ndo , ( const struct ip * ) bp2 , bp , len , len , IPPROTO_VRRP ) ; if ( cksum ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } ND_PRINT ( ( ndo , "", addrs"" ) ) ; if ( naddrs > 1 ) ND_PRINT ( ( ndo , ""(%d)"" , naddrs ) ) ; ND_PRINT ( ( ndo , "":"" ) ) ; c = ' ' ; bp += 8 ; for ( i = 0 ; i < naddrs ; i ++ ) { ND_TCHECK ( bp [ 3 ] ) ; ND_PRINT ( ( ndo , ""%c%s"" , c , ipaddr_string ( ndo , bp ) ) ) ; c = ',' ; bp += 4 ; } if ( version == 2 && auth_type == VRRP_AUTH_SIMPLE ) { ND_TCHECK ( bp [ 7 ] ) ; ND_PRINT ( ( ndo , "" auth \\"""" ) ) ; if ( fn_printn ( ndo , bp , 8 , ndo -> ndo_snapend ) ) { ND_PRINT ( ( ndo , ""\\"""" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""\\"""" ) ) ; } } return ; trunc : ND_PRINT ( ( ndo , ""[|vrrp]"" ) ) ; }",981,-13.62500939029888,-0.013888898461059
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
void vrrp_print ( netdissect_options * ndo , register const u_char * bp , register u_int len , register const u_char * bp2 , int ttl ) { int version , type , auth_type = VRRP_AUTH_NONE ; const char * type_s ; ND_TCHECK ( bp [ 0 ] ) ; version = ( bp [ 0 ] & 0xf0 ) >> 4 ; type = bp [ 0 ] & 0x0f ; type_s = tok2str ( type2str , ""unknown type (%u)"" , type ) ; ND_PRINT ( ( ndo , ""VRRPv%u, %s"" , version , type_s ) ) ; if ( ttl != 255 ) ND_PRINT ( ( ndo , "", (ttl %u)"" , ttl ) ) ; if ( version < 2 || version > 3 || type != VRRP_TYPE_ADVERTISEMENT ) return ; ND_TCHECK ( bp [ 2 ] ) ; ND_PRINT ( ( ndo , "", vrid %u, prio %u"" , bp [ 1 ] , bp [ 2 ] ) ) ; ND_TCHECK ( bp [ 5 ] ) ; if ( version == 2 ) { auth_type = bp [ 4 ] ; ND_PRINT ( ( ndo , "", authtype %s"" , tok2str ( auth2str , NULL , auth_type ) ) ) ; ND_PRINT ( ( ndo , "", intvl %us, length %u"" , bp [ 5 ] , len ) ) ; } else { uint16_t intvl = ( bp [ 4 ] & 0x0f ) << 8 | bp [ 5 ] ; ND_PRINT ( ( ndo , "", intvl %ucs, length %u"" , intvl , len ) ) ; } if ( ndo -> ndo_vflag ) { int naddrs = bp [ 3 ] ; int i ; char c ; if ( version == 2 && ND_TTEST2 ( bp [ 0 ] , len ) ) { struct cksum_vec vec [ 1 ] ; vec [ 0 ] . ptr = bp ; vec [ 0 ] . len = len ; if ( in_cksum ( vec , 1 ) ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } if ( version == 3 && ND_TTEST2 ( bp [ 0 ] , len ) ) { uint16_t cksum = nextproto4_cksum ( ndo , ( const struct ip * ) bp2 , bp , len , len , IPPROTO_VRRP ) ; if ( cksum ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } ND_PRINT ( ( ndo , "", addrs"" ) ) ; if ( naddrs > 1 ) ND_PRINT ( ( ndo , ""(%d)"" , naddrs ) ) ; ND_PRINT ( ( ndo , "":"" ) ) ; c = ' ' ; bp += 8 ; for ( i = 0 ; i < naddrs ; i ++ ) { ND_TCHECK ( bp [ 3 ] ) ; ND_PRINT ( ( ndo , ""%c%s"" , c , ipaddr_string ( ndo , bp ) ) ) ; c = ',' ; bp += 4 ; } if ( version == 2 && auth_type == VRRP_AUTH_SIMPLE ) { ND_TCHECK ( bp [ 7 ] ) ; ND_PRINT ( ( ndo , "" auth \\"""" ) ) ; if ( fn_printn ( ndo , bp , 8 , ndo -> ndo_snapend ) ) { ND_PRINT ( ( ndo , ""\\"""" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""\\"""" ) ) ; } } return ; trunc : ND_PRINT ( ( ndo , ""[|vrrp]"" ) ) ; }
Fixed code:","
void vrrp_print ( netdissect_options * ndo , register const u_char * bp , register u_int len , register const u_char * bp2 , int ttl ) { int version , type , auth_type = VRRP_AUTH_NONE ; const char * type_s ; ND_TCHECK ( bp [ 0 ] ) ; version = ( bp [ 0 ] & 0xf0 ) >> 4 ; type = bp [ 0 ] & 0x0f ; type_s = tok2str ( type2str , ""unknown type (%u)"" , type ) ; ND_PRINT ( ( ndo , ""VRRPv%u, %s"" , version , type_s ) ) ; if ( ttl != 255 ) ND_PRINT ( ( ndo , "", (ttl %u)"" , ttl ) ) ; if ( version < 2 || version > 3 || type != VRRP_TYPE_ADVERTISEMENT ) return ; ND_TCHECK ( bp [ 2 ] ) ; ND_PRINT ( ( ndo , "", vrid %u, prio %u"" , bp [ 1 ] , bp [ 2 ] ) ) ; ND_TCHECK ( bp [ 5 ] ) ; if ( version == 2 ) { auth_type = bp [ 4 ] ; ND_PRINT ( ( ndo , "", authtype %s"" , tok2str ( auth2str , NULL , auth_type ) ) ) ; ND_PRINT ( ( ndo , "", intvl %us, length %u"" , bp [ 5 ] , len ) ) ; } else { uint16_t intvl = ( bp [ 4 ] & 0x0f ) << 8 | bp [ 5 ] ; ND_PRINT ( ( ndo , "", intvl %ucs, length %u"" , intvl , len ) ) ; } if ( ndo -> ndo_vflag && len > 0 ) { int naddrs = bp [ 3 ] ; int i ; char c ; if ( version == 2 ) { struct cksum_vec vec [ 1 ] ; vec [ 0 ] . ptr = bp ; vec [ 0 ] . len = len > 8 ? 8 : len ; if ( in_cksum ( vec , 1 ) ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } if ( version == 3 && len > 8 ) { uint16_t cksum = nextproto4_cksum ( ndo , ( const struct ip * ) bp2 , bp , len , 8 , IPPROTO_VRRP ) ; if ( cksum ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } ND_PRINT ( ( ndo , "", addrs"" ) ) ; if ( naddrs > 1 ) ND_PRINT ( ( ndo , ""(%d)"" , naddrs ) ) ; ND_PRINT ( ( ndo , "":"" ) ) ; c = ' ' ; bp += 8 ; for ( i = 0 ; i < naddrs ; i ++ ) { if ( len < 8 + 4 * i ) break ; ND_TCHECK ( bp [ 3 ] ) ; ND_PRINT ( ( ndo , ""%c%s"" , c , ipaddr_string ( ndo , bp ) ) ) ; c = ',' ; bp += 4 ; } if ( version == 2 && auth_type == VRRP_AUTH_SIMPLE && len > 16 ) { ND_TCHECK ( bp [ 7 ] ) ; ND_PRINT ( ( ndo , "" auth \\"""" ) ) ; if ( fn_printn ( ndo , bp , 8 , bp + 8 ) ) { ND_PRINT ( ( ndo , ""\\"""" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""\\"""" ) ) ; } } return ; trunc : ND_PRINT ( ( ndo , ""[|vrrp]"" ) ) ; }",929,-31.45712081188109,-0.0338612710569226
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
void vrrp_print ( netdissect_options * ndo , register const u_char * bp , register u_int len , register const u_char * bp2 , int ttl ) { int version , type , auth_type = VRRP_AUTH_NONE ; const char * type_s ; ND_TCHECK ( bp [ 0 ] ) ; version = ( bp [ 0 ] & 0xf0 ) >> 4 ; type = bp [ 0 ] & 0x0f ; type_s = tok2str ( type2str , ""unknown type (%u)"" , type ) ; ND_PRINT ( ( ndo , ""VRRPv%u, %s"" , version , type_s ) ) ; if ( ttl != 255 ) ND_PRINT ( ( ndo , "", (ttl %u)"" , ttl ) ) ; if ( version < 2 || version > 3 || type != VRRP_TYPE_ADVERTISEMENT ) return ; ND_TCHECK ( bp [ 2 ] ) ; ND_PRINT ( ( ndo , "", vrid %u, prio %u"" , bp [ 1 ] , bp [ 2 ] ) ) ; ND_TCHECK ( bp [ 5 ] ) ; if ( version == 2 ) { auth_type = bp [ 4 ] ; ND_PRINT ( ( ndo , "", authtype %s"" , tok2str ( auth2str , NULL , auth_type ) ) ) ; ND_PRINT ( ( ndo , "", intvl %us, length %u"" , bp [ 5 ] , len ) ) ; } else { uint16_t intvl = ( bp [ 4 ] & 0x0f ) << 8 | bp [ 5 ] ; ND_PRINT ( ( ndo , "", intvl %ucs, length %u"" , intvl , len ) ) ; } if ( ndo -> ndo_vflag ) { int naddrs = bp [ 3 ] ; int i ; char c ; if ( version == 2 && ND_TTEST2 ( bp [ 0 ] , len ) ) { struct cksum_vec vec [ 1 ] ; vec [ 0 ] . ptr = bp ; vec [ 0 ] . len = len ; if ( in_cksum ( vec , 1 ) ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } if ( version == 3 && ND_TTEST2 ( bp [ 0 ] , len ) ) { uint16_t cksum = nextproto4_cksum ( ndo , ( const struct ip * ) bp2 , bp , len , len , IPPROTO_VRRP ) ; if ( cksum ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } ND_PRINT ( ( ndo , "", addrs"" ) ) ; if ( naddrs > 1 ) ND_PRINT ( ( ndo , ""(%d)"" , naddrs ) ) ; ND_PRINT ( ( ndo , "":"" ) ) ; c = ' ' ; bp += 8 ; for ( i = 0 ; i < naddrs ; i ++ ) { ND_TCHECK ( bp [ 3 ] ) ; ND_PRINT ( ( ndo , ""%c%s"" , c , ipaddr_string ( ndo , bp ) ) ) ; c = ',' ; bp += 4 ; } if ( version == 2 && auth_type == VRRP_AUTH_SIMPLE ) { ND_TCHECK ( bp [ 7 ] ) ; ND_PRINT ( ( ndo , "" auth \\"""" ) ) ; if ( fn_printn ( ndo , bp , 8 , ndo -> ndo_snapend ) ) { ND_PRINT ( ( ndo , ""\\"""" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""\\"""" ) ) ; } } return ; trunc : ND_PRINT ( ( ndo , ""[|vrrp]"" ) ) ; }
Fixed code:","
void vrrp_print ( netdissect_options * ndo , register const u_char * bp , register u_int len , register const u_char * bp2 , int ttl ) { int version , type , auth_type = VRRP_AUTH_NONE ; const char * type_s ; ND_TCHECK ( bp [ 0 ] ) ; version = ( bp [ 0 ] & 0xf0 ) >> 4 ; type = bp [ 0 ] & 0x0f ; type_s = tok2str ( type2str , ""unknown type (%u)"" , type ) ; ND_PRINT ( ( ndo , ""VRRPv%u, %s"" , version , type_s ) ) ; if ( ttl != 255 ) ND_PRINT ( ( ndo , "", (ttl %u)"" , ttl ) ) ; if ( version < 2 || version > 3 || type != VRRP_TYPE_ADVERTISEMENT ) return ; ND_TCHECK ( bp [ 2 ] ) ; ND_PRINT ( ( ndo , "", vrid %u, prio %u"" , bp [ 1 ] , bp [ 2 ] ) ) ; ND_TCHECK ( bp [ 5 ] ) ; if ( version == 2 ) { auth_type = bp [ 4 ] ; ND_PRINT ( ( ndo , "", authtype %s"" , tok2str ( auth2str , NULL , auth_type ) ) ) ; ND_PRINT ( ( ndo , "", intvl %us, length %u"" , bp [ 5 ] , len ) ) ; } else { uint16_t intvl = ( bp [ 4 ] & 0x0f ) << 8 | bp [ 5 ] ; ND_PRINT ( ( ndo , "", intvl %ucs, length %u"" , intvl , len ) ) ; } if ( ndo -> ndo_vflag ) { int naddrs = bp [ 3 ] ; int i ; char c ; if ( version == 2 && ND_TTEST2 ( bp [ 0 ] , len ) ) { struct cksum_vec vec [ 1 ] ; vec [ 0 ] . ptr = bp ; vec [ 0 ] . len = len ; if ( in_cksum ( vec , 1 ) ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } if ( version == 3 && ND_TTEST2 ( bp [ 0 ] , len ) ) { uint16_t cksum = nextproto4_cksum ( ndo , ( const struct ip * ) bp2 , bp , len , len , IPPROTO_VRRP ) ; if ( cksum ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } if(naddrs > 0) { ND_PRINT ( ( ndo , "", addrs"" ) ) ; if ( naddrs > 1 ) ND_PRINT ( ( ndo , ""(%d)"" , naddrs ) ) ; ND_PRINT ( ( ndo , "":"" ) ) ; c = ' ' ; bp += 8 ; for ( i = 0 ; i < naddrs && i < len; i ++ ) { ND_TCHECK ( bp [ 3 ] ) ; ND_PRINT ( ( ndo , ""%c%s"" , c , ipaddr_string ( ndo , bp ) ) ) ; c = ',' ; bp += 4 ; } } if ( version == 2 && auth_type == VRRP_AUTH_SIMPLE ) { ND_TCHECK ( bp [ 7 ] ) ; ND_PRINT ( ( ndo , "" auth \\"""" ) ) ; if ( fn_printn ( ndo , bp , 8 , ndo -> ndo_snapend ) ) { ND_PRINT ( ( ndo , ""\\"""" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""\\"""" ) ) ; } } return ; trunc : ND_PRINT ( ( ndo , ""[|vrrp]"" ) ) ; }",947,-13.490239068917745,-0.014245236609205644
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
void vrrp_print ( netdissect_options * ndo , register const u_char * bp , register u_int len , register const u_char * bp2 , int ttl ) { int version , type , auth_type = VRRP_AUTH_NONE ; const char * type_s ; ND_TCHECK ( bp [ 0 ] ) ; version = ( bp [ 0 ] & 0xf0 ) >> 4 ; type = bp [ 0 ] & 0x0f ; type_s = tok2str ( type2str , ""unknown type (%u)"" , type ) ; ND_PRINT ( ( ndo , ""VRRPv%u, %s"" , version , type_s ) ) ; if ( ttl != 255 ) ND_PRINT ( ( ndo , "", (ttl %u)"" , ttl ) ) ; if ( version < 2 || version > 3 || type != VRRP_TYPE_ADVERTISEMENT ) return ; ND_TCHECK ( bp [ 2 ] ) ; ND_PRINT ( ( ndo , "", vrid %u, prio %u"" , bp [ 1 ] , bp [ 2 ] ) ) ; ND_TCHECK ( bp [ 5 ] ) ; if ( version == 2 ) { auth_type = bp [ 4 ] ; ND_PRINT ( ( ndo , "", authtype %s"" , tok2str ( auth2str , NULL , auth_type ) ) ) ; ND_PRINT ( ( ndo , "", intvl %us, length %u"" , bp [ 5 ] , len ) ) ; } else { uint16_t intvl = ( bp [ 4 ] & 0x0f ) << 8 | bp [ 5 ] ; ND_PRINT ( ( ndo , "", intvl %ucs, length %u"" , intvl , len ) ) ; } if ( ndo -> ndo_vflag ) { int naddrs = bp [ 3 ] ; int i ; char c ; if ( version == 2 && ND_TTEST2 ( bp [ 0 ] , len ) ) { struct cksum_vec vec [ 1 ] ; vec [ 0 ] . ptr = bp ; vec [ 0 ] . len = len ; if ( in_cksum ( vec , 1 ) ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } if ( version == 3 && ND_TTEST2 ( bp [ 0 ] , len ) ) { uint16_t cksum = nextproto4_cksum ( ndo , ( const struct ip * ) bp2 , bp , len , len , IPPROTO_VRRP ) ; if ( cksum ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } ND_PRINT ( ( ndo , "", addrs"" ) ) ; if ( naddrs > 1 ) ND_PRINT ( ( ndo , ""(%d)"" , naddrs ) ) ; ND_PRINT ( ( ndo , "":"" ) ) ; c = ' ' ; bp += 8 ; for ( i = 0 ; i < naddrs ; i ++ ) { ND_TCHECK ( bp [ 3 ] ) ; ND_PRINT ( ( ndo , ""%c%s"" , c , ipaddr_string ( ndo , bp ) ) ) ; c = ',' ; bp += 4 ; } if ( version == 2 && auth_type == VRRP_AUTH_SIMPLE ) { ND_TCHECK ( bp [ 7 ] ) ; ND_PRINT ( ( ndo , "" auth \\"""" ) ) ; if ( fn_printn ( ndo , bp , 8 , ndo -> ndo_snapend ) ) { ND_PRINT ( ( ndo , ""\\"""" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""\\"""" ) ) ; } } return ; trunc : ND_PRINT ( ( ndo , ""[|vrrp]"" ) ) ; }
Fixed code:","
void vrrp_print ( netdissect_options * ndo , register const u_char * bp , register u_int len , register const u_char * bp2 , int ttl ) { int version , type , auth_type = VRRP_AUTH_NONE ; const char * type_s ; if (len > 0) { ND_TCHECK ( bp [ 0 ] ) ; version = ( bp [ 0 ] & 0xf0 ) >> 4 ; type = bp [ 0 ] & 0x0f ; type_s = tok2str ( type2str , ""unknown type (%u)"" , type ) ; ND_PRINT ( ( ndo , ""VRRPv%u, %s"" , version , type_s ) ) ; if ( ttl != 255 ) ND_PRINT ( ( ndo , "", (ttl %u)"" , ttl ) ) ; if ( version < 2 || version > 3 || type != VRRP_TYPE_ADVERTISEMENT ) return ; ND_TCHECK ( bp [ 2 ] ) ; ND_PRINT ( ( ndo , "", vrid %u, prio %u"" , bp [ 1 ] , bp [ 2 ] ) ) ; ND_TCHECK ( bp [ 5 ] ) ; if ( version == 2 ) { auth_type = bp [ 4 ] ; ND_PRINT ( ( ndo , "", authtype %s"" , tok2str ( auth2str , NULL , auth_type ) ) ) ; ND_PRINT ( ( ndo , "", intvl %us, length %u"" , bp [ 5 ] , len ) ) ; } else { uint16_t intvl = ( bp [ 4 ] & 0x0f ) << 8 | bp [ 5 ] ; ND_PRINT ( ( ndo , "", intvl %ucs, length %u"" , intvl , len ) ) ; } if ( ndo -> ndo_vflag ) { int naddrs = bp [ 3 ] ; int i ; char c ; if ( version == 2 && ND_TTEST2 ( bp [ 0 ] , len ) ) { struct cksum_vec vec [ 1 ] ; vec [ 0 ] . ptr = bp ; vec [ 0 ] . len = len ; if ( in_cksum ( vec , 1 ) ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } if ( version == 3 && ND_TTEST2 ( bp [ 0 ] , len ) ) { uint16_t cksum = nextproto4_cksum ( ndo , ( const struct ip * ) bp2 , bp , len , len , IPPROTO_VRRP ) ; if ( cksum ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } ND_PRINT ( ( ndo , "", addrs"" ) ) ; if ( naddrs > 1 ) ND_PRINT ( ( ndo , ""(%d)"" , naddrs ) ) ; ND_PRINT ( ( ndo , "":"" ) ) ; c = ' ' ; bp += 8 ; for ( i = 0 ; i < naddrs ; i ++ ) { if (len >= 7) { ND_TCHECK ( bp [ 3 ] ) ; ND_PRINT ( ( ndo , ""%c%s"" , c , ipaddr_string ( ndo , bp ) ) ) ; c = ',' ; bp += 4 ; } else { return; } } if ( version == 2 && auth_type == VRRP_AUTH_SIMPLE ) { if (len >= 11) { ND_TCHECK ( bp [ 7 ] ) ; ND_PRINT ( ( ndo , "" auth \\"""" ) ) ; if ( fn_printn ( ndo , bp , 8 , ndo -> ndo_snapend ) ) { ND_PRINT ( ( ndo , ""\\"""" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""\\"""" ) ) ; } else { return; } } } return ; trunc : ND_PRINT ( ( ndo , ""[|vrrp]"" ) ) ; }
}",968,-23.55715503775966,-0.024335903964627748
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
void vrrp_print ( netdissect_options * ndo , register const u_char * bp , register u_int len , register const u_char * bp2 , int ttl ) { int version , type , auth_type = VRRP_AUTH_NONE ; const char * type_s ; ND_TCHECK ( bp [ 0 ] ) ; version = ( bp [ 0 ] & 0xf0 ) >> 4 ; type = bp [ 0 ] & 0x0f ; type_s = tok2str ( type2str , ""unknown type (%u)"" , type ) ; ND_PRINT ( ( ndo , ""VRRPv%u, %s"" , version , type_s ) ) ; if ( ttl != 255 ) ND_PRINT ( ( ndo , "", (ttl %u)"" , ttl ) ) ; if ( version < 2 || version > 3 || type != VRRP_TYPE_ADVERTISEMENT ) return ; ND_TCHECK ( bp [ 2 ] ) ; ND_PRINT ( ( ndo , "", vrid %u, prio %u"" , bp [ 1 ] , bp [ 2 ] ) ) ; ND_TCHECK ( bp [ 5 ] ) ; if ( version == 2 ) { auth_type = bp [ 4 ] ; ND_PRINT ( ( ndo , "", authtype %s"" , tok2str ( auth2str , NULL , auth_type ) ) ) ; ND_PRINT ( ( ndo , "", intvl %us, length %u"" , bp [ 5 ] , len ) ) ; } else { uint16_t intvl = ( bp [ 4 ] & 0x0f ) << 8 | bp [ 5 ] ; ND_PRINT ( ( ndo , "", intvl %ucs, length %u"" , intvl , len ) ) ; } if ( ndo -> ndo_vflag ) { int naddrs = bp [ 3 ] ; int i ; char c ; if ( version == 2 && ND_TTEST2 ( bp [ 0 ] , len ) ) { struct cksum_vec vec [ 1 ] ; vec [ 0 ] . ptr = bp ; vec [ 0 ] . len = len ; if ( in_cksum ( vec , 1 ) ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } if ( version == 3 && ND_TTEST2 ( bp [ 0 ] , len ) ) { uint16_t cksum = nextproto4_cksum ( ndo , ( const struct ip * ) bp2 , bp , len , len , IPPROTO_VRRP ) ; if ( cksum ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } ND_PRINT ( ( ndo , "", addrs"" ) ) ; if ( naddrs > 1 ) ND_PRINT ( ( ndo , ""(%d)"" , naddrs ) ) ; ND_PRINT ( ( ndo , "":"" ) ) ; c = ' ' ; bp += 8 ; for ( i = 0 ; i < naddrs ; i ++ ) { ND_TCHECK ( bp [ 3 ] ) ; ND_PRINT ( ( ndo , ""%c%s"" , c , ipaddr_string ( ndo , bp ) ) ) ; c = ',' ; bp += 4 ; } if ( version == 2 && auth_type == VRRP_AUTH_SIMPLE ) { ND_TCHECK ( bp [ 7 ] ) ; ND_PRINT ( ( ndo , "" auth \\"""" ) ) ; if ( fn_printn ( ndo , bp , 8 , ndo -> ndo_snapend ) ) { ND_PRINT ( ( ndo , ""\\"""" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""\\"""" ) ) ; } } return ; trunc : ND_PRINT ( ( ndo , ""[|vrrp]"" ) ) ; }
Fixed code:","
void vrrp_print ( netdissect_options * ndo , register const u_char * bp , register u_int len , register const u_char * bp2 , int ttl ) { int version , type , auth_type = VRRP_AUTH_NONE ; const char * type_s ; if (len < 8) { //Added to check for out-of-bounds read return; } ND_TCHECK ( bp [ 0 ] ) ; version = ( bp [ 0 ] & 0xf0 ) >> 4 ; type = bp [ 0 ] & 0x0f ; type_s = tok2str ( type2str , ""unknown type (%u)"" , type ) ; ND_PRINT ( ( ndo , ""VRRPv%u, %s"" , version , type_s ) ) ; if ( ttl != 255 ) ND_PRINT ( ( ndo , "", (ttl %u)"" , ttl ) ) ; if ( version < 2 || version > 3 || type != VRRP_TYPE_ADVERTISEMENT ) return ; ND_TCHECK ( bp [ 2 ] ) ; ND_PRINT ( ( ndo , "", vrid %u, prio %u"" , bp [ 1 ] , bp [ 2 ] ) ) ; ND_TCHECK ( bp [ 5 ] ) ; if ( version == 2 ) { auth_type = bp [ 4 ] ; ND_PRINT ( ( ndo , "", authtype %s"" , tok2str ( auth2str , NULL , auth_type ) ) ) ; ND_PRINT ( ( ndo , "", intvl %us, length %u"" , bp [ 5 ] , len ) ) ; } else { uint16_t intvl = ( bp [ 4 ] & 0x0f ) << 8 | bp [ 5 ] ; ND_PRINT ( ( ndo , "", intvl %ucs, length %u"" , intvl , len ) ) ; } if ( ndo -> ndo_vflag ) { int naddrs = bp [ 3 ] ; int i ; char c ; if ( version == 2 && ND_TTEST2 ( bp [ 0 ] , len ) ) { struct cksum_vec vec [ 1 ] ; vec [ 0 ] . ptr = bp ; vec [ 0 ] . len = len ; if ( in_cksum ( vec , 1 ) ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } if ( version == 3 && ND_TTEST2 ( bp [ 0 ] , len ) ) { uint16_t cksum = nextproto4_cksum ( ndo , ( const struct ip * ) bp2 , bp , len , len , IPPROTO_VRRP ) ; if ( cksum ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } if (len < 8 + naddrs * 4) { //Added to check for out-of-bounds read return; } ND_PRINT ( ( ndo , "", addrs"" ) ) ; if ( naddrs > 1 ) ND_PRINT ( ( ndo , ""(%d)"" , naddrs ) ) ; ND_PRINT ( ( ndo , "":"" ) ) ; c = ' ' ; bp += 8 ; for ( i = 0 ; i < naddrs ; i ++ ) { ND_TCHECK ( bp [ 3 ] ) ; ND_PRINT ( ( ndo , ""%c%s"" , c , ipaddr_string ( ndo , bp ) ) ) ; c = ',' ; bp += 4 ; } if ( version == 2 && auth_type == VRRP_AUTH_SIMPLE ) { ND_TCHECK ( bp [ 7 ] ) ; ND_PRINT ( ( ndo , "" auth \\"""" ) ) ; if ( fn_printn ( ndo , bp , 8 , ndo -> ndo_snapend ) ) { ND_PRINT ( ( ndo , ""\\"""" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""\\"""" ) ) ; } } return ; trunc : ND_PRINT ( ( ndo , ""[|vrrp]"" ) ) ; }",983,-21.03260023318012,-0.02139633797882006
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
void vrrp_print ( netdissect_options * ndo , register const u_char * bp , register u_int len , register const u_char * bp2 , int ttl ) { int version , type , auth_type = VRRP_AUTH_NONE ; const char * type_s ; ND_TCHECK ( bp [ 0 ] ) ; version = ( bp [ 0 ] & 0xf0 ) >> 4 ; type = bp [ 0 ] & 0x0f ; type_s = tok2str ( type2str , ""unknown type (%u)"" , type ) ; ND_PRINT ( ( ndo , ""VRRPv%u, %s"" , version , type_s ) ) ; if ( ttl != 255 ) ND_PRINT ( ( ndo , "", (ttl %u)"" , ttl ) ) ; if ( version < 2 || version > 3 || type != VRRP_TYPE_ADVERTISEMENT ) return ; ND_TCHECK ( bp [ 2 ] ) ; ND_PRINT ( ( ndo , "", vrid %u, prio %u"" , bp [ 1 ] , bp [ 2 ] ) ) ; ND_TCHECK ( bp [ 5 ] ) ; if ( version == 2 ) { auth_type = bp [ 4 ] ; ND_PRINT ( ( ndo , "", authtype %s"" , tok2str ( auth2str , NULL , auth_type ) ) ) ; ND_PRINT ( ( ndo , "", intvl %us, length %u"" , bp [ 5 ] , len ) ) ; } else { uint16_t intvl = ( bp [ 4 ] & 0x0f ) << 8 | bp [ 5 ] ; ND_PRINT ( ( ndo , "", intvl %ucs, length %u"" , intvl , len ) ) ; } if ( ndo -> ndo_vflag ) { int naddrs = bp [ 3 ] ; int i ; char c ; if ( version == 2 && ND_TTEST2 ( bp [ 0 ] , len ) ) { struct cksum_vec vec [ 1 ] ; vec [ 0 ] . ptr = bp ; vec [ 0 ] . len = len ; if ( in_cksum ( vec , 1 ) ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } if ( version == 3 && ND_TTEST2 ( bp [ 0 ] , len ) ) { uint16_t cksum = nextproto4_cksum ( ndo , ( const struct ip * ) bp2 , bp , len , len , IPPROTO_VRRP ) ; if ( cksum ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } ND_PRINT ( ( ndo , "", addrs"" ) ) ; if ( naddrs > 1 ) ND_PRINT ( ( ndo , ""(%d)"" , naddrs ) ) ; ND_PRINT ( ( ndo , "":"" ) ) ; c = ' ' ; bp += 8 ; for ( i = 0 ; i < naddrs ; i ++ ) { ND_TCHECK ( bp [ 3 ] ) ; ND_PRINT ( ( ndo , ""%c%s"" , c , ipaddr_string ( ndo , bp ) ) ) ; c = ',' ; bp += 4 ; } if ( version == 2 && auth_type == VRRP_AUTH_SIMPLE ) { ND_TCHECK ( bp [ 7 ] ) ; ND_PRINT ( ( ndo , "" auth \\"""" ) ) ; if ( fn_printn ( ndo , bp , 8 , ndo -> ndo_snapend ) ) { ND_PRINT ( ( ndo , ""\\"""" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""\\"""" ) ) ; } } return ; trunc : ND_PRINT ( ( ndo , ""[|vrrp]"" ) ) ; }
Fixed code:","
void vrrp_print ( netdissect_options * ndo , register const u_char * bp , register u_int len , register const u_char * bp2 , int ttl ) { int version , type , auth_type = VRRP_AUTH_NONE ; const char * type_s ; ND_TCHECK ( bp [ 0 ] ) ; version = ( bp [ 0 ] & 0xf0 ) >> 4 ; type = bp [ 0 ] & 0x0f ; type_s = tok2str ( type2str , ""unknown type (%u)"" , type ) ; ND_PRINT ( ( ndo , ""VRRPv%u, %s"" , version , type_s ) ) ; if ( ttl != 255 ) ND_PRINT ( ( ndo , "", (ttl %u)"" , ttl ) ) ; if ( version < 2 || version > 3 || type != VRRP_TYPE_ADVERTISEMENT ) return ; ND_TCHECK ( bp [ 2 ] ) ; ND_PRINT ( ( ndo , "", vrid %u, prio %u"" , bp [ 1 ] , bp [ 2 ] ) ) ; ND_TCHECK ( bp [ 5 ] ) ; if ( version == 2 ) { auth_type = bp [ 4 ] ; ND_PRINT ( ( ndo , "", authtype %s"" , tok2str ( auth2str , NULL , auth_type ) ) ) ; ND_PRINT ( ( ndo , "", intvl %us, length %u"" , bp [ 5 ] , len ) ) ; } else { uint16_t intvl = ( bp [ 4 ] & 0x0f ) << 8 | bp [ 5 ] ; ND_PRINT ( ( ndo , "", intvl %ucs, length %u"" , intvl , len ) ) ; } if ( ndo -> ndo_vflag ) { int naddrs = bp [ 3 ] ; int i ; char c ; if ( version == 2 && ND_TTEST2 ( bp [ 0 ] , len ) && len >= 12) { struct cksum_vec vec [ 1 ] ; vec [ 0 ] . ptr = bp ; vec [ 0 ] . len = len ; if ( in_cksum ( vec , 1 ) ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } if ( version == 3 && ND_TTEST2 ( bp [ 0 ] , len ) && len >= 12) { uint16_t cksum = nextproto4_cksum ( ndo , ( const struct ip * ) bp2 , bp , len , len , IPPROTO_VRRP ) ; if ( cksum ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } ND_PRINT ( ( ndo , "", addrs"" ) ) ; if ( naddrs > 1 ) ND_PRINT ( ( ndo , ""(%d)"" , naddrs ) ) ; ND_PRINT ( ( ndo , "":"" ) ) ; c = ' ' ; bp += 8 ; for ( i = 0 ; i < naddrs ; i ++ ) { if (bp + 4 > bp2 + len) break; ND_TCHECK ( bp [ 3 ] ) ; ND_PRINT ( ( ndo , ""%c%s"" , c , ipaddr_string ( ndo , bp ) ) ) ; c = ',' ; bp += 4 ; } if ( version == 2 && auth_type == VRRP_AUTH_SIMPLE ) { if (bp + 8 > bp2 + len) break; ND_TCHECK ( bp [ 7 ] ) ; ND_PRINT ( ( ndo , "" auth \\"""" ) ) ; if ( fn_printn ( ndo , bp , 8 , ndo -> ndo_snapend ) ) { ND_PRINT ( ( ndo , ""\\"""" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""\\"""" ) ) ; } } return ; trunc : ND_PRINT ( ( ndo , ""[|vrrp]"" ) ) ; }",969,-20.992732422829082,-0.021664326545747247
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
void vrrp_print ( netdissect_options * ndo , register const u_char * bp , register u_int len , register const u_char * bp2 , int ttl ) { int version , type , auth_type = VRRP_AUTH_NONE ; const char * type_s ; ND_TCHECK ( bp [ 0 ] ) ; version = ( bp [ 0 ] & 0xf0 ) >> 4 ; type = bp [ 0 ] & 0x0f ; type_s = tok2str ( type2str , ""unknown type (%u)"" , type ) ; ND_PRINT ( ( ndo , ""VRRPv%u, %s"" , version , type_s ) ) ; if ( ttl != 255 ) ND_PRINT ( ( ndo , "", (ttl %u)"" , ttl ) ) ; if ( version < 2 || version > 3 || type != VRRP_TYPE_ADVERTISEMENT ) return ; ND_TCHECK ( bp [ 2 ] ) ; ND_PRINT ( ( ndo , "", vrid %u, prio %u"" , bp [ 1 ] , bp [ 2 ] ) ) ; ND_TCHECK ( bp [ 5 ] ) ; if ( version == 2 ) { auth_type = bp [ 4 ] ; ND_PRINT ( ( ndo , "", authtype %s"" , tok2str ( auth2str , NULL , auth_type ) ) ) ; ND_PRINT ( ( ndo , "", intvl %us, length %u"" , bp [ 5 ] , len ) ) ; } else { uint16_t intvl = ( bp [ 4 ] & 0x0f ) << 8 | bp [ 5 ] ; ND_PRINT ( ( ndo , "", intvl %ucs, length %u"" , intvl , len ) ) ; } if ( ndo -> ndo_vflag ) { int naddrs = bp [ 3 ] ; int i ; char c ; if ( version == 2 && ND_TTEST2 ( bp [ 0 ] , len ) ) { struct cksum_vec vec [ 1 ] ; vec [ 0 ] . ptr = bp ; vec [ 0 ] . len = len ; if ( in_cksum ( vec , 1 ) ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } if ( version == 3 && ND_TTEST2 ( bp [ 0 ] , len ) ) { uint16_t cksum = nextproto4_cksum ( ndo , ( const struct ip * ) bp2 , bp , len , len , IPPROTO_VRRP ) ; if ( cksum ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } ND_PRINT ( ( ndo , "", addrs"" ) ) ; if ( naddrs > 1 ) ND_PRINT ( ( ndo , ""(%d)"" , naddrs ) ) ; ND_PRINT ( ( ndo , "":"" ) ) ; c = ' ' ; bp += 8 ; for ( i = 0 ; i < naddrs ; i ++ ) { ND_TCHECK ( bp [ 3 ] ) ; ND_PRINT ( ( ndo , ""%c%s"" , c , ipaddr_string ( ndo , bp ) ) ) ; c = ',' ; bp += 4 ; } if ( version == 2 && auth_type == VRRP_AUTH_SIMPLE ) { ND_TCHECK ( bp [ 7 ] ) ; ND_PRINT ( ( ndo , "" auth \\"""" ) ) ; if ( fn_printn ( ndo , bp , 8 , ndo -> ndo_snapend ) ) { ND_PRINT ( ( ndo , ""\\"""" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""\\"""" ) ) ; } } return ; trunc : ND_PRINT ( ( ndo , ""[|vrrp]"" ) ) ; }
Fixed code:","
void vrrp_print ( netdissect_options * ndo , register const u_char * bp , register u_int len , register const u_char * bp2 , int ttl ) { int version , type , auth_type = VRRP_AUTH_NONE ; const char * type_s ; ND_TCHECK ( bp [ 0 ] ) ; version = ( bp [ 0 ] & 0xf0 ) >> 4 ; type = bp [ 0 ] & 0x0f ; type_s = tok2str ( type2str , ""unknown type (%u)"" , type ) ; ND_PRINT ( ( ndo , ""VRRPv%u, %s"" , version , type_s ) ) ; if ( ttl != 255 ) ND_PRINT ( ( ndo , "", (ttl %u)"" , ttl ) ) ; if ( version < 2 || version > 3 || type != VRRP_TYPE_ADVERTISEMENT ) return ; ND_TCHECK ( bp [ 2 ] ) ; ND_PRINT ( ( ndo , "", vrid %u, prio %u"" , bp [ 1 ] , bp [ 2 ] ) ) ; ND_TCHECK ( bp [ 5 ] ) ; if ( version == 2 ) { auth_type = bp [ 4 ] ; ND_PRINT ( ( ndo , "", authtype %s"" , tok2str ( auth2str , NULL , auth_type ) ) ) ; ND_PRINT ( ( ndo , "", intvl %us, length %u"" , bp [ 5 ] , len ) ) ; } else { uint16_t intvl = ( bp [ 4 ] & 0x0f ) << 8 | bp [ 5 ] ; ND_PRINT ( ( ndo , "", intvl %ucs, length %u"" , intvl , len ) ) ; } if ( ndo -> ndo_vflag ) { int naddrs = bp [ 3 ] ; int i ; char c ; if ( version == 2 && len >= 8 && ND_TTEST2 ( bp [ 0 ] , 8 ) ) { struct cksum_vec vec [ 1 ] ; vec [ 0 ] . ptr = bp ; vec [ 0 ] . len = 8 ; if ( in_cksum ( vec , 1 ) ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } if ( version == 3 && len >= 8 && ND_TTEST2 ( bp [ 0 ] , 8 ) ) { uint16_t cksum = nextproto4_cksum ( ndo , ( const struct ip * ) bp2 , bp , len , 8 , IPPROTO_VRRP ) ; if ( cksum ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } ND_PRINT ( ( ndo , "", addrs"" ) ) ; if ( naddrs > 1 ) ND_PRINT ( ( ndo , ""(%d)"" , naddrs ) ) ; ND_PRINT ( ( ndo , "":"" ) ) ; c = ' ' ; bp += 8 ; for ( i = 0 ; i < naddrs ; i ++ ) { ND_TCHECK_LEN ( bp , 4 ) ; ND_PRINT ( ( ndo , ""%c%s"" , c , ipaddr_string ( ndo , bp ) ) ) ; c = ',' ; bp += 4 ; } if ( version == 2 && auth_type == VRRP_AUTH_SIMPLE ) { ND_TCHECK_LEN ( bp , 8 ) ; ND_PRINT ( ( ndo , "" auth \\"""" ) ) ; if ( fn_printn ( ndo , bp , 8 , ndo -> ndo_snapend ) ) { ND_PRINT ( ( ndo , ""\\"""" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""\\"""" ) ) ; } } return ; trunc : ND_PRINT ( ( ndo , ""[|vrrp]"" ) ) ; }",945,-11.98500409884994,-0.012682544019947025
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
void vrrp_print ( netdissect_options * ndo , register const u_char * bp , register u_int len , register const u_char * bp2 , int ttl ) { int version , type , auth_type = VRRP_AUTH_NONE ; const char * type_s ; ND_TCHECK ( bp [ 0 ] ) ; version = ( bp [ 0 ] & 0xf0 ) >> 4 ; type = bp [ 0 ] & 0x0f ; type_s = tok2str ( type2str , ""unknown type (%u)"" , type ) ; ND_PRINT ( ( ndo , ""VRRPv%u, %s"" , version , type_s ) ) ; if ( ttl != 255 ) ND_PRINT ( ( ndo , "", (ttl %u)"" , ttl ) ) ; if ( version < 2 || version > 3 || type != VRRP_TYPE_ADVERTISEMENT ) return ; ND_TCHECK ( bp [ 2 ] ) ; ND_PRINT ( ( ndo , "", vrid %u, prio %u"" , bp [ 1 ] , bp [ 2 ] ) ) ; ND_TCHECK ( bp [ 5 ] ) ; if ( version == 2 ) { auth_type = bp [ 4 ] ; ND_PRINT ( ( ndo , "", authtype %s"" , tok2str ( auth2str , NULL , auth_type ) ) ) ; ND_PRINT ( ( ndo , "", intvl %us, length %u"" , bp [ 5 ] , len ) ) ; } else { uint16_t intvl = ( bp [ 4 ] & 0x0f ) << 8 | bp [ 5 ] ; ND_PRINT ( ( ndo , "", intvl %ucs, length %u"" , intvl , len ) ) ; } if ( ndo -> ndo_vflag ) { int naddrs = bp [ 3 ] ; int i ; char c ; if ( version == 2 && ND_TTEST2 ( bp [ 0 ] , len ) ) { struct cksum_vec vec [ 1 ] ; vec [ 0 ] . ptr = bp ; vec [ 0 ] . len = len ; if ( in_cksum ( vec , 1 ) ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } if ( version == 3 && ND_TTEST2 ( bp [ 0 ] , len ) ) { uint16_t cksum = nextproto4_cksum ( ndo , ( const struct ip * ) bp2 , bp , len , len , IPPROTO_VRRP ) ; if ( cksum ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } ND_PRINT ( ( ndo , "", addrs"" ) ) ; if ( naddrs > 1 ) ND_PRINT ( ( ndo , ""(%d)"" , naddrs ) ) ; ND_PRINT ( ( ndo , "":"" ) ) ; c = ' ' ; bp += 8 ; for ( i = 0 ; i < naddrs ; i ++ ) { ND_TCHECK ( bp [ 3 ] ) ; ND_PRINT ( ( ndo , ""%c%s"" , c , ipaddr_string ( ndo , bp ) ) ) ; c = ',' ; bp += 4 ; } if ( version == 2 && auth_type == VRRP_AUTH_SIMPLE ) { ND_TCHECK ( bp [ 7 ] ) ; ND_PRINT ( ( ndo , "" auth \\"""" ) ) ; if ( fn_printn ( ndo , bp , 8 , ndo -> ndo_snapend ) ) { ND_PRINT ( ( ndo , ""\\"""" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""\\"""" ) ) ; } } return ; trunc : ND_PRINT ( ( ndo , ""[|vrrp]"" ) ) ; }
Fixed code:","
void vrrp_print ( netdissect_options * ndo , register const u_char * bp , register u_int len , register const u_char * bp2 , int ttl ) { int version , type , auth_type = VRRP_AUTH_NONE ; const char * type_s ; ND_TCHECK ( bp [ 0 ] ) ; version = ( bp [ 0 ] & 0xf0 ) >> 4 ; type = bp [ 0 ] & 0x0f ; type_s = tok2str ( type2str , ""unknown type (%u)"" , type ) ; ND_PRINT ( ( ndo , ""VRRPv%u, %s"" , version , type_s ) ) ; if ( ttl != 255 ) ND_PRINT ( ( ndo , "", (ttl %u)"" , ttl ) ) ; if ( version < 2 || version > 3 || type != VRRP_TYPE_ADVERTISEMENT ) return ; ND_TCHECK ( bp [ 2 ] ) ; ND_PRINT ( ( ndo , "", vrid %u, prio %u"" , bp [ 1 ] , bp [ 2 ] ) ) ; ND_TCHECK ( bp [ 5 ] ) ; if ( version == 2 ) { auth_type = bp [ 4 ] ; ND_PRINT ( ( ndo , "", authtype %s"" , tok2str ( auth2str , NULL , auth_type ) ) ) ; ND_PRINT ( ( ndo , "", intvl %us, length %u"" , bp [ 5 ] , len ) ) ; } else { uint16_t intvl = ( bp [ 4 ] & 0x0f ) << 8 | bp [ 5 ] ; ND_PRINT ( ( ndo , "", intvl %ucs, length %u"" , intvl , len ) ) ; } if ( ndo -> ndo_vflag ) { int naddrs = bp [ 3 ] ; int i ; char c ; if ( version == 2 && naddrs <= (len - 8) / 4 ) { struct cksum_vec vec [ 1 ] ; vec [ 0 ] . ptr = bp ; vec [ 0 ] . len = len ; if ( in_cksum ( vec , 1 ) ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } if ( version == 3 && naddrs <= (len - 8) / 4 ) { uint16_t cksum = nextproto4_cksum ( ndo , ( const struct ip * ) bp2 , bp , len , len , IPPROTO_VRRP ) ; if ( cksum ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } ND_PRINT ( ( ndo , "", addrs"" ) ) ; if ( naddrs > 1 ) ND_PRINT ( ( ndo , ""(%d)"" , naddrs ) ) ; ND_PRINT ( ( ndo , "":"" ) ) ; c = ' ' ; bp += 8 ; for ( i = 0 ; i < naddrs ; i ++ ) { ND_TCHECK ( bp [ 3 ] ) ; ND_PRINT ( ( ndo , ""%c%s"" , c , ipaddr_string ( ndo , bp ) ) ) ; c = ',' ; bp += 4 ; } if ( version == 2 && auth_type == VRRP_AUTH_SIMPLE ) { ND_TCHECK ( bp [ 7 ] ) ; ND_PRINT ( ( ndo , "" auth \\"""" ) ) ; if ( fn_printn ( ndo , bp , 8 , ndo -> ndo_snapend ) ) { ND_PRINT ( ( ndo , ""\\"""" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""\\"""" ) ) ; } } return ; trunc : ND_PRINT ( ( ndo , ""[|vrrp]"" ) ) ; }",927,-11.852992660661496,-0.012786399849688776
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
void vrrp_print ( netdissect_options * ndo , register const u_char * bp , register u_int len , register const u_char * bp2 , int ttl ) { int version , type , auth_type = VRRP_AUTH_NONE ; const char * type_s ; ND_TCHECK ( bp [ 0 ] ) ; version = ( bp [ 0 ] & 0xf0 ) >> 4 ; type = bp [ 0 ] & 0x0f ; type_s = tok2str ( type2str , ""unknown type (%u)"" , type ) ; ND_PRINT ( ( ndo , ""VRRPv%u, %s"" , version , type_s ) ) ; if ( ttl != 255 ) ND_PRINT ( ( ndo , "", (ttl %u)"" , ttl ) ) ; if ( version < 2 || version > 3 || type != VRRP_TYPE_ADVERTISEMENT ) return ; ND_TCHECK ( bp [ 2 ] ) ; ND_PRINT ( ( ndo , "", vrid %u, prio %u"" , bp [ 1 ] , bp [ 2 ] ) ) ; ND_TCHECK ( bp [ 5 ] ) ; if ( version == 2 ) { auth_type = bp [ 4 ] ; ND_PRINT ( ( ndo , "", authtype %s"" , tok2str ( auth2str , NULL , auth_type ) ) ) ; ND_PRINT ( ( ndo , "", intvl %us, length %u"" , bp [ 5 ] , len ) ) ; } else { uint16_t intvl = ( bp [ 4 ] & 0x0f ) << 8 | bp [ 5 ] ; ND_PRINT ( ( ndo , "", intvl %ucs, length %u"" , intvl , len ) ) ; } if ( ndo -> ndo_vflag ) { int naddrs = bp [ 3 ] ; int i ; char c ; if ( version == 2 && ND_TTEST2 ( bp [ 0 ] , len ) ) { struct cksum_vec vec [ 1 ] ; vec [ 0 ] . ptr = bp ; vec [ 0 ] . len = len ; if ( in_cksum ( vec , 1 ) ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } if ( version == 3 && ND_TTEST2 ( bp [ 0 ] , len ) ) { uint16_t cksum = nextproto4_cksum ( ndo , ( const struct ip * ) bp2 , bp , len , len , IPPROTO_VRRP ) ; if ( cksum ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } ND_PRINT ( ( ndo , "", addrs"" ) ) ; if ( naddrs > 1 ) ND_PRINT ( ( ndo , ""(%d)"" , naddrs ) ) ; ND_PRINT ( ( ndo , "":"" ) ) ; c = ' ' ; bp += 8 ; for ( i = 0 ; i < naddrs ; i ++ ) { ND_TCHECK ( bp [ 3 ] ) ; ND_PRINT ( ( ndo , ""%c%s"" , c , ipaddr_string ( ndo , bp ) ) ) ; c = ',' ; bp += 4 ; } if ( version == 2 && auth_type == VRRP_AUTH_SIMPLE ) { ND_TCHECK ( bp [ 7 ] ) ; ND_PRINT ( ( ndo , "" auth \\"""" ) ) ; if ( fn_printn ( ndo , bp , 8 , ndo -> ndo_snapend ) ) { ND_PRINT ( ( ndo , ""\\"""" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""\\"""" ) ) ; } } return ; trunc : ND_PRINT ( ( ndo , ""[|vrrp]"" ) ) ; }
Fixed code:","
void vrrp_print ( netdissect_options * ndo , register const u_char * bp , register u_int len , register const u_char * bp2 , int ttl ) { int version , type , auth_type = VRRP_AUTH_NONE ; const char * type_s ; ND_TCHECK ( bp [ 0 ] ) ; version = ( bp [ 0 ] & 0xf0 ) >> 4 ; type = bp [ 0 ] & 0x0f ; type_s = tok2str ( type2str , ""unknown type (%u)"" , type ) ; ND_PRINT ( ( ndo , ""VRRPv%u, %s"" , version , type_s ) ) ; if ( ttl != 255 ) ND_PRINT ( ( ndo , "", (ttl %u)"" , ttl ) ) ; if ( version < 2 || version > 3 || type != VRRP_TYPE_ADVERTISEMENT ) return ; ND_TCHECK ( bp [ 2 ] ) ; ND_PRINT ( ( ndo , "", vrid %u, prio %u"" , bp [ 1 ] , bp [ 2 ] ) ) ; ND_TCHECK ( bp [ 5 ] ) ; if ( version == 2 ) { auth_type = bp [ 4 ] ; ND_PRINT ( ( ndo , "", authtype %s"" , tok2str ( auth2str , NULL , auth_type ) ) ) ; ND_PRINT ( ( ndo , "", intvl %us, length %u"" , bp [ 5 ] , len ) ) ; } else { uint16_t intvl = ( bp [ 4 ] & 0x0f ) << 8 | bp [ 5 ] ; ND_PRINT ( ( ndo , "", intvl %ucs, length %u"" , intvl , len ) ) ; } if ( ndo -> ndo_vflag ) { int naddrs = bp [ 3 ] ; int i ; char c ; if ( version == 2 && ( ND_TTEST2 ( bp [ 0 ] , len ) && len-6 > 0) ) { struct cksum_vec vec [ 1 ] ; vec [ 0 ] . ptr = bp ; vec [ 0 ] . len = len ; if ( in_cksum ( vec , 1 ) ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } if ( version == 3 && ( ND_TTEST2 ( bp [ 0 ] , len ) && len-6 > 0) ) { uint16_t cksum = nextproto4_cksum ( ndo , ( const struct ip * ) bp2 , bp , len , len , IPPROTO_VRRP ) ; if ( cksum ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } ND_PRINT ( ( ndo , "", addrs"" ) ) ; if ( naddrs > 1 ) ND_PRINT ( ( ndo , ""(%d)"" , naddrs ) ) ; ND_PRINT ( ( ndo , "":"" ) ) ; c = ' ' ; bp += 8 ; for ( i = 0 ; i < naddrs ; i ++ ) { ND_TCHECK_LEN (bp, 4); ND_PRINT ( ( ndo , ""%c%s"" , c , ipaddr_string ( ndo , bp ) ) ) ; c = ',' ; bp += 4 ; } if ( version == 2 && auth_type == VRRP_AUTH_SIMPLE ) { ND_TCHECK_LEN ( bp , 8 ) ; ND_PRINT ( ( ndo , "" auth \\"""" ) ) ; if ( fn_printn ( ndo , bp , 8 , ndo -> ndo_snapend ) ) { ND_PRINT ( ( ndo , ""\\"""" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""\\"""" ) ) ; } } return ; trunc : ND_PRINT ( ( ndo , ""[|vrrp]"" ) ) ; }",951,-32.93851119828963,-0.03463565846297543
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
void vrrp_print ( netdissect_options * ndo , register const u_char * bp , register u_int len , register const u_char * bp2 , int ttl ) { int version , type , auth_type = VRRP_AUTH_NONE ; const char * type_s ; ND_TCHECK ( bp [ 0 ] ) ; version = ( bp [ 0 ] & 0xf0 ) >> 4 ; type = bp [ 0 ] & 0x0f ; type_s = tok2str ( type2str , ""unknown type (%u)"" , type ) ; ND_PRINT ( ( ndo , ""VRRPv%u, %s"" , version , type_s ) ) ; if ( ttl != 255 ) ND_PRINT ( ( ndo , "", (ttl %u)"" , ttl ) ) ; if ( version < 2 || version > 3 || type != VRRP_TYPE_ADVERTISEMENT ) return ; ND_TCHECK ( bp [ 2 ] ) ; ND_PRINT ( ( ndo , "", vrid %u, prio %u"" , bp [ 1 ] , bp [ 2 ] ) ) ; ND_TCHECK ( bp [ 5 ] ) ; if ( version == 2 ) { auth_type = bp [ 4 ] ; ND_PRINT ( ( ndo , "", authtype %s"" , tok2str ( auth2str , NULL , auth_type ) ) ) ; ND_PRINT ( ( ndo , "", intvl %us, length %u"" , bp [ 5 ] , len ) ) ; } else { uint16_t intvl = ( bp [ 4 ] & 0x0f ) << 8 | bp [ 5 ] ; ND_PRINT ( ( ndo , "", intvl %ucs, length %u"" , intvl , len ) ) ; } if ( ndo -> ndo_vflag ) { int naddrs = bp [ 3 ] ; int i ; char c ; if ( version == 2 && ND_TTEST2 ( bp [ 0 ] , len ) ) { struct cksum_vec vec [ 1 ] ; vec [ 0 ] . ptr = bp ; vec [ 0 ] . len = len ; if ( in_cksum ( vec , 1 ) ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } if ( version == 3 && ND_TTEST2 ( bp [ 0 ] , len ) ) { uint16_t cksum = nextproto4_cksum ( ndo , ( const struct ip * ) bp2 , bp , len , len , IPPROTO_VRRP ) ; if ( cksum ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } ND_PRINT ( ( ndo , "", addrs"" ) ) ; if ( naddrs > 1 ) ND_PRINT ( ( ndo , ""(%d)"" , naddrs ) ) ; ND_PRINT ( ( ndo , "":"" ) ) ; c = ' ' ; bp += 8 ; for ( i = 0 ; i < naddrs ; i ++ ) { ND_TCHECK ( bp [ 3 ] ) ; ND_PRINT ( ( ndo , ""%c%s"" , c , ipaddr_string ( ndo , bp ) ) ) ; c = ',' ; bp += 4 ; } if ( version == 2 && auth_type == VRRP_AUTH_SIMPLE ) { ND_TCHECK ( bp [ 7 ] ) ; ND_PRINT ( ( ndo , "" auth \\"""" ) ) ; if ( fn_printn ( ndo , bp , 8 , ndo -> ndo_snapend ) ) { ND_PRINT ( ( ndo , ""\\"""" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""\\"""" ) ) ; } } return ; trunc : ND_PRINT ( ( ndo , ""[|vrrp]"" ) ) ; }
Fixed code:","
void vrrp_print ( netdissect_options * ndo , register const u_char * bp , register u_int len , register const u_char * bp2 , int ttl ) { int version , type , auth_type = VRRP_AUTH_NONE ; const char * type_s ; ND_TCHECK ( bp [ 0 ] ) ; version = ( bp [ 0 ] & 0xf0 ) >> 4 ; type = bp [ 0 ] & 0x0f ; type_s = tok2str ( type2str , ""unknown type (%u)"" , type ) ; ND_PRINT ( ( ndo , ""VRRPv%u, %s"" , version , type_s ) ) ; if ( ttl != 255 ) ND_PRINT ( ( ndo , "", (ttl %u)"" , ttl ) ) ; if ( version < 2 || version > 3 || type != VRRP_TYPE_ADVERTISEMENT ) return ; ND_TCHECK ( bp [ 2 ] ) ; ND_PRINT ( ( ndo , "", vrid %u, prio %u"" , bp [ 1 ] , bp [ 2 ] ) ) ; ND_TCHECK ( bp [ 5 ] ) ; if ( version == 2 ) { auth_type = bp [ 4 ] ; ND_PRINT ( ( ndo , "", authtype %s"" , tok2str ( auth2str , NULL , auth_type ) ) ) ; ND_PRINT ( ( ndo , "", intvl %us, length %u"" , bp [ 5 ] , len ) ) ; } else { uint16_t intvl = ( bp [ 4 ] & 0x0f ) << 8 | bp [ 5 ] ; ND_PRINT ( ( ndo , "", intvl %ucs, length %u"" , intvl , len ) ) ; } if ( ndo -> ndo_vflag ) { int naddrs = bp [ 3 ] ; int i ; char c ; if ( version == 2 && ( len < 8 || ! ND_TTEST2 ( bp [ 0 ] , len ) ) ) { ND_PRINT ( ( ndo , ""[|vrrp]"" ) ) ; return; } if ( version == 3 && ( len < 8 || ! ND_TTEST2 ( bp [ 0 ] , len ) ) ) { ND_PRINT ( ( ndo , ""[|vrrp]"" ) ) ; return; } if ( version == 2 ) { struct cksum_vec vec [ 1 ] ; vec [ 0 ] . ptr = bp ; vec [ 0 ] . len = len ; if ( in_cksum ( vec , 1 ) ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } if ( version == 3 ) { uint16_t cksum = nextproto4_cksum ( ndo , ( const struct ip * ) bp2 , bp , len , len , IPPROTO_VRRP ) ; if ( cksum ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } ND_PRINT ( ( ndo , "", addrs"" ) ) ; if ( naddrs > 1 ) ND_PRINT ( ( ndo , ""(%d)"" , naddrs ) ) ; ND_PRINT ( ( ndo , "":"" ) ) ; c = ' ' ; bp += 8 ; for ( i = 0 ; i < naddrs ; i ++ ) { ND_TCHECK ( bp [ 3 ] ) ; ND_PRINT ( ( ndo , ""%c%s"" , c , ipaddr_string ( ndo , bp ) ) ) ; c = ',' ; bp += 4 ; } if ( version == 2 && auth_type == VRRP_AUTH_SIMPLE ) { ND_TCHECK ( bp [ 7 ] ) ; ND_PRINT ( ( ndo , "" auth \\"""" ) ) ; if ( fn_printn ( ndo , bp , 8 , ndo -> ndo_snapend ) ) { ND_PRINT ( ( ndo , ""\\"""" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""\\"""" ) ) ; } } return ; trunc : ND_PRINT ( ( ndo , ""[|vrrp]"" )",1000,-19.258360403269847,-0.019258360403269847
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
void vrrp_print ( netdissect_options * ndo , register const u_char * bp , register u_int len , register const u_char * bp2 , int ttl ) { int version , type , auth_type = VRRP_AUTH_NONE ; const char * type_s ; ND_TCHECK ( bp [ 0 ] ) ; version = ( bp [ 0 ] & 0xf0 ) >> 4 ; type = bp [ 0 ] & 0x0f ; type_s = tok2str ( type2str , ""unknown type (%u)"" , type ) ; ND_PRINT ( ( ndo , ""VRRPv%u, %s"" , version , type_s ) ) ; if ( ttl != 255 ) ND_PRINT ( ( ndo , "", (ttl %u)"" , ttl ) ) ; if ( version < 2 || version > 3 || type != VRRP_TYPE_ADVERTISEMENT ) return ; ND_TCHECK ( bp [ 2 ] ) ; ND_PRINT ( ( ndo , "", vrid %u, prio %u"" , bp [ 1 ] , bp [ 2 ] ) ) ; ND_TCHECK ( bp [ 5 ] ) ; if ( version == 2 ) { auth_type = bp [ 4 ] ; ND_PRINT ( ( ndo , "", authtype %s"" , tok2str ( auth2str , NULL , auth_type ) ) ) ; ND_PRINT ( ( ndo , "", intvl %us, length %u"" , bp [ 5 ] , len ) ) ; } else { uint16_t intvl = ( bp [ 4 ] & 0x0f ) << 8 | bp [ 5 ] ; ND_PRINT ( ( ndo , "", intvl %ucs, length %u"" , intvl , len ) ) ; } if ( ndo -> ndo_vflag ) { int naddrs = bp [ 3 ] ; int i ; char c ; if ( version == 2 && ND_TTEST2 ( bp [ 0 ] , len ) ) { struct cksum_vec vec [ 1 ] ; vec [ 0 ] . ptr = bp ; vec [ 0 ] . len = len ; if ( in_cksum ( vec , 1 ) ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } if ( version == 3 && ND_TTEST2 ( bp [ 0 ] , len ) ) { uint16_t cksum = nextproto4_cksum ( ndo , ( const struct ip * ) bp2 , bp , len , len , IPPROTO_VRRP ) ; if ( cksum ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } ND_PRINT ( ( ndo , "", addrs"" ) ) ; if ( naddrs > 1 ) ND_PRINT ( ( ndo , ""(%d)"" , naddrs ) ) ; ND_PRINT ( ( ndo , "":"" ) ) ; c = ' ' ; bp += 8 ; for ( i = 0 ; i < naddrs ; i ++ ) { ND_TCHECK ( bp [ 3 ] ) ; ND_PRINT ( ( ndo , ""%c%s"" , c , ipaddr_string ( ndo , bp ) ) ) ; c = ',' ; bp += 4 ; } if ( version == 2 && auth_type == VRRP_AUTH_SIMPLE ) { ND_TCHECK ( bp [ 7 ] ) ; ND_PRINT ( ( ndo , "" auth \\"""" ) ) ; if ( fn_printn ( ndo , bp , 8 , ndo -> ndo_snapend ) ) { ND_PRINT ( ( ndo , ""\\"""" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""\\"""" ) ) ; } } return ; trunc : ND_PRINT ( ( ndo , ""[|vrrp]"" ) ) ; }
Fixed code:","
void vrrp_print ( netdissect_options * ndo , register const u_char * bp , register u_int len , register const u_char * bp2 , int ttl ) { int version , type , auth_type = VRRP_AUTH_NONE ; const char * type_s ; if (len < 8) { ND_PRINT((ndo, ""[|vrrp]"")) ; return ; } ND_TCHECK ( bp [ 0 ] ) ; version = ( bp [ 0 ] & 0xf0 ) >> 4 ; type = bp [ 0 ] & 0x0f ; type_s = tok2str ( type2str , ""unknown type (%u)"" , type ) ; ND_PRINT ( ( ndo , ""VRRPv%u, %s"" , version , type_s ) ) ; if ( ttl != 255 ) ND_PRINT ( ( ndo , "", (ttl %u)"" , ttl ) ) ; if ( version < 2 || version > 3 || type != VRRP_TYPE_ADVERTISEMENT ) return ; ND_TCHECK ( bp [ 2 ] ) ; ND_PRINT ( ( ndo , "", vrid %u, prio %u"" , bp [ 1 ] , bp [ 2 ] ) ) ; ND_TCHECK ( bp [ 5 ] ) ; if ( version == 2 ) { auth_type = bp [ 4 ] ; ND_PRINT ( ( ndo , "", authtype %s"" , tok2str ( auth2str , NULL , auth_type ) ) ) ; ND_PRINT ( ( ndo , "", intvl %us, length %u"" , bp [ 5 ] , len ) ) ; } else { uint16_t intvl = ( bp [ 4 ] & 0x0f ) << 8 | bp [ 5 ] ; ND_PRINT ( ( ndo , "", intvl %ucs, length %u"" , intvl , len ) ) ; } if ( ndo -> ndo_vflag ) { int naddrs = bp [ 3 ] ; int i ; char c ; if ( version == 2 && ND_TTEST2 ( bp [ 0 ] , len ) ) { struct cksum_vec vec [ 1 ] ; vec [ 0 ] . ptr = bp ; vec [ 0 ] . len = len ; if ( in_cksum ( vec , 1 ) ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } if ( version == 3 && ND_TTEST2 ( bp [ 0 ] , len ) ) { uint16_t cksum = nextproto4_cksum ( ndo , ( const struct ip * ) bp2 , bp , len , len , IPPROTO_VRRP ) ; if ( cksum ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } ND_PRINT ( ( ndo , "", addrs"" ) ) ; if ( naddrs > 1 ) ND_PRINT ( ( ndo , ""(%d)"" , naddrs ) ) ; ND_PRINT ( ( ndo , "":"" ) ) ; c = ' ' ; bp += 8 ; for ( i = 0 ; i < naddrs ; i ++ ) { ND_TCHECK ( bp [ 3 ] ) ; ND_PRINT ( ( ndo , ""%c%s"" , c , ipaddr_string ( ndo , bp ) ) ) ; c = ',' ; bp += 4 ; } if ( version == 2 && auth_type == VRRP_AUTH_SIMPLE ) { ND_TCHECK ( bp [ 7 ] ) ; ND_PRINT ( ( ndo , "" auth \\"""" ) ) ; if ( fn_printn ( ndo , bp , 8 , ndo -> ndo_snapend ) ) { ND_PRINT ( ( ndo , ""\\"""" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""\\"""" ) ) ; } } return ; trunc : ND_PRINT ( ( ndo , ""[|vrrp]"" ) ) ; }",959,-10.199610438113845,-0.010635673032444051
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
void vrrp_print ( netdissect_options * ndo , register const u_char * bp , register u_int len , register const u_char * bp2 , int ttl ) { int version , type , auth_type = VRRP_AUTH_NONE ; const char * type_s ; ND_TCHECK ( bp [ 0 ] ) ; version = ( bp [ 0 ] & 0xf0 ) >> 4 ; type = bp [ 0 ] & 0x0f ; type_s = tok2str ( type2str , ""unknown type (%u)"" , type ) ; ND_PRINT ( ( ndo , ""VRRPv%u, %s"" , version , type_s ) ) ; if ( ttl != 255 ) ND_PRINT ( ( ndo , "", (ttl %u)"" , ttl ) ) ; if ( version < 2 || version > 3 || type != VRRP_TYPE_ADVERTISEMENT ) return ; ND_TCHECK ( bp [ 2 ] ) ; ND_PRINT ( ( ndo , "", vrid %u, prio %u"" , bp [ 1 ] , bp [ 2 ] ) ) ; ND_TCHECK ( bp [ 5 ] ) ; if ( version == 2 ) { auth_type = bp [ 4 ] ; ND_PRINT ( ( ndo , "", authtype %s"" , tok2str ( auth2str , NULL , auth_type ) ) ) ; ND_PRINT ( ( ndo , "", intvl %us, length %u"" , bp [ 5 ] , len ) ) ; } else { uint16_t intvl = ( bp [ 4 ] & 0x0f ) << 8 | bp [ 5 ] ; ND_PRINT ( ( ndo , "", intvl %ucs, length %u"" , intvl , len ) ) ; } if ( ndo -> ndo_vflag ) { int naddrs = bp [ 3 ] ; int i ; char c ; if ( version == 2 && ND_TTEST2 ( bp [ 0 ] , len ) ) { struct cksum_vec vec [ 1 ] ; vec [ 0 ] . ptr = bp ; vec [ 0 ] . len = len ; if ( in_cksum ( vec , 1 ) ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } if ( version == 3 && ND_TTEST2 ( bp [ 0 ] , len ) ) { uint16_t cksum = nextproto4_cksum ( ndo , ( const struct ip * ) bp2 , bp , len , len , IPPROTO_VRRP ) ; if ( cksum ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } ND_PRINT ( ( ndo , "", addrs"" ) ) ; if ( naddrs > 1 ) ND_PRINT ( ( ndo , ""(%d)"" , naddrs ) ) ; ND_PRINT ( ( ndo , "":"" ) ) ; c = ' ' ; bp += 8 ; for ( i = 0 ; i < naddrs ; i ++ ) { ND_TCHECK ( bp [ 3 ] ) ; ND_PRINT ( ( ndo , ""%c%s"" , c , ipaddr_string ( ndo , bp ) ) ) ; c = ',' ; bp += 4 ; } if ( version == 2 && auth_type == VRRP_AUTH_SIMPLE ) { ND_TCHECK ( bp [ 7 ] ) ; ND_PRINT ( ( ndo , "" auth \\"""" ) ) ; if ( fn_printn ( ndo , bp , 8 , ndo -> ndo_snapend ) ) { ND_PRINT ( ( ndo , ""\\"""" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""\\"""" ) ) ; } } return ; trunc : ND_PRINT ( ( ndo , ""[|vrrp]"" ) ) ; }
Fixed code:","
void vrrp_print ( netdissect_options * ndo , register const u_char * bp , register u_int len , register const u_char * bp2 , int ttl ) { int version , type , auth_type = VRRP_AUTH_NONE ; const char * type_s ; ND_TCHECK ( bp [ 0 ] ) ; version = ( bp [ 0 ] & 0xf0 ) >> 4 ; type = bp [ 0 ] & 0x0f ; type_s = tok2str ( type2str , ""unknown type (%u)"" , type ) ; ND_PRINT ( ( ndo , ""VRRPv%u, %s"" , version , type_s ) ) ; if ( ttl != 255 ) ND_PRINT ( ( ndo , "", (ttl %u)"" , ttl ) ) ; if ( version < 2 || version > 3 || type != VRRP_TYPE_ADVERTISEMENT ) return ; ND_TCHECK ( bp [ 2 ] ) ; ND_PRINT ( ( ndo , "", vrid %u, prio %u"" , bp [ 1 ] , bp [ 2 ] ) ) ; ND_TCHECK ( bp [ 5 ] ) ; if ( version == 2 ) { auth_type = bp [ 4 ] ; ND_PRINT ( ( ndo , "", authtype %s"" , tok2str ( auth2str , NULL , auth_type ) ) ) ; ND_PRINT ( ( ndo , "", intvl %us, length %u"" , bp [ 5 ] , len ) ) ; } else { uint16_t intvl = ( bp [ 4 ] & 0x0f ) << 8 | bp [ 5 ] ; ND_PRINT ( ( ndo , "", intvl %ucs, length %u"" , intvl , len ) ) ; } if ( ndo -> ndo_vflag ) { int naddrs = bp [ 3 ] ; int i ; char c ; if ( version == 2 && ND_TTEST2 ( bp [ 0 ] , len ) ) { struct cksum_vec vec [ 1 ] ; vec [ 0 ] . ptr = bp ; vec [ 0 ] . len = len ; if ( naddrs * 4 + 8 > len ) { ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } else if ( in_cksum ( vec , 1 ) ) { ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } } if ( version == 3 && ND_TTEST2 ( bp [ 0 ] , len ) ) { uint16_t cksum = nextproto4_cksum ( ndo , ( const struct ip * ) bp2 , bp , len , len , IPPROTO_VRRP ) ; if ( cksum ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } ND_PRINT ( ( ndo , "", addrs"" ) ) ; if ( naddrs > 1 ) ND_PRINT ( ( ndo , ""(%d)"" , naddrs ) ) ; ND_PRINT ( ( ndo , "":"" ) ) ; c = ' ' ; bp += 8 ; for ( i = 0 ; i < naddrs ; i ++ ) { ND_TCHECK ( bp [ 3 ] ) ; ND_PRINT ( ( ndo , ""%c%s"" , c , ipaddr_string ( ndo , bp ) ) ) ; c = ',' ; bp += 4 ; } if ( version == 2 && auth_type == VRRP_AUTH_SIMPLE ) { ND_TCHECK ( bp [ 7 ] ) ; ND_PRINT ( ( ndo , "" auth \\"""" ) ) ; if ( fn_printn ( ndo , bp , 8 , ndo -> ndo_snapend ) ) { ND_PRINT ( ( ndo , ""\\"""" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""\\"""" ) ) ; } } return ; trunc : ND_PRINT ( ( ndo , ""[|vrrp]"" ) ) ; }",990,-13.015423382440746,-0.013146892305495704
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
void vrrp_print ( netdissect_options * ndo , register const u_char * bp , register u_int len , register const u_char * bp2 , int ttl ) { int version , type , auth_type = VRRP_AUTH_NONE ; const char * type_s ; ND_TCHECK ( bp [ 0 ] ) ; version = ( bp [ 0 ] & 0xf0 ) >> 4 ; type = bp [ 0 ] & 0x0f ; type_s = tok2str ( type2str , ""unknown type (%u)"" , type ) ; ND_PRINT ( ( ndo , ""VRRPv%u, %s"" , version , type_s ) ) ; if ( ttl != 255 ) ND_PRINT ( ( ndo , "", (ttl %u)"" , ttl ) ) ; if ( version < 2 || version > 3 || type != VRRP_TYPE_ADVERTISEMENT ) return ; ND_TCHECK ( bp [ 2 ] ) ; ND_PRINT ( ( ndo , "", vrid %u, prio %u"" , bp [ 1 ] , bp [ 2 ] ) ) ; ND_TCHECK ( bp [ 5 ] ) ; if ( version == 2 ) { auth_type = bp [ 4 ] ; ND_PRINT ( ( ndo , "", authtype %s"" , tok2str ( auth2str , NULL , auth_type ) ) ) ; ND_PRINT ( ( ndo , "", intvl %us, length %u"" , bp [ 5 ] , len ) ) ; } else { uint16_t intvl = ( bp [ 4 ] & 0x0f ) << 8 | bp [ 5 ] ; ND_PRINT ( ( ndo , "", intvl %ucs, length %u"" , intvl , len ) ) ; } if ( ndo -> ndo_vflag ) { int naddrs = bp [ 3 ] ; int i ; char c ; if ( version == 2 && ND_TTEST2 ( bp [ 0 ] , len ) ) { struct cksum_vec vec [ 1 ] ; vec [ 0 ] . ptr = bp ; vec [ 0 ] . len = len ; if ( in_cksum ( vec , 1 ) ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } if ( version == 3 && ND_TTEST2 ( bp [ 0 ] , len ) ) { uint16_t cksum = nextproto4_cksum ( ndo , ( const struct ip * ) bp2 , bp , len , len , IPPROTO_VRRP ) ; if ( cksum ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } ND_PRINT ( ( ndo , "", addrs"" ) ) ; if ( naddrs > 1 ) ND_PRINT ( ( ndo , ""(%d)"" , naddrs ) ) ; ND_PRINT ( ( ndo , "":"" ) ) ; c = ' ' ; bp += 8 ; for ( i = 0 ; i < naddrs ; i ++ ) { ND_TCHECK ( bp [ 3 ] ) ; ND_PRINT ( ( ndo , ""%c%s"" , c , ipaddr_string ( ndo , bp ) ) ) ; c = ',' ; bp += 4 ; } if ( version == 2 && auth_type == VRRP_AUTH_SIMPLE ) { ND_TCHECK ( bp [ 7 ] ) ; ND_PRINT ( ( ndo , "" auth \\"""" ) ) ; if ( fn_printn ( ndo , bp , 8 , ndo -> ndo_snapend ) ) { ND_PRINT ( ( ndo , ""\\"""" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""\\"""" ) ) ; } } return ; trunc : ND_PRINT ( ( ndo , ""[|vrrp]"" ) ) ; }
Fixed code:","
void vrrp_print ( netdissect_options * ndo , register const u_char * bp , register u_int len , register const u_char * bp2 , int ttl ) { int version , type , auth_type = VRRP_AUTH_NONE ; const char * type_s ; ND_TCHECK ( bp [ 0 ] ) ; version = ( bp [ 0 ] & 0xf0 ) >> 4 ; type = bp [ 0 ] & 0x0f ; type_s = tok2str ( type2str , ""unknown type (%u)"" , type ) ; ND_PRINT ( ( ndo , ""VRRPv%u, %s"" , version , type_s ) ) ; if ( ttl != 255 ) ND_PRINT ( ( ndo , "", (ttl %u)"" , ttl ) ) ; if ( version < 2 || version > 3 || type != VRRP_TYPE_ADVERTISEMENT ) return ; ND_TCHECK ( bp [ 2 ] ) ; ND_PRINT ( ( ndo , "", vrid %u, prio %u"" , bp [ 1 ] , bp [ 2 ] ) ) ; ND_TCHECK ( bp [ 5 ] ) ; if ( version == 2 ) { auth_type = bp [ 4 ] ; ND_PRINT ( ( ndo , "", authtype %s"" , tok2str ( auth2str , NULL , auth_type ) ) ) ; ND_PRINT ( ( ndo , "", intvl %us, length %u"" , bp [ 5 ] , len ) ) ; } else { uint16_t intvl = ( bp [ 4 ] & 0x0f ) << 8 | bp [ 5 ] ; ND_PRINT ( ( ndo , "", intvl %ucs, length %u"" , intvl , len ) ) ; } if ( ndo -> ndo_vflag ) { int naddrs = bp [ 3 ] ; int i ; char c ; if ( version == 2 && ND_TTEST2 ( bp [ 0 ] , len ) ) { struct cksum_vec vec [ 1 ] ; vec [ 0 ] . ptr = bp ; vec [ 0 ] . len = len ; if ( len < 8 ) { ND_PRINT ( ( ndo , "", (bad vrrp cksum)"" ) ) ; } else { if ( in_cksum ( vec , 1 ) ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } } if ( version == 3 && ND_TTEST2 ( bp [ 0 ] , len ) ) { uint16_t cksum = nextproto4_cksum ( ndo , ( const struct ip * ) bp2 , bp , len , len , IPPROTO_VRRP ) ; if ( cksum ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } ND_PRINT ( ( ndo , "", addrs"" ) ) ; if ( naddrs > 1 ) ND_PRINT ( ( ndo , ""(%d)"" , naddrs ) ) ; ND_PRINT ( ( ndo , "":"" ) ) ; c = ' ' ; bp += 8 ; for ( i = 0 ; i < naddrs ; i ++ ) { ND_TCHECK ( bp [ 3 ] ) ; ND_PRINT ( ( ndo , ""%c%s"" , c , ipaddr_string ( ndo , bp ) ) ) ; c = ',' ; bp += 4 ; } if ( version == 2 && auth_type == VRRP_AUTH_SIMPLE ) { ND_TCHECK ( bp [ 7 ] ) ; ND_PRINT ( ( ndo , "" auth \\"""" ) ) ; if ( fn_printn ( ndo , bp , 8 , ndo -> ndo_snapend ) ) { ND_PRINT ( ( ndo , ""\\"""" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""\\"""" ) ) ; } } return ; trunc : ND_PRINT ( ( ndo , ""[|vrrp]"" ) ) ; }",966,-14.062541208734551,-0.014557496075294565
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
void vrrp_print ( netdissect_options * ndo , register const u_char * bp , register u_int len , register const u_char * bp2 , int ttl ) { int version , type , auth_type = VRRP_AUTH_NONE ; const char * type_s ; ND_TCHECK ( bp [ 0 ] ) ; version = ( bp [ 0 ] & 0xf0 ) >> 4 ; type = bp [ 0 ] & 0x0f ; type_s = tok2str ( type2str , ""unknown type (%u)"" , type ) ; ND_PRINT ( ( ndo , ""VRRPv%u, %s"" , version , type_s ) ) ; if ( ttl != 255 ) ND_PRINT ( ( ndo , "", (ttl %u)"" , ttl ) ) ; if ( version < 2 || version > 3 || type != VRRP_TYPE_ADVERTISEMENT ) return ; ND_TCHECK ( bp [ 2 ] ) ; ND_PRINT ( ( ndo , "", vrid %u, prio %u"" , bp [ 1 ] , bp [ 2 ] ) ) ; ND_TCHECK ( bp [ 5 ] ) ; if ( version == 2 ) { auth_type = bp [ 4 ] ; ND_PRINT ( ( ndo , "", authtype %s"" , tok2str ( auth2str , NULL , auth_type ) ) ) ; ND_PRINT ( ( ndo , "", intvl %us, length %u"" , bp [ 5 ] , len ) ) ; } else { uint16_t intvl = ( bp [ 4 ] & 0x0f ) << 8 | bp [ 5 ] ; ND_PRINT ( ( ndo , "", intvl %ucs, length %u"" , intvl , len ) ) ; } if ( ndo -> ndo_vflag ) { int naddrs = bp [ 3 ] ; int i ; char c ; if ( version == 2 && ND_TTEST2 ( bp [ 0 ] , len ) ) { struct cksum_vec vec [ 1 ] ; vec [ 0 ] . ptr = bp ; vec [ 0 ] . len = len ; if ( in_cksum ( vec , 1 ) ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } if ( version == 3 && ND_TTEST2 ( bp [ 0 ] , len ) ) { uint16_t cksum = nextproto4_cksum ( ndo , ( const struct ip * ) bp2 , bp , len , len , IPPROTO_VRRP ) ; if ( cksum ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } ND_PRINT ( ( ndo , "", addrs"" ) ) ; if ( naddrs > 1 ) ND_PRINT ( ( ndo , ""(%d)"" , naddrs ) ) ; ND_PRINT ( ( ndo , "":"" ) ) ; c = ' ' ; bp += 8 ; for ( i = 0 ; i < naddrs ; i ++ ) { ND_TCHECK ( bp [ 3 ] ) ; ND_PRINT ( ( ndo , ""%c%s"" , c , ipaddr_string ( ndo , bp ) ) ) ; c = ',' ; bp += 4 ; } if ( version == 2 && auth_type == VRRP_AUTH_SIMPLE ) { ND_TCHECK ( bp [ 7 ] ) ; ND_PRINT ( ( ndo , "" auth \\"""" ) ) ; if ( fn_printn ( ndo , bp , 8 , ndo -> ndo_snapend ) ) { ND_PRINT ( ( ndo , ""\\"""" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""\\"""" ) ) ; } } return ; trunc : ND_PRINT ( ( ndo , ""[|vrrp]"" ) ) ; }
Fixed code:","

void vrrp_print ( netdissect_options * ndo , register const u_char * bp , register u_int len , register const u_char * bp2 , int ttl ) { int version , type , auth_type = VRRP_AUTH_NONE ; const char * type_s ; if ( len < 8 ) { ND_PRINT ( ( ndo , ""[|vrrp]"" ) ) ; return ; } ND_TCHECK ( bp [ 0 ] ) ; version = ( bp [ 0 ] & 0xf0 ) >> 4 ; type = bp [ 0 ] & 0x0f ; type_s = tok2str ( type2str , ""unknown type (%u)"" , type ) ; ND_PRINT ( ( ndo , ""VRRPv%u, %s"" , version , type_s ) ) ; if ( ttl != 255 ) ND_PRINT ( ( ndo , "", (ttl %u)"" , ttl ) ) ; if ( version < 2 || version > 3 || type != VRRP_TYPE_ADVERTISEMENT ) return ; ND_TCHECK ( bp [ 2 ] ) ; ND_PRINT ( ( ndo , "", vrid %u, prio %u"" , bp [ 1 ] , bp [ 2 ] ) ) ; ND_TCHECK ( bp [ 5 ] ) ; if ( version == 2 ) { auth_type = bp [ 4 ] ; ND_PRINT ( ( ndo , "", authtype %s"" , tok2str ( auth2str , NULL , auth_type ) ) ) ; ND_PRINT ( ( ndo , "", intvl %us, length %u"" , bp [ 5 ] , len ) ) ; } else { uint16_t intvl = ( bp [ 4 ] & 0x0f ) << 8 | bp [ 5 ] ; ND_PRINT ( ( ndo , "", intvl %ucs, length %u"" , intvl , len ) ) ; } if ( ndo -> ndo_vflag ) { int naddrs = bp [ 3 ] ; int i ; char c ; if ( version == 2 && ND_TTEST2 ( bp [ 0 ] , len ) ) { struct cksum_vec vec [ 1 ] ; vec [ 0 ] . ptr = bp ; vec [ 0 ] . len = len ; if ( in_cksum ( vec , 1 ) ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } if ( version == 3 && ND_TTEST2 ( bp [ 0 ] , len ) ) { uint16_t cksum = nextproto4_cksum ( ndo , ( const struct ip * ) bp2 , bp , len , len , IPPROTO_VRRP ) ; if ( cksum ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } ND_PRINT ( ( ndo , "", addrs"" ) ) ; if ( naddrs > 1 ) ND_PRINT ( ( ndo , ""(%d)"" , naddrs ) ) ; ND_PRINT ( ( ndo , "":"" ) ) ; c = ' ' ; bp += 8 ; for ( i = 0 ; i < naddrs ; i ++ ) { ND_TCHECK ( bp [ 3 ] ) ; ND_PRINT ( ( ndo , ""%c%s"" , c , ipaddr_string ( ndo , bp ) ) ) ; c = ',' ; bp += 4 ; } if ( version == 2 && auth_type == VRRP_AUTH_SIMPLE ) { ND_TCHECK ( bp [ 7 ] ) ; ND_PRINT ( ( ndo , "" auth \\"""" ) ) ; if ( fn_printn ( ndo , bp , 8 , ndo -> ndo_snapend ) ) { ND_PRINT ( ( ndo , ""\\"""" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""\\"""" ) ) ; } } return ; trunc : ND_PRINT ( ( ndo , ""[|vrrp]"" ) ) ; }",962,-11.682731373359086,-0.012144211406818177
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
void vrrp_print ( netdissect_options * ndo , register const u_char * bp , register u_int len , register const u_char * bp2 , int ttl ) { int version , type , auth_type = VRRP_AUTH_NONE ; const char * type_s ; ND_TCHECK ( bp [ 0 ] ) ; version = ( bp [ 0 ] & 0xf0 ) >> 4 ; type = bp [ 0 ] & 0x0f ; type_s = tok2str ( type2str , ""unknown type (%u)"" , type ) ; ND_PRINT ( ( ndo , ""VRRPv%u, %s"" , version , type_s ) ) ; if ( ttl != 255 ) ND_PRINT ( ( ndo , "", (ttl %u)"" , ttl ) ) ; if ( version < 2 || version > 3 || type != VRRP_TYPE_ADVERTISEMENT ) return ; ND_TCHECK ( bp [ 2 ] ) ; ND_PRINT ( ( ndo , "", vrid %u, prio %u"" , bp [ 1 ] , bp [ 2 ] ) ) ; ND_TCHECK ( bp [ 5 ] ) ; if ( version == 2 ) { auth_type = bp [ 4 ] ; ND_PRINT ( ( ndo , "", authtype %s"" , tok2str ( auth2str , NULL , auth_type ) ) ) ; ND_PRINT ( ( ndo , "", intvl %us, length %u"" , bp [ 5 ] , len ) ) ; } else { uint16_t intvl = ( bp [ 4 ] & 0x0f ) << 8 | bp [ 5 ] ; ND_PRINT ( ( ndo , "", intvl %ucs, length %u"" , intvl , len ) ) ; } if ( ndo -> ndo_vflag ) { int naddrs = bp [ 3 ] ; int i ; char c ; if ( version == 2 && ND_TTEST2 ( bp [ 0 ] , len ) ) { struct cksum_vec vec [ 1 ] ; vec [ 0 ] . ptr = bp ; vec [ 0 ] . len = len ; if ( in_cksum ( vec , 1 ) ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } if ( version == 3 && ND_TTEST2 ( bp [ 0 ] , len ) ) { uint16_t cksum = nextproto4_cksum ( ndo , ( const struct ip * ) bp2 , bp , len , len , IPPROTO_VRRP ) ; if ( cksum ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } ND_PRINT ( ( ndo , "", addrs"" ) ) ; if ( naddrs > 1 ) ND_PRINT ( ( ndo , ""(%d)"" , naddrs ) ) ; ND_PRINT ( ( ndo , "":"" ) ) ; c = ' ' ; bp += 8 ; for ( i = 0 ; i < naddrs ; i ++ ) { ND_TCHECK ( bp [ 3 ] ) ; ND_PRINT ( ( ndo , ""%c%s"" , c , ipaddr_string ( ndo , bp ) ) ) ; c = ',' ; bp += 4 ; } if ( version == 2 && auth_type == VRRP_AUTH_SIMPLE ) { ND_TCHECK ( bp [ 7 ] ) ; ND_PRINT ( ( ndo , "" auth \\"""" ) ) ; if ( fn_printn ( ndo , bp , 8 , ndo -> ndo_snapend ) ) { ND_PRINT ( ( ndo , ""\\"""" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""\\"""" ) ) ; } } return ; trunc : ND_PRINT ( ( ndo , ""[|vrrp]"" ) ) ; }
Fixed code:","
void vrrp_print ( netdissect_options * ndo , register const u_char * bp , register u_int len , register const u_char * bp2 , int ttl ) { int version , type , auth_type = VRRP_AUTH_NONE ; const char * type_s ; ND_TCHECK ( bp [ 0 ] ) ; version = ( bp [ 0 ] & 0xf0 ) >> 4 ; type = bp [ 0 ] & 0x0f ; type_s = tok2str ( type2str , ""unknown type (%u)"" , type ) ; ND_PRINT ( ( ndo , ""VRRPv%u, %s"" , version , type_s ) ) ; if ( ttl != 255 ) ND_PRINT ( ( ndo , "", (ttl %u)"" , ttl ) ) ; if ( version < 2 || version > 3 || type != VRRP_TYPE_ADVERTISEMENT ) return ; ND_TCHECK ( bp [ 2 ] ) ; ND_PRINT ( ( ndo , "", vrid %u, prio %u"" , bp [ 1 ] , bp [ 2 ] ) ) ; ND_TCHECK ( bp [ 5 ] ) ; if ( version == 2 ) { auth_type = bp [ 4 ] ; ND_PRINT ( ( ndo , "", authtype %s"" , tok2str ( auth2str , NULL , auth_type ) ) ) ; ND_PRINT ( ( ndo , "", intvl %us, length %u"" , bp [ 5 ] , len ) ) ; } else { uint16_t intvl = ( bp [ 4 ] & 0x0f ) << 8 | bp [ 5 ] ; ND_PRINT ( ( ndo , "", intvl %ucs, length %u"" , intvl , len ) ) ; } if ( ndo -> ndo_vflag ) { int naddrs = bp [ 3 ] ; int i ; char c ; if ( version == 2 && ND_TTEST2 ( bp [ 0 ] , len ) ) { struct cksum_vec vec [ 1 ] ; vec [ 0 ] . ptr = bp ; vec [ 0 ] . len = len ; if ( in_cksum ( vec , 1 ) ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } if ( version == 3 && ND_TTEST2 ( bp [ 0 ] , len ) ) { uint16_t cksum = nextproto4_cksum ( ndo , ( const struct ip * ) bp2 , bp , len , len , IPPROTO_VRRP ) ; if ( cksum ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } ND_PRINT ( ( ndo , "", addrs"" ) ) ; if ( naddrs > 1 ) ND_PRINT ( ( ndo , ""(%d)"" , naddrs ) ) ; ND_PRINT ( ( ndo , "":"" ) ) ; c = ' ' ; bp += 8 ; for ( i = 0 ; i < naddrs && i < (len - 8) / 4; i ++ ) { ND_TCHECK ( bp [ 3 ] ) ; ND_PRINT ( ( ndo , ""%c%s"" , c , ipaddr_string ( ndo , bp ) ) ) ; c = ',' ; bp += 4 ; } if ( version == 2 && auth_type == VRRP_AUTH_SIMPLE ) { ND_TCHECK ( bp [ 7 ] ) ; ND_PRINT ( ( ndo , "" auth \\"""" ) ) ; if ( fn_printn ( ndo , bp , 8 , ndo -> ndo_snapend ) ) { ND_PRINT ( ( ndo , ""\\"""" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""\\"""" ) ) ; } } return ; trunc : ND_PRINT ( ( ndo , ""[|vrrp]"" ) ) ; }",943,-12.53618511673334,-0.013293939678402268
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
void vrrp_print ( netdissect_options * ndo , register const u_char * bp , register u_int len , register const u_char * bp2 , int ttl ) { int version , type , auth_type = VRRP_AUTH_NONE ; const char * type_s ; ND_TCHECK ( bp [ 0 ] ) ; version = ( bp [ 0 ] & 0xf0 ) >> 4 ; type = bp [ 0 ] & 0x0f ; type_s = tok2str ( type2str , ""unknown type (%u)"" , type ) ; ND_PRINT ( ( ndo , ""VRRPv%u, %s"" , version , type_s ) ) ; if ( ttl != 255 ) ND_PRINT ( ( ndo , "", (ttl %u)"" , ttl ) ) ; if ( version < 2 || version > 3 || type != VRRP_TYPE_ADVERTISEMENT ) return ; ND_TCHECK ( bp [ 2 ] ) ; ND_PRINT ( ( ndo , "", vrid %u, prio %u"" , bp [ 1 ] , bp [ 2 ] ) ) ; ND_TCHECK ( bp [ 5 ] ) ; if ( version == 2 ) { auth_type = bp [ 4 ] ; ND_PRINT ( ( ndo , "", authtype %s"" , tok2str ( auth2str , NULL , auth_type ) ) ) ; ND_PRINT ( ( ndo , "", intvl %us, length %u"" , bp [ 5 ] , len ) ) ; } else { uint16_t intvl = ( bp [ 4 ] & 0x0f ) << 8 | bp [ 5 ] ; ND_PRINT ( ( ndo , "", intvl %ucs, length %u"" , intvl , len ) ) ; } if ( ndo -> ndo_vflag ) { int naddrs = bp [ 3 ] ; int i ; char c ; if ( version == 2 && ND_TTEST2 ( bp [ 0 ] , len ) ) { struct cksum_vec vec [ 1 ] ; vec [ 0 ] . ptr = bp ; vec [ 0 ] . len = len ; if ( in_cksum ( vec , 1 ) ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } if ( version == 3 && ND_TTEST2 ( bp [ 0 ] , len ) ) { uint16_t cksum = nextproto4_cksum ( ndo , ( const struct ip * ) bp2 , bp , len , len , IPPROTO_VRRP ) ; if ( cksum ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } ND_PRINT ( ( ndo , "", addrs"" ) ) ; if ( naddrs > 1 ) ND_PRINT ( ( ndo , ""(%d)"" , naddrs ) ) ; ND_PRINT ( ( ndo , "":"" ) ) ; c = ' ' ; bp += 8 ; for ( i = 0 ; i < naddrs ; i ++ ) { ND_TCHECK ( bp [ 3 ] ) ; ND_PRINT ( ( ndo , ""%c%s"" , c , ipaddr_string ( ndo , bp ) ) ) ; c = ',' ; bp += 4 ; } if ( version == 2 && auth_type == VRRP_AUTH_SIMPLE ) { ND_TCHECK ( bp [ 7 ] ) ; ND_PRINT ( ( ndo , "" auth \\"""" ) ) ; if ( fn_printn ( ndo , bp , 8 , ndo -> ndo_snapend ) ) { ND_PRINT ( ( ndo , ""\\"""" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""\\"""" ) ) ; } } return ; trunc : ND_PRINT ( ( ndo , ""[|vrrp]"" ) ) ; }
Fixed code:"," 
void vrrp_print ( netdissect_options * ndo , register const u_char * bp , register u_int len , register const u_char * bp2 , int ttl ) { 
    int version , type , auth_type = VRRP_AUTH_NONE ; 
    const char * type_s ; 
    int fixed_len = len > 8 ? 8 : len;
    ND_TCHECK ( bp [ 0 ] ) ; 
    version = ( bp [ 0 ] & 0xf0 ) >> 4 ; 
    type = bp [ 0 ] & 0x0f ; 
    type_s = tok2str ( type2str , ""unknown type (%u)"" , type ) ; 
    ND_PRINT ( ( ndo , ""VRRPv%u, %s"" , version , type_s ) ) ; 
    if ( ttl != 255 ) ND_PRINT ( ( ndo , "", (ttl %u)"" , ttl ) ) ; 
    if ( version < 2 || version > 3 || type != VRRP_TYPE_ADVERTISEMENT ) return ; 
    ND_TCHECK ( bp [ 2 ] ) ; 
    ND_PRINT ( ( ndo , "", vrid %u, prio %u"" , bp [ 1 ] , bp [ 2 ] ) ) ; 
    ND_TCHECK ( bp [ 5 ] ) ; 
    if ( version == 2 ) { 
        auth_type = bp [ 4 ] ; 
        ND_PRINT ( ( ndo , "", authtype %s"" , tok2str ( auth2str , NULL , auth_type ) ) ) ; 
        ND_PRINT ( ( ndo , "", intvl %us, length %u"" , bp [ 5 ] , len ) ) ; 
    } else { 
        uint16_t intvl = ( bp [ 4 ] & 0x0f ) << 8 | bp [ 5 ] ; 
        ND_PRINT ( ( ndo , "", intvl %ucs, length %u"" , intvl , len ) ) ; 
    } 
    if ( ndo -> ndo_vflag ) { 
        int naddrs = bp [ 3 ] ; 
        int i ; 
        char c ; 
        if ( version == 2 && ND_TTEST2 ( bp [ 0 ] , fixed_len ) ) { 
            struct cksum_vec vec [ 1 ] ; vec [ 0 ] . ptr = bp ; vec [ 0 ] . len = fixed_len ; 
            if ( in_cksum ( vec , 1 ) ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; 
        } 
        if ( version == 3 && ND_TTEST2 ( bp [ 0 ] , fixed_len ) ) { 
            uint16_t cksum = nextproto4_cksum ( ndo , ( const struct ip * ) bp2 , bp , fixed_len , len , IPPROTO_VRRP ) ; 
            if ( cksum ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; 
        } 
        ND_PRINT ( ( ndo , "", addrs"" ) ) ; 
        if ( naddrs > 1 ) ND_PRINT ( ( ndo , ""(%d)"" , naddrs ) ) ; 
        ND_PRINT ( ( ndo , "":"" ) ) ; 
        c = ' ' ; bp += 8 ; 
        for ( i = 0 ; i < naddrs ; i ++ ) {
            if(bp + 4 > bp2 + len)
                break;
            ND_TCHECK ( bp [ 3 ] ) ; 
            ND_PRINT ( ( ndo , ""%c%s"" , c , ipaddr_string ( ndo , bp ) ) ) ; 
            c = ',' ; bp += 4 ; 
        } 
        if ( version == 2 && auth_type == VRRP_AUTH_SIMPLE ) { 
            if ( bp + 8 > bp2 +",1000,-53.37277703140613,-0.05337277703140613
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
void vrrp_print ( netdissect_options * ndo , register const u_char * bp , register u_int len , register const u_char * bp2 , int ttl ) { int version , type , auth_type = VRRP_AUTH_NONE ; const char * type_s ; ND_TCHECK ( bp [ 0 ] ) ; version = ( bp [ 0 ] & 0xf0 ) >> 4 ; type = bp [ 0 ] & 0x0f ; type_s = tok2str ( type2str , ""unknown type (%u)"" , type ) ; ND_PRINT ( ( ndo , ""VRRPv%u, %s"" , version , type_s ) ) ; if ( ttl != 255 ) ND_PRINT ( ( ndo , "", (ttl %u)"" , ttl ) ) ; if ( version < 2 || version > 3 || type != VRRP_TYPE_ADVERTISEMENT ) return ; ND_TCHECK ( bp [ 2 ] ) ; ND_PRINT ( ( ndo , "", vrid %u, prio %u"" , bp [ 1 ] , bp [ 2 ] ) ) ; ND_TCHECK ( bp [ 5 ] ) ; if ( version == 2 ) { auth_type = bp [ 4 ] ; ND_PRINT ( ( ndo , "", authtype %s"" , tok2str ( auth2str , NULL , auth_type ) ) ) ; ND_PRINT ( ( ndo , "", intvl %us, length %u"" , bp [ 5 ] , len ) ) ; } else { uint16_t intvl = ( bp [ 4 ] & 0x0f ) << 8 | bp [ 5 ] ; ND_PRINT ( ( ndo , "", intvl %ucs, length %u"" , intvl , len ) ) ; } if ( ndo -> ndo_vflag ) { int naddrs = bp [ 3 ] ; int i ; char c ; if ( version == 2 && ND_TTEST2 ( bp [ 0 ] , len ) ) { struct cksum_vec vec [ 1 ] ; vec [ 0 ] . ptr = bp ; vec [ 0 ] . len = len ; if ( in_cksum ( vec , 1 ) ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } if ( version == 3 && ND_TTEST2 ( bp [ 0 ] , len ) ) { uint16_t cksum = nextproto4_cksum ( ndo , ( const struct ip * ) bp2 , bp , len , len , IPPROTO_VRRP ) ; if ( cksum ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } ND_PRINT ( ( ndo , "", addrs"" ) ) ; if ( naddrs > 1 ) ND_PRINT ( ( ndo , ""(%d)"" , naddrs ) ) ; ND_PRINT ( ( ndo , "":"" ) ) ; c = ' ' ; bp += 8 ; for ( i = 0 ; i < naddrs ; i ++ ) { ND_TCHECK ( bp [ 3 ] ) ; ND_PRINT ( ( ndo , ""%c%s"" , c , ipaddr_string ( ndo , bp ) ) ) ; c = ',' ; bp += 4 ; } if ( version == 2 && auth_type == VRRP_AUTH_SIMPLE ) { ND_TCHECK ( bp [ 7 ] ) ; ND_PRINT ( ( ndo , "" auth \\"""" ) ) ; if ( fn_printn ( ndo , bp , 8 , ndo -> ndo_snapend ) ) { ND_PRINT ( ( ndo , ""\\"""" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""\\"""" ) ) ; } } return ; trunc : ND_PRINT ( ( ndo , ""[|vrrp]"" ) ) ; }
Fixed code:","
void vrrp_print ( netdissect_options * ndo , register const u_char * bp , register u_int len , register const u_char * bp2 , int ttl ) { int version , type , auth_type = VRRP_AUTH_NONE ; const char * type_s ; if(len < 8) return; ND_TCHECK ( bp [ 0 ] ) ; version = ( bp [ 0 ] & 0xf0 ) >> 4 ; type = bp [ 0 ] & 0x0f ; type_s = tok2str ( type2str , ""unknown type (%u)"" , type ) ; ND_PRINT ( ( ndo , ""VRRPv%u, %s"" , version , type_s ) ) ; if ( ttl != 255 ) ND_PRINT ( ( ndo , "", (ttl %u)"" , ttl ) ) ; if ( version < 2 || version > 3 || type != VRRP_TYPE_ADVERTISEMENT ) return ; ND_TCHECK ( bp [ 2 ] ) ; ND_PRINT ( ( ndo , "", vrid %u, prio %u"" , bp [ 1 ] , bp [ 2 ] ) ) ; ND_TCHECK ( bp [ 5 ] ) ; if ( version == 2 ) { auth_type = bp [ 4 ] ; ND_PRINT ( ( ndo , "", authtype %s"" , tok2str ( auth2str , NULL , auth_type ) ) ) ; ND_PRINT ( ( ndo , "", intvl %us, length %u"" , bp [ 5 ] , len ) ) ; } else { uint16_t intvl = ( bp [ 4 ] & 0x0f ) << 8 | bp [ 5 ] ; ND_PRINT ( ( ndo , "", intvl %ucs, length %u"" , intvl , len ) ) ; } if ( ndo -> ndo_vflag ) { int naddrs = bp [ 3 ] ; int i ; char c ; if ( version == 2 && ND_TTEST2 ( bp [ 0 ] , len ) ) { struct cksum_vec vec [ 1 ] ; vec [ 0 ] . ptr = bp ; vec [ 0 ] . len = len ; if ( in_cksum ( vec , 1 ) ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } if ( version == 3 && ND_TTEST2 ( bp [ 0 ] , len ) ) { uint16_t cksum = nextproto4_cksum ( ndo , ( const struct ip * ) bp2 , bp , len , len , IPPROTO_VRRP ) ; if ( cksum ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } ND_PRINT ( ( ndo , "", addrs"" ) ) ; if ( naddrs > 1 ) ND_PRINT ( ( ndo , ""(%d)"" , naddrs ) ) ; ND_PRINT ( ( ndo , "":"" ) ) ; c = ' ' ; bp += 8 ; for ( i = 0 ; i < naddrs ; i ++ ) { ND_TCHECK ( bp [ 3 ] ) ; ND_PRINT ( ( ndo , ""%c%s"" , c , ipaddr_string ( ndo , bp ) ) ) ; c = ',' ; bp += 4 ; } if ( version == 2 && auth_type == VRRP_AUTH_SIMPLE ) { ND_TCHECK ( bp [ 7 ] ) ; ND_PRINT ( ( ndo , "" auth \\"""" ) ) ; if ( fn_printn ( ndo , bp , 8 , ndo -> ndo_snapend ) ) { ND_PRINT ( ( ndo , ""\\"""" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""\\"""" ) ) ; } } return ; trunc : ND_PRINT ( ( ndo , ""[|vrrp]"" ) ) ; }",941,-9.056870925372488,-0.009624729995082347
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
void vrrp_print ( netdissect_options * ndo , register const u_char * bp , register u_int len , register const u_char * bp2 , int ttl ) { int version , type , auth_type = VRRP_AUTH_NONE ; const char * type_s ; ND_TCHECK ( bp [ 0 ] ) ; version = ( bp [ 0 ] & 0xf0 ) >> 4 ; type = bp [ 0 ] & 0x0f ; type_s = tok2str ( type2str , ""unknown type (%u)"" , type ) ; ND_PRINT ( ( ndo , ""VRRPv%u, %s"" , version , type_s ) ) ; if ( ttl != 255 ) ND_PRINT ( ( ndo , "", (ttl %u)"" , ttl ) ) ; if ( version < 2 || version > 3 || type != VRRP_TYPE_ADVERTISEMENT ) return ; ND_TCHECK ( bp [ 2 ] ) ; ND_PRINT ( ( ndo , "", vrid %u, prio %u"" , bp [ 1 ] , bp [ 2 ] ) ) ; ND_TCHECK ( bp [ 5 ] ) ; if ( version == 2 ) { auth_type = bp [ 4 ] ; ND_PRINT ( ( ndo , "", authtype %s"" , tok2str ( auth2str , NULL , auth_type ) ) ) ; ND_PRINT ( ( ndo , "", intvl %us, length %u"" , bp [ 5 ] , len ) ) ; } else { uint16_t intvl = ( bp [ 4 ] & 0x0f ) << 8 | bp [ 5 ] ; ND_PRINT ( ( ndo , "", intvl %ucs, length %u"" , intvl , len ) ) ; } if ( ndo -> ndo_vflag ) { int naddrs = bp [ 3 ] ; int i ; char c ; if ( version == 2 && ND_TTEST2 ( bp [ 0 ] , len ) ) { struct cksum_vec vec [ 1 ] ; vec [ 0 ] . ptr = bp ; vec [ 0 ] . len = len ; if ( in_cksum ( vec , 1 ) ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } if ( version == 3 && ND_TTEST2 ( bp [ 0 ] , len ) ) { uint16_t cksum = nextproto4_cksum ( ndo , ( const struct ip * ) bp2 , bp , len , len , IPPROTO_VRRP ) ; if ( cksum ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } ND_PRINT ( ( ndo , "", addrs"" ) ) ; if ( naddrs > 1 ) ND_PRINT ( ( ndo , ""(%d)"" , naddrs ) ) ; ND_PRINT ( ( ndo , "":"" ) ) ; c = ' ' ; bp += 8 ; for ( i = 0 ; i < naddrs ; i ++ ) { ND_TCHECK ( bp [ 3 ] ) ; ND_PRINT ( ( ndo , ""%c%s"" , c , ipaddr_string ( ndo , bp ) ) ) ; c = ',' ; bp += 4 ; } if ( version == 2 && auth_type == VRRP_AUTH_SIMPLE ) { ND_TCHECK ( bp [ 7 ] ) ; ND_PRINT ( ( ndo , "" auth \\"""" ) ) ; if ( fn_printn ( ndo , bp , 8 , ndo -> ndo_snapend ) ) { ND_PRINT ( ( ndo , ""\\"""" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""\\"""" ) ) ; } } return ; trunc : ND_PRINT ( ( ndo , ""[|vrrp]"" ) ) ; }
Fixed code:","
void vrrp_print ( netdissect_options * ndo , register const u_char * bp , register u_int len , register const u_char * bp2 , int ttl ) { int version , type , auth_type = VRRP_AUTH_NONE ; const char * type_s ; if ( len < 8 ) { ND_PRINT ( ( ndo , ""[|vrrp]"" ) ) ; return ; } ND_TCHECK ( bp [ 0 ] ) ; version = ( bp [ 0 ] & 0xf0 ) >> 4 ; type = bp [ 0 ] & 0x0f ; type_s = tok2str ( type2str , ""unknown type (%u)"" , type ) ; ND_PRINT ( ( ndo , ""VRRPv%u, %s"" , version , type_s ) ) ; if ( ttl != 255 ) ND_PRINT ( ( ndo , "", (ttl %u)"" , ttl ) ) ; if ( version < 2 || version > 3 || type != VRRP_TYPE_ADVERTISEMENT ) return ; ND_TCHECK ( bp [ 2 ] ) ; ND_PRINT ( ( ndo , "", vrid %u, prio %u"" , bp [ 1 ] , bp [ 2 ] ) ) ; ND_TCHECK ( bp [ 5 ] ) ; if ( version == 2 ) { auth_type = bp [ 4 ] ; ND_PRINT ( ( ndo , "", authtype %s"" , tok2str ( auth2str , NULL , auth_type ) ) ) ; ND_PRINT ( ( ndo , "", intvl %us, length %u"" , bp [ 5 ] , len ) ) ; } else { uint16_t intvl = ( bp [ 4 ] & 0x0f ) << 8 | bp [ 5 ] ; ND_PRINT ( ( ndo , "", intvl %ucs, length %u"" , intvl , len ) ) ; } if ( ndo -> ndo_vflag ) { int naddrs = bp [ 3 ] ; int i ; char c ; if ( version == 2 && ND_TTEST2 ( bp [ 0 ] , len ) ) { struct cksum_vec vec [ 1 ] ; vec [ 0 ] . ptr = bp ; vec [ 0 ] . len = len ; if ( in_cksum ( vec , 1 ) ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } if ( version == 3 && ND_TTEST2 ( bp [ 0 ] , len ) ) { uint16_t cksum = nextproto4_cksum ( ndo , ( const struct ip * ) bp2 , bp , len , len , IPPROTO_VRRP ) ; if ( cksum ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } ND_PRINT ( ( ndo , "", addrs"" ) ) ; if ( naddrs > 1 ) ND_PRINT ( ( ndo , ""(%d)"" , naddrs ) ) ; ND_PRINT ( ( ndo , "":"" ) ) ; c = ' ' ; bp += 8 ; for ( i = 0 ; i < naddrs ; i ++ ) { if ( bp + 4 > bp2 + len ) { ND_PRINT ( ( ndo , ""[|vrrp]"" ) ) ; return ; } ND_TCHECK ( bp [ 3 ] ) ; ND_PRINT ( ( ndo , ""%c%s"" , c , ipaddr_string ( ndo , bp ) ) ) ; c = ',' ; bp += 4 ; } if ( version == 2 && auth_type == VRRP_AUTH_SIMPLE ) { if ( bp + 8 > bp2 + len ) { ND_PRINT ( ( ndo , ""[|vrrp]"" ) ) ; return ; } ND_TCHECK ( bp [ 7 ] ) ; ND_PRINT ( ( ndo , "" auth \\"""" ) ) ; if ( fn_printn ( ndo , bp , 8 , ndo -> ndo_snapend ) ) { ND_PRINT ( ( ndo , ""\\"""" ) ) ; goto trunc ; } ND_PRINT ( ( ndo ,",1000,-12.785903127685527,-0.012785903127685527
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
void vrrp_print ( netdissect_options * ndo , register const u_char * bp , register u_int len , register const u_char * bp2 , int ttl ) { int version , type , auth_type = VRRP_AUTH_NONE ; const char * type_s ; ND_TCHECK ( bp [ 0 ] ) ; version = ( bp [ 0 ] & 0xf0 ) >> 4 ; type = bp [ 0 ] & 0x0f ; type_s = tok2str ( type2str , ""unknown type (%u)"" , type ) ; ND_PRINT ( ( ndo , ""VRRPv%u, %s"" , version , type_s ) ) ; if ( ttl != 255 ) ND_PRINT ( ( ndo , "", (ttl %u)"" , ttl ) ) ; if ( version < 2 || version > 3 || type != VRRP_TYPE_ADVERTISEMENT ) return ; ND_TCHECK ( bp [ 2 ] ) ; ND_PRINT ( ( ndo , "", vrid %u, prio %u"" , bp [ 1 ] , bp [ 2 ] ) ) ; ND_TCHECK ( bp [ 5 ] ) ; if ( version == 2 ) { auth_type = bp [ 4 ] ; ND_PRINT ( ( ndo , "", authtype %s"" , tok2str ( auth2str , NULL , auth_type ) ) ) ; ND_PRINT ( ( ndo , "", intvl %us, length %u"" , bp [ 5 ] , len ) ) ; } else { uint16_t intvl = ( bp [ 4 ] & 0x0f ) << 8 | bp [ 5 ] ; ND_PRINT ( ( ndo , "", intvl %ucs, length %u"" , intvl , len ) ) ; } if ( ndo -> ndo_vflag ) { int naddrs = bp [ 3 ] ; int i ; char c ; if ( version == 2 && ND_TTEST2 ( bp [ 0 ] , len ) ) { struct cksum_vec vec [ 1 ] ; vec [ 0 ] . ptr = bp ; vec [ 0 ] . len = len ; if ( in_cksum ( vec , 1 ) ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } if ( version == 3 && ND_TTEST2 ( bp [ 0 ] , len ) ) { uint16_t cksum = nextproto4_cksum ( ndo , ( const struct ip * ) bp2 , bp , len , len , IPPROTO_VRRP ) ; if ( cksum ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } ND_PRINT ( ( ndo , "", addrs"" ) ) ; if ( naddrs > 1 ) ND_PRINT ( ( ndo , ""(%d)"" , naddrs ) ) ; ND_PRINT ( ( ndo , "":"" ) ) ; c = ' ' ; bp += 8 ; for ( i = 0 ; i < naddrs ; i ++ ) { ND_TCHECK ( bp [ 3 ] ) ; ND_PRINT ( ( ndo , ""%c%s"" , c , ipaddr_string ( ndo , bp ) ) ) ; c = ',' ; bp += 4 ; } if ( version == 2 && auth_type == VRRP_AUTH_SIMPLE ) { ND_TCHECK ( bp [ 7 ] ) ; ND_PRINT ( ( ndo , "" auth \\"""" ) ) ; if ( fn_printn ( ndo , bp , 8 , ndo -> ndo_snapend ) ) { ND_PRINT ( ( ndo , ""\\"""" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""\\"""" ) ) ; } } return ; trunc : ND_PRINT ( ( ndo , ""[|vrrp]"" ) ) ; }
Fixed code:","
void vrrp_print ( netdissect_options * ndo , register const u_char * bp , register u_int len , register const u_char * bp2 , int ttl ) { int version , type , auth_type = VRRP_AUTH_NONE ; const char * type_s ; ND_TCHECK ( bp [ 0 ] ) ; version = ( bp [ 0 ] & 0xf0 ) >> 4 ; type = bp [ 0 ] & 0x0f ; type_s = tok2str ( type2str , ""unknown type (%u)"" , type ) ; ND_PRINT ( ( ndo , ""VRRPv%u, %s"" , version , type_s ) ) ; if ( ttl != 255 ) ND_PRINT ( ( ndo , "", (ttl %u)"" , ttl ) ) ; if ( version < 2 || version > 3 || type != VRRP_TYPE_ADVERTISEMENT ) return ; ND_TCHECK ( bp [ 2 ] ) ; ND_PRINT ( ( ndo , "", vrid %u, prio %u"" , bp [ 1 ] , bp [ 2 ] ) ) ; ND_TCHECK ( bp [ 5 ] ) ; if ( version == 2 ) { auth_type = bp [ 4 ] ; ND_PRINT ( ( ndo , "", authtype %s"" , tok2str ( auth2str , NULL , auth_type ) ) ) ; ND_PRINT ( ( ndo , "", intvl %us, length %u"" , bp [ 5 ] , len ) ) ; } else { uint16_t intvl = ( bp [ 4 ] & 0x0f ) << 8 | bp [ 5 ] ; ND_PRINT ( ( ndo , "", intvl %ucs, length %u"" , intvl , len ) ) ; } if ( ndo -> ndo_vflag ) { int naddrs = bp [ 3 ] ; int i ; char c ; if ( ND_TTEST2 ( bp [ 0 ] , len ) ) { 
        if (version == 2) {
            struct cksum_vec vec [ 1 ] ;
            vec [ 0 ] . ptr = bp ;
            vec [ 0 ] . len = len ;
            if ( in_cksum ( vec , 1 ) ) {
                ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ;
            }
        }
        else if (version == 3 && ND_TTEST2 ( bp [ 0 ] , len ) ) {
            uint16_t cksum = nextproto4_cksum ( ndo , ( const struct ip * ) bp2 , bp , len , len , IPPROTO_VRRP ) ;
            if ( cksum ) {
                ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ;
            }
        }
    } 
    ND_PRINT ( ( ndo , "", addrs"" ) ) ; 
    if ( naddrs > 1 ) {
        ND_PRINT ( ( ndo , ""(%d)"" , naddrs ) ) ; 
    }
    ND_PRINT ( ( ndo , "":"" ) ) ; 
    c = ' ' ; 
    bp += 8 ; 
    for ( i = 0 ; i < naddrs ; i ++ ) {
        if (i < naddrs && ND_TTEST2(bp[3], len)) { 
            ND_TCHECK ( bp [ 3 ] ) ; 
            ND_PRINT ( ( ndo , ""%c%s"" , c , ipaddr_string ( ndo , bp ) ) ) ; 
            c = ',' ; 
            bp += 4 ; 
        }
    } 
    if ( version == 2 && auth_type == VRRP_AUTH_SIMPLE ) {
        if ( ND_TTEST2 ( bp [ 7 ] , len ) ) { 
            ND_PRINT ( ( ndo , "" auth \\"""" ) ) ; 
            if ( fn_printn ( ndo , bp , 8 , ndo -> ndo_snapend ) ) { 
                ND",1000,-44.3501191623698,-0.0443501191623698
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
void vrrp_print ( netdissect_options * ndo , register const u_char * bp , register u_int len , register const u_char * bp2 , int ttl ) { int version , type , auth_type = VRRP_AUTH_NONE ; const char * type_s ; ND_TCHECK ( bp [ 0 ] ) ; version = ( bp [ 0 ] & 0xf0 ) >> 4 ; type = bp [ 0 ] & 0x0f ; type_s = tok2str ( type2str , ""unknown type (%u)"" , type ) ; ND_PRINT ( ( ndo , ""VRRPv%u, %s"" , version , type_s ) ) ; if ( ttl != 255 ) ND_PRINT ( ( ndo , "", (ttl %u)"" , ttl ) ) ; if ( version < 2 || version > 3 || type != VRRP_TYPE_ADVERTISEMENT ) return ; ND_TCHECK ( bp [ 2 ] ) ; ND_PRINT ( ( ndo , "", vrid %u, prio %u"" , bp [ 1 ] , bp [ 2 ] ) ) ; ND_TCHECK ( bp [ 5 ] ) ; if ( version == 2 ) { auth_type = bp [ 4 ] ; ND_PRINT ( ( ndo , "", authtype %s"" , tok2str ( auth2str , NULL , auth_type ) ) ) ; ND_PRINT ( ( ndo , "", intvl %us, length %u"" , bp [ 5 ] , len ) ) ; } else { uint16_t intvl = ( bp [ 4 ] & 0x0f ) << 8 | bp [ 5 ] ; ND_PRINT ( ( ndo , "", intvl %ucs, length %u"" , intvl , len ) ) ; } if ( ndo -> ndo_vflag ) { int naddrs = bp [ 3 ] ; int i ; char c ; if ( version == 2 && ND_TTEST2 ( bp [ 0 ] , len ) ) { struct cksum_vec vec [ 1 ] ; vec [ 0 ] . ptr = bp ; vec [ 0 ] . len = len ; if ( in_cksum ( vec , 1 ) ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } if ( version == 3 && ND_TTEST2 ( bp [ 0 ] , len ) ) { uint16_t cksum = nextproto4_cksum ( ndo , ( const struct ip * ) bp2 , bp , len , len , IPPROTO_VRRP ) ; if ( cksum ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } ND_PRINT ( ( ndo , "", addrs"" ) ) ; if ( naddrs > 1 ) ND_PRINT ( ( ndo , ""(%d)"" , naddrs ) ) ; ND_PRINT ( ( ndo , "":"" ) ) ; c = ' ' ; bp += 8 ; for ( i = 0 ; i < naddrs ; i ++ ) { ND_TCHECK ( bp [ 3 ] ) ; ND_PRINT ( ( ndo , ""%c%s"" , c , ipaddr_string ( ndo , bp ) ) ) ; c = ',' ; bp += 4 ; } if ( version == 2 && auth_type == VRRP_AUTH_SIMPLE ) { ND_TCHECK ( bp [ 7 ] ) ; ND_PRINT ( ( ndo , "" auth \\"""" ) ) ; if ( fn_printn ( ndo , bp , 8 , ndo -> ndo_snapend ) ) { ND_PRINT ( ( ndo , ""\\"""" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""\\"""" ) ) ; } } return ; trunc : ND_PRINT ( ( ndo , ""[|vrrp]"" ) ) ; }
Fixed code:","
void vrrp_print ( netdissect_options * ndo , register const u_char * bp , register u_int len , register const u_char * bp2 , int ttl ) { int version , type , auth_type = VRRP_AUTH_NONE ; const char * type_s ; ND_TCHECK ( bp [ 0 ] ) ; version = ( bp [ 0 ] & 0xf0 ) >> 4 ; type = bp [ 0 ] & 0x0f ; type_s = tok2str ( type2str , ""unknown type (%u)"" , type ) ; ND_PRINT ( ( ndo , ""VRRPv%u, %s"" , version , type_s ) ) ; if ( ttl != 255 ) ND_PRINT ( ( ndo , "", (ttl %u)"" , ttl ) ) ; if ( version < 2 || version > 3 || type != VRRP_TYPE_ADVERTISEMENT ) return ; ND_TCHECK ( bp [ 2 ] ) ; ND_PRINT ( ( ndo , "", vrid %u, prio %u"" , bp [ 1 ] , bp [ 2 ] ) ) ; ND_TCHECK ( bp [ 5 ] ) ; if ( version == 2 ) { auth_type = bp [ 4 ] ; ND_PRINT ( ( ndo , "", authtype %s"" , tok2str ( auth2str , NULL , auth_type ) ) ) ; ND_PRINT ( ( ndo , "", intvl %us, length %u"" , bp [ 5 ] , len ) ) ; } else { uint16_t intvl = ( bp [ 4 ] & 0x0f ) << 8 | bp [ 5 ] ; ND_PRINT ( ( ndo , "", intvl %ucs, length %u"" , intvl , len ) ) ; } if ( ndo -> ndo_vflag ) { int naddrs = bp [ 3 ] ; int i ; char c ; if ( naddrs > 0 && (version == 2 && ND_TTEST2 ( bp [ 0 ] , len ) || version == 3 && ND_TTEST2 ( bp [ 0 ] , len ) ) ) { struct cksum_vec vec [ 1 ] ; vec [ 0 ] . ptr = bp ; vec [ 0 ] . len = len ; if ( in_cksum ( vec , 1 ) ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } ND_PRINT ( ( ndo , "", addrs"" ) ) ; if ( naddrs > 1 ) ND_PRINT ( ( ndo , ""(%d)"" , naddrs ) ) ; ND_PRINT ( ( ndo , "":"" ) ) ; c = ' ' ; bp += 8 ; for ( i = 0 ; i < naddrs ; i ++ ) { if ( ND_TTEST2 ( bp [ 3 ] , 4 ) ) { ND_PRINT ( ( ndo , ""%c%s"" , c , ipaddr_string ( ndo , bp ) ) ) ; c = ',' ; bp += 4 ; } else { break ; } } if ( version == 2 && auth_type == VRRP_AUTH_SIMPLE ) { if ( ND_TTEST2 ( bp [ 7 ] , 8 ) ) { ND_PRINT ( ( ndo , "" auth \\"""" ) ) ; if ( fn_printn ( ndo , bp , 8 , ndo -> ndo_snapend ) ) { ND_PRINT ( ( ndo , ""\\"""" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""\\"""" ) ) ; } else { break ; } } } return ; trunc : ND_PRINT ( ( ndo , ""[|vrrp]"" ) ) ; }",871,-26.323271545899,-0.030221896149137773
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
void vrrp_print ( netdissect_options * ndo , register const u_char * bp , register u_int len , register const u_char * bp2 , int ttl ) { int version , type , auth_type = VRRP_AUTH_NONE ; const char * type_s ; ND_TCHECK ( bp [ 0 ] ) ; version = ( bp [ 0 ] & 0xf0 ) >> 4 ; type = bp [ 0 ] & 0x0f ; type_s = tok2str ( type2str , ""unknown type (%u)"" , type ) ; ND_PRINT ( ( ndo , ""VRRPv%u, %s"" , version , type_s ) ) ; if ( ttl != 255 ) ND_PRINT ( ( ndo , "", (ttl %u)"" , ttl ) ) ; if ( version < 2 || version > 3 || type != VRRP_TYPE_ADVERTISEMENT ) return ; ND_TCHECK ( bp [ 2 ] ) ; ND_PRINT ( ( ndo , "", vrid %u, prio %u"" , bp [ 1 ] , bp [ 2 ] ) ) ; ND_TCHECK ( bp [ 5 ] ) ; if ( version == 2 ) { auth_type = bp [ 4 ] ; ND_PRINT ( ( ndo , "", authtype %s"" , tok2str ( auth2str , NULL , auth_type ) ) ) ; ND_PRINT ( ( ndo , "", intvl %us, length %u"" , bp [ 5 ] , len ) ) ; } else { uint16_t intvl = ( bp [ 4 ] & 0x0f ) << 8 | bp [ 5 ] ; ND_PRINT ( ( ndo , "", intvl %ucs, length %u"" , intvl , len ) ) ; } if ( ndo -> ndo_vflag ) { int naddrs = bp [ 3 ] ; int i ; char c ; if ( version == 2 && ND_TTEST2 ( bp [ 0 ] , len ) ) { struct cksum_vec vec [ 1 ] ; vec [ 0 ] . ptr = bp ; vec [ 0 ] . len = len ; if ( in_cksum ( vec , 1 ) ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } if ( version == 3 && ND_TTEST2 ( bp [ 0 ] , len ) ) { uint16_t cksum = nextproto4_cksum ( ndo , ( const struct ip * ) bp2 , bp , len , len , IPPROTO_VRRP ) ; if ( cksum ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } ND_PRINT ( ( ndo , "", addrs"" ) ) ; if ( naddrs > 1 ) ND_PRINT ( ( ndo , ""(%d)"" , naddrs ) ) ; ND_PRINT ( ( ndo , "":"" ) ) ; c = ' ' ; bp += 8 ; for ( i = 0 ; i < naddrs ; i ++ ) { ND_TCHECK ( bp [ 3 ] ) ; ND_PRINT ( ( ndo , ""%c%s"" , c , ipaddr_string ( ndo , bp ) ) ) ; c = ',' ; bp += 4 ; } if ( version == 2 && auth_type == VRRP_AUTH_SIMPLE ) { ND_TCHECK ( bp [ 7 ] ) ; ND_PRINT ( ( ndo , "" auth \\"""" ) ) ; if ( fn_printn ( ndo , bp , 8 , ndo -> ndo_snapend ) ) { ND_PRINT ( ( ndo , ""\\"""" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""\\"""" ) ) ; } } return ; trunc : ND_PRINT ( ( ndo , ""[|vrrp]"" ) ) ; }
Fixed code:","
void vrrp_print ( netdissect_options * ndo , register const u_char * bp , register u_int len , register const u_char * bp2 , int ttl ) { int version , type , auth_type = VRRP_AUTH_NONE ; const char * type_s ; //Check for buffer bounds before accessing data ND_TCHECK2 ( bp [ 0 ] , 1 ) ; version = ( bp [ 0 ] & 0xf0 ) >> 4 ; type = bp [ 0 ] & 0x0f ; type_s = tok2str ( type2str , ""unknown type (%u)"" , type ) ; ND_PRINT ( ( ndo , ""VRRPv%u, %s"" , version , type_s ) ) ; if ( ttl != 255 ) ND_PRINT ( ( ndo , "", (ttl %u)"" , ttl ) ) ; if ( version < 2 || version > 3 || type != VRRP_TYPE_ADVERTISEMENT ) return ; //Check for buffer bounds before accessing data ND_TCHECK2 ( bp [ 2 ] , 1 ) ; ND_PRINT ( ( ndo , "", vrid %u, prio %u"" , bp [ 1 ] , bp [ 2 ] ) ) ; //Check for buffer bounds before accessing data ND_TCHECK2 ( bp [ 5 ] , 1 ) ; if ( version == 2 ) { auth_type = bp [ 4 ] ; ND_PRINT ( ( ndo , "", authtype %s"" , tok2str ( auth2str , NULL , auth_type ) ) ) ; ND_PRINT ( ( ndo , "", intvl %us, length %u"" , bp [ 5 ] , len ) ) ; } else { uint16_t intvl = ( bp [ 4 ] & 0x0f ) << 8 | bp [ 5 ] ; ND_PRINT ( ( ndo , "", intvl %ucs, length %u"" , intvl , len ) ) ; } if ( ndo -> ndo_vflag ) { int naddrs = bp [ 3 ] ; int i ; char c ; //Check for buffer bounds before accessing data if ( version == 2 && ND_TTEST2 ( bp [ 0 ] , len ) ) { struct cksum_vec vec [ 1 ] ; vec [ 0 ] . ptr = bp ; vec [ 0 ] . len = len ; if ( in_cksum ( vec , 1 ) ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } //Check for buffer bounds before accessing data if ( version == 3 && ND_TTEST2 ( bp [ 0 ] , len ) ) { uint16_t cksum = nextproto4_cksum ( ndo , ( const struct ip * ) bp2 , bp , len , len , IPPROTO_VRRP ) ; if ( cksum ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } ND_PRINT ( ( ndo , "", addrs"" ) ) ; if ( naddrs > 1 ) ND_PRINT ( ( ndo , ""(%d)"" , naddrs ) ) ; ND_PRINT ( ( ndo , "":"" ) ) ; c = ' ' ; bp += 8 ; for ( i = 0 ; i < naddrs ; i ++ ) { //Check for buffer bounds before accessing data ND_TCHECK2 ( bp [ 3 ] , 1 ) ; ND_PRINT ( ( ndo , ""%c%s"" , c , ipaddr_string ( ndo , bp ) ) ) ; c = ',' ; bp += 4 ; } if ( version == 2 && auth_type == VRRP_AUTH_SIMPLE ) { //Check for buffer bounds before accessing data ND_TCHECK2 ( bp [ 7 ] , 1 ) ; ND_PRINT ( ( ndo , "" auth \\"""" ) ) ; if ( fn_printn ( ndo , bp , 8 , ndo -> ndo_snapend ) ) { ND_PRINT ( ( ndo , ""\\"""" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""\\"""" ) ) ; } } return ; trunc : ND_PRINT ( ( ndo , ""[|vrrp]""",1000,-21.951093466809674,-0.021951093466809672
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
void vrrp_print ( netdissect_options * ndo , register const u_char * bp , register u_int len , register const u_char * bp2 , int ttl ) { int version , type , auth_type = VRRP_AUTH_NONE ; const char * type_s ; ND_TCHECK ( bp [ 0 ] ) ; version = ( bp [ 0 ] & 0xf0 ) >> 4 ; type = bp [ 0 ] & 0x0f ; type_s = tok2str ( type2str , ""unknown type (%u)"" , type ) ; ND_PRINT ( ( ndo , ""VRRPv%u, %s"" , version , type_s ) ) ; if ( ttl != 255 ) ND_PRINT ( ( ndo , "", (ttl %u)"" , ttl ) ) ; if ( version < 2 || version > 3 || type != VRRP_TYPE_ADVERTISEMENT ) return ; ND_TCHECK ( bp [ 2 ] ) ; ND_PRINT ( ( ndo , "", vrid %u, prio %u"" , bp [ 1 ] , bp [ 2 ] ) ) ; ND_TCHECK ( bp [ 5 ] ) ; if ( version == 2 ) { auth_type = bp [ 4 ] ; ND_PRINT ( ( ndo , "", authtype %s"" , tok2str ( auth2str , NULL , auth_type ) ) ) ; ND_PRINT ( ( ndo , "", intvl %us, length %u"" , bp [ 5 ] , len ) ) ; } else { uint16_t intvl = ( bp [ 4 ] & 0x0f ) << 8 | bp [ 5 ] ; ND_PRINT ( ( ndo , "", intvl %ucs, length %u"" , intvl , len ) ) ; } if ( ndo -> ndo_vflag ) { int naddrs = bp [ 3 ] ; int i ; char c ; if ( version == 2 && ND_TTEST2 ( bp [ 0 ] , len ) ) { struct cksum_vec vec [ 1 ] ; vec [ 0 ] . ptr = bp ; vec [ 0 ] . len = len ; if ( in_cksum ( vec , 1 ) ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } if ( version == 3 && ND_TTEST2 ( bp [ 0 ] , len ) ) { uint16_t cksum = nextproto4_cksum ( ndo , ( const struct ip * ) bp2 , bp , len , len , IPPROTO_VRRP ) ; if ( cksum ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } ND_PRINT ( ( ndo , "", addrs"" ) ) ; if ( naddrs > 1 ) ND_PRINT ( ( ndo , ""(%d)"" , naddrs ) ) ; ND_PRINT ( ( ndo , "":"" ) ) ; c = ' ' ; bp += 8 ; for ( i = 0 ; i < naddrs ; i ++ ) { ND_TCHECK ( bp [ 3 ] ) ; ND_PRINT ( ( ndo , ""%c%s"" , c , ipaddr_string ( ndo , bp ) ) ) ; c = ',' ; bp += 4 ; } if ( version == 2 && auth_type == VRRP_AUTH_SIMPLE ) { ND_TCHECK ( bp [ 7 ] ) ; ND_PRINT ( ( ndo , "" auth \\"""" ) ) ; if ( fn_printn ( ndo , bp , 8 , ndo -> ndo_snapend ) ) { ND_PRINT ( ( ndo , ""\\"""" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""\\"""" ) ) ; } } return ; trunc : ND_PRINT ( ( ndo , ""[|vrrp]"" ) ) ; }
Fixed code:","
void vrrp_print ( netdissect_options * ndo , register const u_char * bp , register u_int len , register const u_char * bp2 , int ttl ) { int version , type , auth_type = VRRP_AUTH_NONE ; const char * type_s ; if (len < 8) { ND_PRINT ( ( ndo , ""[|vrrp]"" ) ) ; return; } ND_TCHECK ( bp [ 0 ] ) ; version = ( bp [ 0 ] & 0xf0 ) >> 4 ; type = bp [ 0 ] & 0x0f ; type_s = tok2str ( type2str , ""unknown type (%u)"" , type ) ; ND_PRINT ( ( ndo , ""VRRPv%u, %s"" , version , type_s ) ) ; if ( ttl != 255 ) ND_PRINT ( ( ndo , "", (ttl %u)"" , ttl ) ) ; if ( version < 2 || version > 3 || type != VRRP_TYPE_ADVERTISEMENT ) return ; ND_TCHECK ( bp [ 2 ] ) ; ND_PRINT ( ( ndo , "", vrid %u, prio %u"" , bp [ 1 ] , bp [ 2 ] ) ) ; ND_TCHECK ( bp [ 5 ] ) ; if ( version == 2 ) { auth_type = bp [ 4 ] ; ND_PRINT ( ( ndo , "", authtype %s"" , tok2str ( auth2str , NULL , auth_type ) ) ) ; ND_PRINT ( ( ndo , "", intvl %us, length %u"" , bp [ 5 ] , len ) ) ; } else { uint16_t intvl = ( bp [ 4 ] & 0x0f ) << 8 | bp [ 5 ] ; ND_PRINT ( ( ndo , "", intvl %ucs, length %u"" , intvl , len ) ) ; } if ( ndo -> ndo_vflag ) { int naddrs = bp [ 3 ] ; int i ; char c ; if ( version == 2 && ND_TTEST2 ( bp [ 0 ] , len ) ) { struct cksum_vec vec [ 1 ] ; vec [ 0 ] . ptr = bp ; vec [ 0 ] . len = len ; if ( in_cksum ( vec , 1 ) ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } if ( version == 3 && ND_TTEST2 ( bp [ 0 ] , len ) ) { uint16_t cksum = nextproto4_cksum ( ndo , ( const struct ip * ) bp2 , bp , len , len , IPPROTO_VRRP ) ; if ( cksum ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } ND_PRINT ( ( ndo , "", addrs"" ) ) ; if ( naddrs > 1 ) ND_PRINT ( ( ndo , ""(%d)"" , naddrs ) ) ; ND_PRINT ( ( ndo , "":"" ) ) ; c = ' ' ; bp += 8 ; for ( i = 0 ; i < naddrs ; i ++ ) { ND_TCHECK ( bp [ 3 ] ) ; ND_PRINT ( ( ndo , ""%c%s"" , c , ipaddr_string ( ndo , bp ) ) ) ; c = ',' ; bp += 4 ; if (bp + 4 > bp2 + len){ ND_PRINT ( ( ndo , ""[|vrrp]"" ) ) ; return; } } if ( version == 2 && auth_type == VRRP_AUTH_SIMPLE ) { ND_TCHECK ( bp [ 7 ] ) ; ND_PRINT ( ( ndo , "" auth \\"""" ) ) ; if ( fn_printn ( ndo , bp , 8 , ndo -> ndo_snapend ) ) { ND_PRINT ( ( ndo , ""\\"""" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""\\"""" ) ) ; } } return ; trunc : ND_PRINT ( ( ndo , ""[|vrrp]"" ) ) ; }",994,-16.356351124705434,-0.016455081614391784
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
void vrrp_print ( netdissect_options * ndo , register const u_char * bp , register u_int len , register const u_char * bp2 , int ttl ) { int version , type , auth_type = VRRP_AUTH_NONE ; const char * type_s ; ND_TCHECK ( bp [ 0 ] ) ; version = ( bp [ 0 ] & 0xf0 ) >> 4 ; type = bp [ 0 ] & 0x0f ; type_s = tok2str ( type2str , ""unknown type (%u)"" , type ) ; ND_PRINT ( ( ndo , ""VRRPv%u, %s"" , version , type_s ) ) ; if ( ttl != 255 ) ND_PRINT ( ( ndo , "", (ttl %u)"" , ttl ) ) ; if ( version < 2 || version > 3 || type != VRRP_TYPE_ADVERTISEMENT ) return ; ND_TCHECK ( bp [ 2 ] ) ; ND_PRINT ( ( ndo , "", vrid %u, prio %u"" , bp [ 1 ] , bp [ 2 ] ) ) ; ND_TCHECK ( bp [ 5 ] ) ; if ( version == 2 ) { auth_type = bp [ 4 ] ; ND_PRINT ( ( ndo , "", authtype %s"" , tok2str ( auth2str , NULL , auth_type ) ) ) ; ND_PRINT ( ( ndo , "", intvl %us, length %u"" , bp [ 5 ] , len ) ) ; } else { uint16_t intvl = ( bp [ 4 ] & 0x0f ) << 8 | bp [ 5 ] ; ND_PRINT ( ( ndo , "", intvl %ucs, length %u"" , intvl , len ) ) ; } if ( ndo -> ndo_vflag ) { int naddrs = bp [ 3 ] ; int i ; char c ; if ( version == 2 && ND_TTEST2 ( bp [ 0 ] , len ) ) { struct cksum_vec vec [ 1 ] ; vec [ 0 ] . ptr = bp ; vec [ 0 ] . len = len ; if ( in_cksum ( vec , 1 ) ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } if ( version == 3 && ND_TTEST2 ( bp [ 0 ] , len ) ) { uint16_t cksum = nextproto4_cksum ( ndo , ( const struct ip * ) bp2 , bp , len , len , IPPROTO_VRRP ) ; if ( cksum ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } ND_PRINT ( ( ndo , "", addrs"" ) ) ; if ( naddrs > 1 ) ND_PRINT ( ( ndo , ""(%d)"" , naddrs ) ) ; ND_PRINT ( ( ndo , "":"" ) ) ; c = ' ' ; bp += 8 ; for ( i = 0 ; i < naddrs ; i ++ ) { ND_TCHECK ( bp [ 3 ] ) ; ND_PRINT ( ( ndo , ""%c%s"" , c , ipaddr_string ( ndo , bp ) ) ) ; c = ',' ; bp += 4 ; } if ( version == 2 && auth_type == VRRP_AUTH_SIMPLE ) { ND_TCHECK ( bp [ 7 ] ) ; ND_PRINT ( ( ndo , "" auth \\"""" ) ) ; if ( fn_printn ( ndo , bp , 8 , ndo -> ndo_snapend ) ) { ND_PRINT ( ( ndo , ""\\"""" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""\\"""" ) ) ; } } return ; trunc : ND_PRINT ( ( ndo , ""[|vrrp]"" ) ) ; }
Fixed code:","

void vrrp_print ( netdissect_options * ndo , register const u_char * bp , register u_int len , register const u_char * bp2 , int ttl ) { int version , type , auth_type = VRRP_AUTH_NONE ; const char * type_s ; ND_TCHECK2 ( bp [ 0 ] , 1 ) ; version = ( bp [ 0 ] & 0xf0 ) >> 4 ; type = bp [ 0 ] & 0x0f ; type_s = tok2str ( type2str , ""unknown type (%u)"" , type ) ; ND_PRINT ( ( ndo , ""VRRPv%u, %s"" , version , type_s ) ) ; if ( ttl != 255 ) ND_PRINT ( ( ndo , "", (ttl %u)"" , ttl ) ) ; if ( version < 2 || version > 3 || type != VRRP_TYPE_ADVERTISEMENT ) return ; ND_TCHECK2 ( bp [ 2 ] , 2 ) ; ND_PRINT ( ( ndo , "", vrid %u, prio %u"" , bp [ 1 ] , bp [ 2 ] ) ) ; ND_TCHECK2 ( bp [ 5 ] , 1 ) ; if ( version == 2 ) { auth_type = bp [ 4 ] ; ND_PRINT ( ( ndo , "", authtype %s"" , tok2str ( auth2str , NULL , auth_type ) ) ) ; ND_PRINT ( ( ndo , "", intvl %us, length %u"" , bp [ 5 ] , len ) ) ; } else { uint16_t intvl = ( bp [ 4 ] & 0x0f ) << 8 | bp [ 5 ] ; ND_PRINT ( ( ndo , "", intvl %ucs, length %u"" , intvl , len ) ) ; } if ( ndo -> ndo_vflag ) { int naddrs = bp [ 3 ] ; int i ; char c ; if( len >= 8) { if ( version == 2 && ND_TTEST2 ( bp [ 0 ] , len ) ) { struct cksum_vec vec [ 1 ] ; vec [ 0 ] . ptr = bp ; vec [ 0 ] . len = len ; if ( in_cksum ( vec , 1 ) ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } if ( version == 3 && ND_TTEST2 ( bp [ 0 ] , len ) ) { uint16_t cksum = nextproto4_cksum ( ndo , ( const struct ip * ) bp2 , bp , len , len , IPPROTO_VRRP ) ; if ( cksum ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } ND_PRINT ( ( ndo , "", addrs"" ) ) ; if ( naddrs > 1 ) ND_PRINT ( ( ndo , ""(%d)"" , naddrs ) ) ; ND_PRINT ( ( ndo , "":"" ) ) ; c = ' ' ; bp += 8 ; for ( i = 0 ; i < naddrs ; i ++ ) { ND_TCHECK2 ( bp [ 3 ] , 1 ) ; ND_PRINT ( ( ndo , ""%c%s"" , c , ipaddr_string ( ndo , bp ) ) ) ; c = ',' ; bp += 4 ; } if ( version == 2 && auth_type == VRRP_AUTH_SIMPLE ) { ND_TCHECK2 ( bp [ 7 ] , 1 ) ; ND_PRINT ( ( ndo , "" auth \\"""" ) ) ; if ( fn_printn ( ndo , bp , 8 , ndo -> ndo_snapend ) ) { ND_PRINT ( ( ndo , ""\\"""" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""\\"""" ) ) ; } } } return ; trunc : ND_PRINT ( ( ndo , ""[|vrrp]"" ) ) ; }",957,-33.530170920220776,-0.03503675122280123
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
void vrrp_print ( netdissect_options * ndo , register const u_char * bp , register u_int len , register const u_char * bp2 , int ttl ) { int version , type , auth_type = VRRP_AUTH_NONE ; const char * type_s ; ND_TCHECK ( bp [ 0 ] ) ; version = ( bp [ 0 ] & 0xf0 ) >> 4 ; type = bp [ 0 ] & 0x0f ; type_s = tok2str ( type2str , ""unknown type (%u)"" , type ) ; ND_PRINT ( ( ndo , ""VRRPv%u, %s"" , version , type_s ) ) ; if ( ttl != 255 ) ND_PRINT ( ( ndo , "", (ttl %u)"" , ttl ) ) ; if ( version < 2 || version > 3 || type != VRRP_TYPE_ADVERTISEMENT ) return ; ND_TCHECK ( bp [ 2 ] ) ; ND_PRINT ( ( ndo , "", vrid %u, prio %u"" , bp [ 1 ] , bp [ 2 ] ) ) ; ND_TCHECK ( bp [ 5 ] ) ; if ( version == 2 ) { auth_type = bp [ 4 ] ; ND_PRINT ( ( ndo , "", authtype %s"" , tok2str ( auth2str , NULL , auth_type ) ) ) ; ND_PRINT ( ( ndo , "", intvl %us, length %u"" , bp [ 5 ] , len ) ) ; } else { uint16_t intvl = ( bp [ 4 ] & 0x0f ) << 8 | bp [ 5 ] ; ND_PRINT ( ( ndo , "", intvl %ucs, length %u"" , intvl , len ) ) ; } if ( ndo -> ndo_vflag ) { int naddrs = bp [ 3 ] ; int i ; char c ; if ( version == 2 && ND_TTEST2 ( bp [ 0 ] , len ) ) { struct cksum_vec vec [ 1 ] ; vec [ 0 ] . ptr = bp ; vec [ 0 ] . len = len ; if ( in_cksum ( vec , 1 ) ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } if ( version == 3 && ND_TTEST2 ( bp [ 0 ] , len ) ) { uint16_t cksum = nextproto4_cksum ( ndo , ( const struct ip * ) bp2 , bp , len , len , IPPROTO_VRRP ) ; if ( cksum ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } ND_PRINT ( ( ndo , "", addrs"" ) ) ; if ( naddrs > 1 ) ND_PRINT ( ( ndo , ""(%d)"" , naddrs ) ) ; ND_PRINT ( ( ndo , "":"" ) ) ; c = ' ' ; bp += 8 ; for ( i = 0 ; i < naddrs ; i ++ ) { ND_TCHECK ( bp [ 3 ] ) ; ND_PRINT ( ( ndo , ""%c%s"" , c , ipaddr_string ( ndo , bp ) ) ) ; c = ',' ; bp += 4 ; } if ( version == 2 && auth_type == VRRP_AUTH_SIMPLE ) { ND_TCHECK ( bp [ 7 ] ) ; ND_PRINT ( ( ndo , "" auth \\"""" ) ) ; if ( fn_printn ( ndo , bp , 8 , ndo -> ndo_snapend ) ) { ND_PRINT ( ( ndo , ""\\"""" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""\\"""" ) ) ; } } return ; trunc : ND_PRINT ( ( ndo , ""[|vrrp]"" ) ) ; }
Fixed code:","
void vrrp_print ( netdissect_options * ndo , register const u_char * bp , register u_int len , register const u_char * bp2 , int ttl ) { int version , type , auth_type = VRRP_AUTH_NONE ; const char * type_s ; if (len < 1) { return; } ND_TCHECK ( bp [ 0 ] ) ; version = ( bp [ 0 ] & 0xf0 ) >> 4 ; type = bp [ 0 ] & 0x0f ; type_s = tok2str ( type2str , ""unknown type (%u)"" , type ) ; ND_PRINT ( ( ndo , ""VRRPv%u, %s"" , version , type_s ) ) ; if ( ttl != 255 ) ND_PRINT ( ( ndo , "", (ttl %u)"" , ttl ) ) ; if ( version < 2 || version > 3 || type != VRRP_TYPE_ADVERTISEMENT ) return ; if (len < 3) { return; } ND_TCHECK ( bp [ 2 ] ) ; ND_PRINT ( ( ndo , "", vrid %u, prio %u"" , bp [ 1 ] , bp [ 2 ] ) ) ; if (len < 6) { return; } ND_TCHECK ( bp [ 5 ] ) ; if ( version == 2 ) { auth_type = bp [ 4 ] ; ND_PRINT ( ( ndo , "", authtype %s"" , tok2str ( auth2str , NULL , auth_type ) ) ) ; ND_PRINT ( ( ndo , "", intvl %us, length %u"" , bp [ 5 ] , len ) ) ; } else { uint16_t intvl = ( bp [ 4 ] & 0x0f ) << 8 | bp [ 5 ] ; ND_PRINT ( ( ndo , "", intvl %ucs, length %u"" , intvl , len ) ) ; } if ( ndo -> ndo_vflag ) { int naddrs = bp [ 3 ] ; int i ; char c ; if ( version == 2 && ND_TTEST2 ( bp [ 0 ] , len ) ) { struct cksum_vec vec [ 1 ] ; vec [ 0 ] . ptr = bp ; vec [ 0 ] . len = len ; if ( in_cksum ( vec , 1 ) ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } if ( version == 3 && ND_TTEST2 ( bp [ 0 ] , len ) ) { uint16_t cksum = nextproto4_cksum ( ndo , ( const struct ip * ) bp2 , bp , len , len , IPPROTO_VRRP ) ; if ( cksum ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } if (len < 8) { return; } ND_PRINT ( ( ndo , "", addrs"" ) ) ; if ( naddrs > 1 ) ND_PRINT ( ( ndo , ""(%d)"" , naddrs ) ) ; ND_PRINT ( ( ndo , "":"" ) ) ; c = ' ' ; bp += 8 ; for ( i = 0 ; i < naddrs ; i ++ ) { if (len < 12) { return; } ND_TCHECK ( bp [ 3 ] ) ; ND_PRINT ( ( ndo , ""%c%s"" , c , ipaddr_string ( ndo , bp ) ) ) ; c = ',' ; bp += 4 ; } if ( version == 2 && auth_type == VRRP_AUTH_SIMPLE ) { if (len < 16) { return; } ND_TCHECK ( bp [ 7 ] ) ; ND_PRINT ( ( ndo , "" auth \\"""" ) ) ; if ( fn_printn ( ndo , bp , 8 , ndo -> ndo_snapend ) ) { ND_PRINT ( ( ndo , ""\\"""" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""\\"""" ) ) ; } } return ; trunc : ND_PRINT ( ( ndo , ""[|vrrp]"" ) ) ; }",993,-12.791833315124123,-0.01288200736669096
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
void vrrp_print ( netdissect_options * ndo , register const u_char * bp , register u_int len , register const u_char * bp2 , int ttl ) { int version , type , auth_type = VRRP_AUTH_NONE ; const char * type_s ; ND_TCHECK ( bp [ 0 ] ) ; version = ( bp [ 0 ] & 0xf0 ) >> 4 ; type = bp [ 0 ] & 0x0f ; type_s = tok2str ( type2str , ""unknown type (%u)"" , type ) ; ND_PRINT ( ( ndo , ""VRRPv%u, %s"" , version , type_s ) ) ; if ( ttl != 255 ) ND_PRINT ( ( ndo , "", (ttl %u)"" , ttl ) ) ; if ( version < 2 || version > 3 || type != VRRP_TYPE_ADVERTISEMENT ) return ; ND_TCHECK ( bp [ 2 ] ) ; ND_PRINT ( ( ndo , "", vrid %u, prio %u"" , bp [ 1 ] , bp [ 2 ] ) ) ; ND_TCHECK ( bp [ 5 ] ) ; if ( version == 2 ) { auth_type = bp [ 4 ] ; ND_PRINT ( ( ndo , "", authtype %s"" , tok2str ( auth2str , NULL , auth_type ) ) ) ; ND_PRINT ( ( ndo , "", intvl %us, length %u"" , bp [ 5 ] , len ) ) ; } else { uint16_t intvl = ( bp [ 4 ] & 0x0f ) << 8 | bp [ 5 ] ; ND_PRINT ( ( ndo , "", intvl %ucs, length %u"" , intvl , len ) ) ; } if ( ndo -> ndo_vflag ) { int naddrs = bp [ 3 ] ; int i ; char c ; if ( version == 2 && ND_TTEST2 ( bp [ 0 ] , len ) ) { struct cksum_vec vec [ 1 ] ; vec [ 0 ] . ptr = bp ; vec [ 0 ] . len = len ; if ( in_cksum ( vec , 1 ) ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } if ( version == 3 && ND_TTEST2 ( bp [ 0 ] , len ) ) { uint16_t cksum = nextproto4_cksum ( ndo , ( const struct ip * ) bp2 , bp , len , len , IPPROTO_VRRP ) ; if ( cksum ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } ND_PRINT ( ( ndo , "", addrs"" ) ) ; if ( naddrs > 1 ) ND_PRINT ( ( ndo , ""(%d)"" , naddrs ) ) ; ND_PRINT ( ( ndo , "":"" ) ) ; c = ' ' ; bp += 8 ; for ( i = 0 ; i < naddrs ; i ++ ) { ND_TCHECK ( bp [ 3 ] ) ; ND_PRINT ( ( ndo , ""%c%s"" , c , ipaddr_string ( ndo , bp ) ) ) ; c = ',' ; bp += 4 ; } if ( version == 2 && auth_type == VRRP_AUTH_SIMPLE ) { ND_TCHECK ( bp [ 7 ] ) ; ND_PRINT ( ( ndo , "" auth \\"""" ) ) ; if ( fn_printn ( ndo , bp , 8 , ndo -> ndo_snapend ) ) { ND_PRINT ( ( ndo , ""\\"""" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""\\"""" ) ) ; } } return ; trunc : ND_PRINT ( ( ndo , ""[|vrrp]"" ) ) ; }
Fixed code:","
void vrrp_print ( netdissect_options * ndo , register const u_char * bp , register u_int len , register const u_char * bp2 , int ttl ) { int version , type , auth_type = VRRP_AUTH_NONE ; const char * type_s ; if (len < 1) {  // added to prevent out of bounds read 
    ND_PRINT((ndo, ""[|vrrp]"")); 
    return;
}
ND_TCHECK ( bp [ 0 ] ) ; version = ( bp [ 0 ] & 0xf0 ) >> 4 ; type = bp [ 0 ] & 0x0f ; type_s = tok2str ( type2str , ""unknown type (%u)"" , type ) ; ND_PRINT ( ( ndo , ""VRRPv%u, %s"" , version , type_s ) ) ; if ( ttl != 255 ) ND_PRINT ( ( ndo , "", (ttl %u)"" , ttl ) ) ; if ( version < 2 || version > 3 || type != VRRP_TYPE_ADVERTISEMENT ) return ; ND_TCHECK ( bp [ 2 ] ) ; ND_PRINT ( ( ndo , "", vrid %u, prio %u"" , bp [ 1 ] , bp [ 2 ] ) ) ; ND_TCHECK ( bp [ 5 ] ) ; if ( version == 2 ) { auth_type = bp [ 4 ] ; ND_PRINT ( ( ndo , "", authtype %s"" , tok2str ( auth2str , NULL , auth_type ) ) ) ; ND_PRINT ( ( ndo , "", intvl %us, length %u"" , bp [ 5 ] , len ) ) ; } else { uint16_t intvl = ( bp [ 4 ] & 0x0f ) << 8 | bp [ 5 ] ; ND_PRINT ( ( ndo , "", intvl %ucs, length %u"" , intvl , len ) ) ; } if ( ndo -> ndo_vflag ) { int naddrs = bp [ 3 ] ; int i ; char c ; if ( version == 2 && ND_TTEST2 ( bp [ 0 ] , len ) ) { struct cksum_vec vec [ 1 ] ; vec [ 0 ] . ptr = bp ; vec [ 0 ] . len = len ; if ( in_cksum ( vec , 1 ) ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } if ( version == 3 && ND_TTEST2 ( bp [ 0 ] , len ) ) { uint16_t cksum = nextproto4_cksum ( ndo , ( const struct ip * ) bp2 , bp , len , len , IPPROTO_VRRP ) ; if ( cksum ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } ND_PRINT ( ( ndo , "", addrs"" ) ) ; if ( naddrs > 1 ) ND_PRINT ( ( ndo , ""(%d)"" , naddrs ) ) ; ND_PRINT ( ( ndo , "":"" ) ) ; c = ' ' ; bp += 8 ; for ( i = 0 ; i < naddrs ; i ++ ) { ND_TCHECK ( bp [ 3 ] ) ; ND_PRINT ( ( ndo , ""%c%s"" , c , ipaddr_string ( ndo , bp ) ) ) ; c = ',' ; bp += 4 ; } if ( version == 2 && auth_type == VRRP_AUTH_SIMPLE ) { ND_TCHECK ( bp [ 7 ] ) ; ND_PRINT ( ( ndo , "" auth \\"""" ) ) ; if ( fn_printn ( ndo , bp , 8 , ndo -> ndo_snapend ) ) { ND_PRINT ( ( ndo , ""\\"""" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""\\"""" ) ) ; } } return ; trunc : ND_PRINT ( ( ndo , ""[|vrrp]"" ) ) ; }",976,-27.37298604095369,-0.028046092255075504
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
void vrrp_print ( netdissect_options * ndo , register const u_char * bp , register u_int len , register const u_char * bp2 , int ttl ) { int version , type , auth_type = VRRP_AUTH_NONE ; const char * type_s ; ND_TCHECK ( bp [ 0 ] ) ; version = ( bp [ 0 ] & 0xf0 ) >> 4 ; type = bp [ 0 ] & 0x0f ; type_s = tok2str ( type2str , ""unknown type (%u)"" , type ) ; ND_PRINT ( ( ndo , ""VRRPv%u, %s"" , version , type_s ) ) ; if ( ttl != 255 ) ND_PRINT ( ( ndo , "", (ttl %u)"" , ttl ) ) ; if ( version < 2 || version > 3 || type != VRRP_TYPE_ADVERTISEMENT ) return ; ND_TCHECK ( bp [ 2 ] ) ; ND_PRINT ( ( ndo , "", vrid %u, prio %u"" , bp [ 1 ] , bp [ 2 ] ) ) ; ND_TCHECK ( bp [ 5 ] ) ; if ( version == 2 ) { auth_type = bp [ 4 ] ; ND_PRINT ( ( ndo , "", authtype %s"" , tok2str ( auth2str , NULL , auth_type ) ) ) ; ND_PRINT ( ( ndo , "", intvl %us, length %u"" , bp [ 5 ] , len ) ) ; } else { uint16_t intvl = ( bp [ 4 ] & 0x0f ) << 8 | bp [ 5 ] ; ND_PRINT ( ( ndo , "", intvl %ucs, length %u"" , intvl , len ) ) ; } if ( ndo -> ndo_vflag ) { int naddrs = bp [ 3 ] ; int i ; char c ; if ( version == 2 && ND_TTEST2 ( bp [ 0 ] , len ) ) { struct cksum_vec vec [ 1 ] ; vec [ 0 ] . ptr = bp ; vec [ 0 ] . len = len ; if ( in_cksum ( vec , 1 ) ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } if ( version == 3 && ND_TTEST2 ( bp [ 0 ] , len ) ) { uint16_t cksum = nextproto4_cksum ( ndo , ( const struct ip * ) bp2 , bp , len , len , IPPROTO_VRRP ) ; if ( cksum ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } ND_PRINT ( ( ndo , "", addrs"" ) ) ; if ( naddrs > 1 ) ND_PRINT ( ( ndo , ""(%d)"" , naddrs ) ) ; ND_PRINT ( ( ndo , "":"" ) ) ; c = ' ' ; bp += 8 ; for ( i = 0 ; i < naddrs ; i ++ ) { ND_TCHECK ( bp [ 3 ] ) ; ND_PRINT ( ( ndo , ""%c%s"" , c , ipaddr_string ( ndo , bp ) ) ) ; c = ',' ; bp += 4 ; } if ( version == 2 && auth_type == VRRP_AUTH_SIMPLE ) { ND_TCHECK ( bp [ 7 ] ) ; ND_PRINT ( ( ndo , "" auth \\"""" ) ) ; if ( fn_printn ( ndo , bp , 8 , ndo -> ndo_snapend ) ) { ND_PRINT ( ( ndo , ""\\"""" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""\\"""" ) ) ; } } return ; trunc : ND_PRINT ( ( ndo , ""[|vrrp]"" ) ) ; }
Fixed code:","
void vrrp_print ( netdissect_options * ndo , register const u_char * bp , register u_int len , register const u_char * bp2 , int ttl ) { int version , type , auth_type = VRRP_AUTH_NONE ; const char * type_s ; ND_TCHECK ( bp [ 0 ] ) ; version = ( bp [ 0 ] & 0xf0 ) >> 4 ; type = bp [ 0 ] & 0x0f ; type_s = tok2str ( type2str , ""unknown type (%u)"" , type ) ; ND_PRINT ( ( ndo , ""VRRPv%u, %s"" , version , type_s ) ) ; if ( ttl != 255 ) ND_PRINT ( ( ndo , "", (ttl %u)"" , ttl ) ) ; if ( version < 2 || version > 3 || type != VRRP_TYPE_ADVERTISEMENT ) return ; ND_TCHECK ( bp [ 2 ] ) ; ND_PRINT ( ( ndo , "", vrid %u, prio %u"" , bp [ 1 ] , bp [ 2 ] ) ) ; ND_TCHECK ( bp [ 5 ] ) ; if ( version == 2 ) { auth_type = bp [ 4 ] ; ND_PRINT ( ( ndo , "", authtype %s"" , tok2str ( auth2str , NULL , auth_type ) ) ) ; ND_PRINT ( ( ndo , "", intvl %us, length %u"" , bp [ 5 ] , len ) ) ; } else { uint16_t intvl = ( bp [ 4 ] & 0x0f ) << 8 | bp [ 5 ] ; ND_PRINT ( ( ndo , "", intvl %ucs, length %u"" , intvl , len ) ) ; } if ( ndo -> ndo_vflag ) { int naddrs = bp [ 3 ] ; int i ; char c ; if ( version == 2 && ND_TTEST2 ( bp [ 0 ] , len ) ) { struct cksum_vec vec [ 1 ] ; vec [ 0 ] . ptr = bp ; vec [ 0 ] . len = len ; if ( in_cksum ( vec , 1 ) ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } if ( version == 3 && ND_TTEST2 ( bp [ 0 ] , len ) ) { uint16_t cksum = nextproto4_cksum ( ndo , ( const struct ip * ) bp2 , bp , len , len , IPPROTO_VRRP ) ; if ( cksum ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } ND_PRINT ( ( ndo , "", addrs"" ) ) ; if ( naddrs > 1 ) ND_PRINT ( ( ndo , ""(%d)"" , naddrs ) ) ; ND_PRINT ( ( ndo , "":"" ) ) ; 
//Added an if condition to check for buffer overflow
if(len-8 > 0)
{
  c = ' ' ; bp += 8 ; 
  for ( i = 0 ; i < naddrs ; i ++ ) { ND_TCHECK ( bp [ 3 ] ) ; ND_PRINT ( ( ndo , ""%c%s"" , c , ipaddr_string ( ndo , bp ) ) ) ; c = ',' ; bp += 4 ; } 
}
if ( version == 2 && auth_type == VRRP_AUTH_SIMPLE ) { 
//Added an if condition to check for buffer overflow
  if(len-8 > 0)
  {
    ND_TCHECK ( bp [ 7 ] ) ; ND_PRINT ( ( ndo , "" auth \\"""" ) ) ; 
    if ( fn_printn ( ndo , bp , 8 , ndo -> ndo_snapend ) ) { ND_PRINT ( ( ndo , ""\\"""" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""\\"""" ) ) ; 
  }
} 
return ; 
trunc : ND_PRINT ( ( ndo , ""[|vrrp]""",1000,-49.00743976275859,-0.049007439762758585
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
void vrrp_print ( netdissect_options * ndo , register const u_char * bp , register u_int len , register const u_char * bp2 , int ttl ) { int version , type , auth_type = VRRP_AUTH_NONE ; const char * type_s ; ND_TCHECK ( bp [ 0 ] ) ; version = ( bp [ 0 ] & 0xf0 ) >> 4 ; type = bp [ 0 ] & 0x0f ; type_s = tok2str ( type2str , ""unknown type (%u)"" , type ) ; ND_PRINT ( ( ndo , ""VRRPv%u, %s"" , version , type_s ) ) ; if ( ttl != 255 ) ND_PRINT ( ( ndo , "", (ttl %u)"" , ttl ) ) ; if ( version < 2 || version > 3 || type != VRRP_TYPE_ADVERTISEMENT ) return ; ND_TCHECK ( bp [ 2 ] ) ; ND_PRINT ( ( ndo , "", vrid %u, prio %u"" , bp [ 1 ] , bp [ 2 ] ) ) ; ND_TCHECK ( bp [ 5 ] ) ; if ( version == 2 ) { auth_type = bp [ 4 ] ; ND_PRINT ( ( ndo , "", authtype %s"" , tok2str ( auth2str , NULL , auth_type ) ) ) ; ND_PRINT ( ( ndo , "", intvl %us, length %u"" , bp [ 5 ] , len ) ) ; } else { uint16_t intvl = ( bp [ 4 ] & 0x0f ) << 8 | bp [ 5 ] ; ND_PRINT ( ( ndo , "", intvl %ucs, length %u"" , intvl , len ) ) ; } if ( ndo -> ndo_vflag ) { int naddrs = bp [ 3 ] ; int i ; char c ; if ( version == 2 && ND_TTEST2 ( bp [ 0 ] , len ) ) { struct cksum_vec vec [ 1 ] ; vec [ 0 ] . ptr = bp ; vec [ 0 ] . len = len ; if ( in_cksum ( vec , 1 ) ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } if ( version == 3 && ND_TTEST2 ( bp [ 0 ] , len ) ) { uint16_t cksum = nextproto4_cksum ( ndo , ( const struct ip * ) bp2 , bp , len , len , IPPROTO_VRRP ) ; if ( cksum ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } ND_PRINT ( ( ndo , "", addrs"" ) ) ; if ( naddrs > 1 ) ND_PRINT ( ( ndo , ""(%d)"" , naddrs ) ) ; ND_PRINT ( ( ndo , "":"" ) ) ; c = ' ' ; bp += 8 ; for ( i = 0 ; i < naddrs ; i ++ ) { ND_TCHECK ( bp [ 3 ] ) ; ND_PRINT ( ( ndo , ""%c%s"" , c , ipaddr_string ( ndo , bp ) ) ) ; c = ',' ; bp += 4 ; } if ( version == 2 && auth_type == VRRP_AUTH_SIMPLE ) { ND_TCHECK ( bp [ 7 ] ) ; ND_PRINT ( ( ndo , "" auth \\"""" ) ) ; if ( fn_printn ( ndo , bp , 8 , ndo -> ndo_snapend ) ) { ND_PRINT ( ( ndo , ""\\"""" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""\\"""" ) ) ; } } return ; trunc : ND_PRINT ( ( ndo , ""[|vrrp]"" ) ) ; }
Fixed code:","
void vrrp_print ( netdissect_options * ndo , register const u_char * bp , register u_int len , register const u_char * bp2 , int ttl ) { int version , type , auth_type = VRRP_AUTH_NONE ; const char * type_s ; ND_TCHECK ( bp [ 0 ] ) ; version = ( bp [ 0 ] & 0xf0 ) >> 4 ; type = bp [ 0 ] & 0x0f ; type_s = tok2str ( type2str , ""unknown type (%u)"" , type ) ; ND_PRINT ( ( ndo , ""VRRPv%u, %s"" , version , type_s ) ) ; if ( ttl != 255 ) ND_PRINT ( ( ndo , "", (ttl %u)"" , ttl ) ) ; if ( version < 2 || version > 3 || type != VRRP_TYPE_ADVERTISEMENT ) return ; ND_TCHECK ( bp [ 2 ] ) ; ND_PRINT ( ( ndo , "", vrid %u, prio %u"" , bp [ 1 ] , bp [ 2 ] ) ) ; ND_TCHECK ( bp [ 5 ] ) ; if ( version == 2 ) { auth_type = bp [ 4 ] ; ND_PRINT ( ( ndo , "", authtype %s"" , tok2str ( auth2str , NULL , auth_type ) ) ) ; ND_PRINT ( ( ndo , "", intvl %us, length %u"" , bp [ 5 ] , len ) ) ; } else { uint16_t intvl = ( bp [ 4 ] & 0x0f ) << 8 | bp [ 5 ] ; ND_PRINT ( ( ndo , "", intvl %ucs, length %u"" , intvl , len ) ) ; } if ( ndo -> ndo_vflag ) { int naddrs = bp [ 3 ] ; int i ; char c ; if ( version == 2 && ND_TTEST2 ( bp [ 0 ] , len ) ) { struct cksum_vec vec [ 1 ] ; vec [ 0 ] . ptr = bp ; vec [ 0 ] . len = len ; if ( in_cksum ( vec , 1 ) ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } if ( version == 3 && ND_TTEST2 ( bp [ 0 ] , len ) ) { uint16_t cksum = nextproto4_cksum ( ndo , ( const struct ip * ) bp2 , bp , len , len , IPPROTO_VRRP ) ; if ( cksum ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } ND_PRINT ( ( ndo , "", addrs"" ) ) ; if ( naddrs > 1 ) ND_PRINT ( ( ndo , ""(%d)"" , naddrs ) ) ; ND_PRINT ( ( ndo , "":"" ) ) ; c = ' ' ; bp += 8 ; if(len < (naddrs * 4) + 8) { ND_PRINT ( ( ndo , ""[|vrrp]"") ); return; } for ( i = 0 ; i < naddrs ; i ++ ) { ND_TCHECK ( bp [ 3 ] ) ; ND_PRINT ( ( ndo , ""%c%s"" , c , ipaddr_string ( ndo , bp ) ) ) ; c = ',' ; bp += 4 ; } if ( version == 2 && auth_type == VRRP_AUTH_SIMPLE ) { ND_TCHECK ( bp [ 7 ] ) ; ND_PRINT ( ( ndo , "" auth \\"""" ) ) ; if ( fn_printn ( ndo , bp , 8 , ndo -> ndo_snapend ) ) { ND_PRINT ( ( ndo , ""\\"""" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""\\"""" ) ) ; } } return ; trunc : ND_PRINT ( ( ndo , ""[|vrrp]"" ) ) ; }",968,-20.860991432306623,-0.021550610983787834
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
void vrrp_print ( netdissect_options * ndo , register const u_char * bp , register u_int len , register const u_char * bp2 , int ttl ) { int version , type , auth_type = VRRP_AUTH_NONE ; const char * type_s ; ND_TCHECK ( bp [ 0 ] ) ; version = ( bp [ 0 ] & 0xf0 ) >> 4 ; type = bp [ 0 ] & 0x0f ; type_s = tok2str ( type2str , ""unknown type (%u)"" , type ) ; ND_PRINT ( ( ndo , ""VRRPv%u, %s"" , version , type_s ) ) ; if ( ttl != 255 ) ND_PRINT ( ( ndo , "", (ttl %u)"" , ttl ) ) ; if ( version < 2 || version > 3 || type != VRRP_TYPE_ADVERTISEMENT ) return ; ND_TCHECK ( bp [ 2 ] ) ; ND_PRINT ( ( ndo , "", vrid %u, prio %u"" , bp [ 1 ] , bp [ 2 ] ) ) ; ND_TCHECK ( bp [ 5 ] ) ; if ( version == 2 ) { auth_type = bp [ 4 ] ; ND_PRINT ( ( ndo , "", authtype %s"" , tok2str ( auth2str , NULL , auth_type ) ) ) ; ND_PRINT ( ( ndo , "", intvl %us, length %u"" , bp [ 5 ] , len ) ) ; } else { uint16_t intvl = ( bp [ 4 ] & 0x0f ) << 8 | bp [ 5 ] ; ND_PRINT ( ( ndo , "", intvl %ucs, length %u"" , intvl , len ) ) ; } if ( ndo -> ndo_vflag ) { int naddrs = bp [ 3 ] ; int i ; char c ; if ( version == 2 && ND_TTEST2 ( bp [ 0 ] , len ) ) { struct cksum_vec vec [ 1 ] ; vec [ 0 ] . ptr = bp ; vec [ 0 ] . len = len ; if ( in_cksum ( vec , 1 ) ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } if ( version == 3 && ND_TTEST2 ( bp [ 0 ] , len ) ) { uint16_t cksum = nextproto4_cksum ( ndo , ( const struct ip * ) bp2 , bp , len , len , IPPROTO_VRRP ) ; if ( cksum ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } ND_PRINT ( ( ndo , "", addrs"" ) ) ; if ( naddrs > 1 ) ND_PRINT ( ( ndo , ""(%d)"" , naddrs ) ) ; ND_PRINT ( ( ndo , "":"" ) ) ; c = ' ' ; bp += 8 ; for ( i = 0 ; i < naddrs ; i ++ ) { ND_TCHECK ( bp [ 3 ] ) ; ND_PRINT ( ( ndo , ""%c%s"" , c , ipaddr_string ( ndo , bp ) ) ) ; c = ',' ; bp += 4 ; } if ( version == 2 && auth_type == VRRP_AUTH_SIMPLE ) { ND_TCHECK ( bp [ 7 ] ) ; ND_PRINT ( ( ndo , "" auth \\"""" ) ) ; if ( fn_printn ( ndo , bp , 8 , ndo -> ndo_snapend ) ) { ND_PRINT ( ( ndo , ""\\"""" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""\\"""" ) ) ; } } return ; trunc : ND_PRINT ( ( ndo , ""[|vrrp]"" ) ) ; }
Fixed code:","
void vrrp_print ( netdissect_options * ndo , register const u_char * bp , register u_int len , register const u_char * bp2 , int ttl ) { int version , type , auth_type = VRRP_AUTH_NONE ; const char * type_s ; ND_TCHECK ( bp [ 0 ] ) ; version = ( bp [ 0 ] & 0xf0 ) >> 4 ; type = bp [ 0 ] & 0x0f ; type_s = tok2str ( type2str , ""unknown type (%u)"" , type ) ; ND_PRINT ( ( ndo , ""VRRPv%u, %s"" , version , type_s ) ) ; if ( ttl != 255 ) ND_PRINT ( ( ndo , "", (ttl %u)"" , ttl ) ) ; if ( version < 2 || version > 3 || type != VRRP_TYPE_ADVERTISEMENT ) return ; ND_TCHECK ( bp [ 2 ] ) ; ND_PRINT ( ( ndo , "", vrid %u, prio %u"" , bp [ 1 ] , bp [ 2 ] ) ) ; ND_TCHECK ( bp [ 5 ] ) ; if ( version == 2 ) { auth_type = bp [ 4 ] ; ND_PRINT ( ( ndo , "", authtype %s"" , tok2str ( auth2str , NULL , auth_type ) ) ) ; ND_PRINT ( ( ndo , "", intvl %us, length %u"" , bp [ 5 ] , len ) ) ; } else { uint16_t intvl = ( bp [ 4 ] & 0x0f ) << 8 | bp [ 5 ] ; ND_PRINT ( ( ndo , "", intvl %ucs, length %u"" , intvl , len ) ) ; } if ( ndo -> ndo_vflag ) { int naddrs = bp [ 3 ] ; int i ; char c ; if ( version == 2 ) { if (ND_TTEST2 ( bp [ 0 ] , len ) && len >= 8) { struct cksum_vec vec [ 1 ] ; vec [ 0 ] . ptr = bp ; vec [ 0 ] . len = len ; if ( in_cksum ( vec , 1 ) ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } } if ( version == 3 ) { if (ND_TTEST2 ( bp [ 0 ] , len ) && len >= 8) { uint16_t cksum = nextproto4_cksum ( ndo , ( const struct ip * ) bp2 , bp , len , len , IPPROTO_VRRP ) ; if ( cksum ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } } ND_PRINT ( ( ndo , "", addrs"" ) ) ; if ( naddrs > 1 ) ND_PRINT ( ( ndo , ""(%d)"" , naddrs ) ) ; ND_PRINT ( ( ndo , "":"" ) ) ; c = ' ' ; bp += 8 ; for ( i = 0 ; i < naddrs ; i ++ ) { if (ND_TTEST2 ( bp [ 3 ] , 4)) { ND_PRINT ( ( ndo , ""%c%s"" , c , ipaddr_string ( ndo , bp ) ) ) ; } c = ',' ; bp += 4 ; } if ( version == 2 && auth_type == VRRP_AUTH_SIMPLE ) { if (ND_TTEST2 ( bp [ 7 ] , 8) && len >= 16) { ND_PRINT ( ( ndo , "" auth \\"""" ) ) ; if ( fn_printn ( ndo , bp , 8 , ndo -> ndo_snapend ) ) { ND_PRINT ( ( ndo , ""\\"""" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""\\"""" ) ) ; } } } return ; trunc : ND_PRINT ( ( ndo , ""[|vrrp]"" ) ) ; }",966,-25.36170530038353,-0.02625435331302643
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
void vrrp_print ( netdissect_options * ndo , register const u_char * bp , register u_int len , register const u_char * bp2 , int ttl ) { int version , type , auth_type = VRRP_AUTH_NONE ; const char * type_s ; ND_TCHECK ( bp [ 0 ] ) ; version = ( bp [ 0 ] & 0xf0 ) >> 4 ; type = bp [ 0 ] & 0x0f ; type_s = tok2str ( type2str , ""unknown type (%u)"" , type ) ; ND_PRINT ( ( ndo , ""VRRPv%u, %s"" , version , type_s ) ) ; if ( ttl != 255 ) ND_PRINT ( ( ndo , "", (ttl %u)"" , ttl ) ) ; if ( version < 2 || version > 3 || type != VRRP_TYPE_ADVERTISEMENT ) return ; ND_TCHECK ( bp [ 2 ] ) ; ND_PRINT ( ( ndo , "", vrid %u, prio %u"" , bp [ 1 ] , bp [ 2 ] ) ) ; ND_TCHECK ( bp [ 5 ] ) ; if ( version == 2 ) { auth_type = bp [ 4 ] ; ND_PRINT ( ( ndo , "", authtype %s"" , tok2str ( auth2str , NULL , auth_type ) ) ) ; ND_PRINT ( ( ndo , "", intvl %us, length %u"" , bp [ 5 ] , len ) ) ; } else { uint16_t intvl = ( bp [ 4 ] & 0x0f ) << 8 | bp [ 5 ] ; ND_PRINT ( ( ndo , "", intvl %ucs, length %u"" , intvl , len ) ) ; } if ( ndo -> ndo_vflag ) { int naddrs = bp [ 3 ] ; int i ; char c ; if ( version == 2 && ND_TTEST2 ( bp [ 0 ] , len ) ) { struct cksum_vec vec [ 1 ] ; vec [ 0 ] . ptr = bp ; vec [ 0 ] . len = len ; if ( in_cksum ( vec , 1 ) ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } if ( version == 3 && ND_TTEST2 ( bp [ 0 ] , len ) ) { uint16_t cksum = nextproto4_cksum ( ndo , ( const struct ip * ) bp2 , bp , len , len , IPPROTO_VRRP ) ; if ( cksum ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } ND_PRINT ( ( ndo , "", addrs"" ) ) ; if ( naddrs > 1 ) ND_PRINT ( ( ndo , ""(%d)"" , naddrs ) ) ; ND_PRINT ( ( ndo , "":"" ) ) ; c = ' ' ; bp += 8 ; for ( i = 0 ; i < naddrs ; i ++ ) { ND_TCHECK ( bp [ 3 ] ) ; ND_PRINT ( ( ndo , ""%c%s"" , c , ipaddr_string ( ndo , bp ) ) ) ; c = ',' ; bp += 4 ; } if ( version == 2 && auth_type == VRRP_AUTH_SIMPLE ) { ND_TCHECK ( bp [ 7 ] ) ; ND_PRINT ( ( ndo , "" auth \\"""" ) ) ; if ( fn_printn ( ndo , bp , 8 , ndo -> ndo_snapend ) ) { ND_PRINT ( ( ndo , ""\\"""" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""\\"""" ) ) ; } } return ; trunc : ND_PRINT ( ( ndo , ""[|vrrp]"" ) ) ; }
Fixed code:","
void vrrp_print ( netdissect_options * ndo , register const u_char * bp , register u_int len , register const u_char * bp2 , int ttl ) { int version , type , auth_type = VRRP_AUTH_NONE ; const char * type_s ; if (len < 1) { ND_PRINT((ndo, ""[|vrrp]"")); return; } ND_TCHECK ( bp [ 0 ] ) ; version = ( bp [ 0 ] & 0xf0 ) >> 4 ; type = bp [ 0 ] & 0x0f ; type_s = tok2str ( type2str , ""unknown type (%u)"" , type ) ; ND_PRINT ( ( ndo , ""VRRPv%u, %s"" , version , type_s ) ) ; if ( ttl != 255 ) ND_PRINT ( ( ndo , "", (ttl %u)"" , ttl ) ) ; if ( version < 2 || version > 3 || type != VRRP_TYPE_ADVERTISEMENT ) return ; ND_TCHECK ( bp [ 2 ] ) ; ND_PRINT ( ( ndo , "", vrid %u, prio %u"" , bp [ 1 ] , bp [ 2 ] ) ) ; ND_TCHECK ( bp [ 5 ] ) ; if ( version == 2 ) { auth_type = bp [ 4 ] ; ND_PRINT ( ( ndo , "", authtype %s"" , tok2str ( auth2str , NULL , auth_type ) ) ) ; ND_PRINT ( ( ndo , "", intvl %us, length %u"" , bp [ 5 ] , len ) ) ; } else { uint16_t intvl = ( bp [ 4 ] & 0x0f ) << 8 | bp [ 5 ] ; ND_PRINT ( ( ndo , "", intvl %ucs, length %u"" , intvl , len ) ) ; } if ( ndo -> ndo_vflag ) { int naddrs = bp [ 3 ] ; int i ; char c ; if ( version == 2 && ND_TTEST2 ( bp [ 0 ] , len ) ) { struct cksum_vec vec [ 1 ] ; vec [ 0 ] . ptr = bp ; vec [ 0 ] . len = len ; if ( in_cksum ( vec , 1 ) ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } if ( version == 3 && ND_TTEST2 ( bp [ 0 ] , len ) ) { uint16_t cksum = nextproto4_cksum ( ndo , ( const struct ip * ) bp2 , bp , len , len , IPPROTO_VRRP ) ; if ( cksum ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } ND_PRINT ( ( ndo , "", addrs"" ) ) ; if ( naddrs > 1 ) ND_PRINT ( ( ndo , ""(%d)"" , naddrs ) ) ; ND_PRINT ( ( ndo , "":"" ) ) ; c = ' ' ; bp += 8 ; for ( i = 0 ; i < naddrs ; i ++ ) { if (len < (bp + 4 - bp)) { ND_PRINT((ndo, ""[|vrrp]"")); return; } ND_TCHECK ( bp [ 3 ] ) ; ND_PRINT ( ( ndo , ""%c%s"" , c , ipaddr_string ( ndo , bp ) ) ) ; c = ',' ; bp += 4 ; } if ( version == 2 && auth_type == VRRP_AUTH_SIMPLE ) { if (len < (bp + 8 - bp)) { ND_PRINT((ndo, ""[|vrrp]"")); return; } ND_TCHECK ( bp [ 7 ] ) ; ND_PRINT ( ( ndo , "" auth \\"""" ) ) ; if ( fn_printn ( ndo , bp , 8 , ndo -> ndo_snapend ) ) { ND_PRINT ( ( ndo , ""\\"""" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""\\"""" ) ) ; } }",1000,-12.294749660838612,-0.012294749660838612
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
void vrrp_print ( netdissect_options * ndo , register const u_char * bp , register u_int len , register const u_char * bp2 , int ttl ) { int version , type , auth_type = VRRP_AUTH_NONE ; const char * type_s ; ND_TCHECK ( bp [ 0 ] ) ; version = ( bp [ 0 ] & 0xf0 ) >> 4 ; type = bp [ 0 ] & 0x0f ; type_s = tok2str ( type2str , ""unknown type (%u)"" , type ) ; ND_PRINT ( ( ndo , ""VRRPv%u, %s"" , version , type_s ) ) ; if ( ttl != 255 ) ND_PRINT ( ( ndo , "", (ttl %u)"" , ttl ) ) ; if ( version < 2 || version > 3 || type != VRRP_TYPE_ADVERTISEMENT ) return ; ND_TCHECK ( bp [ 2 ] ) ; ND_PRINT ( ( ndo , "", vrid %u, prio %u"" , bp [ 1 ] , bp [ 2 ] ) ) ; ND_TCHECK ( bp [ 5 ] ) ; if ( version == 2 ) { auth_type = bp [ 4 ] ; ND_PRINT ( ( ndo , "", authtype %s"" , tok2str ( auth2str , NULL , auth_type ) ) ) ; ND_PRINT ( ( ndo , "", intvl %us, length %u"" , bp [ 5 ] , len ) ) ; } else { uint16_t intvl = ( bp [ 4 ] & 0x0f ) << 8 | bp [ 5 ] ; ND_PRINT ( ( ndo , "", intvl %ucs, length %u"" , intvl , len ) ) ; } if ( ndo -> ndo_vflag ) { int naddrs = bp [ 3 ] ; int i ; char c ; if ( version == 2 && ND_TTEST2 ( bp [ 0 ] , len ) ) { struct cksum_vec vec [ 1 ] ; vec [ 0 ] . ptr = bp ; vec [ 0 ] . len = len ; if ( in_cksum ( vec , 1 ) ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } if ( version == 3 && ND_TTEST2 ( bp [ 0 ] , len ) ) { uint16_t cksum = nextproto4_cksum ( ndo , ( const struct ip * ) bp2 , bp , len , len , IPPROTO_VRRP ) ; if ( cksum ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } ND_PRINT ( ( ndo , "", addrs"" ) ) ; if ( naddrs > 1 ) ND_PRINT ( ( ndo , ""(%d)"" , naddrs ) ) ; ND_PRINT ( ( ndo , "":"" ) ) ; c = ' ' ; bp += 8 ; for ( i = 0 ; i < naddrs ; i ++ ) { ND_TCHECK ( bp [ 3 ] ) ; ND_PRINT ( ( ndo , ""%c%s"" , c , ipaddr_string ( ndo , bp ) ) ) ; c = ',' ; bp += 4 ; } if ( version == 2 && auth_type == VRRP_AUTH_SIMPLE ) { ND_TCHECK ( bp [ 7 ] ) ; ND_PRINT ( ( ndo , "" auth \\"""" ) ) ; if ( fn_printn ( ndo , bp , 8 , ndo -> ndo_snapend ) ) { ND_PRINT ( ( ndo , ""\\"""" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""\\"""" ) ) ; } } return ; trunc : ND_PRINT ( ( ndo , ""[|vrrp]"" ) ) ; }
Fixed code:","
void vrrp_print ( netdissect_options * ndo , register const u_char * bp , register u_int len , register const u_char * bp2 , int ttl ) { int version , type , auth_type = VRRP_AUTH_NONE ; const char * type_s ; ND_TCHECK ( bp [ 0 ] ) ; version = ( bp [ 0 ] & 0xf0 ) >> 4 ; type = bp [ 0 ] & 0x0f ; type_s = tok2str ( type2str , ""unknown type (%u)"" , type ) ; ND_PRINT ( ( ndo , ""VRRPv%u, %s"" , version , type_s ) ) ; if ( ttl != 255 ) ND_PRINT ( ( ndo , "", (ttl %u)"" , ttl ) ) ; if ( version < 2 || version > 3 || type != VRRP_TYPE_ADVERTISEMENT ) return ; ND_TCHECK ( bp [ 2 ] ) ; ND_PRINT ( ( ndo , "", vrid %u, prio %u"" , bp [ 1 ] , bp [ 2 ] ) ) ; ND_TCHECK ( bp [ 5 ] ) ; if ( version == 2 ) { auth_type = bp [ 4 ] ; ND_PRINT ( ( ndo , "", authtype %s"" , tok2str ( auth2str , NULL , auth_type ) ) ) ; ND_PRINT ( ( ndo , "", intvl %us, length %u"" , bp [ 5 ] , len ) ) ; } else { uint16_t intvl = ( bp [ 4 ] & 0x0f ) << 8 | bp [ 5 ] ; ND_PRINT ( ( ndo , "", intvl %ucs, length %u"" , intvl , len ) ) ; } if ( ndo -> ndo_vflag ) { int naddrs = bp [ 3 ] ; int i ; char c ; if ( version == 2 && ND_TTEST2 ( bp [ 0 ] , len ) ) { struct cksum_vec vec [ 1 ] ; vec [ 0 ] . ptr = bp ; vec [ 0 ] . len = len ; if ( in_cksum ( vec , 1 ) ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } if ( version == 3 && ND_TTEST2 ( bp [ 0 ] , len ) ) { uint16_t cksum = nextproto4_cksum ( ndo , ( const struct ip * ) bp2 , bp , len , len , IPPROTO_VRRP ) ; if ( cksum ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } ND_PRINT ( ( ndo , "", addrs"" ) ) ; if ( naddrs > 1 ) ND_PRINT ( ( ndo , ""(%d)"" , naddrs ) ) ; ND_PRINT ( ( ndo , "":"" ) ) ; c = ' ' ; bp += 8 ; for ( i = 0 ; i < naddrs && (bp + 4) <= ndo->ndo_snapend ; i ++ ) { ND_TCHECK ( bp [ 3 ] ) ; ND_PRINT ( ( ndo , ""%c%s"" , c , ipaddr_string ( ndo , bp ) ) ) ; c = ',' ; bp += 4 ; } if ( version == 2 && auth_type == VRRP_AUTH_SIMPLE ) { ND_TCHECK ( bp [ 7 ] ) ; ND_PRINT ( ( ndo , "" auth \\"""" ) ) ; if ( fn_printn ( ndo , bp , 8 , ndo -> ndo_snapend ) ) { ND_PRINT ( ( ndo , ""\\"""" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""\\"""" ) ) ; } } return ; trunc : ND_PRINT ( ( ndo , ""[|vrrp]"" ) ) ; }",948,-13.66876863451138,-0.014418532314885423
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
void vrrp_print ( netdissect_options * ndo , register const u_char * bp , register u_int len , register const u_char * bp2 , int ttl ) { int version , type , auth_type = VRRP_AUTH_NONE ; const char * type_s ; ND_TCHECK ( bp [ 0 ] ) ; version = ( bp [ 0 ] & 0xf0 ) >> 4 ; type = bp [ 0 ] & 0x0f ; type_s = tok2str ( type2str , ""unknown type (%u)"" , type ) ; ND_PRINT ( ( ndo , ""VRRPv%u, %s"" , version , type_s ) ) ; if ( ttl != 255 ) ND_PRINT ( ( ndo , "", (ttl %u)"" , ttl ) ) ; if ( version < 2 || version > 3 || type != VRRP_TYPE_ADVERTISEMENT ) return ; ND_TCHECK ( bp [ 2 ] ) ; ND_PRINT ( ( ndo , "", vrid %u, prio %u"" , bp [ 1 ] , bp [ 2 ] ) ) ; ND_TCHECK ( bp [ 5 ] ) ; if ( version == 2 ) { auth_type = bp [ 4 ] ; ND_PRINT ( ( ndo , "", authtype %s"" , tok2str ( auth2str , NULL , auth_type ) ) ) ; ND_PRINT ( ( ndo , "", intvl %us, length %u"" , bp [ 5 ] , len ) ) ; } else { uint16_t intvl = ( bp [ 4 ] & 0x0f ) << 8 | bp [ 5 ] ; ND_PRINT ( ( ndo , "", intvl %ucs, length %u"" , intvl , len ) ) ; } if ( ndo -> ndo_vflag ) { int naddrs = bp [ 3 ] ; int i ; char c ; if ( version == 2 && ND_TTEST2 ( bp [ 0 ] , len ) ) { struct cksum_vec vec [ 1 ] ; vec [ 0 ] . ptr = bp ; vec [ 0 ] . len = len ; if ( in_cksum ( vec , 1 ) ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } if ( version == 3 && ND_TTEST2 ( bp [ 0 ] , len ) ) { uint16_t cksum = nextproto4_cksum ( ndo , ( const struct ip * ) bp2 , bp , len , len , IPPROTO_VRRP ) ; if ( cksum ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } ND_PRINT ( ( ndo , "", addrs"" ) ) ; if ( naddrs > 1 ) ND_PRINT ( ( ndo , ""(%d)"" , naddrs ) ) ; ND_PRINT ( ( ndo , "":"" ) ) ; c = ' ' ; bp += 8 ; for ( i = 0 ; i < naddrs ; i ++ ) { ND_TCHECK ( bp [ 3 ] ) ; ND_PRINT ( ( ndo , ""%c%s"" , c , ipaddr_string ( ndo , bp ) ) ) ; c = ',' ; bp += 4 ; } if ( version == 2 && auth_type == VRRP_AUTH_SIMPLE ) { ND_TCHECK ( bp [ 7 ] ) ; ND_PRINT ( ( ndo , "" auth \\"""" ) ) ; if ( fn_printn ( ndo , bp , 8 , ndo -> ndo_snapend ) ) { ND_PRINT ( ( ndo , ""\\"""" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""\\"""" ) ) ; } } return ; trunc : ND_PRINT ( ( ndo , ""[|vrrp]"" ) ) ; }
Fixed code:","
void vrrp_print ( netdissect_options * ndo , register const u_char * bp , register u_int len , register const u_char * bp2 , int ttl ) { int version , type , auth_type = VRRP_AUTH_NONE ; const char * type_s ; ND_TCHECK ( bp [ 0 ] ) ; version = ( bp [ 0 ] & 0xf0 ) >> 4 ; type = bp [ 0 ] & 0x0f ; type_s = tok2str ( type2str , ""unknown type (%u)"" , type ) ; ND_PRINT ( ( ndo , ""VRRPv%u, %s"" , version , type_s ) ) ; if ( ttl != 255 ) ND_PRINT ( ( ndo , "", (ttl %u)"" , ttl ) ) ; if ( version < 2 || version > 3 || type != VRRP_TYPE_ADVERTISEMENT ) return ; ND_TCHECK ( bp [ 2 ] ) ; ND_PRINT ( ( ndo , "", vrid %u, prio %u"" , bp [ 1 ] , bp [ 2 ] ) ) ; ND_TCHECK ( bp [ 5 ] ) ; if ( version == 2 ) { auth_type = bp [ 4 ] ; ND_PRINT ( ( ndo , "", authtype %s"" , tok2str ( auth2str , NULL , auth_type ) ) ) ; ND_PRINT ( ( ndo , "", intvl %us, length %u"" , bp [ 5 ] , len ) ) ; } else { uint16_t intvl = ( bp [ 4 ] & 0x0f ) << 8 | bp [ 5 ] ; ND_PRINT ( ( ndo , "", intvl %ucs, length %u"" , intvl , len ) ) ; } if ( ndo -> ndo_vflag ) { int naddrs = bp [ 3 ] ; int i ; char c ; if ( ND_TTEST2 ( bp [ 0 ] , len ) ) {  if (version == 2){ 
 struct cksum_vec vec [ 1 ] ; vec [ 0 ] . ptr = bp ; vec [ 0 ] . len = len ; if ( in_cksum ( vec , 1 ) ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; 
} else if (version == 3) {
 uint16_t cksum = nextproto4_cksum ( ndo , ( const struct ip * ) bp2 , bp , len , len , IPPROTO_VRRP ) ; if ( cksum ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; 
} 
}
 ND_PRINT ( ( ndo , "", addrs"" ) ) ; if ( naddrs > 1 ) ND_PRINT ( ( ndo , ""(%d)"" , naddrs ) ) ; ND_PRINT ( ( ndo , "":"" ) ) ; c = ' ' ; bp += 8 ; for ( i = 0 ; i < naddrs ; i ++ ) { ND_TCHECK ( bp [ 3 ] ) ; ND_PRINT ( ( ndo , ""%c%s"" , c , ipaddr_string ( ndo , bp ) ) ) ; c = ',' ; bp += 4 ; } if ( version == 2 && auth_type == VRRP_AUTH_SIMPLE ) { ND_TCHECK2 ( bp [ 7 ] , len ) ; ND_PRINT ( ( ndo , "" auth \\"""" ) ) ; if ( fn_printn ( ndo , bp , 8 , ndo -> ndo_snapend ) ) { ND_PRINT ( ( ndo , ""\\"""" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""\\"""" ) ) ; } } return ; trunc : ND_PRINT ( ( ndo , ""[|vrrp]"" ) ) ; }",936,-34.01131848302802,-0.03633687872118378
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
void vrrp_print ( netdissect_options * ndo , register const u_char * bp , register u_int len , register const u_char * bp2 , int ttl ) { int version , type , auth_type = VRRP_AUTH_NONE ; const char * type_s ; ND_TCHECK ( bp [ 0 ] ) ; version = ( bp [ 0 ] & 0xf0 ) >> 4 ; type = bp [ 0 ] & 0x0f ; type_s = tok2str ( type2str , ""unknown type (%u)"" , type ) ; ND_PRINT ( ( ndo , ""VRRPv%u, %s"" , version , type_s ) ) ; if ( ttl != 255 ) ND_PRINT ( ( ndo , "", (ttl %u)"" , ttl ) ) ; if ( version < 2 || version > 3 || type != VRRP_TYPE_ADVERTISEMENT ) return ; ND_TCHECK ( bp [ 2 ] ) ; ND_PRINT ( ( ndo , "", vrid %u, prio %u"" , bp [ 1 ] , bp [ 2 ] ) ) ; ND_TCHECK ( bp [ 5 ] ) ; if ( version == 2 ) { auth_type = bp [ 4 ] ; ND_PRINT ( ( ndo , "", authtype %s"" , tok2str ( auth2str , NULL , auth_type ) ) ) ; ND_PRINT ( ( ndo , "", intvl %us, length %u"" , bp [ 5 ] , len ) ) ; } else { uint16_t intvl = ( bp [ 4 ] & 0x0f ) << 8 | bp [ 5 ] ; ND_PRINT ( ( ndo , "", intvl %ucs, length %u"" , intvl , len ) ) ; } if ( ndo -> ndo_vflag ) { int naddrs = bp [ 3 ] ; int i ; char c ; if ( version == 2 && ND_TTEST2 ( bp [ 0 ] , len ) ) { struct cksum_vec vec [ 1 ] ; vec [ 0 ] . ptr = bp ; vec [ 0 ] . len = len ; if ( in_cksum ( vec , 1 ) ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } if ( version == 3 && ND_TTEST2 ( bp [ 0 ] , len ) ) { uint16_t cksum = nextproto4_cksum ( ndo , ( const struct ip * ) bp2 , bp , len , len , IPPROTO_VRRP ) ; if ( cksum ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } ND_PRINT ( ( ndo , "", addrs"" ) ) ; if ( naddrs > 1 ) ND_PRINT ( ( ndo , ""(%d)"" , naddrs ) ) ; ND_PRINT ( ( ndo , "":"" ) ) ; c = ' ' ; bp += 8 ; for ( i = 0 ; i < naddrs ; i ++ ) { ND_TCHECK ( bp [ 3 ] ) ; ND_PRINT ( ( ndo , ""%c%s"" , c , ipaddr_string ( ndo , bp ) ) ) ; c = ',' ; bp += 4 ; } if ( version == 2 && auth_type == VRRP_AUTH_SIMPLE ) { ND_TCHECK ( bp [ 7 ] ) ; ND_PRINT ( ( ndo , "" auth \\"""" ) ) ; if ( fn_printn ( ndo , bp , 8 , ndo -> ndo_snapend ) ) { ND_PRINT ( ( ndo , ""\\"""" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""\\"""" ) ) ; } } return ; trunc : ND_PRINT ( ( ndo , ""[|vrrp]"" ) ) ; }
Fixed code:","
void vrrp_print ( netdissect_options * ndo , register const u_char * bp , register u_int len , register const u_char * bp2 , int ttl ) { int version , type , auth_type = VRRP_AUTH_NONE ; const char * type_s ; if (len < 8) { ND_PRINT((ndo, ""[|vrrp]"")); return; } ND_TCHECK ( bp [ 0 ] ) ; version = ( bp [ 0 ] & 0xf0 ) >> 4 ; type = bp [ 0 ] & 0x0f ; type_s = tok2str ( type2str , ""unknown type (%u)"" , type ) ; ND_PRINT ( ( ndo , ""VRRPv%u, %s"" , version , type_s ) ) ; if ( ttl != 255 ) ND_PRINT ( ( ndo , "", (ttl %u)"" , ttl ) ) ; if ( version < 2 || version > 3 || type != VRRP_TYPE_ADVERTISEMENT ) return ; ND_TCHECK ( bp [ 2 ] ) ; ND_PRINT ( ( ndo , "", vrid %u, prio %u"" , bp [ 1 ] , bp [ 2 ] ) ) ; ND_TCHECK ( bp [ 5 ] ) ; if ( version == 2 ) { auth_type = bp [ 4 ] ; ND_PRINT ( ( ndo , "", authtype %s"" , tok2str ( auth2str , NULL , auth_type ) ) ) ; ND_PRINT ( ( ndo , "", intvl %us, length %u"" , bp [ 5 ] , len ) ) ; } else { uint16_t intvl = ( bp [ 4 ] & 0x0f ) << 8 | bp [ 5 ] ; ND_PRINT ( ( ndo , "", intvl %ucs, length %u"" , intvl , len ) ) ; } if ( ndo -> ndo_vflag ) { int naddrs = bp [ 3 ] ; int i ; char c ; if ( version == 2 && len >= 14 ) { struct cksum_vec vec [ 1 ] ; vec [ 0 ] . ptr = bp ; vec [ 0 ] . len = len ; if ( in_cksum ( vec , 1 ) ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } if ( version == 3 && len >= 14 ) { uint16_t cksum = nextproto4_cksum ( ndo , ( const struct ip * ) bp2 , bp , len , len , IPPROTO_VRRP ) ; if ( cksum ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } ND_PRINT ( ( ndo , "", addrs"" ) ) ; if ( naddrs > 1 ) ND_PRINT ( ( ndo , ""(%d)"" , naddrs ) ) ; ND_PRINT ( ( ndo , "":"" ) ) ; c = ' ' ; bp += 8 ; for ( i = 0 ; i < naddrs ; i ++ ) { if (len < bp - 8 + i * 4 + 4) { ND_PRINT((ndo, ""[|vrrp]"")); return; } ND_TCHECK ( bp [ 3 ] ) ; ND_PRINT ( ( ndo , ""%c%s"" , c , ipaddr_string ( ndo , bp ) ) ) ; c = ',' ; bp += 4 ; } if ( version == 2 && auth_type == VRRP_AUTH_SIMPLE ) { if (len < bp - 8 + 8) { ND_PRINT((ndo, ""[|vrrp]"")); return; } ND_TCHECK ( bp [ 7 ] ) ; ND_PRINT ( ( ndo , "" auth \\"""" ) ) ; if ( fn_printn ( ndo , bp , 8 , ndo -> ndo_snapend ) ) { ND_PRINT ( ( ndo , ""\\"""" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""\\"""" ) ) ; } } return ; trunc : ND_PRINT ( ( ndo , ""[|vrrp]"" )",1000,-22.3760962743484,-0.0223760962743484
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
void vrrp_print ( netdissect_options * ndo , register const u_char * bp , register u_int len , register const u_char * bp2 , int ttl ) { int version , type , auth_type = VRRP_AUTH_NONE ; const char * type_s ; ND_TCHECK ( bp [ 0 ] ) ; version = ( bp [ 0 ] & 0xf0 ) >> 4 ; type = bp [ 0 ] & 0x0f ; type_s = tok2str ( type2str , ""unknown type (%u)"" , type ) ; ND_PRINT ( ( ndo , ""VRRPv%u, %s"" , version , type_s ) ) ; if ( ttl != 255 ) ND_PRINT ( ( ndo , "", (ttl %u)"" , ttl ) ) ; if ( version < 2 || version > 3 || type != VRRP_TYPE_ADVERTISEMENT ) return ; ND_TCHECK ( bp [ 2 ] ) ; ND_PRINT ( ( ndo , "", vrid %u, prio %u"" , bp [ 1 ] , bp [ 2 ] ) ) ; ND_TCHECK ( bp [ 5 ] ) ; if ( version == 2 ) { auth_type = bp [ 4 ] ; ND_PRINT ( ( ndo , "", authtype %s"" , tok2str ( auth2str , NULL , auth_type ) ) ) ; ND_PRINT ( ( ndo , "", intvl %us, length %u"" , bp [ 5 ] , len ) ) ; } else { uint16_t intvl = ( bp [ 4 ] & 0x0f ) << 8 | bp [ 5 ] ; ND_PRINT ( ( ndo , "", intvl %ucs, length %u"" , intvl , len ) ) ; } if ( ndo -> ndo_vflag ) { int naddrs = bp [ 3 ] ; int i ; char c ; if ( version == 2 && ND_TTEST2 ( bp [ 0 ] , len ) ) { struct cksum_vec vec [ 1 ] ; vec [ 0 ] . ptr = bp ; vec [ 0 ] . len = len ; if ( in_cksum ( vec , 1 ) ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } if ( version == 3 && ND_TTEST2 ( bp [ 0 ] , len ) ) { uint16_t cksum = nextproto4_cksum ( ndo , ( const struct ip * ) bp2 , bp , len , len , IPPROTO_VRRP ) ; if ( cksum ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } ND_PRINT ( ( ndo , "", addrs"" ) ) ; if ( naddrs > 1 ) ND_PRINT ( ( ndo , ""(%d)"" , naddrs ) ) ; ND_PRINT ( ( ndo , "":"" ) ) ; c = ' ' ; bp += 8 ; for ( i = 0 ; i < naddrs ; i ++ ) { ND_TCHECK ( bp [ 3 ] ) ; ND_PRINT ( ( ndo , ""%c%s"" , c , ipaddr_string ( ndo , bp ) ) ) ; c = ',' ; bp += 4 ; } if ( version == 2 && auth_type == VRRP_AUTH_SIMPLE ) { ND_TCHECK ( bp [ 7 ] ) ; ND_PRINT ( ( ndo , "" auth \\"""" ) ) ; if ( fn_printn ( ndo , bp , 8 , ndo -> ndo_snapend ) ) { ND_PRINT ( ( ndo , ""\\"""" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""\\"""" ) ) ; } } return ; trunc : ND_PRINT ( ( ndo , ""[|vrrp]"" ) ) ; }
Fixed code:","
void vrrp_print ( netdissect_options * ndo , register const u_char * bp , register u_int len , register const u_char * bp2 , int ttl ) { int version , type , auth_type = VRRP_AUTH_NONE ; const char * type_s ; if (len > 0) { ND_TCHECK ( bp [ 0 ] ) ; version = ( bp [ 0 ] & 0xf0 ) >> 4 ; type = bp [ 0 ] & 0x0f ; type_s = tok2str ( type2str , ""unknown type (%u)"" , type ) ; ND_PRINT ( ( ndo , ""VRRPv%u, %s"" , version , type_s ) ) ; if ( ttl != 255 ) ND_PRINT ( ( ndo , "", (ttl %u)"" , ttl ) ) ; if ( version < 2 || version > 3 || type != VRRP_TYPE_ADVERTISEMENT ) return ; ND_TCHECK ( bp [ 2 ] ) ; ND_PRINT ( ( ndo , "", vrid %u, prio %u"" , bp [ 1 ] , bp [ 2 ] ) ) ; ND_TCHECK ( bp [ 5 ] ) ; if ( version == 2 ) { auth_type = bp [ 4 ] ; ND_PRINT ( ( ndo , "", authtype %s"" , tok2str ( auth2str , NULL , auth_type ) ) ) ; ND_PRINT ( ( ndo , "", intvl %us, length %u"" , bp [ 5 ] , len ) ) ; } else { uint16_t intvl = ( bp [ 4 ] & 0x0f ) << 8 | bp [ 5 ] ; ND_PRINT ( ( ndo , "", intvl %ucs, length %u"" , intvl , len ) ) ; } if ( ndo -> ndo_vflag ) { int naddrs = bp [ 3 ] ; int i ; char c ; if ( version == 2 && ND_TTEST2 ( bp [ 0 ] , len ) ) { struct cksum_vec vec [ 1 ] ; vec [ 0 ] . ptr = bp ; vec [ 0 ] . len = len ; if ( in_cksum ( vec , 1 ) ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } if ( version == 3 && ND_TTEST2 ( bp [ 0 ] , len ) ) { uint16_t cksum = nextproto4_cksum ( ndo , ( const struct ip * ) bp2 , bp , len , len , IPPROTO_VRRP ) ; if ( cksum ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } if (naddrs > 0) { ND_PRINT ( ( ndo , "", addrs"" ) ) ; if ( naddrs > 1 ) ND_PRINT ( ( ndo , ""(%d)"" , naddrs ) ) ; ND_PRINT ( ( ndo , "":"" ) ) ; c = ' ' ; bp += 8 ; for ( i = 0 ; i < naddrs ; i ++ ) { ND_TCHECK ( bp [ 3 ] ) ; ND_PRINT ( ( ndo , ""%c%s"" , c , ipaddr_string ( ndo , bp ) ) ) ; c = ',' ; bp += 4 ; } } if ( version == 2 && auth_type == VRRP_AUTH_SIMPLE ) { ND_TCHECK ( bp [ 7 ] ) ; ND_PRINT ( ( ndo , "" auth \\"""" ) ) ; if ( fn_printn ( ndo , bp , 8 , ndo -> ndo_snapend ) ) { ND_PRINT ( ( ndo , ""\\"""" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""\\"""" ) ) ; } } return ; trunc : ND_PRINT ( ( ndo , ""[|vrrp]"" ) ) ; }
}",952,-13.435457987792935,-0.014112876037597621
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
void vrrp_print ( netdissect_options * ndo , register const u_char * bp , register u_int len , register const u_char * bp2 , int ttl ) { int version , type , auth_type = VRRP_AUTH_NONE ; const char * type_s ; ND_TCHECK ( bp [ 0 ] ) ; version = ( bp [ 0 ] & 0xf0 ) >> 4 ; type = bp [ 0 ] & 0x0f ; type_s = tok2str ( type2str , ""unknown type (%u)"" , type ) ; ND_PRINT ( ( ndo , ""VRRPv%u, %s"" , version , type_s ) ) ; if ( ttl != 255 ) ND_PRINT ( ( ndo , "", (ttl %u)"" , ttl ) ) ; if ( version < 2 || version > 3 || type != VRRP_TYPE_ADVERTISEMENT ) return ; ND_TCHECK ( bp [ 2 ] ) ; ND_PRINT ( ( ndo , "", vrid %u, prio %u"" , bp [ 1 ] , bp [ 2 ] ) ) ; ND_TCHECK ( bp [ 5 ] ) ; if ( version == 2 ) { auth_type = bp [ 4 ] ; ND_PRINT ( ( ndo , "", authtype %s"" , tok2str ( auth2str , NULL , auth_type ) ) ) ; ND_PRINT ( ( ndo , "", intvl %us, length %u"" , bp [ 5 ] , len ) ) ; } else { uint16_t intvl = ( bp [ 4 ] & 0x0f ) << 8 | bp [ 5 ] ; ND_PRINT ( ( ndo , "", intvl %ucs, length %u"" , intvl , len ) ) ; } if ( ndo -> ndo_vflag ) { int naddrs = bp [ 3 ] ; int i ; char c ; if ( version == 2 && ND_TTEST2 ( bp [ 0 ] , len ) ) { struct cksum_vec vec [ 1 ] ; vec [ 0 ] . ptr = bp ; vec [ 0 ] . len = len ; if ( in_cksum ( vec , 1 ) ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } if ( version == 3 && ND_TTEST2 ( bp [ 0 ] , len ) ) { uint16_t cksum = nextproto4_cksum ( ndo , ( const struct ip * ) bp2 , bp , len , len , IPPROTO_VRRP ) ; if ( cksum ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } ND_PRINT ( ( ndo , "", addrs"" ) ) ; if ( naddrs > 1 ) ND_PRINT ( ( ndo , ""(%d)"" , naddrs ) ) ; ND_PRINT ( ( ndo , "":"" ) ) ; c = ' ' ; bp += 8 ; for ( i = 0 ; i < naddrs ; i ++ ) { ND_TCHECK ( bp [ 3 ] ) ; ND_PRINT ( ( ndo , ""%c%s"" , c , ipaddr_string ( ndo , bp ) ) ) ; c = ',' ; bp += 4 ; } if ( version == 2 && auth_type == VRRP_AUTH_SIMPLE ) { ND_TCHECK ( bp [ 7 ] ) ; ND_PRINT ( ( ndo , "" auth \\"""" ) ) ; if ( fn_printn ( ndo , bp , 8 , ndo -> ndo_snapend ) ) { ND_PRINT ( ( ndo , ""\\"""" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""\\"""" ) ) ; } } return ; trunc : ND_PRINT ( ( ndo , ""[|vrrp]"" ) ) ; }
Fixed code:","
void vrrp_print ( netdissect_options * ndo , register const u_char * bp , register u_int len , register const u_char * bp2 , int ttl ) { int version , type , auth_type = VRRP_AUTH_NONE ; const char * type_s ; if ( len < 8 ) { ND_PRINT ( ( ndo , ""[|vrrp]"" ) ) ; return ; } ND_TCHECK ( bp [ 0 ] ) ; version = ( bp [ 0 ] & 0xf0 ) >> 4 ; type = bp [ 0 ] & 0x0f ; type_s = tok2str ( type2str , ""unknown type (%u)"" , type ) ; ND_PRINT ( ( ndo , ""VRRPv%u, %s"" , version , type_s ) ) ; if ( ttl != 255 ) ND_PRINT ( ( ndo , "", (ttl %u)"" , ttl ) ) ; if ( version < 2 || version > 3 || type != VRRP_TYPE_ADVERTISEMENT ) return ; ND_TCHECK ( bp [ 2 ] ) ; ND_PRINT ( ( ndo , "", vrid %u, prio %u"" , bp [ 1 ] , bp [ 2 ] ) ) ; ND_TCHECK ( bp [ 5 ] ) ; if ( version == 2 ) { auth_type = bp [ 4 ] ; ND_PRINT ( ( ndo , "", authtype %s"" , tok2str ( auth2str , NULL , auth_type ) ) ) ; ND_PRINT ( ( ndo , "", intvl %us, length %u"" , bp [ 5 ] , len ) ) ; } else { uint16_t intvl = ( bp [ 4 ] & 0x0f ) << 8 | bp [ 5 ] ; ND_PRINT ( ( ndo , "", intvl %ucs, length %u"" , intvl , len ) ) ; } if ( ndo -> ndo_vflag ) { int naddrs = bp [ 3 ] ; int i ; char c ; if ( version == 2 && ND_TTEST2 ( bp [ 0 ] , len ) ) { struct cksum_vec vec [ 1 ] ; vec [ 0 ] . ptr = bp ; vec [ 0 ] . len = len ; if ( in_cksum ( vec , 1 ) ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } if ( version == 3 && ND_TTEST2 ( bp [ 0 ] , len ) ) { uint16_t cksum = nextproto4_cksum ( ndo , ( const struct ip * ) bp2 , bp , len , len , IPPROTO_VRRP ) ; if ( cksum ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } ND_PRINT ( ( ndo , "", addrs"" ) ) ; if ( naddrs > 1 ) ND_PRINT ( ( ndo , ""(%d)"" , naddrs ) ) ; ND_PRINT ( ( ndo , "":"" ) ) ; c = ' ' ; bp += 8 ; if (len < 8+naddrs*4) { ND_PRINT ( ( ndo , ""[|vrrp]"" ) ) ; return ; } for ( i = 0 ; i < naddrs ; i ++ ) { ND_TCHECK ( bp [ 3 ] ) ; ND_PRINT ( ( ndo , ""%c%s"" , c , ipaddr_string ( ndo , bp ) ) ) ; c = ',' ; bp += 4 ; } if ( version == 2 && auth_type == VRRP_AUTH_SIMPLE ) { ND_TCHECK ( bp [ 7 ] ) ; ND_PRINT ( ( ndo , "" auth \\"""" ) ) ; if ( fn_printn ( ndo , bp , 8 , ndo -> ndo_snapend ) ) { ND_PRINT ( ( ndo , ""\\"""" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""\\"""" ) ) ; } } return ; trunc : ND_PRINT ( ( ndo , ""[|vrrp]"" ) ) ; }",995,-13.824590650576367,-0.013894060955353133
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
void vrrp_print ( netdissect_options * ndo , register const u_char * bp , register u_int len , register const u_char * bp2 , int ttl ) { int version , type , auth_type = VRRP_AUTH_NONE ; const char * type_s ; ND_TCHECK ( bp [ 0 ] ) ; version = ( bp [ 0 ] & 0xf0 ) >> 4 ; type = bp [ 0 ] & 0x0f ; type_s = tok2str ( type2str , ""unknown type (%u)"" , type ) ; ND_PRINT ( ( ndo , ""VRRPv%u, %s"" , version , type_s ) ) ; if ( ttl != 255 ) ND_PRINT ( ( ndo , "", (ttl %u)"" , ttl ) ) ; if ( version < 2 || version > 3 || type != VRRP_TYPE_ADVERTISEMENT ) return ; ND_TCHECK ( bp [ 2 ] ) ; ND_PRINT ( ( ndo , "", vrid %u, prio %u"" , bp [ 1 ] , bp [ 2 ] ) ) ; ND_TCHECK ( bp [ 5 ] ) ; if ( version == 2 ) { auth_type = bp [ 4 ] ; ND_PRINT ( ( ndo , "", authtype %s"" , tok2str ( auth2str , NULL , auth_type ) ) ) ; ND_PRINT ( ( ndo , "", intvl %us, length %u"" , bp [ 5 ] , len ) ) ; } else { uint16_t intvl = ( bp [ 4 ] & 0x0f ) << 8 | bp [ 5 ] ; ND_PRINT ( ( ndo , "", intvl %ucs, length %u"" , intvl , len ) ) ; } if ( ndo -> ndo_vflag ) { int naddrs = bp [ 3 ] ; int i ; char c ; if ( version == 2 && ND_TTEST2 ( bp [ 0 ] , len ) ) { struct cksum_vec vec [ 1 ] ; vec [ 0 ] . ptr = bp ; vec [ 0 ] . len = len ; if ( in_cksum ( vec , 1 ) ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } if ( version == 3 && ND_TTEST2 ( bp [ 0 ] , len ) ) { uint16_t cksum = nextproto4_cksum ( ndo , ( const struct ip * ) bp2 , bp , len , len , IPPROTO_VRRP ) ; if ( cksum ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } ND_PRINT ( ( ndo , "", addrs"" ) ) ; if ( naddrs > 1 ) ND_PRINT ( ( ndo , ""(%d)"" , naddrs ) ) ; ND_PRINT ( ( ndo , "":"" ) ) ; c = ' ' ; bp += 8 ; for ( i = 0 ; i < naddrs ; i ++ ) { ND_TCHECK ( bp [ 3 ] ) ; ND_PRINT ( ( ndo , ""%c%s"" , c , ipaddr_string ( ndo , bp ) ) ) ; c = ',' ; bp += 4 ; } if ( version == 2 && auth_type == VRRP_AUTH_SIMPLE ) { ND_TCHECK ( bp [ 7 ] ) ; ND_PRINT ( ( ndo , "" auth \\"""" ) ) ; if ( fn_printn ( ndo , bp , 8 , ndo -> ndo_snapend ) ) { ND_PRINT ( ( ndo , ""\\"""" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""\\"""" ) ) ; } } return ; trunc : ND_PRINT ( ( ndo , ""[|vrrp]"" ) ) ; }
Fixed code:","
void vrrp_print ( netdissect_options * ndo , register const u_char * bp , register u_int len , register const u_char * bp2 , int ttl ) { int version , type , auth_type = VRRP_AUTH_NONE ; const char * type_s ; ND_TCHECK ( bp [ 0 ] ) ; version = ( bp [ 0 ] & 0xf0 ) >> 4 ; type = bp [ 0 ] & 0x0f ; type_s = tok2str ( type2str , ""unknown type (%u)"" , type ) ; ND_PRINT ( ( ndo , ""VRRPv%u, %s"" , version , type_s ) ) ; if ( ttl != 255 ) ND_PRINT ( ( ndo , "", (ttl %u)"" , ttl ) ) ; if ( version < 2 || version > 3 || type != VRRP_TYPE_ADVERTISEMENT ) return ; ND_TCHECK ( bp [ 2 ] ) ; ND_PRINT ( ( ndo , "", vrid %u, prio %u"" , bp [ 1 ] , bp [ 2 ] ) ) ; ND_TCHECK ( bp [ 5 ] ) ; if ( version == 2 ) { auth_type = bp [ 4 ] ; ND_PRINT ( ( ndo , "", authtype %s"" , tok2str ( auth2str , NULL , auth_type ) ) ) ; ND_PRINT ( ( ndo , "", intvl %us, length %u"" , bp [ 5 ] , len ) ) ; } else { uint16_t intvl = ( bp [ 4 ] & 0x0f ) << 8 | bp [ 5 ] ; ND_PRINT ( ( ndo , "", intvl %ucs, length %u"" , intvl , len ) ) ; } if ( ndo -> ndo_vflag ) { int naddrs = bp [ 3 ] ; int i ; char c ; if ( version == 2 && ND_TTEST2 ( bp [ 0 ] , len ) ) { struct cksum_vec vec [ 1 ] ; vec [ 0 ] . ptr = bp ; vec [ 0 ] . len = len ; if ( in_cksum ( vec , 1 ) ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } if ( version == 3 && ND_TTEST2 ( bp [ 0 ] , len ) ) { uint16_t cksum = nextproto4_cksum ( ndo , ( const struct ip * ) bp2 , bp , len , len , IPPROTO_VRRP ) ; if ( cksum ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } ND_PRINT ( ( ndo , "", addrs"" ) ) ; if ( naddrs > 1 ) ND_PRINT ( ( ndo , ""(%d)"" , naddrs ) ) ; ND_PRINT ( ( ndo , "":"" ) ) ; c = ' ' ; bp += 8 ; if ( naddrs > 0) {  //Verify that naddrs is within bounds 
  for ( i = 0; i < naddrs; i ++ ) { 
    if (ND_TTEST2(bp[3],len)) { //Verify that bp[3] is within bounds of array bp
      ND_PRINT ( ( ndo , ""%c%s"" , c , ipaddr_string ( ndo , bp ) ) ) ; c = ',' ; bp += 4 ; 
    } else {
      ND_PRINT ( ( ndo , ""%c (out of bounds)"" , c ) ) ;
    }
  }
if ( version == 2 && auth_type == VRRP_AUTH_SIMPLE ) { ND_TCHECK ( bp [ 7 ] ) ; ND_PRINT ( ( ndo , "" auth \\"""" ) ) ; if ( fn_printn ( ndo , bp , 8 , ndo -> ndo_snapend ) ) { ND_PRINT ( ( ndo , ""\\"""" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""\\"""" ) ) ; } } return ; trunc : ND_PRINT",1000,-73.23472386455934,-0.07323472386455934
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
void vrrp_print ( netdissect_options * ndo , register const u_char * bp , register u_int len , register const u_char * bp2 , int ttl ) { int version , type , auth_type = VRRP_AUTH_NONE ; const char * type_s ; ND_TCHECK ( bp [ 0 ] ) ; version = ( bp [ 0 ] & 0xf0 ) >> 4 ; type = bp [ 0 ] & 0x0f ; type_s = tok2str ( type2str , ""unknown type (%u)"" , type ) ; ND_PRINT ( ( ndo , ""VRRPv%u, %s"" , version , type_s ) ) ; if ( ttl != 255 ) ND_PRINT ( ( ndo , "", (ttl %u)"" , ttl ) ) ; if ( version < 2 || version > 3 || type != VRRP_TYPE_ADVERTISEMENT ) return ; ND_TCHECK ( bp [ 2 ] ) ; ND_PRINT ( ( ndo , "", vrid %u, prio %u"" , bp [ 1 ] , bp [ 2 ] ) ) ; ND_TCHECK ( bp [ 5 ] ) ; if ( version == 2 ) { auth_type = bp [ 4 ] ; ND_PRINT ( ( ndo , "", authtype %s"" , tok2str ( auth2str , NULL , auth_type ) ) ) ; ND_PRINT ( ( ndo , "", intvl %us, length %u"" , bp [ 5 ] , len ) ) ; } else { uint16_t intvl = ( bp [ 4 ] & 0x0f ) << 8 | bp [ 5 ] ; ND_PRINT ( ( ndo , "", intvl %ucs, length %u"" , intvl , len ) ) ; } if ( ndo -> ndo_vflag ) { int naddrs = bp [ 3 ] ; int i ; char c ; if ( version == 2 && ND_TTEST2 ( bp [ 0 ] , len ) ) { struct cksum_vec vec [ 1 ] ; vec [ 0 ] . ptr = bp ; vec [ 0 ] . len = len ; if ( in_cksum ( vec , 1 ) ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } if ( version == 3 && ND_TTEST2 ( bp [ 0 ] , len ) ) { uint16_t cksum = nextproto4_cksum ( ndo , ( const struct ip * ) bp2 , bp , len , len , IPPROTO_VRRP ) ; if ( cksum ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } ND_PRINT ( ( ndo , "", addrs"" ) ) ; if ( naddrs > 1 ) ND_PRINT ( ( ndo , ""(%d)"" , naddrs ) ) ; ND_PRINT ( ( ndo , "":"" ) ) ; c = ' ' ; bp += 8 ; for ( i = 0 ; i < naddrs ; i ++ ) { ND_TCHECK ( bp [ 3 ] ) ; ND_PRINT ( ( ndo , ""%c%s"" , c , ipaddr_string ( ndo , bp ) ) ) ; c = ',' ; bp += 4 ; } if ( version == 2 && auth_type == VRRP_AUTH_SIMPLE ) { ND_TCHECK ( bp [ 7 ] ) ; ND_PRINT ( ( ndo , "" auth \\"""" ) ) ; if ( fn_printn ( ndo , bp , 8 , ndo -> ndo_snapend ) ) { ND_PRINT ( ( ndo , ""\\"""" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""\\"""" ) ) ; } } return ; trunc : ND_PRINT ( ( ndo , ""[|vrrp]"" ) ) ; }
Fixed code:","
void vrrp_print ( netdissect_options * ndo , register const u_char * bp , register u_int len , register const u_char * bp2 , int ttl ) { int version , type , auth_type = VRRP_AUTH_NONE ; const char * type_s ; if ( len < 8 ) { ND_PRINT ( ( ndo , ""[|vrrp]"" ) ) ; return ; } ND_TCHECK ( bp [ 0 ] ) ; version = ( bp [ 0 ] & 0xf0 ) >> 4 ; type = bp [ 0 ] & 0x0f ; type_s = tok2str ( type2str , ""unknown type (%u)"" , type ) ; ND_PRINT ( ( ndo , ""VRRPv%u, %s"" , version , type_s ) ) ; if ( ttl != 255 ) ND_PRINT ( ( ndo , "", (ttl %u)"" , ttl ) ) ; if ( version < 2 || version > 3 || type != VRRP_TYPE_ADVERTISEMENT ) return ; ND_TCHECK ( bp [ 2 ] ) ; ND_PRINT ( ( ndo , "", vrid %u, prio %u"" , bp [ 1 ] , bp [ 2 ] ) ) ; ND_TCHECK ( bp [ 5 ] ) ; if ( version == 2 ) { auth_type = bp [ 4 ] ; ND_PRINT ( ( ndo , "", authtype %s"" , tok2str ( auth2str , NULL , auth_type ) ) ) ; ND_PRINT ( ( ndo , "", intvl %us, length %u"" , bp [ 5 ] , len ) ) ; } else { uint16_t intvl = ( bp [ 4 ] & 0x0f ) << 8 | bp [ 5 ] ; ND_PRINT ( ( ndo , "", intvl %ucs, length %u"" , intvl , len ) ) ; } if ( ndo -> ndo_vflag ) { int naddrs = bp [ 3 ] ; int i ; char c ; if ( version == 2 && ND_TTEST2 ( bp [ 0 ] , len ) ) { struct cksum_vec vec [ 1 ] ; vec [ 0 ] . ptr = bp ; vec [ 0 ] . len = len ; if ( in_cksum ( vec , 1 ) ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } if ( version == 3 && ND_TTEST2 ( bp [ 0 ] , len ) ) { uint16_t cksum = nextproto4_cksum ( ndo , ( const struct ip * ) bp2 , bp , len , len , IPPROTO_VRRP ) ; if ( cksum ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } ND_PRINT ( ( ndo , "", addrs"" ) ) ; if ( naddrs > 1 ) ND_PRINT ( ( ndo , ""(%d)"" , naddrs ) ) ; ND_PRINT ( ( ndo , "":"" ) ) ; c = ' ' ; bp += 8 ; for ( i = 0 ; i < naddrs ; i ++ ) { if (len < (bp - bp2) + 4) { ND_PRINT( ( ndo , ""[|vrrp]"" ) ) ; return; } ND_TCHECK ( bp [ 3 ] ) ; ND_PRINT ( ( ndo , ""%c%s"" , c , ipaddr_string ( ndo , bp ) ) ) ; c = ',' ; bp += 4 ; } if ( version == 2 && auth_type == VRRP_AUTH_SIMPLE ) { if (len < (bp - bp2) + 8) { ND_PRINT( ( ndo , ""[|vrrp]"" ) ) ; return; } ND_TCHECK ( bp [ 7 ] ) ; ND_PRINT ( ( ndo , "" auth \\"""" ) ) ; if ( fn_printn ( ndo , bp , 8 , ndo -> ndo_snapend ) ) { ND_PRINT ( ( ndo , ""\\"""" ) ) ; goto trunc ; } ND_PRINT ( ( n",1000,-18.54927752009647,-0.018549277520096472
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
void vrrp_print ( netdissect_options * ndo , register const u_char * bp , register u_int len , register const u_char * bp2 , int ttl ) { int version , type , auth_type = VRRP_AUTH_NONE ; const char * type_s ; ND_TCHECK ( bp [ 0 ] ) ; version = ( bp [ 0 ] & 0xf0 ) >> 4 ; type = bp [ 0 ] & 0x0f ; type_s = tok2str ( type2str , ""unknown type (%u)"" , type ) ; ND_PRINT ( ( ndo , ""VRRPv%u, %s"" , version , type_s ) ) ; if ( ttl != 255 ) ND_PRINT ( ( ndo , "", (ttl %u)"" , ttl ) ) ; if ( version < 2 || version > 3 || type != VRRP_TYPE_ADVERTISEMENT ) return ; ND_TCHECK ( bp [ 2 ] ) ; ND_PRINT ( ( ndo , "", vrid %u, prio %u"" , bp [ 1 ] , bp [ 2 ] ) ) ; ND_TCHECK ( bp [ 5 ] ) ; if ( version == 2 ) { auth_type = bp [ 4 ] ; ND_PRINT ( ( ndo , "", authtype %s"" , tok2str ( auth2str , NULL , auth_type ) ) ) ; ND_PRINT ( ( ndo , "", intvl %us, length %u"" , bp [ 5 ] , len ) ) ; } else { uint16_t intvl = ( bp [ 4 ] & 0x0f ) << 8 | bp [ 5 ] ; ND_PRINT ( ( ndo , "", intvl %ucs, length %u"" , intvl , len ) ) ; } if ( ndo -> ndo_vflag ) { int naddrs = bp [ 3 ] ; int i ; char c ; if ( version == 2 && ND_TTEST2 ( bp [ 0 ] , len ) ) { struct cksum_vec vec [ 1 ] ; vec [ 0 ] . ptr = bp ; vec [ 0 ] . len = len ; if ( in_cksum ( vec , 1 ) ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } if ( version == 3 && ND_TTEST2 ( bp [ 0 ] , len ) ) { uint16_t cksum = nextproto4_cksum ( ndo , ( const struct ip * ) bp2 , bp , len , len , IPPROTO_VRRP ) ; if ( cksum ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } ND_PRINT ( ( ndo , "", addrs"" ) ) ; if ( naddrs > 1 ) ND_PRINT ( ( ndo , ""(%d)"" , naddrs ) ) ; ND_PRINT ( ( ndo , "":"" ) ) ; c = ' ' ; bp += 8 ; for ( i = 0 ; i < naddrs ; i ++ ) { ND_TCHECK ( bp [ 3 ] ) ; ND_PRINT ( ( ndo , ""%c%s"" , c , ipaddr_string ( ndo , bp ) ) ) ; c = ',' ; bp += 4 ; } if ( version == 2 && auth_type == VRRP_AUTH_SIMPLE ) { ND_TCHECK ( bp [ 7 ] ) ; ND_PRINT ( ( ndo , "" auth \\"""" ) ) ; if ( fn_printn ( ndo , bp , 8 , ndo -> ndo_snapend ) ) { ND_PRINT ( ( ndo , ""\\"""" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""\\"""" ) ) ; } } return ; trunc : ND_PRINT ( ( ndo , ""[|vrrp]"" ) ) ; }
Fixed code:","
void vrrp_print ( netdissect_options * ndo , register const u_char * bp , register u_int len , register const u_char * bp2 , int ttl ) { int version , type , auth_type = VRRP_AUTH_NONE ; const char * type_s ; if (len < 8) { ND_PRINT((ndo, ""[|vrrp]"")); return; } ND_TCHECK ( bp [ 0 ] ) ; version = ( bp [ 0 ] & 0xf0 ) >> 4 ; type = bp [ 0 ] & 0x0f ; type_s = tok2str ( type2str , ""unknown type (%u)"" , type ) ; ND_PRINT ( ( ndo , ""VRRPv%u, %s"" , version , type_s ) ) ; if ( ttl != 255 ) ND_PRINT ( ( ndo , "", (ttl %u)"" , ttl ) ) ; if ( version < 2 || version > 3 || type != VRRP_TYPE_ADVERTISEMENT ) return ; ND_TCHECK ( bp [ 2 ] ) ; ND_PRINT ( ( ndo , "", vrid %u, prio %u"" , bp [ 1 ] , bp [ 2 ] ) ) ; ND_TCHECK ( bp [ 5 ] ) ; if ( version == 2 ) { auth_type = bp [ 4 ] ; ND_PRINT ( ( ndo , "", authtype %s"" , tok2str ( auth2str , NULL , auth_type ) ) ) ; ND_PRINT ( ( ndo , "", intvl %us, length %u"" , bp [ 5 ] , len ) ) ; } else { uint16_t intvl = ( bp [ 4 ] & 0x0f ) << 8 | bp [ 5 ] ; ND_PRINT ( ( ndo , "", intvl %ucs, length %u"" , intvl , len ) ) ; } if ( ndo -> ndo_vflag ) { int naddrs = bp [ 3 ] ; int i ; char c ; if ( version == 2 && ND_TTEST2 ( bp [ 0 ] , len ) ) { struct cksum_vec vec [ 1 ] ; vec [ 0 ] . ptr = bp ; vec [ 0 ] . len = len ; if ( in_cksum ( vec , 1 ) ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } if ( version == 3 && ND_TTEST2 ( bp [ 0 ] , len ) ) { uint16_t cksum = nextproto4_cksum ( ndo , ( const struct ip * ) bp2 , bp , len , len , IPPROTO_VRRP ) ; if ( cksum ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } ND_PRINT ( ( ndo , "", addrs"" ) ) ; if ( naddrs > 1 ) ND_PRINT ( ( ndo , ""(%d)"" , naddrs ) ) ; ND_PRINT ( ( ndo , "":"" ) ) ; c = ' ' ; bp += 8 ; for ( i = 0 ; i < naddrs ; i ++ ) { if (len < 12) { ND_PRINT((ndo, ""[|vrrp]"")); return; } ND_TCHECK ( bp [ 3 ] ) ; ND_PRINT ( ( ndo , ""%c%s"" , c , ipaddr_string ( ndo , bp ) ) ) ; c = ',' ; bp += 4 ; } if ( version == 2 && auth_type == VRRP_AUTH_SIMPLE ) { if (len < 16) { ND_PRINT((ndo, ""[|vrrp]"")); return; } ND_TCHECK ( bp [ 7 ] ) ; ND_PRINT ( ( ndo , "" auth \\"""" ) ) ; if ( fn_printn ( ndo , bp , 8 , ndo -> ndo_snapend ) ) { ND_PRINT ( ( ndo , ""\\"""" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""\\"""" ) ) ; } } return ; trunc : ND_PRINT ( ( ndo",1000,-9.069213256240023,-0.009069213256240022
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
void vrrp_print ( netdissect_options * ndo , register const u_char * bp , register u_int len , register const u_char * bp2 , int ttl ) { int version , type , auth_type = VRRP_AUTH_NONE ; const char * type_s ; ND_TCHECK ( bp [ 0 ] ) ; version = ( bp [ 0 ] & 0xf0 ) >> 4 ; type = bp [ 0 ] & 0x0f ; type_s = tok2str ( type2str , ""unknown type (%u)"" , type ) ; ND_PRINT ( ( ndo , ""VRRPv%u, %s"" , version , type_s ) ) ; if ( ttl != 255 ) ND_PRINT ( ( ndo , "", (ttl %u)"" , ttl ) ) ; if ( version < 2 || version > 3 || type != VRRP_TYPE_ADVERTISEMENT ) return ; ND_TCHECK ( bp [ 2 ] ) ; ND_PRINT ( ( ndo , "", vrid %u, prio %u"" , bp [ 1 ] , bp [ 2 ] ) ) ; ND_TCHECK ( bp [ 5 ] ) ; if ( version == 2 ) { auth_type = bp [ 4 ] ; ND_PRINT ( ( ndo , "", authtype %s"" , tok2str ( auth2str , NULL , auth_type ) ) ) ; ND_PRINT ( ( ndo , "", intvl %us, length %u"" , bp [ 5 ] , len ) ) ; } else { uint16_t intvl = ( bp [ 4 ] & 0x0f ) << 8 | bp [ 5 ] ; ND_PRINT ( ( ndo , "", intvl %ucs, length %u"" , intvl , len ) ) ; } if ( ndo -> ndo_vflag ) { int naddrs = bp [ 3 ] ; int i ; char c ; if ( version == 2 && ND_TTEST2 ( bp [ 0 ] , len ) ) { struct cksum_vec vec [ 1 ] ; vec [ 0 ] . ptr = bp ; vec [ 0 ] . len = len ; if ( in_cksum ( vec , 1 ) ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } if ( version == 3 && ND_TTEST2 ( bp [ 0 ] , len ) ) { uint16_t cksum = nextproto4_cksum ( ndo , ( const struct ip * ) bp2 , bp , len , len , IPPROTO_VRRP ) ; if ( cksum ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } ND_PRINT ( ( ndo , "", addrs"" ) ) ; if ( naddrs > 1 ) ND_PRINT ( ( ndo , ""(%d)"" , naddrs ) ) ; ND_PRINT ( ( ndo , "":"" ) ) ; c = ' ' ; bp += 8 ; for ( i = 0 ; i < naddrs ; i ++ ) { ND_TCHECK ( bp [ 3 ] ) ; ND_PRINT ( ( ndo , ""%c%s"" , c , ipaddr_string ( ndo , bp ) ) ) ; c = ',' ; bp += 4 ; } if ( version == 2 && auth_type == VRRP_AUTH_SIMPLE ) { ND_TCHECK ( bp [ 7 ] ) ; ND_PRINT ( ( ndo , "" auth \\"""" ) ) ; if ( fn_printn ( ndo , bp , 8 , ndo -> ndo_snapend ) ) { ND_PRINT ( ( ndo , ""\\"""" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""\\"""" ) ) ; } } return ; trunc : ND_PRINT ( ( ndo , ""[|vrrp]"" ) ) ; }
Fixed code:","
void vrrp_print ( netdissect_options * ndo , register const u_char * bp , register u_int len , register const u_char * bp2 , int ttl ) { int version , type , auth_type = VRRP_AUTH_NONE ; const char * type_s ; if ( len < 1 ) return ; ND_TCHECK ( bp [ 0 ] ) ; version = ( bp [ 0 ] & 0xf0 ) >> 4 ; type = bp [ 0 ] & 0x0f ; type_s = tok2str ( type2str , ""unknown type (%u)"" , type ) ; ND_PRINT ( ( ndo , ""VRRPv%u, %s"" , version , type_s ) ) ; if ( ttl != 255 ) ND_PRINT ( ( ndo , "", (ttl %u)"" , ttl ) ) ; if ( version < 2 || version > 3 || type != VRRP_TYPE_ADVERTISEMENT ) return ; ND_TCHECK ( bp [ 2 ] ) ; ND_PRINT ( ( ndo , "", vrid %u, prio %u"" , bp [ 1 ] , bp [ 2 ] ) ) ; ND_TCHECK ( bp [ 5 ] ) ; if ( version == 2 ) { auth_type = bp [ 4 ] ; ND_PRINT ( ( ndo , "", authtype %s"" , tok2str ( auth2str , NULL , auth_type ) ) ) ; if ( len < 8 ) return ; ND_PRINT ( ( ndo , "", intvl %us, length %u"" , bp [ 5 ] , len ) ) ; } else { if ( len < 8 ) return ; uint16_t intvl = ( bp [ 4 ] & 0x0f ) << 8 | bp [ 5 ] ; ND_PRINT ( ( ndo , "", intvl %ucs, length %u"" , intvl , len ) ) ; } if ( ndo -> ndo_vflag ) { int naddrs = bp [ 3 ] ; int i ; char c ; if ( version == 2 && ND_TTEST2 ( bp [ 0 ] , len ) ) { struct cksum_vec vec [ 1 ] ; vec [ 0 ] . ptr = bp ; vec [ 0 ] . len = len ; if ( in_cksum ( vec , 1 ) ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } if ( version == 3 && ND_TTEST2 ( bp [ 0 ] , len ) ) { uint16_t cksum = nextproto4_cksum ( ndo , ( const struct ip * ) bp2 , bp , len , len , IPPROTO_VRRP ) ; if ( cksum ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } if ( len < 8 ) return ; ND_PRINT ( ( ndo , "", addrs"" ) ) ; if ( naddrs > 1 ) ND_PRINT ( ( ndo , ""(%d)"" , naddrs ) ) ; ND_PRINT ( ( ndo , "":"" ) ) ; c = ' ' ; bp += 8 ; for ( i = 0 ; i < naddrs ; i ++ ) { if ( len < 8 ) return ; ND_TCHECK ( bp [ 3 ] ) ; ND_PRINT ( ( ndo , ""%c%s"" , c , ipaddr_string ( ndo , bp ) ) ) ; c = ',' ; bp += 4 ; } if ( version == 2 && auth_type == VRRP_AUTH_SIMPLE ) { if ( len < 16 ) return ; ND_TCHECK ( bp [ 7 ] ) ; ND_PRINT ( ( ndo , "" auth \\"""" ) ) ; if ( fn_printn ( ndo , bp , 8 , ndo -> ndo_snapend ) ) { ND_PRINT ( ( ndo , ""\\"""" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""\\"""" ) ) ; } } return ; trunc : ND_PRINT ( ( ndo , ""[|vrrp]"" ) ) ; }",981,-17.726750394821934,-0.01807008195190819
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
void vrrp_print ( netdissect_options * ndo , register const u_char * bp , register u_int len , register const u_char * bp2 , int ttl ) { int version , type , auth_type = VRRP_AUTH_NONE ; const char * type_s ; ND_TCHECK ( bp [ 0 ] ) ; version = ( bp [ 0 ] & 0xf0 ) >> 4 ; type = bp [ 0 ] & 0x0f ; type_s = tok2str ( type2str , ""unknown type (%u)"" , type ) ; ND_PRINT ( ( ndo , ""VRRPv%u, %s"" , version , type_s ) ) ; if ( ttl != 255 ) ND_PRINT ( ( ndo , "", (ttl %u)"" , ttl ) ) ; if ( version < 2 || version > 3 || type != VRRP_TYPE_ADVERTISEMENT ) return ; ND_TCHECK ( bp [ 2 ] ) ; ND_PRINT ( ( ndo , "", vrid %u, prio %u"" , bp [ 1 ] , bp [ 2 ] ) ) ; ND_TCHECK ( bp [ 5 ] ) ; if ( version == 2 ) { auth_type = bp [ 4 ] ; ND_PRINT ( ( ndo , "", authtype %s"" , tok2str ( auth2str , NULL , auth_type ) ) ) ; ND_PRINT ( ( ndo , "", intvl %us, length %u"" , bp [ 5 ] , len ) ) ; } else { uint16_t intvl = ( bp [ 4 ] & 0x0f ) << 8 | bp [ 5 ] ; ND_PRINT ( ( ndo , "", intvl %ucs, length %u"" , intvl , len ) ) ; } if ( ndo -> ndo_vflag ) { int naddrs = bp [ 3 ] ; int i ; char c ; if ( version == 2 && ND_TTEST2 ( bp [ 0 ] , len ) ) { struct cksum_vec vec [ 1 ] ; vec [ 0 ] . ptr = bp ; vec [ 0 ] . len = len ; if ( in_cksum ( vec , 1 ) ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } if ( version == 3 && ND_TTEST2 ( bp [ 0 ] , len ) ) { uint16_t cksum = nextproto4_cksum ( ndo , ( const struct ip * ) bp2 , bp , len , len , IPPROTO_VRRP ) ; if ( cksum ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } ND_PRINT ( ( ndo , "", addrs"" ) ) ; if ( naddrs > 1 ) ND_PRINT ( ( ndo , ""(%d)"" , naddrs ) ) ; ND_PRINT ( ( ndo , "":"" ) ) ; c = ' ' ; bp += 8 ; for ( i = 0 ; i < naddrs ; i ++ ) { ND_TCHECK ( bp [ 3 ] ) ; ND_PRINT ( ( ndo , ""%c%s"" , c , ipaddr_string ( ndo , bp ) ) ) ; c = ',' ; bp += 4 ; } if ( version == 2 && auth_type == VRRP_AUTH_SIMPLE ) { ND_TCHECK ( bp [ 7 ] ) ; ND_PRINT ( ( ndo , "" auth \\"""" ) ) ; if ( fn_printn ( ndo , bp , 8 , ndo -> ndo_snapend ) ) { ND_PRINT ( ( ndo , ""\\"""" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""\\"""" ) ) ; } } return ; trunc : ND_PRINT ( ( ndo , ""[|vrrp]"" ) ) ; }
Fixed code:","
void vrrp_print ( netdissect_options * ndo , register const u_char * bp , register u_int len , register const u_char * bp2 , int ttl ) { int version , type , auth_type = VRRP_AUTH_NONE ; const char * type_s ; ND_TCHECK ( bp [ 0 ] ) ; version = ( bp [ 0 ] & 0xf0 ) >> 4 ; type = bp [ 0 ] & 0x0f ; type_s = tok2str ( type2str , ""unknown type (%u)"" , type ) ; ND_PRINT ( ( ndo , ""VRRPv%u, %s"" , version , type_s ) ) ; if ( ttl != 255 ) ND_PRINT ( ( ndo , "", (ttl %u)"" , ttl ) ) ; if ( version < 2 || version > 3 || type != VRRP_TYPE_ADVERTISEMENT ) return ; ND_TCHECK ( bp [ 2 ] ) ; ND_PRINT ( ( ndo , "", vrid %u, prio %u"" , bp [ 1 ] , bp [ 2 ] ) ) ; ND_TCHECK ( bp [ 5 ] ) ; if ( version == 2 ) { auth_type = bp [ 4 ] ; ND_PRINT ( ( ndo , "", authtype %s"" , tok2str ( auth2str , NULL , auth_type ) ) ) ; ND_PRINT ( ( ndo , "", intvl %us, length %u"" , bp [ 5 ] , len ) ) ; } else { uint16_t intvl = ( bp [ 4 ] & 0x0f ) << 8 | bp [ 5 ] ; ND_PRINT ( ( ndo , "", intvl %ucs, length %u"" , intvl , len ) ) ; } if ( ndo -> ndo_vflag && len >= 8 ) { int naddrs = bp [ 3 ] ; int i ; char c ; if ( version == 2 ) { struct cksum_vec vec [ 1 ] ; vec [ 0 ] . ptr = bp ; vec [ 0 ] . len = len ; if ( in_cksum ( vec , 1 ) ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } if ( version == 3 ) { uint16_t cksum = nextproto4_cksum ( ndo , ( const struct ip * ) bp2 , bp , len , len , IPPROTO_VRRP ) ; if ( cksum ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } ND_PRINT ( ( ndo , "", addrs"" ) ) ; if ( naddrs > 1 ) ND_PRINT ( ( ndo , ""(%d)"" , naddrs ) ) ; ND_PRINT ( ( ndo , "":"" ) ) ; c = ' ' ; bp += 8 ; for ( i = 0 ; i < naddrs ; i ++ ) { if ( ( 8 + 4 * i ) >= len ) goto trunc ; ND_TCHECK ( bp [ 3 ] ) ; ND_PRINT ( ( ndo , ""%c%s"" , c , ipaddr_string ( ndo , bp ) ) ) ; c = ',' ; bp += 4 ; } if ( version == 2 && auth_type == VRRP_AUTH_SIMPLE ) { if ( ( 8 + 4 * naddrs ) >= len ) goto trunc ; ND_TCHECK ( bp [ 7 ] ) ; ND_PRINT ( ( ndo , "" auth \\"""" ) ) ; if ( fn_printn ( ndo , bp , 8 , ndo -> ndo_snapend ) ) { ND_PRINT ( ( ndo , ""\\"""" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""\\"""" ) ) ; } } return ; trunc : ND_PRINT ( ( ndo , ""[|vrrp]"" ) ) ; }",939,-22.282543612527935,-0.02373007839459844
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
void vrrp_print ( netdissect_options * ndo , register const u_char * bp , register u_int len , register const u_char * bp2 , int ttl ) { int version , type , auth_type = VRRP_AUTH_NONE ; const char * type_s ; ND_TCHECK ( bp [ 0 ] ) ; version = ( bp [ 0 ] & 0xf0 ) >> 4 ; type = bp [ 0 ] & 0x0f ; type_s = tok2str ( type2str , ""unknown type (%u)"" , type ) ; ND_PRINT ( ( ndo , ""VRRPv%u, %s"" , version , type_s ) ) ; if ( ttl != 255 ) ND_PRINT ( ( ndo , "", (ttl %u)"" , ttl ) ) ; if ( version < 2 || version > 3 || type != VRRP_TYPE_ADVERTISEMENT ) return ; ND_TCHECK ( bp [ 2 ] ) ; ND_PRINT ( ( ndo , "", vrid %u, prio %u"" , bp [ 1 ] , bp [ 2 ] ) ) ; ND_TCHECK ( bp [ 5 ] ) ; if ( version == 2 ) { auth_type = bp [ 4 ] ; ND_PRINT ( ( ndo , "", authtype %s"" , tok2str ( auth2str , NULL , auth_type ) ) ) ; ND_PRINT ( ( ndo , "", intvl %us, length %u"" , bp [ 5 ] , len ) ) ; } else { uint16_t intvl = ( bp [ 4 ] & 0x0f ) << 8 | bp [ 5 ] ; ND_PRINT ( ( ndo , "", intvl %ucs, length %u"" , intvl , len ) ) ; } if ( ndo -> ndo_vflag ) { int naddrs = bp [ 3 ] ; int i ; char c ; if ( version == 2 && ND_TTEST2 ( bp [ 0 ] , len ) ) { struct cksum_vec vec [ 1 ] ; vec [ 0 ] . ptr = bp ; vec [ 0 ] . len = len ; if ( in_cksum ( vec , 1 ) ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } if ( version == 3 && ND_TTEST2 ( bp [ 0 ] , len ) ) { uint16_t cksum = nextproto4_cksum ( ndo , ( const struct ip * ) bp2 , bp , len , len , IPPROTO_VRRP ) ; if ( cksum ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } ND_PRINT ( ( ndo , "", addrs"" ) ) ; if ( naddrs > 1 ) ND_PRINT ( ( ndo , ""(%d)"" , naddrs ) ) ; ND_PRINT ( ( ndo , "":"" ) ) ; c = ' ' ; bp += 8 ; for ( i = 0 ; i < naddrs ; i ++ ) { ND_TCHECK ( bp [ 3 ] ) ; ND_PRINT ( ( ndo , ""%c%s"" , c , ipaddr_string ( ndo , bp ) ) ) ; c = ',' ; bp += 4 ; } if ( version == 2 && auth_type == VRRP_AUTH_SIMPLE ) { ND_TCHECK ( bp [ 7 ] ) ; ND_PRINT ( ( ndo , "" auth \\"""" ) ) ; if ( fn_printn ( ndo , bp , 8 , ndo -> ndo_snapend ) ) { ND_PRINT ( ( ndo , ""\\"""" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""\\"""" ) ) ; } } return ; trunc : ND_PRINT ( ( ndo , ""[|vrrp]"" ) ) ; }
Fixed code:","
void vrrp_print ( netdissect_options * ndo , register const u_char * bp , register u_int len , register const u_char * bp2 , int ttl ) { int version , type , auth_type = VRRP_AUTH_NONE ; const char * type_s ; if (len <= 0) { return; } ND_TCHECK ( bp [ 0 ] ) ; version = ( bp [ 0 ] & 0xf0 ) >> 4 ; type = bp [ 0 ] & 0x0f ; type_s = tok2str ( type2str , ""unknown type (%u)"" , type ) ; ND_PRINT ( ( ndo , ""VRRPv%u, %s"" , version , type_s ) ) ; if ( ttl != 255 ) ND_PRINT ( ( ndo , "", (ttl %u)"" , ttl ) ) ; if ( version < 2 || version > 3 || type != VRRP_TYPE_ADVERTISEMENT ) return ; ND_TCHECK ( bp [ 2 ] ) ; ND_PRINT ( ( ndo , "", vrid %u, prio %u"" , bp [ 1 ] , bp [ 2 ] ) ) ; ND_TCHECK ( bp [ 5 ] ) ; if ( version == 2 ) { auth_type = bp [ 4 ] ; ND_PRINT ( ( ndo , "", authtype %s"" , tok2str ( auth2str , NULL , auth_type ) ) ) ; ND_PRINT ( ( ndo , "", intvl %us, length %u"" , bp [ 5 ] , len ) ) ; } else { uint16_t intvl = ( bp [ 4 ] & 0x0f ) << 8 | bp [ 5 ] ; ND_PRINT ( ( ndo , "", intvl %ucs, length %u"" , intvl , len ) ) ; } if ( ndo -> ndo_vflag ) { int naddrs = bp [ 3 ] ; int i ; char c ; if ( version == 2 && ND_TTEST2 ( bp [ 0 ] , len ) ) { struct cksum_vec vec [ 1 ] ; vec [ 0 ] . ptr = bp ; vec [ 0 ] . len = len ; if ( in_cksum ( vec , 1 ) ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } if ( version == 3 && ND_TTEST2 ( bp [ 0 ] , len ) ) { uint16_t cksum = nextproto4_cksum ( ndo , ( const struct ip * ) bp2 , bp , len , len , IPPROTO_VRRP ) ; if ( cksum ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } ND_PRINT ( ( ndo , "", addrs"" ) ) ; if ( naddrs > 1 ) ND_PRINT ( ( ndo , ""(%d)"" , naddrs ) ) ; ND_PRINT ( ( ndo , "":"" ) ) ; c = ' ' ; bp += 8 ; for ( i = 0 ; i < naddrs ; i ++ ) { if (len < bp + 4) { break; } ND_TCHECK ( bp [ 3 ] ) ; ND_PRINT ( ( ndo , ""%c%s"" , c , ipaddr_string ( ndo , bp ) ) ) ; c = ',' ; bp += 4 ; } if ( version == 2 && auth_type == VRRP_AUTH_SIMPLE ) { if (len < bp + 8) { break; } ND_TCHECK ( bp [ 7 ] ) ; ND_PRINT ( ( ndo , "" auth \\"""" ) ) ; if ( fn_printn ( ndo , bp , 8 , ndo -> ndo_snapend ) ) { ND_PRINT ( ( ndo , ""\\"""" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""\\"""" ) ) ; } } return ; trunc : ND_PRINT ( ( ndo , ""[|vrrp]"" ) ) ; }",969,-13.494825363838821,-0.013926548363094758
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
void vrrp_print ( netdissect_options * ndo , register const u_char * bp , register u_int len , register const u_char * bp2 , int ttl ) { int version , type , auth_type = VRRP_AUTH_NONE ; const char * type_s ; ND_TCHECK ( bp [ 0 ] ) ; version = ( bp [ 0 ] & 0xf0 ) >> 4 ; type = bp [ 0 ] & 0x0f ; type_s = tok2str ( type2str , ""unknown type (%u)"" , type ) ; ND_PRINT ( ( ndo , ""VRRPv%u, %s"" , version , type_s ) ) ; if ( ttl != 255 ) ND_PRINT ( ( ndo , "", (ttl %u)"" , ttl ) ) ; if ( version < 2 || version > 3 || type != VRRP_TYPE_ADVERTISEMENT ) return ; ND_TCHECK ( bp [ 2 ] ) ; ND_PRINT ( ( ndo , "", vrid %u, prio %u"" , bp [ 1 ] , bp [ 2 ] ) ) ; ND_TCHECK ( bp [ 5 ] ) ; if ( version == 2 ) { auth_type = bp [ 4 ] ; ND_PRINT ( ( ndo , "", authtype %s"" , tok2str ( auth2str , NULL , auth_type ) ) ) ; ND_PRINT ( ( ndo , "", intvl %us, length %u"" , bp [ 5 ] , len ) ) ; } else { uint16_t intvl = ( bp [ 4 ] & 0x0f ) << 8 | bp [ 5 ] ; ND_PRINT ( ( ndo , "", intvl %ucs, length %u"" , intvl , len ) ) ; } if ( ndo -> ndo_vflag ) { int naddrs = bp [ 3 ] ; int i ; char c ; if ( version == 2 && ND_TTEST2 ( bp [ 0 ] , len ) ) { struct cksum_vec vec [ 1 ] ; vec [ 0 ] . ptr = bp ; vec [ 0 ] . len = len ; if ( in_cksum ( vec , 1 ) ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } if ( version == 3 && ND_TTEST2 ( bp [ 0 ] , len ) ) { uint16_t cksum = nextproto4_cksum ( ndo , ( const struct ip * ) bp2 , bp , len , len , IPPROTO_VRRP ) ; if ( cksum ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } ND_PRINT ( ( ndo , "", addrs"" ) ) ; if ( naddrs > 1 ) ND_PRINT ( ( ndo , ""(%d)"" , naddrs ) ) ; ND_PRINT ( ( ndo , "":"" ) ) ; c = ' ' ; bp += 8 ; for ( i = 0 ; i < naddrs ; i ++ ) { ND_TCHECK ( bp [ 3 ] ) ; ND_PRINT ( ( ndo , ""%c%s"" , c , ipaddr_string ( ndo , bp ) ) ) ; c = ',' ; bp += 4 ; } if ( version == 2 && auth_type == VRRP_AUTH_SIMPLE ) { ND_TCHECK ( bp [ 7 ] ) ; ND_PRINT ( ( ndo , "" auth \\"""" ) ) ; if ( fn_printn ( ndo , bp , 8 , ndo -> ndo_snapend ) ) { ND_PRINT ( ( ndo , ""\\"""" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""\\"""" ) ) ; } } return ; trunc : ND_PRINT ( ( ndo , ""[|vrrp]"" ) ) ; }
Fixed code:","
void vrrp_print ( netdissect_options * ndo , register const u_char * bp , register u_int len , register const u_char * bp2 , int ttl ) { int version , type , auth_type = VRRP_AUTH_NONE ; const char * type_s ; ND_TCHECK ( bp [ 0 ] ) ; version = ( bp [ 0 ] & 0xf0 ) >> 4 ; type = bp [ 0 ] & 0x0f ; type_s = tok2str ( type2str , ""unknown type (%u)"" , type ) ; ND_PRINT ( ( ndo , ""VRRPv%u, %s"" , version , type_s ) ) ; if ( ttl != 255 ) ND_PRINT ( ( ndo , "", (ttl %u)"" , ttl ) ) ; if ( version < 2 || version > 3 || type != VRRP_TYPE_ADVERTISEMENT ) return ; ND_TCHECK ( bp [ 2 ] ) ; ND_PRINT ( ( ndo , "", vrid %u, prio %u"" , bp [ 1 ] , bp [ 2 ] ) ) ; ND_TCHECK ( bp [ 5 ] ) ; if ( version == 2 ) { auth_type = bp [ 4 ] ; ND_PRINT ( ( ndo , "", authtype %s"" , tok2str ( auth2str , NULL , auth_type ) ) ) ; ND_PRINT ( ( ndo , "", intvl %us, length %u"" , bp [ 5 ] , len ) ) ; } else { uint16_t intvl = ( bp [ 4 ] & 0x0f ) << 8 | bp [ 5 ] ; ND_PRINT ( ( ndo , "", intvl %ucs, length %u"" , intvl , len ) ) ; } if ( ndo -> ndo_vflag ) { int naddrs = bp [ 3 ] ; int i ; char c ; if ( version == 2 && ND_TTEST2 ( bp [ 0 ] , len ) ) { struct cksum_vec vec [ 1 ] ; vec [ 0 ] . ptr = bp ; vec [ 0 ] . len = len ; if ( in_cksum ( vec , 1 ) ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } if ( version == 3 && ND_TTEST2 ( bp [ 0 ] , len ) ) { uint16_t cksum = nextproto4_cksum ( ndo , ( const struct ip * ) bp2 , bp , len , len , IPPROTO_VRRP ) ; if ( cksum ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } ND_PRINT ( ( ndo , "", addrs"" ) ) ; if ( naddrs > 1 ) ND_PRINT ( ( ndo , ""(%d)"" , naddrs ) ) ; ND_PRINT ( ( ndo , "":"" ) ) ; c = ' ' ; bp += 8 ; if ( naddrs*4 > (len-8)) { return; } //added return if naddrs is out of bounds for ( i = 0 ; i < naddrs ; i ++ ) { ND_TCHECK ( bp [ 3 ] ) ; ND_PRINT ( ( ndo , ""%c%s"" , c , ipaddr_string ( ndo , bp ) ) ) ; c = ',' ; bp += 4 ; } if ( version == 2 && auth_type == VRRP_AUTH_SIMPLE ) { ND_TCHECK ( bp [ 7 ] ) ; ND_PRINT ( ( ndo , "" auth \\"""" ) ) ; if ( fn_printn ( ndo , bp , 8 , ndo -> ndo_snapend ) ) { ND_PRINT ( ( ndo , ""\\"""" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""\\"""" ) ) ; } } return ; trunc : ND_PRINT ( ( ndo , ""[|vrrp]"" ) ) ; }",961,-37.32238419521521,-0.03883702829887118
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
void vrrp_print ( netdissect_options * ndo , register const u_char * bp , register u_int len , register const u_char * bp2 , int ttl ) { int version , type , auth_type = VRRP_AUTH_NONE ; const char * type_s ; ND_TCHECK ( bp [ 0 ] ) ; version = ( bp [ 0 ] & 0xf0 ) >> 4 ; type = bp [ 0 ] & 0x0f ; type_s = tok2str ( type2str , ""unknown type (%u)"" , type ) ; ND_PRINT ( ( ndo , ""VRRPv%u, %s"" , version , type_s ) ) ; if ( ttl != 255 ) ND_PRINT ( ( ndo , "", (ttl %u)"" , ttl ) ) ; if ( version < 2 || version > 3 || type != VRRP_TYPE_ADVERTISEMENT ) return ; ND_TCHECK ( bp [ 2 ] ) ; ND_PRINT ( ( ndo , "", vrid %u, prio %u"" , bp [ 1 ] , bp [ 2 ] ) ) ; ND_TCHECK ( bp [ 5 ] ) ; if ( version == 2 ) { auth_type = bp [ 4 ] ; ND_PRINT ( ( ndo , "", authtype %s"" , tok2str ( auth2str , NULL , auth_type ) ) ) ; ND_PRINT ( ( ndo , "", intvl %us, length %u"" , bp [ 5 ] , len ) ) ; } else { uint16_t intvl = ( bp [ 4 ] & 0x0f ) << 8 | bp [ 5 ] ; ND_PRINT ( ( ndo , "", intvl %ucs, length %u"" , intvl , len ) ) ; } if ( ndo -> ndo_vflag ) { int naddrs = bp [ 3 ] ; int i ; char c ; if ( version == 2 && ND_TTEST2 ( bp [ 0 ] , len ) ) { struct cksum_vec vec [ 1 ] ; vec [ 0 ] . ptr = bp ; vec [ 0 ] . len = len ; if ( in_cksum ( vec , 1 ) ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } if ( version == 3 && ND_TTEST2 ( bp [ 0 ] , len ) ) { uint16_t cksum = nextproto4_cksum ( ndo , ( const struct ip * ) bp2 , bp , len , len , IPPROTO_VRRP ) ; if ( cksum ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } ND_PRINT ( ( ndo , "", addrs"" ) ) ; if ( naddrs > 1 ) ND_PRINT ( ( ndo , ""(%d)"" , naddrs ) ) ; ND_PRINT ( ( ndo , "":"" ) ) ; c = ' ' ; bp += 8 ; for ( i = 0 ; i < naddrs ; i ++ ) { ND_TCHECK ( bp [ 3 ] ) ; ND_PRINT ( ( ndo , ""%c%s"" , c , ipaddr_string ( ndo , bp ) ) ) ; c = ',' ; bp += 4 ; } if ( version == 2 && auth_type == VRRP_AUTH_SIMPLE ) { ND_TCHECK ( bp [ 7 ] ) ; ND_PRINT ( ( ndo , "" auth \\"""" ) ) ; if ( fn_printn ( ndo , bp , 8 , ndo -> ndo_snapend ) ) { ND_PRINT ( ( ndo , ""\\"""" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""\\"""" ) ) ; } } return ; trunc : ND_PRINT ( ( ndo , ""[|vrrp]"" ) ) ; }
Fixed code:","
void vrrp_print ( netdissect_options * ndo , register const u_char * bp , register u_int len , register const u_char * bp2 , int ttl ) { int version , type , auth_type = VRRP_AUTH_NONE ; const char * type_s ; if (len < 8) {  ND_PRINT ( ( ndo , ""[|vrrp]"" ) ) ; return; } ND_TCHECK ( bp [ 0 ] ) ; version = ( bp [ 0 ] & 0xf0 ) >> 4 ; type = bp [ 0 ] & 0x0f ; type_s = tok2str ( type2str , ""unknown type (%u)"" , type ) ; ND_PRINT ( ( ndo , ""VRRPv%u, %s"" , version , type_s ) ) ; if ( ttl != 255 ) ND_PRINT ( ( ndo , "", (ttl %u)"" , ttl ) ) ; if ( version < 2 || version > 3 || type != VRRP_TYPE_ADVERTISEMENT ) return ; ND_TCHECK ( bp [ 2 ] ) ; ND_PRINT ( ( ndo , "", vrid %u, prio %u"" , bp [ 1 ] , bp [ 2 ] ) ) ; ND_TCHECK ( bp [ 5 ] ) ; if ( version == 2 ) { auth_type = bp [ 4 ] ; ND_PRINT ( ( ndo , "", authtype %s"" , tok2str ( auth2str , NULL , auth_type ) ) ) ; ND_PRINT ( ( ndo , "", intvl %us, length %u"" , bp [ 5 ] , len ) ) ; } else { uint16_t intvl = ( bp [ 4 ] & 0x0f ) << 8 | bp [ 5 ] ; ND_PRINT ( ( ndo , "", intvl %ucs, length %u"" , intvl , len ) ) ; } if ( ndo -> ndo_vflag ) { int naddrs = bp [ 3 ] ; int i ; char c ; if ( version == 2 && ND_TTEST2 ( bp [ 0 ] , len ) ) { struct cksum_vec vec [ 1 ] ; vec [ 0 ] . ptr = bp ; vec [ 0 ] . len = len ; if ( in_cksum ( vec , 1 ) ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } if ( version == 3 && ND_TTEST2 ( bp [ 0 ] , len ) ) { uint16_t cksum = nextproto4_cksum ( ndo , ( const struct ip * ) bp2 , bp , len , len , IPPROTO_VRRP ) ; if ( cksum ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } ND_PRINT ( ( ndo , "", addrs"" ) ) ; if ( naddrs > 1 ) ND_PRINT ( ( ndo , ""(%d)"" , naddrs ) ) ; ND_PRINT ( ( ndo , "":"" ) ) ; c = ' ' ; bp += 8 ; for ( i = 0 ; i < naddrs ; i ++ ) { ND_TCHECK ( bp [ 3 ] ) ; ND_PRINT ( ( ndo , ""%c%s"" , c , ipaddr_string ( ndo , bp ) ) ) ; c = ',' ; bp += 4 ; } if ( version == 2 && auth_type == VRRP_AUTH_SIMPLE ) { ND_TCHECK ( bp [ 7 ] ) ; ND_PRINT ( ( ndo , "" auth \\"""" ) ) ; if ( fn_printn ( ndo , bp , 8 , ndo -> ndo_snapend ) ) { ND_PRINT ( ( ndo , ""\\"""" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""\\"""" ) ) ; } } return ; trunc : ND_PRINT ( ( ndo , ""[|vrrp]"" ) ) ; }",962,-10.892682317681027,-0.01132295459218402
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
void vrrp_print ( netdissect_options * ndo , register const u_char * bp , register u_int len , register const u_char * bp2 , int ttl ) { int version , type , auth_type = VRRP_AUTH_NONE ; const char * type_s ; ND_TCHECK ( bp [ 0 ] ) ; version = ( bp [ 0 ] & 0xf0 ) >> 4 ; type = bp [ 0 ] & 0x0f ; type_s = tok2str ( type2str , ""unknown type (%u)"" , type ) ; ND_PRINT ( ( ndo , ""VRRPv%u, %s"" , version , type_s ) ) ; if ( ttl != 255 ) ND_PRINT ( ( ndo , "", (ttl %u)"" , ttl ) ) ; if ( version < 2 || version > 3 || type != VRRP_TYPE_ADVERTISEMENT ) return ; ND_TCHECK ( bp [ 2 ] ) ; ND_PRINT ( ( ndo , "", vrid %u, prio %u"" , bp [ 1 ] , bp [ 2 ] ) ) ; ND_TCHECK ( bp [ 5 ] ) ; if ( version == 2 ) { auth_type = bp [ 4 ] ; ND_PRINT ( ( ndo , "", authtype %s"" , tok2str ( auth2str , NULL , auth_type ) ) ) ; ND_PRINT ( ( ndo , "", intvl %us, length %u"" , bp [ 5 ] , len ) ) ; } else { uint16_t intvl = ( bp [ 4 ] & 0x0f ) << 8 | bp [ 5 ] ; ND_PRINT ( ( ndo , "", intvl %ucs, length %u"" , intvl , len ) ) ; } if ( ndo -> ndo_vflag ) { int naddrs = bp [ 3 ] ; int i ; char c ; if ( version == 2 && ND_TTEST2 ( bp [ 0 ] , len ) ) { struct cksum_vec vec [ 1 ] ; vec [ 0 ] . ptr = bp ; vec [ 0 ] . len = len ; if ( in_cksum ( vec , 1 ) ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } if ( version == 3 && ND_TTEST2 ( bp [ 0 ] , len ) ) { uint16_t cksum = nextproto4_cksum ( ndo , ( const struct ip * ) bp2 , bp , len , len , IPPROTO_VRRP ) ; if ( cksum ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } ND_PRINT ( ( ndo , "", addrs"" ) ) ; if ( naddrs > 1 ) ND_PRINT ( ( ndo , ""(%d)"" , naddrs ) ) ; ND_PRINT ( ( ndo , "":"" ) ) ; c = ' ' ; bp += 8 ; for ( i = 0 ; i < naddrs ; i ++ ) { ND_TCHECK ( bp [ 3 ] ) ; ND_PRINT ( ( ndo , ""%c%s"" , c , ipaddr_string ( ndo , bp ) ) ) ; c = ',' ; bp += 4 ; } if ( version == 2 && auth_type == VRRP_AUTH_SIMPLE ) { ND_TCHECK ( bp [ 7 ] ) ; ND_PRINT ( ( ndo , "" auth \\"""" ) ) ; if ( fn_printn ( ndo , bp , 8 , ndo -> ndo_snapend ) ) { ND_PRINT ( ( ndo , ""\\"""" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""\\"""" ) ) ; } } return ; trunc : ND_PRINT ( ( ndo , ""[|vrrp]"" ) ) ; }
Fixed code:","
void vrrp_print ( netdissect_options * ndo , register const u_char * bp , register u_int len , register const u_char * bp2 , int ttl ) { int version , type , auth_type = VRRP_AUTH_NONE ; const char * type_s ; ND_TCHECK ( bp [ 0 ] ) ; version = ( bp [ 0 ] & 0xf0 ) >> 4 ; type = bp [ 0 ] & 0x0f ; type_s = tok2str ( type2str , ""unknown type (%u)"" , type ) ; ND_PRINT ( ( ndo , ""VRRPv%u, %s"" , version , type_s ) ) ; if ( ttl != 255 ) ND_PRINT ( ( ndo , "", (ttl %u)"" , ttl ) ) ; if ( version < 2 || version > 3 || type != VRRP_TYPE_ADVERTISEMENT ) return ; ND_TCHECK ( bp [ 2 ] ) ; ND_PRINT ( ( ndo , "", vrid %u, prio %u"" , bp [ 1 ] , bp [ 2 ] ) ) ; ND_TCHECK ( bp [ 5 ] ) ; if ( version == 2 ) { auth_type = bp [ 4 ] ; ND_PRINT ( ( ndo , "", authtype %s"" , tok2str ( auth2str , NULL , auth_type ) ) ) ; ND_PRINT ( ( ndo , "", intvl %us, length %u"" , bp [ 5 ] , len ) ) ; } else { uint16_t intvl = ( bp [ 4 ] & 0x0f ) << 8 | bp [ 5 ] ; ND_PRINT ( ( ndo , "", intvl %ucs, length %u"" , intvl , len ) ) ; } if ( ndo -> ndo_vflag ) { int naddrs = bp [ 3 ] ; int i ; char c ; if ( version == 2 && len >= 8 ) { struct cksum_vec vec [ 1 ] ; vec [ 0 ] . ptr = bp ; vec [ 0 ] . len = len ; if ( in_cksum ( vec , 1 ) ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } if ( version == 3 && len >= 8 ) { uint16_t cksum = nextproto4_cksum ( ndo , ( const struct ip * ) bp2 , bp , len , len , IPPROTO_VRRP ) ; if ( cksum ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } ND_PRINT ( ( ndo , "", addrs"" ) ) ; if ( naddrs > 1 ) ND_PRINT ( ( ndo , ""(%d)"" , naddrs ) ) ; ND_PRINT ( ( ndo , "":"" ) ) ; c = ' ' ; bp += 8 ; for ( i = 0 ; i < naddrs ; i ++ ) { ND_TCHECK ( bp [ 3 ] ) ; ND_PRINT ( ( ndo , ""%c%s"" , c , ipaddr_string ( ndo , bp ) ) ) ; c = ',' ; bp += 4 ; } if ( version == 2 && auth_type == VRRP_AUTH_SIMPLE && len > 8 ) { ND_TCHECK ( bp [ 7 ] ) ; ND_PRINT ( ( ndo , "" auth \\"""" ) ) ; if ( fn_printn ( ndo , bp , 8 , ndo -> ndo_snapend ) ) { ND_PRINT ( ( ndo , ""\\"""" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""\\"""" ) ) ; } } return ; trunc : ND_PRINT ( ( ndo , ""[|vrrp]"" ) ) ; }",915,-12.749227554328325,-0.013933582026588334
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
void vrrp_print ( netdissect_options * ndo , register const u_char * bp , register u_int len , register const u_char * bp2 , int ttl ) { int version , type , auth_type = VRRP_AUTH_NONE ; const char * type_s ; ND_TCHECK ( bp [ 0 ] ) ; version = ( bp [ 0 ] & 0xf0 ) >> 4 ; type = bp [ 0 ] & 0x0f ; type_s = tok2str ( type2str , ""unknown type (%u)"" , type ) ; ND_PRINT ( ( ndo , ""VRRPv%u, %s"" , version , type_s ) ) ; if ( ttl != 255 ) ND_PRINT ( ( ndo , "", (ttl %u)"" , ttl ) ) ; if ( version < 2 || version > 3 || type != VRRP_TYPE_ADVERTISEMENT ) return ; ND_TCHECK ( bp [ 2 ] ) ; ND_PRINT ( ( ndo , "", vrid %u, prio %u"" , bp [ 1 ] , bp [ 2 ] ) ) ; ND_TCHECK ( bp [ 5 ] ) ; if ( version == 2 ) { auth_type = bp [ 4 ] ; ND_PRINT ( ( ndo , "", authtype %s"" , tok2str ( auth2str , NULL , auth_type ) ) ) ; ND_PRINT ( ( ndo , "", intvl %us, length %u"" , bp [ 5 ] , len ) ) ; } else { uint16_t intvl = ( bp [ 4 ] & 0x0f ) << 8 | bp [ 5 ] ; ND_PRINT ( ( ndo , "", intvl %ucs, length %u"" , intvl , len ) ) ; } if ( ndo -> ndo_vflag ) { int naddrs = bp [ 3 ] ; int i ; char c ; if ( version == 2 && ND_TTEST2 ( bp [ 0 ] , len ) ) { struct cksum_vec vec [ 1 ] ; vec [ 0 ] . ptr = bp ; vec [ 0 ] . len = len ; if ( in_cksum ( vec , 1 ) ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } if ( version == 3 && ND_TTEST2 ( bp [ 0 ] , len ) ) { uint16_t cksum = nextproto4_cksum ( ndo , ( const struct ip * ) bp2 , bp , len , len , IPPROTO_VRRP ) ; if ( cksum ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } ND_PRINT ( ( ndo , "", addrs"" ) ) ; if ( naddrs > 1 ) ND_PRINT ( ( ndo , ""(%d)"" , naddrs ) ) ; ND_PRINT ( ( ndo , "":"" ) ) ; c = ' ' ; bp += 8 ; for ( i = 0 ; i < naddrs ; i ++ ) { ND_TCHECK ( bp [ 3 ] ) ; ND_PRINT ( ( ndo , ""%c%s"" , c , ipaddr_string ( ndo , bp ) ) ) ; c = ',' ; bp += 4 ; } if ( version == 2 && auth_type == VRRP_AUTH_SIMPLE ) { ND_TCHECK ( bp [ 7 ] ) ; ND_PRINT ( ( ndo , "" auth \\"""" ) ) ; if ( fn_printn ( ndo , bp , 8 , ndo -> ndo_snapend ) ) { ND_PRINT ( ( ndo , ""\\"""" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""\\"""" ) ) ; } } return ; trunc : ND_PRINT ( ( ndo , ""[|vrrp]"" ) ) ; }
Fixed code:","
void vrrp_print ( netdissect_options * ndo , register const u_char * bp , register u_int len , register const u_char * bp2 , int ttl ) { int version , type , auth_type = VRRP_AUTH_NONE ; const char * type_s ; if (len < 8) { ND_PRINT((ndo, ""[|vrrp]"")); return; } ND_TCHECK ( bp [ 0 ] ) ; version = ( bp [ 0 ] & 0xf0 ) >> 4 ; type = bp [ 0 ] & 0x0f ; type_s = tok2str ( type2str , ""unknown type (%u)"" , type ) ; ND_PRINT ( ( ndo , ""VRRPv%u, %s"" , version , type_s ) ) ; if ( ttl != 255 ) ND_PRINT ( ( ndo , "", (ttl %u)"" , ttl ) ) ; if ( version < 2 || version > 3 || type != VRRP_TYPE_ADVERTISEMENT ) return ; ND_TCHECK ( bp [ 2 ] ) ; ND_PRINT ( ( ndo , "", vrid %u, prio %u"" , bp [ 1 ] , bp [ 2 ] ) ) ; ND_TCHECK ( bp [ 5 ] ) ; if ( version == 2 ) { auth_type = bp [ 4 ] ; ND_PRINT ( ( ndo , "", authtype %s"" , tok2str ( auth2str , NULL , auth_type ) ) ) ; ND_PRINT ( ( ndo , "", intvl %us, length %u"" , bp [ 5 ] , len ) ) ; } else { uint16_t intvl = ( bp [ 4 ] & 0x0f ) << 8 | bp [ 5 ] ; ND_PRINT ( ( ndo , "", intvl %ucs, length %u"" , intvl , len ) ) ; } if ( ndo -> ndo_vflag ) { int naddrs = bp [ 3 ] ; int i ; char c ; if ( version == 2 && ND_TTEST2 ( bp [ 0 ] , len ) ) { struct cksum_vec vec [ 1 ] ; vec [ 0 ] . ptr = bp ; vec [ 0 ] . len = len ; if ( in_cksum ( vec , 1 ) ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } if ( version == 3 && ND_TTEST2 ( bp [ 0 ] , len ) ) { uint16_t cksum = nextproto4_cksum ( ndo , ( const struct ip * ) bp2 , bp , len , len , IPPROTO_VRRP ) ; if ( cksum ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } if ( len < (naddrs * 4) + 8) { ND_PRINT((ndo, ""[|vrrp]"")); return; } ND_PRINT ( ( ndo , "", addrs"" ) ) ; if ( naddrs > 1 ) ND_PRINT ( ( ndo , ""(%d)"" , naddrs ) ) ; ND_PRINT ( ( ndo , "":"" ) ) ; c = ' ' ; bp += 8 ; for ( i = 0 ; i < naddrs ; i ++ ) { ND_TCHECK ( bp [ 3 ] ) ; ND_PRINT ( ( ndo , ""%c%s"" , c , ipaddr_string ( ndo , bp ) ) ) ; c = ',' ; bp += 4 ; } if ( version == 2 && auth_type == VRRP_AUTH_SIMPLE ) { ND_TCHECK ( bp [ 7 ] ) ; ND_PRINT ( ( ndo , "" auth \\"""" ) ) ; if ( fn_printn ( ndo , bp , 8 , ndo -> ndo_snapend ) ) { ND_PRINT ( ( ndo , ""\\"""" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""\\"""" ) ) ; } } return ; trunc : ND_PRINT ( ( ndo , ""[|vrrp]"" ) ) ; }",993,-16.552396727965597,-0.016669080289995565
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
void vrrp_print ( netdissect_options * ndo , register const u_char * bp , register u_int len , register const u_char * bp2 , int ttl ) { int version , type , auth_type = VRRP_AUTH_NONE ; const char * type_s ; ND_TCHECK ( bp [ 0 ] ) ; version = ( bp [ 0 ] & 0xf0 ) >> 4 ; type = bp [ 0 ] & 0x0f ; type_s = tok2str ( type2str , ""unknown type (%u)"" , type ) ; ND_PRINT ( ( ndo , ""VRRPv%u, %s"" , version , type_s ) ) ; if ( ttl != 255 ) ND_PRINT ( ( ndo , "", (ttl %u)"" , ttl ) ) ; if ( version < 2 || version > 3 || type != VRRP_TYPE_ADVERTISEMENT ) return ; ND_TCHECK ( bp [ 2 ] ) ; ND_PRINT ( ( ndo , "", vrid %u, prio %u"" , bp [ 1 ] , bp [ 2 ] ) ) ; ND_TCHECK ( bp [ 5 ] ) ; if ( version == 2 ) { auth_type = bp [ 4 ] ; ND_PRINT ( ( ndo , "", authtype %s"" , tok2str ( auth2str , NULL , auth_type ) ) ) ; ND_PRINT ( ( ndo , "", intvl %us, length %u"" , bp [ 5 ] , len ) ) ; } else { uint16_t intvl = ( bp [ 4 ] & 0x0f ) << 8 | bp [ 5 ] ; ND_PRINT ( ( ndo , "", intvl %ucs, length %u"" , intvl , len ) ) ; } if ( ndo -> ndo_vflag ) { int naddrs = bp [ 3 ] ; int i ; char c ; if ( version == 2 && ND_TTEST2 ( bp [ 0 ] , len ) ) { struct cksum_vec vec [ 1 ] ; vec [ 0 ] . ptr = bp ; vec [ 0 ] . len = len ; if ( in_cksum ( vec , 1 ) ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } if ( version == 3 && ND_TTEST2 ( bp [ 0 ] , len ) ) { uint16_t cksum = nextproto4_cksum ( ndo , ( const struct ip * ) bp2 , bp , len , len , IPPROTO_VRRP ) ; if ( cksum ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } ND_PRINT ( ( ndo , "", addrs"" ) ) ; if ( naddrs > 1 ) ND_PRINT ( ( ndo , ""(%d)"" , naddrs ) ) ; ND_PRINT ( ( ndo , "":"" ) ) ; c = ' ' ; bp += 8 ; for ( i = 0 ; i < naddrs ; i ++ ) { ND_TCHECK ( bp [ 3 ] ) ; ND_PRINT ( ( ndo , ""%c%s"" , c , ipaddr_string ( ndo , bp ) ) ) ; c = ',' ; bp += 4 ; } if ( version == 2 && auth_type == VRRP_AUTH_SIMPLE ) { ND_TCHECK ( bp [ 7 ] ) ; ND_PRINT ( ( ndo , "" auth \\"""" ) ) ; if ( fn_printn ( ndo , bp , 8 , ndo -> ndo_snapend ) ) { ND_PRINT ( ( ndo , ""\\"""" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""\\"""" ) ) ; } } return ; trunc : ND_PRINT ( ( ndo , ""[|vrrp]"" ) ) ; }
Fixed code:","
void vrrp_print ( netdissect_options * ndo , register const u_char * bp , register u_int len , register const u_char * bp2 , int ttl ) { int version , type , auth_type = VRRP_AUTH_NONE ; const char * type_s ; ND_TCHECK ( bp [ 0 ] ) ; version = ( bp [ 0 ] & 0xf0 ) >> 4 ; type = bp [ 0 ] & 0x0f ; type_s = tok2str ( type2str , ""unknown type (%u)"" , type ) ; ND_PRINT ( ( ndo , ""VRRPv%u, %s"" , version , type_s ) ) ; if ( ttl != 255 ) ND_PRINT ( ( ndo , "", (ttl %u)"" , ttl ) ) ; if ( version < 2 || version > 3 || type != VRRP_TYPE_ADVERTISEMENT ) return ; ND_TCHECK ( bp [ 2 ] ) ; ND_PRINT ( ( ndo , "", vrid %u, prio %u"" , bp [ 1 ] , bp [ 2 ] ) ) ; ND_TCHECK ( bp [ 5 ] ) ; if ( version == 2 ) { auth_type = bp [ 4 ] ; ND_PRINT ( ( ndo , "", authtype %s"" , tok2str ( auth2str , NULL , auth_type ) ) ) ; ND_PRINT ( ( ndo , "", intvl %us, length %u"" , bp [ 5 ] , len ) ) ; } else { uint16_t intvl = ( bp [ 4 ] & 0x0f ) << 8 | bp [ 5 ] ; ND_PRINT ( ( ndo , "", intvl %ucs, length %u"" , intvl , len ) ) ; } if ( ndo -> ndo_vflag ) { int naddrs = bp [ 3 ] ; int i ; char c ; if ( version == 2 && len >= 8) { struct cksum_vec vec [ 1 ] ; vec [ 0 ] . ptr = bp ; vec [ 0 ] . len = len ; if ( in_cksum ( vec , 1 ) ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } if ( version == 3 && len >= 8) { uint16_t cksum = nextproto4_cksum ( ndo , ( const struct ip * ) bp2 , bp , len , len , IPPROTO_VRRP ) ; if ( cksum ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } ND_PRINT ( ( ndo , "", addrs"" ) ) ; if ( naddrs > 1 ) ND_PRINT ( ( ndo , ""(%d)"" , naddrs ) ) ; ND_PRINT ( ( ndo , "":"" ) ) ; c = ' ' ; bp += 8 ; for ( i = 0 ; i < naddrs ; i ++ ) { if (len<(bp-8+4)) break; ND_TCHECK ( bp [ 3 ] ) ; ND_PRINT ( ( ndo , ""%c%s"" , c , ipaddr_string ( ndo , bp ) ) ) ; c = ',' ; bp += 4 ; } if ( version == 2 && auth_type == VRRP_AUTH_SIMPLE ) { if (len<(bp-8+8)) break; ND_TCHECK ( bp [ 7 ] ) ; ND_PRINT ( ( ndo , "" auth \\"""" ) ) ; if ( fn_printn ( ndo , bp , 8 , ndo -> ndo_snapend ) ) { ND_PRINT ( ( ndo , ""\\"""" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""\\"""" ) ) ; } } return ; trunc : ND_PRINT ( ( ndo , ""[|vrrp]"" ) ) ; }",937,-20.472782227684956,-0.021849287329439655
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
void vrrp_print ( netdissect_options * ndo , register const u_char * bp , register u_int len , register const u_char * bp2 , int ttl ) { int version , type , auth_type = VRRP_AUTH_NONE ; const char * type_s ; ND_TCHECK ( bp [ 0 ] ) ; version = ( bp [ 0 ] & 0xf0 ) >> 4 ; type = bp [ 0 ] & 0x0f ; type_s = tok2str ( type2str , ""unknown type (%u)"" , type ) ; ND_PRINT ( ( ndo , ""VRRPv%u, %s"" , version , type_s ) ) ; if ( ttl != 255 ) ND_PRINT ( ( ndo , "", (ttl %u)"" , ttl ) ) ; if ( version < 2 || version > 3 || type != VRRP_TYPE_ADVERTISEMENT ) return ; ND_TCHECK ( bp [ 2 ] ) ; ND_PRINT ( ( ndo , "", vrid %u, prio %u"" , bp [ 1 ] , bp [ 2 ] ) ) ; ND_TCHECK ( bp [ 5 ] ) ; if ( version == 2 ) { auth_type = bp [ 4 ] ; ND_PRINT ( ( ndo , "", authtype %s"" , tok2str ( auth2str , NULL , auth_type ) ) ) ; ND_PRINT ( ( ndo , "", intvl %us, length %u"" , bp [ 5 ] , len ) ) ; } else { uint16_t intvl = ( bp [ 4 ] & 0x0f ) << 8 | bp [ 5 ] ; ND_PRINT ( ( ndo , "", intvl %ucs, length %u"" , intvl , len ) ) ; } if ( ndo -> ndo_vflag ) { int naddrs = bp [ 3 ] ; int i ; char c ; if ( version == 2 && ND_TTEST2 ( bp [ 0 ] , len ) ) { struct cksum_vec vec [ 1 ] ; vec [ 0 ] . ptr = bp ; vec [ 0 ] . len = len ; if ( in_cksum ( vec , 1 ) ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } if ( version == 3 && ND_TTEST2 ( bp [ 0 ] , len ) ) { uint16_t cksum = nextproto4_cksum ( ndo , ( const struct ip * ) bp2 , bp , len , len , IPPROTO_VRRP ) ; if ( cksum ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } ND_PRINT ( ( ndo , "", addrs"" ) ) ; if ( naddrs > 1 ) ND_PRINT ( ( ndo , ""(%d)"" , naddrs ) ) ; ND_PRINT ( ( ndo , "":"" ) ) ; c = ' ' ; bp += 8 ; for ( i = 0 ; i < naddrs ; i ++ ) { ND_TCHECK ( bp [ 3 ] ) ; ND_PRINT ( ( ndo , ""%c%s"" , c , ipaddr_string ( ndo , bp ) ) ) ; c = ',' ; bp += 4 ; } if ( version == 2 && auth_type == VRRP_AUTH_SIMPLE ) { ND_TCHECK ( bp [ 7 ] ) ; ND_PRINT ( ( ndo , "" auth \\"""" ) ) ; if ( fn_printn ( ndo , bp , 8 , ndo -> ndo_snapend ) ) { ND_PRINT ( ( ndo , ""\\"""" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""\\"""" ) ) ; } } return ; trunc : ND_PRINT ( ( ndo , ""[|vrrp]"" ) ) ; }
Fixed code:","
void vrrp_print ( netdissect_options * ndo , register const u_char * bp , register u_int len , register const u_char * bp2 , int ttl ) { int version , type , auth_type = VRRP_AUTH_NONE ; const char * type_s ; 
if (len < 8) {
  ND_PRINT ( ( ndo , ""[|vrrp]"" ) ); 
  return;
}
ND_TCHECK ( bp [ 0 ] ) ; version = ( bp [ 0 ] & 0xf0 ) >> 4 ; type = bp [ 0 ] & 0x0f ; type_s = tok2str ( type2str , ""unknown type (%u)"" , type ) ; ND_PRINT ( ( ndo , ""VRRPv%u, %s"" , version , type_s ) ) ; if ( ttl != 255 ) ND_PRINT ( ( ndo , "", (ttl %u)"" , ttl ) ) ; if ( version < 2 || version > 3 || type != VRRP_TYPE_ADVERTISEMENT ) return ; ND_TCHECK ( bp [ 2 ] ) ; ND_PRINT ( ( ndo , "", vrid %u, prio %u"" , bp [ 1 ] , bp [ 2 ] ) ) ; ND_TCHECK ( bp [ 5 ] ) ; if ( version == 2 ) { auth_type = bp [ 4 ] ; ND_PRINT ( ( ndo , "", authtype %s"" , tok2str ( auth2str , NULL , auth_type ) ) ) ; ND_PRINT ( ( ndo , "", intvl %us, length %u"" , bp [ 5 ] , len ) ) ; } else { uint16_t intvl = ( bp [ 4 ] & 0x0f ) << 8 | bp [ 5 ] ; ND_PRINT ( ( ndo , "", intvl %ucs, length %u"" , intvl , len ) ) ; } if ( ndo -> ndo_vflag ) { int naddrs = bp [ 3 ] ; int i ; char c ; 
  if (len < 8 + (4*naddrs)) { 
    ND_PRINT ( ( ndo , ""[|vrrp]"" ) ); 
    return;
  } 
if ( version == 2 && ND_TTEST2 ( bp [ 0 ] , len ) ) { struct cksum_vec vec [ 1 ] ; vec [ 0 ] . ptr = bp ; vec [ 0 ] . len = len ; if ( in_cksum ( vec , 1 ) ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } if ( version == 3 && ND_TTEST2 ( bp [ 0 ] , len ) ) { uint16_t cksum = nextproto4_cksum ( ndo , ( const struct ip * ) bp2 , bp , len , len , IPPROTO_VRRP ) ; if ( cksum ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } ND_PRINT ( ( ndo , "", addrs"" ) ) ; if ( naddrs > 1 ) ND_PRINT ( ( ndo , ""(%d)"" , naddrs ) ) ; ND_PRINT ( ( ndo , "":"" ) ) ; c = ' ' ; bp += 8 ; for ( i = 0 ; i < naddrs ; i ++ ) { ND_TCHECK ( bp [ 3 ] ) ; ND_PRINT ( ( ndo , ""%c%s"" , c , ipaddr_string ( ndo , bp ) ) ) ; c = ',' ; bp += 4 ; } if ( version == 2 && auth_type == VRRP_AUTH_SIMPLE ) { ND_TCHECK ( bp [ 7 ] ) ; ND_PRINT ( ( ndo , "" auth \\"""" ) ) ; if ( fn_printn ( ndo , bp , 8 , ndo -> ndo_snapend ) ) { ND_PRINT ( ( ndo , ""\\"""" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""\\"""" ) ) ; } } return ; trunc : ND_PR",1000,-31.791716161129223,-0.031791716161129226
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
void vrrp_print ( netdissect_options * ndo , register const u_char * bp , register u_int len , register const u_char * bp2 , int ttl ) { int version , type , auth_type = VRRP_AUTH_NONE ; const char * type_s ; ND_TCHECK ( bp [ 0 ] ) ; version = ( bp [ 0 ] & 0xf0 ) >> 4 ; type = bp [ 0 ] & 0x0f ; type_s = tok2str ( type2str , ""unknown type (%u)"" , type ) ; ND_PRINT ( ( ndo , ""VRRPv%u, %s"" , version , type_s ) ) ; if ( ttl != 255 ) ND_PRINT ( ( ndo , "", (ttl %u)"" , ttl ) ) ; if ( version < 2 || version > 3 || type != VRRP_TYPE_ADVERTISEMENT ) return ; ND_TCHECK ( bp [ 2 ] ) ; ND_PRINT ( ( ndo , "", vrid %u, prio %u"" , bp [ 1 ] , bp [ 2 ] ) ) ; ND_TCHECK ( bp [ 5 ] ) ; if ( version == 2 ) { auth_type = bp [ 4 ] ; ND_PRINT ( ( ndo , "", authtype %s"" , tok2str ( auth2str , NULL , auth_type ) ) ) ; ND_PRINT ( ( ndo , "", intvl %us, length %u"" , bp [ 5 ] , len ) ) ; } else { uint16_t intvl = ( bp [ 4 ] & 0x0f ) << 8 | bp [ 5 ] ; ND_PRINT ( ( ndo , "", intvl %ucs, length %u"" , intvl , len ) ) ; } if ( ndo -> ndo_vflag ) { int naddrs = bp [ 3 ] ; int i ; char c ; if ( version == 2 && ND_TTEST2 ( bp [ 0 ] , len ) ) { struct cksum_vec vec [ 1 ] ; vec [ 0 ] . ptr = bp ; vec [ 0 ] . len = len ; if ( in_cksum ( vec , 1 ) ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } if ( version == 3 && ND_TTEST2 ( bp [ 0 ] , len ) ) { uint16_t cksum = nextproto4_cksum ( ndo , ( const struct ip * ) bp2 , bp , len , len , IPPROTO_VRRP ) ; if ( cksum ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } ND_PRINT ( ( ndo , "", addrs"" ) ) ; if ( naddrs > 1 ) ND_PRINT ( ( ndo , ""(%d)"" , naddrs ) ) ; ND_PRINT ( ( ndo , "":"" ) ) ; c = ' ' ; bp += 8 ; for ( i = 0 ; i < naddrs ; i ++ ) { ND_TCHECK ( bp [ 3 ] ) ; ND_PRINT ( ( ndo , ""%c%s"" , c , ipaddr_string ( ndo , bp ) ) ) ; c = ',' ; bp += 4 ; } if ( version == 2 && auth_type == VRRP_AUTH_SIMPLE ) { ND_TCHECK ( bp [ 7 ] ) ; ND_PRINT ( ( ndo , "" auth \\"""" ) ) ; if ( fn_printn ( ndo , bp , 8 , ndo -> ndo_snapend ) ) { ND_PRINT ( ( ndo , ""\\"""" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""\\"""" ) ) ; } } return ; trunc : ND_PRINT ( ( ndo , ""[|vrrp]"" ) ) ; }
Fixed code:","
void vrrp_print ( netdissect_options * ndo , register const u_char * bp , register u_int len , register const u_char * bp2 , int ttl ) { int version , type , auth_type = VRRP_AUTH_NONE ; const char * type_s ; if (len < 1) return; ND_TCHECK ( bp [ 0 ] ) ; version = ( bp [ 0 ] & 0xf0 ) >> 4 ; type = bp [ 0 ] & 0x0f ; type_s = tok2str ( type2str , ""unknown type (%u)"" , type ) ; ND_PRINT ( ( ndo , ""VRRPv%u, %s"" , version , type_s ) ) ; if ( ttl != 255 ) ND_PRINT ( ( ndo , "", (ttl %u)"" , ttl ) ) ; if ( version < 2 || version > 3 || type != VRRP_TYPE_ADVERTISEMENT ) return ; if (len < 3) return; ND_TCHECK ( bp [ 2 ] ) ; ND_PRINT ( ( ndo , "", vrid %u, prio %u"" , bp [ 1 ] , bp [ 2 ] ) ) ; if (len < 6) return; ND_TCHECK ( bp [ 5 ] ) ; if ( version == 2 ) { auth_type = bp [ 4 ] ; ND_PRINT ( ( ndo , "", authtype %s"" , tok2str ( auth2str , NULL , auth_type ) ) ) ; ND_PRINT ( ( ndo , "", intvl %us, length %u"" , bp [ 5 ] , len ) ) ; } else { uint16_t intvl = ( bp [ 4 ] & 0x0f ) << 8 | bp [ 5 ] ; ND_PRINT ( ( ndo , "", intvl %ucs, length %u"" , intvl , len ) ) ; } if ( ndo -> ndo_vflag ) { int naddrs = bp [ 3 ] ; int i ; char c ; if ( version == 2 && len >= 7 ) { struct cksum_vec vec [ 1 ] ; vec [ 0 ] . ptr = bp ; vec [ 0 ] . len = len ; if ( in_cksum ( vec , 1 ) ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } if ( version == 3 && len >= 7 ) { uint16_t cksum = nextproto4_cksum ( ndo , ( const struct ip * ) bp2 , bp , len , len , IPPROTO_VRRP ) ; if ( cksum ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } ND_PRINT ( ( ndo , "", addrs"" ) ) ; if ( naddrs > 1 ) ND_PRINT ( ( ndo , ""(%d)"" , naddrs ) ) ; ND_PRINT ( ( ndo , "":"" ) ) ; c = ' ' ; bp += 8 ; for ( i = 0 ; i < naddrs ; i ++ ) { if (len < bp + 3) return; ND_TCHECK ( bp [ 3 ] ) ; ND_PRINT ( ( ndo , ""%c%s"" , c , ipaddr_string ( ndo , bp ) ) ) ; c = ',' ; bp += 4 ; } if ( version == 2 && auth_type == VRRP_AUTH_SIMPLE ) { if (len < bp + 7) return; ND_TCHECK ( bp [ 7 ] ) ; ND_PRINT ( ( ndo , "" auth \\"""" ) ) ; if ( fn_printn ( ndo , bp , 8 , ndo -> ndo_snapend ) ) { ND_PRINT ( ( ndo , ""\\"""" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""\\"""" ) ) ; } } return ; trunc : ND_PRINT ( ( ndo , ""[|vrrp]"" ) ) ; }",957,-18.719068466609272,-0.01956015513752275
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
void vrrp_print ( netdissect_options * ndo , register const u_char * bp , register u_int len , register const u_char * bp2 , int ttl ) { int version , type , auth_type = VRRP_AUTH_NONE ; const char * type_s ; ND_TCHECK ( bp [ 0 ] ) ; version = ( bp [ 0 ] & 0xf0 ) >> 4 ; type = bp [ 0 ] & 0x0f ; type_s = tok2str ( type2str , ""unknown type (%u)"" , type ) ; ND_PRINT ( ( ndo , ""VRRPv%u, %s"" , version , type_s ) ) ; if ( ttl != 255 ) ND_PRINT ( ( ndo , "", (ttl %u)"" , ttl ) ) ; if ( version < 2 || version > 3 || type != VRRP_TYPE_ADVERTISEMENT ) return ; ND_TCHECK ( bp [ 2 ] ) ; ND_PRINT ( ( ndo , "", vrid %u, prio %u"" , bp [ 1 ] , bp [ 2 ] ) ) ; ND_TCHECK ( bp [ 5 ] ) ; if ( version == 2 ) { auth_type = bp [ 4 ] ; ND_PRINT ( ( ndo , "", authtype %s"" , tok2str ( auth2str , NULL , auth_type ) ) ) ; ND_PRINT ( ( ndo , "", intvl %us, length %u"" , bp [ 5 ] , len ) ) ; } else { uint16_t intvl = ( bp [ 4 ] & 0x0f ) << 8 | bp [ 5 ] ; ND_PRINT ( ( ndo , "", intvl %ucs, length %u"" , intvl , len ) ) ; } if ( ndo -> ndo_vflag ) { int naddrs = bp [ 3 ] ; int i ; char c ; if ( version == 2 && ND_TTEST2 ( bp [ 0 ] , len ) ) { struct cksum_vec vec [ 1 ] ; vec [ 0 ] . ptr = bp ; vec [ 0 ] . len = len ; if ( in_cksum ( vec , 1 ) ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } if ( version == 3 && ND_TTEST2 ( bp [ 0 ] , len ) ) { uint16_t cksum = nextproto4_cksum ( ndo , ( const struct ip * ) bp2 , bp , len , len , IPPROTO_VRRP ) ; if ( cksum ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } ND_PRINT ( ( ndo , "", addrs"" ) ) ; if ( naddrs > 1 ) ND_PRINT ( ( ndo , ""(%d)"" , naddrs ) ) ; ND_PRINT ( ( ndo , "":"" ) ) ; c = ' ' ; bp += 8 ; for ( i = 0 ; i < naddrs ; i ++ ) { ND_TCHECK ( bp [ 3 ] ) ; ND_PRINT ( ( ndo , ""%c%s"" , c , ipaddr_string ( ndo , bp ) ) ) ; c = ',' ; bp += 4 ; } if ( version == 2 && auth_type == VRRP_AUTH_SIMPLE ) { ND_TCHECK ( bp [ 7 ] ) ; ND_PRINT ( ( ndo , "" auth \\"""" ) ) ; if ( fn_printn ( ndo , bp , 8 , ndo -> ndo_snapend ) ) { ND_PRINT ( ( ndo , ""\\"""" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""\\"""" ) ) ; } } return ; trunc : ND_PRINT ( ( ndo , ""[|vrrp]"" ) ) ; }
Fixed code:","
void vrrp_print ( netdissect_options * ndo , register const u_char * bp , register u_int len , register const u_char * bp2 , int ttl ) { int version , type , auth_type = VRRP_AUTH_NONE ; const char * type_s ; if (len < 1) return; ND_TCHECK ( bp [ 0 ] ) ; version = ( bp [ 0 ] & 0xf0 ) >> 4 ; type = bp [ 0 ] & 0x0f ; type_s = tok2str ( type2str , ""unknown type (%u)"" , type ) ; ND_PRINT ( ( ndo , ""VRRPv%u, %s"" , version , type_s ) ) ; if ( ttl != 255 ) ND_PRINT ( ( ndo , "", (ttl %u)"" , ttl ) ) ; if ( version < 2 || version > 3 || type != VRRP_TYPE_ADVERTISEMENT ) return ; ND_TCHECK ( bp [ 2 ] ) ; ND_PRINT ( ( ndo , "", vrid %u, prio %u"" , bp [ 1 ] , bp [ 2 ] ) ) ; ND_TCHECK ( bp [ 5 ] ) ; if ( version == 2 ) { auth_type = bp [ 4 ] ; ND_PRINT ( ( ndo , "", authtype %s"" , tok2str ( auth2str , NULL , auth_type ) ) ) ; ND_PRINT ( ( ndo , "", intvl %us, length %u"" , bp [ 5 ] , len ) ) ; } else { uint16_t intvl = ( bp [ 4 ] & 0x0f ) << 8 | bp [ 5 ] ; ND_PRINT ( ( ndo , "", intvl %ucs, length %u"" , intvl , len ) ) ; } if ( ndo -> ndo_vflag ) { int naddrs = bp [ 3 ] ; int i ; char c ; if (len < 8) return; if ( version == 2 && ND_TTEST2 ( bp [ 0 ] , len ) ) { struct cksum_vec vec [ 1 ] ; vec [ 0 ] . ptr = bp ; vec [ 0 ] . len = len ; if ( in_cksum ( vec , 1 ) ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } if ( version == 3 && ND_TTEST2 ( bp [ 0 ] , len ) ) { uint16_t cksum = nextproto4_cksum ( ndo , ( const struct ip * ) bp2 , bp , len , len , IPPROTO_VRRP ) ; if ( cksum ) ND_PRINT ( ( ndo , "", (bad vrrp cksum %x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } ND_PRINT ( ( ndo , "", addrs"" ) ) ; if ( naddrs > 1 ) ND_PRINT ( ( ndo , ""(%d)"" , naddrs ) ) ; ND_PRINT ( ( ndo , "":"" ) ) ; c = ' ' ; bp += 8 ; for ( i = 0 ; i < naddrs ; i ++ ) { if (len < 8) return; ND_TCHECK ( bp [ 3 ] ) ; ND_PRINT ( ( ndo , ""%c%s"" , c , ipaddr_string ( ndo , bp ) ) ) ; c = ',' ; bp += 4 ; } if ( version == 2 && auth_type == VRRP_AUTH_SIMPLE ) { if (len <16) return; ND_TCHECK ( bp [ 7 ] ) ; ND_PRINT ( ( ndo , "" auth \\"""" ) ) ; if ( fn_printn ( ndo , bp , 8 , ndo -> ndo_snapend ) ) { ND_PRINT ( ( ndo , ""\\"""" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""\\"""" ) ) ; } } return ; trunc : ND_PRINT ( ( ndo , ""[|vrrp]"" ) ) ; }",965,-17.91587187360729,-0.018565670335344342
